{"meta":{"title":"tianfeng","subtitle":"","description":"","author":"Tian Feng","url":"http://example.com","root":"/"},"pages":[{"title":"关于","date":"2023-09-27T14:13:06.680Z","updated":"2022-03-21T07:18:46.000Z","comments":false,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"个人详细介绍"},{"title":"404 Not Found：该页无法显示","date":"2023-09-27T13:09:00.666Z","updated":"2022-03-21T07:18:46.000Z","comments":false,"path":"/404.html","permalink":"http://example.com/404.html","excerpt":"","text":""},{"title":"书单","date":"2023-09-27T14:03:34.980Z","updated":"2022-03-21T07:18:46.000Z","comments":false,"path":"books/index.html","permalink":"http://example.com/books/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2023-09-27T16:33:32.977Z","updated":"2022-03-21T07:18:46.000Z","comments":true,"path":"links/index.html","permalink":"http://example.com/links/index.html","excerpt":"","text":""},{"title":"分类","date":"2023-09-27T13:39:49.782Z","updated":"2022-03-21T07:18:46.000Z","comments":false,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2023-09-27T13:09:00.666Z","updated":"2022-03-21T07:18:46.000Z","comments":false,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2023-09-28T00:46:50.774Z","updated":"2022-03-21T07:18:46.000Z","comments":false,"path":"repository/index.html","permalink":"http://example.com/repository/index.html","excerpt":"","text":""}],"posts":[{"title":"","slug":"赠：程序员的日常工作解密","date":"2023-09-27T14:15:58.895Z","updated":"2023-08-22T08:46:41.047Z","comments":true,"path":"2023/09/27/赠：程序员的日常工作解密/","link":"","permalink":"http://example.com/2023/09/27/%E8%B5%A0%EF%BC%9A%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E6%97%A5%E5%B8%B8%E5%B7%A5%E4%BD%9C%E8%A7%A3%E5%AF%86/","excerpt":"","text":"程序员的日常工作解密调研1、后端工程师典型的日常1：国企受访人 22岁 平时每天的上班时间和下班时间分别是？ 早上 9 点上班， 晚上 6 点下班 最近一周有加班么？加班的天数是？一般加到多晚？ 最近一周加班三天，工作日加班到晚上8点30左右，周末一天加班一整天，晚上不加。 描述一下你的「典型的一天」 住公司提供的宿舍，早上8:40起床， 9点到公司食堂吃早饭， 9:30左右开始正式上班， 到11:30会稍微休息一会，然后浏览一些技术博客、运动相关的东西。 12点在公司的食堂吃午饭， 12:30到13:30回宿舍休息， 14点左右再回到工位上开始上班。刚开始到位置上，如果任务赶的话直接开始敲代码，如果任务不赶，会拿30分钟到1一个小时看一下公司的前端框架。 期间会在公司的休闲室休息一会，然后到18.00下班。 18:00 去健身房锻炼一个小时 19:30 训练结束回到宿舍，洗澡，准备晚饭。 20:00 吃完饭，这时候追两集动漫，看看视频，刷刷微博 到22:00 因为自我感觉基础非常薄弱，这个时候通常会学一点东西。 在上边描述的日常中，你最想吐槽的是什么？ 毕业之后一直在负责维护一个公司比较旧版本的项目，所以经常出现一些非常奇怪的需求。还有一些非常老旧的代码，找不到之前的author，也不知道如何调试。 在上边描述的日常中，你最满意的是什么？ 很自由，我可以在正常的上班时间之内自己支配。 在现在这个职位上，你遇到的最大的技术挑战是什么？怎么解决的？ 在熟悉公司新开发的一套框架上。因为文档不齐全，而且前端相对薄弱，所以一直不知道如何去下手。 后面为了能够快速熟悉起来，我就找带我的小哥要了一个很简单的任务，直接进行下手，然后直接在开发中对遇到的问题 进行跟踪调试，开发完这个模块花了一个礼拜，虽然进度很慢..但是现在对这个框架已经有点熟悉了。 你是怎么度过从新人到熟手的阶段的？公司有安排培训么？如果有，你觉得其中对你最有用的内容是什么？ 其实现在还是一个新人。公司曾在我们实习的时候安排了一个月的培训，主要是对公司在使用中的框架（Spring MyBatis）等进行培训。我觉得最有用的还是给我们上课的大牛给我们的一些学习方法，以及工作方法。 你对即将入职这个岗位的新人，有什么建议？（做什么、不要做什么） 要做：我是一个非985&#x2F;211大学的学生，等我有职业规划的想法的时候已经是大三下学期了，所以我感觉自己起步非常非常慢，技术也很差。所以我想说的是，如果想走技术这条路，那一定不要呆在懒惰区，而且对基础的东西要更重视，同时也要关注新的技术。 不要做：对自己的规划模棱俩可.不知道自己为什么要做技术相关的工作。 调研2、后端工程师典型的日常2：知名创业公司受访人 23 岁，后端产品研发工程师。 平时每天的上班时间和下班时间分别是？ 前公司一般是 11 点上班，现在是 10 点，下班时间我一般工作外也会待在公司做些别的，大概平均也得 9、10 点吧。 最近一周有加班么？加班的天数是？一般加到多晚？ 属于比较忙的组，之前一直封闭开发，差不多 11、10、6 吧（也就持续一两周）。 描述一下你的「典型的一天」 9:00 起床 10:00 打车到公司 上午主要是整理性质，会开站会，整理下今天要做的事（不光工作，翻翻邮件、订阅的博客、Github 之类的） 12:00 在食堂吃饭，然后出去散散步，没有午睡的习惯 下午基本都在工作 19:00 在食堂吃晚饭 之后如果工作还比较忙就接着弄工作，否则会按照优先级选一些个人的事去做（Side Project、知识积累、阅读） 21:00~22:00 下班回家。到家基本上就只是放松了，看看日剧、追番 偶尔有很感兴趣的事驱动的时候（比如 Side Project 灵感很多的时候），会熬夜做，大概到 3:00 为底线 在上边描述的日常中，你最想吐槽的是什么？ 目前在新公司还有两个比较严重的问题： 对任务的估时准确度不高，很多时候要么过忙，要么被严重 Block。 对任务的优先级分配有问题，我希望能静下心做一些重要且不紧急的事情，但是实际上大部分时间都在帮别人解决一些小问题。 在上边描述的日常中，你最满意的是什么？ 上家公司是技术很好的小团队（ 好到什么程度呢？后端 + 平台 15 人左右，能维护一套微服务，并且自研容器编排 ），但是很遗憾的是业务本身没有太大量级，对后端来说历练还太小。 来新公司主要是为了技术挑战，业务上的压力肯定是有的，就看自己能不能抓住机会了。 在现在这个职位上，你遇到的最大的技术挑战是什么？怎么解决的？ 技术挑战可能不会太多，我认为很多业务场景都是有取巧的解决方案的（取巧可能形容有误，非贬义，类似于分库分表即使不需要太多技术也可以 Hard Coding 实现，并且能有效解决问题）。而中小型公司的平台方案一般又都是追随开源的，所以我也选择尽量追随开源社区。 在现在这个职位上，你遇到的最大的非技术挑战是什么？怎么解决的？ 我比较不擅长编程以外的任何事，最不擅长的就是与人相处。讨厌漫长的会议，讨厌一些混日子的同事。 你是怎么度过从新人到熟手的阶段的？公司有安排培训么？如果有，你觉得其中对你最有用的内容是什么？ 呆的都是中小型公司，没参与过什么培训，个人感觉比较幸运的主要还是多逛开源社区吧，很多时候公司交给我去做的事都是因为我之前有过了解（哪怕只是简单了解，也比大部分人强很多），这样慢慢的就能成为良性循环。 你对即将入职这个岗位的新人，有什么建议？（做什么、不要做什么） 不要盲目崇拜自己公司的技术，很多时候技术会因为架构师的喜好、成本、甚至一些和技术无关的因素而决定。即使去用了，也要明白这些技术有哪些优点、哪些缺点、如何改进。这样你至少迈出了第一步：不会因为最开始运气不好去了一家不好的公司或是部门而陷入技术上的恶性循环。 其次就是无论前端也好、后端也好，多去了解了解新技术，即使作为一个后端我也会偶尔和 Android 同事聊聊 Kotlin，和前端同事聊聊 React、Vue，你会发现只需花费非常低的成本就能学到一门可以弥补你短板的新技术，让你之前很多看似做不到的想法都可以轻松实现。 调研3、前端工程师典型的日常3：知名互联网公司受访人 21岁，在北京某D轮知名移动互联网公司担任前端。 平时每天的上班时间和下班时间分别是？ 早9点，晚6:30。 最近一周有加班么？加班的天数是？一般加到多晚？ 最近有加班因为双11，基本天天加班，加班到7:30，平时较少加班。 你的「典型的一天」？ 每天 8:30 起床， 接近 9 点出门， 到公司 9 点多一点， 中午 11:30 骑摩拜去公司另一个食堂吃饭， 回来 12:30 开始午休， 1:30 缓一会儿看看邮件消息， 2点开始干活， 6:30去楼下食堂吃饭然后回家 在上边描述的日常中，你最想吐槽的是什么？ 最想吐槽日常低效率的沟通，每天花费在看邮件和消息的时间比较多，很多内容和自己没有太大的关系，比较影响工作效率，还有就是需求变更比较频繁。 在上边描述的日常中，你最满意的是什么？ 日常比较满意的是宽松的工作氛围，和谐的上下级关系，以及团队有技术上的大牛，当然还有很多妹纸~ 在现在这个职位上，你遇到的最大的技术挑战是什么？怎么解决的？ 其实目前来说还没有遇到真正意义上的技术挑战，因为轮子已经有前人造好了，挑战可能更多的是需要自己去了解这些实现细节。如果确实遇到困难，我会先去看看之前项目里面的代码别人是怎么实现的，然后自己也会了。 在现在这个职位上，你遇到的最大的非技术挑战是什么？怎么解决的？ 非技术挑战可能是需要协调好在开发过程中与PM，设计，运营以及其他工程师之间的teamwork，避免因为交流不够彻底而导致做一些无意义或者重复的事情。 解决这个问题其实是比较困难的，我们可能有时问同一项目里面不同两个人对相同的问题给出不同的答案，这个时候我一般会明确的这个问题真正的需求是什么，同时会和同一团队的成员都确认一下。 你是怎么度过从新人到熟手的阶段的？公司有安排培训么？如果有，你觉得其中对你最有用的内容是什么？ 从新人到现在的转变就是不明确的或者不会的地方，就去看前人是怎么实现，再不会就问leader(一般很少发生这种情况)。 公司有安排培训，培训的价值其实在输出的内容上并没有对我有多大的提升，反倒是让我对认识问题的态度有很大的转变，我们喜欢用事实标准去讲一个问题，而不是通过别人的经验或者某些技术博客的介绍就认为问题就是这样。 技术人看待问题就应该是非常严谨，就像写代码一样，我们要做到bug free，虽然这是不可能的。 你对即将入职这个岗位的新人，有什么建议？（做什么、不要做什么） 我想说，与其把大把的时间花在学习几个瞬息万变的新框架API使用中，不如多花点时间在基础知识学习。我认为这才是真正决定一个技术人能走多远的基石，虽然这句话可能你已经听烦了。 新的东西解决了很多问题，但是很多人甚至都不知道为什么会存在这些问题更别谈解决方案和实现的原理，还有就是不要盲目的相信技术网红的一些观点，他们不一定是正确或者恰当的。 前端最不缺网红，工作后我才认识到大部分真正牛逼的人都是比较低调的(但并不是高调的人就不牛)；在有一些基础后可以多看一些原理性质或者质量高的博客，多读一些业界认可度高的书籍，看看一些开源项目从简单的入手，自己去实践并验证你学习到的知识，同时多关注开源社区 你在这些年的工作中，有没有遇到特别好的工具、资料、书籍之类，想要推荐给大家？一两样也行哦。 推荐一本书《JavaScript高级程序设计》，相当于 Web API Wiki 的 MDN ，以及 Google 开发者文档中的 Web 部分，更细节可以看看 W3C 标准、ECMAScript 标准、WHATWG 标准。在准备读一本书的时候可以先去豆瓣上看看评价，如果只有6、7分你就要慎重了，因为他可能不仅仅是在浪费你的时间还可能误导你。 调研4、创业公司技术负责人的日常4受访人 27岁 ，5月份离开微博到深圳已经半年，目前与几个朋友创业中，负责技术部分。 平时每天的上班时间和下班时间分别是？ 创建阶段也没有固定吧，其实也与大家都差不多。 最近一周有加班么？加班的天数是？一般加到多晚？ 创业阶段就没有加班一说了，因为也没有固定的下班时间，有事情就多忙一会儿，晚点回家，没事就早点回去。 你的「典型的一天」？ 一般是 8 点左右起床， 然后 9 点从坪洲站出发， 9 点 50 左右到水湾站，出站就是公司所在地：深圳自贸中心。 整体感觉还是很方便的。 中午楼下吃饭， 然后工作到 7-8 点左右回家。 在上边描述的日常中，你最想吐槽的是什么？ 其实相对于北京，深圳给我的印象没有太多槽点，大家都很有秩序的排队是印象最深刻的，地铁也不挤（也许是我9点才出发的原因吧）， 因为我住坪洲，办公室在深圳自贸中心稍微离我稍微远一点，40-50 分钟左右的地铁也许是最差的一点了吧，不过都还能接受了。 在上边描述的日常中，你最满意的是什么？ 最满意的就是团队了，几个合伙人的执行力是我见过最棒的，然后很满意的就是公司环境很好，大家有空可以来参观一下。 在现在这个职位上，你遇到的最大的技术挑战是什么？怎么解决的？ 由于我们是创业项目，线上线下联动，并非纯互联网项目，我们没有太多的难点需要解决，所以大部分是在接入一些服务时感觉比较麻烦一些吧，目前来讲没有遇到什么技术难题，因为不管从项目复杂度上还是用户量级上都还没有到有挑战的程度。 在现在这个职位上，你遇到的最大的非技术挑战是什么？怎么解决的？ 作为技术负责人，除了搞定技术问题外，更多的时间都是与大家在讨论产品，用户体验，以及一些未来规划可能需要做的准备工作。另外就是需要扩大技术广度来避免团队扩大时的管理难题。目前来讲就是在时间管理上还需要一些调整，不是太能控制好个人时间。 你是怎么度过从新人到熟手的阶段的？公司有安排培训么？如果有，你觉得其中对你最有用的内容是什么？ 其实很多的实践经验基本都来自公司项目或者自己业余项目，工作之外的时间主要就是做一些基础知识的积累。还是得感谢这几年经历的几家公司，对我的成长提升都很大，在微博的两年，领导的大力支持给了我很多帮助。然后折腾开源项目的时间也是我个人成长过程中收益最大的投入。 公司培训的话，有过，不过比较少，更多的是团队内的知识分享，这方面手机微博做得还是很棒的。其实分享不在于能让你在这么短时间内学会什么，我觉得它最大的益处就是增加知识面：你会的东西，在分享过程中可能会看到新的玩法，或者更有效的玩法，你不会的东西，增加知识广度，新东西能增加个人的学习气氛（折腾新东西的时候持续的兴奋感特别棒）。另外主动分享也能锻炼表达能力。 你对即将入职这个岗位的新人，有什么建议？（做什么、不要做什么） 新人最大的难点可能在选择上，这个选择包括很多方面吧，比如用什么语言（这个争吵太多了）、用什么编辑器到用什么框架、写不写注释等等，我个人的建议是：把握一个方向，找比较能入手的（像 PHP 就很容易入手），大家都在用的（或者说用得人多的）深入学习，精通它，在项目中去实践，然后扩大知识面，了解一下其它周边的东西，比如你写后端，你起码也得懂 CSS，js 之类的基础使用比较好。少看社区八卦，他们爱吵不吵，不要受影响，相信自己的选择。因为到后面你会发现，真正的牛人，不是在于哪个语言他用得 6 不 6，而是在项目上的架构能力，解决问题的能力才是最厉害的。 你在这些年的工作中，有没有遇到特别好的工具、资料、书籍之类，想要推荐给大家？一两样也行哦。 太多了，不过不常用的我就不提了，自己常用的东西有： 工具方面（全部已购买正版授权）： 写代码：Sublime Text 3 + PHPStorm(开源授权) 做设计：Sketch 数据库：Sequel pro 记笔记：Bear TODO：Things 3 办公：企业微信 项目管理：Teambition 其它工具：1password、Charles、Item2 等 书籍方面其实我不太有发言权，因为比较懒，不过还是有本认为很棒的推荐给大家：《C和指针》系列。 调研5、CTO的日常受访人 39岁，北京某云计算公司 CTO ，原知名上市公司研发总监。 平时每天的上班时间和下班时间分别是？ 早10:30到晚8:30。 最近一周有加班么？加班的天数是？一般加到多晚？ 有加班，2天，一般加班到9点30。 能否按小时描述一下你的「典型的一天」？ 8点起床， 9点出门， 10点半到公司，处理邮件，处理和工作相关的微信，和同事讨论工作进展情况， 12点吃饭， 12点半看业内资讯、技术文章， 1点半休息半小时， 2点会议或者面试， 3点会议或者面试， 4点和同事或者客户沟通工作， 5点看工作相关的运营数据、邮件、文档、了解各项工作的进展， 6点吃饭，有时候约了饭局出发，不出去的话， 6点半和同事沟通工作， 8点半下班。 在上边描述的日常中，你最想吐槽的是什么？ 上班太远，路上总堵车。 在上边描述的日常中，你最满意的是什么？ 发展空间大。 在现在这个职位上，你遇到的最大的技术挑战是什么？怎么解决的？ 产品和服务的质量，体现在服务的响应速度快、稳定性好故障率底，主要通过不断改进系统的缺陷，完善技术开发和变更的流程机制。 在现在这个职位上，你遇到的最大的非技术挑战是什么？怎么解决的？ 非技术挑战就是拓展业务，跟更多的潜在客户沟通，介绍公司的产品，争取测试的机会。 你是怎么度过从新人到熟手的阶段的？公司有安排培训么？如果有，你觉得其中对你最有用的内容是什么？ 自己和公司的人多沟通，了解公司的人、流程、部门。 你在这些年的工作中，有没有遇到特别好的工具、资料、书籍之类，想要推荐给大家？一两样也行哦。 事物管理工具用 JIRA ，文档管理用 Confluence ，代码管理用 BitBucket 。 案例来自于掘金小册《程序员职业小白书 —— 如何规划和经营你的职业》欢迎大家订阅。如侵删。","categories":[],"tags":[]},{"title":"优秀程序员的五个特质","slug":"赠：优秀程序员的五个特质","date":"2023-09-27T14:15:54.896Z","updated":"2023-09-27T14:27:31.322Z","comments":true,"path":"2023/09/27/赠：优秀程序员的五个特质/","link":"","permalink":"http://example.com/2023/09/27/%E8%B5%A0%EF%BC%9A%E4%BC%98%E7%A7%80%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E4%BA%94%E4%B8%AA%E7%89%B9%E8%B4%A8/","excerpt":"","text":"1、程序员的焦虑我们的焦虑来自于对未来的不确定性，而这种不确定性是一个特定时代加上特定行业的产物。 今天的我们处在一个人类历史上少有的快速发展时代，我们看不清以后的人生，大脑却还停留在上一代人的思维习惯上。 IT 行业在国内的大发展也就最近20多年的事，行业里很少有走过完整职业生涯的程序员。 也正是因为如此，我们经常会产生了各种焦虑： 我刚刚入行时，有人问，程序员能做到 30 岁吗？ 我快 30 岁时，有人问，35 岁还能做程序员吗？ 我 35 岁时，讨论变成了 40 岁的程序员该怎么办？ 估计等国内有越来越多的程序员走完了整个职业生涯，就会有人关心，程序员退休之后的生活应该是什么样子了。 2、坦然面对当前的问题接下来，我们要踏上征程，一步一个脚印的看清楚当前面临的问题。 如果你还什么都不会，那就应该从HelloWorld编码开始。 如果你已经能够写好普通的代码，那就应该尝试去练习更复杂算法的代码。 如果你实现一个具体功能都没问题了，那就去做架构设计，让程序有更好的组织。 如果你已经能完成一个普通的系统设计，那就应该去设计业务量更大的系统。 如果你还没有工作，那有一份编程的工作就好。 如果你已经有一份收入尚可的工作，那就可以考虑冲击下有挑战性的岗位或大厂。 3、什么样的程序员才是优秀的程序员呢？ 本人眼中：写的一手好代码，做过几个大项目，设计、编程不在话下 同学眼中：刚毕业就去了大厂，各种福利待遇羡慕的不行 同事眼中：人挺好，干活挺快 HR眼中：省钱、出活 4、五个关键特质1、熟练操作一门编程语言 优秀的程序员需要写的一手好代码。把标准降低来说，最起码需要熟练使用一门编程语言。 熟练了之后，很多语法、语句在我们编写程序的时候，会下意识地就流露出来。正如，我们中国人会熟练的使用筷子夹各种食物；很多年轻人会熟练的骑自行车，下意识的避开路上的障碍。如果我们设计一个线程类，在编写代码时，至少 class 和 extends 这两个关键字的使用是不需要大脑有意识地参与的。 编程语言，基本上是相通的。掌握了第一门编程语言后，第二门语言学起来就快很多，第三门语言学起来更快。现在我们几乎都是多语言使用者，但一定要先精通一门语言，达到像用筷子那样的熟练程度。 2、解决实际问题的能力 代码是要解决具体的问题的，我们需要通过编程语言把解决问题的办法和思路表达出来。 要解决具体的问题，仅仅做到熟练使用编程语言是远远不够的，优秀的程序员还要深入理解问题，懂得问题的最核心价值。 只有理解了问题，看到了解决问题的价值，我们才能够真正解决好问题，并且从中获得满满的成就感。我们一定要记得，程序员的存在不是为了写代码，而是为了解决现实问题，实现现实价值。 真实的作品，都带着我们对于现实问题的理解。而打磨一个这样的作品，需要缜密的逻辑、 突破创新和贯彻执行。通过使用合适的工具，把简单的、一行一行的代码，耐心地粘合、打 磨成优秀的作品。 这里举例几个：阿里合伙人 前蚂蚁金服CEO胡晓明：中专 前阿里集团CTO张建峰：中专(温州机械工业学校) 前蚂蚁金服CTO胡喜：大学肄业(大连外国语) 现蚂蚁金服CTO倪行军：大专(浙江财经学院) 3、发现关键问题的能力 能够发现关键的问题，是一个好程序员和优秀程序员的分水岭。 优秀的程序员，能够发现一门编程语言的缺陷，一个顺手工具的局限。所以，他知道该怎么选择最合适的工具，该怎么避免不必要的麻烦。 优秀的程序员，能够发现解决方案背后的妥协和风险。所以，他可以预设风险防范措施，设置软件的适用边界。 优秀的程序员，能够敏锐地观察到产品的关键问题，或者客户未被满足的需求。所以，他可以推动产品持续地进步和演化。 能够发现关键的问题，意味着我们可以从一个被动的做事情的程序员，升级为一个主动找事情的程序员。 能够发现关键的问题，往往需要我们对一个领域有很深入的研究和深厚的积累，并且对新鲜事物保持充分的好奇心和求知欲。 我们写的每一行代码，都可能存在问题。有时候，我发现别人的代码的问题；有时候，别人 发现我的代码的问题。我们最后都会明白，要坦诚地面对别人的问题，也要坦然地面对自己的问题。在解决问题和帮助别人解决问题中，我们把一个产品变得越来越好，问题越来越少。 4、是可以依赖的伙伴 优秀的程序员是一个领导型的人。他能够倾听，持续地获取他人的优秀想法，以及不同的意见。他能够表达，准确地传递自己的想法，恰当地陈述自己的意见。 他是一个给予者，给别人尊重，给别人启发，给别人指导，给别人施展才华的空间。 他是一个索取者，需要获得尊重，需要获得支持，需要持续学习，需要一个自主决策的空间。他能够应对压力，承担责 任，积极主动，大部分时候保持克制和冷静，偶尔也会表达愤怒。 他具有一定的影响力，以及良好的人际关系，能够和各种类型的人相处，能够引发反对意见，但是又不损害人际关 系。他知道什么时候可以妥协，什么时候应该坚持。 上面的这些，通常称为“软技能”。如果说，编程语言、花样工具、逻辑思维、解决问题这些“硬技能”可以决定我们的起点的话，影响力、人际关系这些“软技能”通常影响着我们可以到达的高度。因为，无论我们是加入他人的团队，或者组建自己的团队，我们只有在团队中才能变得越来越出色，做的事情越来越重要。所以，我们需要成为优秀的团队成员，接受影响，也影响他人。 5、自律、适度的偏执 当谈到成为优秀的程序员时，自律和适度的偏执是两个非常重要的特质。它们有助于提高工作效率、代码质量和问题解决能力。 一个自律的程序员能够有效地管理时间、资源和任务，以达到最佳的工作成果。以下是自律如何在编程中发挥作用的几个方面： 时间管理：自律的程序员能够设定合理的工作时间表，并遵循这些时间表来完成任务。他们知道何时专注于编码，何时进行休息和放松，以保持高效率。 任务优先级：自律的程序员能够识别任务的重要性和紧急性，并根据优先级合理地分配时间和精力。这有助于避免陷入无谓的琐事，而是专注于关键的项目和问题。 学习和成长：优秀的程序员不断学习新技术和工具。自律的程序员会制定学习计划，定期投入时间来提升自己的技能，以保持竞争力。 代码质量：自律的程序员遵循最佳实践，编写干净、可维护和可扩展的代码。他们会花时间进行代码审查和测试，以确保交付高质量的软件。 适度的偏执是指对细节的高度关注和追求完美的态度。在编程中，这种偏执可以带来以下好处： Bug 的挖掘：适度的偏执使程序员对代码的每个细节都充满敏感。他们会仔细检查可能的边界情况和潜在的错误，从而减少Bug的出现概率。 性能优化：偏执的程序员会追求代码的高效性能。他们会关注算法的时间和空间复杂度，以及代码执行的速度，以确保软件在各种情况下都能够高效运行。 代码审查：偏执的程序员会在代码审查过程中严格要求自己和同事。他们会挑剔地检查代码，确保代码质量和一致性。 综上所述，自律和适度的偏执是成为优秀程序员的关键特质。自律能够帮助管理时间和资源，以及保持持续的学习和提升。适度的偏执则有助于保障代码质量，挖掘潜在问题，并提供出色的用户体验。这两个特质相互补充，共同促使程序员在不断变化的技术环境中脱颖而出。","categories":[{"name":"程序猿","slug":"程序猿","permalink":"http://example.com/categories/%E7%A8%8B%E5%BA%8F%E7%8C%BF/"}],"tags":[{"name":"经验","slug":"经验","permalink":"http://example.com/tags/%E7%BB%8F%E9%AA%8C/"}]},{"title":"八、终极实战：SpringBoot版微头条实战","slug":"SSM/八、终极实战：SpringBoot版微头条实战/八、终极实战：SpringBoot版微头条实战","date":"2022-10-02T10:55:54.000Z","updated":"2023-09-28T00:33:28.583Z","comments":true,"path":"2022/10/02/SSM/八、终极实战：SpringBoot版微头条实战/八、终极实战：SpringBoot版微头条实战/","link":"","permalink":"http://example.com/2022/10/02/SSM/%E5%85%AB%E3%80%81%E7%BB%88%E6%9E%81%E5%AE%9E%E6%88%98%EF%BC%9ASpringBoot%E7%89%88%E5%BE%AE%E5%A4%B4%E6%9D%A1%E5%AE%9E%E6%88%98/%E5%85%AB%E3%80%81%E7%BB%88%E6%9E%81%E5%AE%9E%E6%88%98%EF%BC%9ASpringBoot%E7%89%88%E5%BE%AE%E5%A4%B4%E6%9D%A1%E5%AE%9E%E6%88%98/","excerpt":"","text":"八、终极实战：SpringBoot版微头条实战目录 一、微头条案例介绍 微头条业务简介 技术栈介绍 功能展示 二、微头条前端搭建 三、基于SpringBoot搭建项目基础架构 1. 数据库脚本执行 2. 搭建SprintBoot工程 3. MybatisX逆向工程 四、后台功能开发 4.1 用户模块开发 4.2 首页模块开发 4.3 头条模块开发 五、前后端联调 一、微头条案例介绍微头条业务简介 用户功能 注册功能 登录功能 jwt实现 头条新闻 新闻的分页浏览 通过标题关键字搜索新闻 查看新闻详情 新闻的修改和删除 技术栈介绍 前端技术栈 ES6作为基础JS语法 nodejs用于运行环境 npm用于项目依赖管理工具 vite用于项目的构建架工具 Vue3用于项目数据的渲染框架 Axios用于前后端数据的交互 Router用于页面的跳转 Pinia用于存储用户的数据 LocalStorage作为用户校验token的存储手段 Element-Plus提供组件 后端技术栈 JAVA作为开发语言,版本为JDK17 Tomcat作为服务容器,版本为10.1.7 Mysql8用于项目存储数据 SpringMVC用于控制层实现前后端数据交互 MyBatis-Plus用于实现数据的CURD Druid用于提供数据源的连接池 SpringBoot作为项目基础架构 MD5用于用户密码的加密 Jwt用于token的生成和校验 Jackson用于转换JSON 功能展示 头条首页信息搜索 登录功能 注册功能 展示功能 发布头条功能 修改头条功能 删除头条功能 二、微头条前端搭建 确保本地node，npm，vscode安装完毕！ 如果没有安装可以回看ssm整合实战！ 解压前端项目代码并存放到磁盘的合适位置 atguigu-headline.rar 使用vscode打开工程 进入项目后打开集成终端或者在src上右击选择在集成终端中打开 通过 npm run dev启动前端项目 12npm install npm run dev 三、基于SpringBoot搭建项目基础架构1. 数据库脚本执行执行数据库脚本: top_news.sql 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293CREATE DATABASE sm_db;USE sm_db;SET NAMES utf8mb4;SET FOREIGN_KEY_CHECKS = 0;-- ------------------------------ Table structure for news_headline-- ----------------------------DROP TABLE IF EXISTS `news_headline`;CREATE TABLE `news_headline` ( `hid` INT NOT NULL AUTO_INCREMENT COMMENT &#x27;头条id&#x27;, `title` VARCHAR(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT &#x27;头条标题&#x27;, `article` VARCHAR(5000) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT &#x27;头条新闻内容&#x27;, `type` INT NOT NULL COMMENT &#x27;头条类型id&#x27;, `publisher` INT NOT NULL COMMENT &#x27;头条发布用户id&#x27;, `page_views` INT NOT NULL COMMENT &#x27;头条浏览量&#x27;, `create_time` DATETIME(0) NULL DEFAULT NULL COMMENT &#x27;头条发布时间&#x27;, `update_time` DATETIME(0) NULL DEFAULT NULL COMMENT &#x27;头条最后的修改时间&#x27;, `version` INT DEFAULT 1 COMMENT &#x27;乐观锁&#x27;, `is_deleted` INT DEFAULT 0 COMMENT &#x27;头条是否被删除 1 删除 0 未删除&#x27;, PRIMARY KEY (`hid`) USING BTREE) ENGINE = INNODB AUTO_INCREMENT = 1 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = DYNAMIC;-- ------------------------------ Records of news_headline-- ----------------------------INSERT INTO `news_headline` (hid,title,article,TYPE,publisher,page_views,create_time,update_time,is_deleted) VALUES (1, &#x27;特色产业激发乡村振兴新活力&#x27;, &#x27;推进中国式现代化，必须全面推进乡村振兴。习近平总书记指出，产业振兴是乡村振兴的重中之重，也是实际工作的切入点。近日，记者走进乡村一线，看到各地以特色产业为抓手，拓展产业链发展产业集群，一二三产业融合发展，培育乡村振兴新动能。\\n\\n 这个端午，广东茂名高州市根子镇柏桥村的荔枝迎来了丰收。今年4月，习近平总书记来到柏桥村考察调研。总书记走进荔枝种植园，了解当地发展特色种植产业和文旅产业等情况，并同现场技术人员亲切交流。&#x27;, 1, 1, 0, &#x27;2023-06-25 09:26:20&#x27;, &#x27;2023-06-25 09:26:20&#x27;, 0);INSERT INTO `news_headline` (hid,title,article,TYPE,publisher,page_views,create_time,update_time,is_deleted) VALUES (2, &#x27;北京连续三天最高温超40℃，6月“炎值”因何爆表？&#x27;, &#x27; 中新社北京6月24日电 (记者 陈杭 徐婧)京城连续三日“热晴不减”，且高温红色预警持续生效。截至24日13时51分，作为北京地区气象观测代表站的南郊观象台气温突破40℃，这是该站观测史上首次连续三天气温超40℃。22日以来，北京高温“烤验”突出。22日，北京南郊观象台最高气温达41.1℃，这是有观测纪录以来历史第二高(并列)。北京市气象局表示，观象台1951年建站以来极端最高气温为41.9℃，出现在1999年7月24日。\\n\\n 23日，北京南郊观象台最高气温为40.3℃，这是该观象台建站以来首次出现连续两天最高气温超40℃。当天，北京时隔9年再次发布最高级别的高温红色预警信号。&#x27;, 1, 1, 0, &#x27;2023-06-25 09:28:06&#x27;, &#x27;2023-06-25 09:28:06&#x27;, 0);INSERT INTO `news_headline` (hid,title,article,TYPE,publisher,page_views,create_time,update_time,is_deleted) VALUES (3, &#x27;今年夏天，极端高温是否会成为常态？&#x27;, &#x27;针对京津冀地区持续高温天气，23日下午，中国气象局召开高温天气新闻通气会。\\n\\n 刚过6月就出现极端高温天，今年夏天还会有多少高温天呢？对此，国家气候中心首席预报员高辉表示，根据国家气候中心预计，今年夏天全国大部分地区气温都比常年同期要偏高，这也对应着高温日数也要高于常年同期。但不同的地区，高温集中时段不一样，比如南方地区是在盛夏时间段进入高温季，而北方地区往往是在初夏时间段，所以从今年夏季来说，要区分不同的地区来考虑高温的影响。\\n\\n 我国各地高温集中时段有明显的地域差异。对华北地区来说，通常雨季前的6月至7月初更容易出现高温天气，连续数天的高温在6月也比较常见。高辉说，这段时间主要是干热型高温为主，表现为气温高湿度小。进入7月后期，随着副高北跳和夏季风往北推进，水汽输送和大气湿度增加，云量也会增多，会出现闷热天气，也就是湿热型高温。就最高气温而言，前一时段气温最高值通常高于后一时段。但也需要说明的是，人体体感温度不仅和气温有关，还受到湿度影响，往往这种湿热型高温会加重人体体感温度。&#x27;, 1, 1, 0, &#x27;2023-06-25 09:31:00&#x27;, &#x27;2023-06-25 09:31:00&#x27;, 0);INSERT INTO `news_headline` (hid,title,article,TYPE,publisher,page_views,create_time,update_time,is_deleted) VALUES (4, &#x27;中央气象台发布今年首个高温橙色预警&#x27;, &#x27;新华社北京6月22日电（记者黄垚）22日18时，中央气象台升级发布今年首个高温橙色预警。预计23日白天，华北、黄淮等地将继续出现35℃以上的高温天气，北京、天津、河北中南部、山东中北部等地部分地区最高气温可达40℃左右。\\n\\n 气象监测显示，22日8时至16时，北京、天津、河北中部、山东北部等地气温上升迅猛，最高气温升至40℃以上。上述4省份共有17个国家气象观测站最高气温突破历史极值。&#x27;, 1, 1, 0, &#x27;2023-06-25 09:31:36&#x27;, &#x27;2023-06-25 09:31:36&#x27;, 0);INSERT INTO `news_headline` (hid,title,article,TYPE,publisher,page_views,create_time,update_time,is_deleted) VALUES (5, &#x27;江南水乡 龙舟竞渡&#x27;, &#x27;江南水乡 龙舟竞渡---6月18日，浙江省湖州市“我们的节日·端午”暨第七届江南·民当端午民俗文化旅游节在南浔区和孚镇民当村开幕，来自南浔区各个乡镇的农民选手在河道中赛龙舟、划菱桶，体验传统端午民俗。&#x27;, 1, 1, 0, &#x27;2023-06-25 09:32:13&#x27;, &#x27;2023-06-25 09:32:13&#x27;, 0);INSERT INTO `news_headline` (hid,title,article,TYPE,publisher,page_views,create_time,update_time,is_deleted) VALUES (6, &#x27;螃蟹粽、印花蛋、艾草凉粉……你知道端午有哪些创意美食吗？&#x27;, &#x27;端午有旅行路上的见闻，有诗画里的艺术，也少不了舌尖上的风韵。听风入夏粽香佐茶，您还知道端午有哪些创意美食吗？端午至味，总少不了粽子这一味。甜的、咸的，肉馅的、蛋黄的、红枣的、豆沙的……一起来寻味端午！\\n\\n 古人其实早就喜欢把各种果干放进粽子里，美食家苏轼还发明了杨梅粽。《玉台新咏》中说，“酒中喜桃子，粽里觅杨梅。”后来苏轼曾借用过这个典故，在元祐三年所写的端午帖子中说，“不独盘中见卢橘，时于粽里得杨梅”。&#x27;, 1, 1, 0, &#x27;2023-06-25 09:32:40&#x27;, &#x27;2023-06-25 09:32:40&#x27;, 0);INSERT INTO `news_headline` (hid,title,article,TYPE,publisher,page_views,create_time,update_time,is_deleted) VALUES (7, &#x27;尼克斯拒绝执行罗斯球队选项 罗斯成自由球员&#x27;, &#x27;北京时间6月25日，据多方消息源报道，尼克斯拒绝执行德里克-罗斯下赛季的球队选项，罗斯成为完全自由球员。\\n\\n 34岁的罗斯在刚刚结束的赛季队内角色严重下滑，他仅出战27场比赛，场均登场12.5分钟，得到5.6分1.5篮板1.7助攻。\\n\\n 2021年，罗斯与尼克斯签下3年4300万美元的续约合同，其中最后一年为1560万美元球队选项。&#x27;, 2, 2, 0, &#x27;2023-06-25 09:34:26&#x27;, &#x27;2023-06-25 09:34:26&#x27;, 0);INSERT INTO `news_headline` (hid,title,article,TYPE,publisher,page_views,create_time,update_time,is_deleted) VALUES (8, &#x27;班凯罗承诺代表美国男篮打世界杯 名单仅差1人&#x27;, &#x27;北京时间6月25日，据著名NBA记者沙姆斯-查拉尼亚报道，魔术前锋保罗-班凯罗承诺将代表美国男篮参加2023年男篮世界杯。\\n\\n 班凯罗在刚刚结束的赛季场均能够砍下20.0分6.9篮板3.7助攻，获得了NBA2022-23赛季年度最佳新秀。&#x27;, 2, 2, 0, &#x27;2023-06-25 09:34:59&#x27;, &#x27;2023-06-25 09:34:59&#x27;, 0);INSERT INTO `news_headline` (hid,title,article,TYPE,publisher,page_views,create_time,update_time,is_deleted) VALUES (9, &#x27;F1加拿大大奖赛正赛：维斯塔潘冠军 阿隆索亚军&#x27;, &#x27;2023年F1加拿大大奖赛正式比赛结束。红牛车队维斯塔潘杆位发车一路轻松领跑，再次完成了Pole-to-Win！这是红牛车队历史上的第100座分站冠军！同时也是维斯塔潘F1生涯的第41座分站冠军，追平了“车神”埃尔顿·塞纳的冠军数！阿斯顿马丁车队阿隆索亚军，梅赛德斯车队汉密尔顿季军。&#x27;, 2, 2, 0, &#x27;2023-06-25 09:35:43&#x27;, &#x27;2023-06-25 09:35:43&#x27;, 0);INSERT INTO `news_headline` (hid,title,article,TYPE,publisher,page_views,create_time,update_time,is_deleted) VALUES (10, &#x27;CTCC绍兴柯桥站圆满落幕 张志强曹宏炜各取一冠&#x27;, &#x27;6月24日，2023赛季CTCC中国汽车场地职业联赛绍兴柯桥站在雨中的浙江国际赛车场上演了两回合决赛的巅峰角逐。在线上线下观众的共同见证下，超级杯-TCR中国系列赛、运动杯-长三角赛车节联袂献上高水平对决，以精彩的比赛献礼这个端午节假期！TCR 中国系列赛第三回合于今天上午率先开战。来自壳牌捷凯领克车队的张志强穿云破雾夺得冠军；夺得该回合亚军的是驾驶新赛车出战的东风本田车手高度，季军则由Z.SPEED N车队的张臻东斩获。这也是超级杯四冠王本赛季首次登台。&#x27;, 2, 2, 0, &#x27;2023-06-25 09:36:18&#x27;, &#x27;2023-06-25 09:36:18&#x27;, 0);INSERT INTO `news_headline` (hid,title,article,TYPE,publisher,page_views,create_time,update_time,is_deleted) VALUES (11, &#x27;国象联赛常规赛收兵：杭州银行第一 山东成功上岸&#x27;, &#x27;6月17日，“武陵山大裂谷杯”中国国际象棋甲级联赛常规赛在武陵云海国际酒店进行了最后一轮的争夺，杭州银行弈和山东队，抢到常规赛的冠军；山东队也是凭借这场平局，成功脱离保级区。本轮最大的悬念是第八名的争夺——在年底进行的甲级联赛总决赛中，前八名为上半区争冠组，保级无忧；而第九至十二名为保级区，不仅夺冠无望，还要为保级而苦战。&#x27;, 2, 2, 0, &#x27;2023-06-25 09:36:51&#x27;, &#x27;2023-06-25 09:36:51&#x27;, 0);INSERT INTO `news_headline` (hid,title,article,TYPE,publisher,page_views,create_time,update_time,is_deleted) VALUES (12, &#x27;围棋名宿解读高考作文:人生如棋 要先学会下“本手”&#x27;, &#x27;今年高考开考了，在语文考试后，体育借势冲上了社交媒体的热搜榜。奥运相关话题进入高考，是意料之中。不过当记者看到关于围棋术语“本手、妙手和俗手”的作文命题时，着实觉得有些难。在被迅速刷屏的朋友圈里，记者感受到了很多从业者的激动、兴奋乃至油然而生的自豪感。但也有人则为那些没学过棋的孩子感到担心，这么难的题目，究竟该如何解题？\\n\\n “围棋正在深入人心。题目有些难，‘俗手’如何定义？但确实应该先下好‘本手’。”翻到中国围棋协会副主席、国家围棋队领队华学明的这条朋友圈动态时，记者瞬间觉得这道公认的难题有了解题的思路。正如高考作文材料中所说，本手是基础。只有持之以恒地打好基础，补强短板，守住不发生系统性风险的底线，才有可能在本手的基础上，下出妙手，避免俗手。而如果脱离了基础，所谓的妙手很可能就是花拳绣腿，经不起推敲，更经不起对手的冲击。世界冠军柯洁表示：“很多人在对局中经常会拘泥于局部，下出假妙手。想下出真正的妙手，必须在平日里有一定的经验积累和训练，才可能完成真正卓越的妙手。”人生如棋，棋如人生。“其实人生中大部分时间都是在下本手”，围棋名宿曹大元九段说。&#x27;, 2, 2, 0, &#x27;2023-06-25 09:37:43&#x27;, &#x27;2023-06-25 09:37:43&#x27;, 0);INSERT INTO `news_headline` (hid,title,article,TYPE,publisher,page_views,create_time,update_time,is_deleted) VALUES (13, &#x27;不甘人后：被生成式AI弥漫的亚马逊&#x27;, &#x27;今年早些时候，随着ChatGPT席卷全球，亚马逊的经理们要求员工开动脑筋，想想如何使用人工智能（AI）聊天机器人技术来改进自家产品和工作流程。\\n\\n 其中一些想法被分享在一份名为《生成式AI——ChatGPT的影响和机会分析》的内部文件中。这份文件共列了ChatGPT和类似应用程序在亚马逊多个团队中的67个潜在应用案例。\\n\\n 早在20世纪90年代，亚马逊就靠在网上卖书创造了互联网界首个真正的商业奇迹。\\n\\n 随后，Kindle阅读器带来革命性体验，Alexa和Echo智能音箱又带来了语音计算，而AWS则创造了云计算行业，ChatGPT就运行在这个行业之上。\\n\\n 但这次热潮中拿到先发优势的是同为科技大厂的微软。微软现在是OpenAI背后的金主，且还在忙着把ChatGPT的底层技术融进微软产品和服务中。&#x27;, 4, 5, 0, &#x27;2023-06-25 09:40:20&#x27;, &#x27;2023-06-25 09:40:20&#x27;, 0);INSERT INTO `news_headline` (hid,title,article,TYPE,publisher,page_views,create_time,update_time,is_deleted) VALUES (14, &#x27;微创新超实用：米家旅行箱居然想到了这一点&#x27;, &#x27;旅行说走就走，除非老板没安排。名义上是旅游，实则执行任务，对内讲“为公司负重前行”，对外称“带薪游山玩水”，一介打工人，两副扑克脸，个中苦乐谁人知！\\n\\n“差旅人”精明如我，随身携带更偏向实用。\\n\\n必备日用之外，能路上买的尽量不带，华而不实的东西，往包里多塞一个都算我输。行李箱尺寸自然也要浓缩到小巧但够装的20英寸，拉着轻松又顺手，常用小物件转移到背包，“轻装上战场”。&#x27;, 4, 5, 0, &#x27;2023-06-25 09:41:04&#x27;, &#x27;2023-06-25 09:41:04&#x27;, 0);INSERT INTO `news_headline` (hid,title,article,TYPE,publisher,page_views,create_time,update_time,is_deleted) VALUES (15, &#x27;小鹏G6动态试驾：辅助驾驶很惊喜&#x27;, &#x27;这次我们开着小鹏G6上了赛道，又体验了最新版本的高速NGP和城市NGP，小鹏，还顺便测了下充电速度，那么小鹏G6驾驶感受如何？辅助驾驶表现怎么样？&#x27;, 4, 5, 0, &#x27;2023-06-25 09:42:07&#x27;, &#x27;2023-06-25 09:42:07&#x27;, 0);INSERT INTO `news_headline` (hid,title,article,TYPE,publisher,page_views,create_time,update_time,is_deleted) VALUES (16, &#x27;养车市场陷入低价内卷，“虎猫狗”还没等到春天&#x27;, &#x27;今年“618”期间，汽车后市场的玩家们都打出了“低价牌”。比如途虎养车宣布推出“6.18全民养车季”活动，在此期间北京车主可享受“轮胎买一送一”以及多品牌轮胎降价促销的活动。\\n\\n 与此同时，京东养车和天猫养车两大大厂玩家，在本次618期间也喊出了各自的营销口号。\\n\\n 前者不仅喊出了“养车爱车立省不止30%”的口号，还推出了轮胎、保养买贵赔两倍、“轮胎免费装、三年无忧质保”、5公里无服务门店赔双倍安装费等举措；天猫养车的618活动，则覆盖了更大的零部件范围，比如推出了空调清洗、机油和轮胎更换等低价服务。\\n\\n 这样看，在本次618期间，途虎养车、京东养车和天猫养车均贯彻着“以价换量”的战略，以至于让行业价格战一触即发。这些玩家会这样做，主要是为了与传统4S店、以及与彼此竞争，以便保证自身获得更多的市场份额。&#x27;, 4, 5, 0, &#x27;2023-06-25 09:42:51&#x27;, &#x27;2023-06-25 09:42:51&#x27;, 0);INSERT INTO `news_headline` (hid,title,article,TYPE,publisher,page_views,create_time,update_time,is_deleted) VALUES (17, &#x27;微软股价历史新高 聊天机器人技术潜力显现&#x27;, &#x27;周四，微软股价创下历史新高，成为今年继英伟达和苹果之后，又一家市值达到新高点的大型科技公司。这家软件巨头正致力于在其产品和服务中添加生成式人工智能功能，旨在全面改造其Office产品阵容，其中包括Excel、PowerPoint、Outlook和Word等。股价上涨3.2%，收于每股348.1美元，为2021年11月19日以来的最高收盘价。自今年初起，微软股价累计上涨了45%，市值增加约8006亿美元。微软持有OpenAI的大部分股份，这家初创公司凭借聊天机器人ChatGPT引发生成式人工智能的热潮。近几个月来，该工具广受欢迎，展示了聊天机器人技术所具有的巨大潜力。微软于今年1月宣布将再向OpenAI投资100亿美元。然而有报道称，微软与OpenAI之间既有合作，亦存竞争，这种特殊的双重关系导致了双方关系的紧张和潜在冲突。科技股如英伟达等同样受益于生成式人工智能技术的应用，各公司将此技术融入各自产品，进而推动相关芯片需求。英伟达股价今年已飙升192%，被视为最大赢家。&#x27;, 4, 5, 0, &#x27;2023-06-25 09:43:48&#x27;, &#x27;2023-06-25 09:43:48&#x27;, 0);INSERT INTO `news_headline` (hid,title,article,TYPE,publisher,page_views,create_time,update_time,is_deleted) VALUES (18, &#x27;再获11亿美元投资：蔚来“长期主义”的底气&#x27;, &#x27;如果说全系降价3万是李斌的“阳谋”，那么蔚来ET5T的发布，则是李斌的又一次诚意之作。\\n\\n ET5T是蔚来首款售价下探到30万元以下的新车，作为ET5的姐妹车型，ET5T和ET5的双车合璧，得以在30万以下快速开疆辟土。\\n\\n 这样的做法有迹可循：特斯拉曾经在Model Y上实践过，并大获成功。\\n\\n Model Y和Model 3共用平台，零部件复用率高达75%，研发成本骤降。尽管Model Y最初被用户吐槽是Model 3的放大版，但不置可否的是Model Y确实解决了用户对Model 3空间不足的槽点。\\n\\n 不过，最为关键的还是Model Y的价格足够低，直接降低了特斯拉的购买门槛，给那些对价格敏感，本犹豫要不要多花四五万的消费者一个充足的理由。\\n\\n 蔚来ET5T正在用一种经受了市场验证过的方式，直面与特斯拉的竞争。但同时，蔚来ET5T在智能化、空间表现、设计以及产品力上，都正在接近、超越特斯拉Model Y。\\n\\n 蔚来ET5T，平替特斯拉Model Y？\\n\\n 小家庭，预算30万左右，消费者到底会选哪款纯电动车？\\n\\n 全球市场的反馈是，特斯拉Model Y ——一款紧凑型SUV。2022年，Model Y的全球销量为74.7万辆，其在中国的销量为31.5万台，约占其全球份额的42.2%。\\n\\n 按照车型大小，SUV可以分为大型、中型、小型、紧凑型四大类。按照价位，SUV又可以分为实用型、经济型、中高档型、豪华型、超豪华型等。\\n\\n Model Y 在中高端SUV的细分市场中一骑绝尘，可以说是没有对手。因为无论是奔驰EQC、宝马iX3，还是国产的比亚迪唐EV等，和Model Y相比，都不能对其构成威胁。奔驰EQC、宝马iX3这两款车型都是“油改电”，算不上真正的电动车。而比亚迪的智能化能力，远及不特斯拉，座舱、智驾上的核心模块还来自于供应商方案，并非自研。\\n\\n 雷峰网认为，此前，国内的自主品牌中只有蔚来的ES6能和Model Y一较高下。不过ES6的均价比Model Y高出一大截，二者入门版之间的价差大约在10万左右。但在蔚来推出ET5T后，局势必然会发生逆转。&#x27;, 4, 5, 0, &#x27;2023-06-25 09:44:20&#x27;, &#x27;2023-06-25 09:44:20&#x27;, 0);-- ------------------------------ Table structure for news_type-- ----------------------------DROP TABLE IF EXISTS `news_type`;CREATE TABLE `news_type` ( `tid` INT NOT NULL AUTO_INCREMENT COMMENT &#x27;新闻类型id&#x27;, `tname` VARCHAR(10) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT &#x27;新闻类型描述&#x27;, `version` INT DEFAULT 1 COMMENT &#x27;乐观锁&#x27;, `is_deleted` INT DEFAULT 0 COMMENT &#x27;头条是否被删除 1 删除 0 未删除&#x27;, PRIMARY KEY (`tid`) USING BTREE) ENGINE = INNODB AUTO_INCREMENT = 8 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = DYNAMIC;-- ------------------------------ Records of news_type-- ----------------------------INSERT INTO `news_type` (tid,tname) VALUES (1, &#x27;新闻&#x27;);INSERT INTO `news_type` (tid,tname) VALUES (2, &#x27;体育&#x27;);INSERT INTO `news_type` (tid,tname) VALUES (3, &#x27;娱乐&#x27;);INSERT INTO `news_type` (tid,tname) VALUES (4, &#x27;科技&#x27;);INSERT INTO `news_type` (tid,tname) VALUES (5, &#x27;其他&#x27;);-- ------------------------------ Table structure for news_user-- ----------------------------DROP TABLE IF EXISTS `news_user`;CREATE TABLE `news_user` ( `uid` INT NOT NULL AUTO_INCREMENT COMMENT &#x27;用户id&#x27;, `username` VARCHAR(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT &#x27;用户登录名&#x27;, `user_pwd` VARCHAR(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT &#x27;用户登录密码密文&#x27;, `nick_name` VARCHAR(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT &#x27;用户昵称&#x27;, `version` INT DEFAULT 1 COMMENT &#x27;乐观锁&#x27;, `is_deleted` INT DEFAULT 0 COMMENT &#x27;头条是否被删除 1 删除 0 未删除&#x27;, PRIMARY KEY (`uid`) USING BTREE, UNIQUE INDEX `username_unique`(`username`) USING BTREE) ENGINE = INNODB AUTO_INCREMENT = 9 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = DYNAMIC;-- ------------------------------ Records of news_user-- ----------------------------INSERT INTO `news_user` (uid,username,user_pwd,nick_name) VALUES (1, &#x27;zhangsan&#x27;, &#x27;e10adc3949ba59abbe56e057f20f883e&#x27;, &#x27;张三&#x27;);INSERT INTO `news_user` (uid,username,user_pwd,nick_name) VALUES (2, &#x27;lisi&#x27;, &#x27;e10adc3949ba59abbe56e057f20f883e&#x27;, &#x27;李四&#x27;);INSERT INTO `news_user` (uid,username,user_pwd,nick_name) VALUES (5, &#x27;zhangxiaoming&#x27;, &#x27;e10adc3949ba59abbe56e057f20f883e&#x27;, &#x27;张小明&#x27;);INSERT INTO `news_user` (uid,username,user_pwd,nick_name)VALUES (6, &#x27;xiaohei&#x27;, &#x27;e10adc3949ba59abbe56e057f20f883e&#x27;, &#x27;李小黑&#x27;);SET FOREIGN_KEY_CHECKS = 1; 2. 搭建SprintBoot工程 创建boot工程 导入依赖 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;3.0.5&lt;/version&gt;&lt;/parent&gt;&lt;groupId&gt;com.atguigu&lt;/groupId&gt;&lt;artifactId&gt;springboot-headline&lt;/artifactId&gt;&lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;&lt;properties&gt; &lt;maven.compiler.source&gt;17&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;17&lt;/maven.compiler.target&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;&lt;/properties&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- mybatis-plus --&gt; &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.5.3.1&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 数据库相关配置启动器 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- druid启动器的依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-3-starter&lt;/artifactId&gt; &lt;version&gt;1.2.18&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 驱动类--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.28&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.28&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt;&lt;/dependencies&gt; org.springframework.boot spring-boot-maven-plugin 123456789101112131415161718192021222324252627283. 编写配置 application.yaml ```yaml # server配置 server: port: 8080 servlet: context-path: / # 连接池配置 spring: datasource: type: com.alibaba.druid.pool.DruidDataSource druid: url: jdbc:mysql:///sm_db1 username: root password: root driver-class-name: com.mysql.cj.jdbc.Driver # mybatis-plus的配置 mybatis-plus: type-aliases-package: com.atguigu.pojo global-config: db-config: logic-delete-field: isDeleted #全局逻辑删除 id-type: auto #主键策略自增长 table-prefix: news_ # 设置表的前缀 druid兼容springboot3文件 文件名和内容 12文件名:org.springframework.boot.autoconfigure.AutoConfiguration.imports内容:com.alibaba.druid.spring.boot3.autoconfigure.DruidDataSourceAutoConfigure 启动类和mybatis-plus配置 包: com.atguigu 1234567891011121314151617181920@SpringBootApplication@MapperScan(&quot;com.atguigu.mapper&quot;)public class Main &#123; public static void main(String[] args) &#123; SpringApplication.run(Main.class,args); &#125; //配置mybatis-plus插件 @Bean public MybatisPlusInterceptor mybatisPlusInterceptor() &#123; MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor(); interceptor.addInnerInterceptor(new PaginationInnerInterceptor(DbType.MYSQL)); //分页 interceptor.addInnerInterceptor(new OptimisticLockerInnerInterceptor()); //乐观锁 interceptor.addInnerInterceptor(new BlockAttackInnerInterceptor()); //防全局修改和删除 return interceptor; &#125;&#125; 工具类准备 结果封装类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667/** * 全局统一返回结果类 */public class Result&lt;T&gt; &#123; // 返回码 private Integer code; // 返回消息 private String message; // 返回数据 private T data; public Result()&#123;&#125; // 返回数据 protected static &lt;T&gt; Result&lt;T&gt; build(T data) &#123; Result&lt;T&gt; result = new Result&lt;T&gt;(); if (data != null) result.setData(data); return result; &#125; public static &lt;T&gt; Result&lt;T&gt; build(T body, Integer code, String message) &#123; Result&lt;T&gt; result = build(body); result.setCode(code); result.setMessage(message); return result; &#125; public static &lt;T&gt; Result&lt;T&gt; build(T body, ResultCodeEnum resultCodeEnum) &#123; Result&lt;T&gt; result = build(body); result.setCode(resultCodeEnum.getCode()); result.setMessage(resultCodeEnum.getMessage()); return result; &#125; /** * 操作成功 * @param data baseCategory1List * @param &lt;T&gt; * @return */ public static&lt;T&gt; Result&lt;T&gt; ok(T data)&#123; Result&lt;T&gt; result = build(data); return build(data, ResultCodeEnum.SUCCESS); &#125; public Result&lt;T&gt; message(String msg)&#123; this.setMessage(msg); return this; &#125; public Result&lt;T&gt; code(Integer code)&#123; this.setCode(code); return this; &#125; public Integer getCode() &#123; return code; &#125; public void setCode(Integer code) &#123; this.code = code; &#125; public String getMessage() &#123; return message; &#125; public void setMessage(String message) &#123; this.message = message; &#125; public T getData() &#123; return data; &#125; public void setData(T data) &#123; this.data = data; &#125;&#125; 解决枚举类 1234567891011121314151617181920212223242526/** * 统一返回结果状态信息类 * */public enum ResultCodeEnum &#123; SUCCESS(200,&quot;success&quot;), USERNAME_ERROR(501,&quot;usernameError&quot;), PASSWORD_ERROR(503,&quot;passwordError&quot;), NOTLOGIN(504,&quot;notLogin&quot;), USERNAME_USED(505,&quot;userNameUsed&quot;); private Integer code; private String message; private ResultCodeEnum(Integer code, String message) &#123; this.code = code; this.message = message; &#125; public Integer getCode() &#123; return code; &#125; public String getMessage() &#123; return message; &#125;&#125; MD5加密工具类 12345678910111213141516171819202122232425262728import java.security.MessageDigest;import java.security.NoSuchAlgorithmException;@Componentpublic final class MD5Util &#123; public static String encrypt(String strSrc) &#123; try &#123; char hexChars[] = &#123; &#x27;0&#x27;, &#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;4&#x27;, &#x27;5&#x27;, &#x27;6&#x27;, &#x27;7&#x27;, &#x27;8&#x27;, &#x27;9&#x27;, &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;, &#x27;f&#x27; &#125;; byte[] bytes = strSrc.getBytes(); MessageDigest md = MessageDigest.getInstance(&quot;MD5&quot;); md.update(bytes); bytes = md.digest(); int j = bytes.length; char[] chars = new char[j * 2]; int k = 0; for (int i = 0; i &lt; bytes.length; i++) &#123; byte b = bytes[i]; chars[k++] = hexChars[b &gt;&gt;&gt; 4 &amp; 0xf]; chars[k++] = hexChars[b &amp; 0xf]; &#125; return new String(chars); &#125; catch (NoSuchAlgorithmException e) &#123; e.printStackTrace(); throw new RuntimeException(&quot;MD5加密出错！！+&quot; + e); &#125; &#125;&#125; 3. MybatisX逆向工程 逆向工程 完善实体类注解 删除tableName注解,全局统一设置 添加主键,乐观锁,逻辑删除注解!!! 1234567891011121314151617181920@Datapublic class User implements Serializable &#123; @TableId private Integer uid; private String username; private String userPwd; private String nickName; @Version private Integer version; @TableLogic private Integer isDeleted; private static final long serialVersionUID = 1L;&#125; 四、后台功能开发4.1 用户模块开发 1.1 jwt和token介绍 token介绍 令牌（Token）：在计算机领域，令牌是一种代表某种访问权限或身份认证信息的令牌。它可以是一串随机生成的字符或数字，用于验证用户的身份或授权用户对特定资源的访问。普通的令牌可能以各种形式出现，如访问令牌、身份令牌、刷新令牌等。 简单理解 : 每个用户生成的唯一字符串标识,可以进行用户识别和校验 类似技术: 天王盖地虎 ,小鸡炖蘑菇 优势: token验证标识无法直接识别用户的信息,盗取token后也无法`登录`程序! 相对安全! jwt介绍 Token是一项规范和标准(接口) JWT(JSON Web Token)是具体可以生成,校验,解析等动作Token的技术(实现类) jwt工作流程 用户提供其凭据（通常是用户名和密码）进行身份验证。 服务器对这些凭据进行验证，并在验证成功后创建一个JWT。 服务器将JWT发送给客户端，并客户端在后续的请求中将JWT附加在请求头或参数中。 服务器接收到请求后，验证JWT的签名和有效性，并根据JWT中的声明进行身份验证和授权操作 jwt数据组成和包含信息 JWT由三部分组成: header(头部).payload(载荷).signature(签名) 我们需要理解的是, jwt可以携带很多信息! 一般情况,需要加入:有效时间,签名秘钥,其他用户标识信息! 有效时间为了保证token的时效性,过期可以重新登录获取! 签名秘钥为了防止其他人随意解析和校验token数据! 用户信息为了我们自己解析的时候,知道Token对应的具体用户! jwt使用和测试 导入依赖 1234567891011&lt;dependency&gt; &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt; &lt;artifactId&gt;jjwt&lt;/artifactId&gt; &lt;version&gt;0.9.1&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;javax.xml.bind&lt;/groupId&gt; &lt;artifactId&gt;jaxb-api&lt;/artifactId&gt; &lt;version&gt;2.3.0&lt;/version&gt;&lt;/dependency&gt; 编写配置 application.yaml 12345#jwt配置jwt: token: tokenExpiration: 120 #有效时间,单位分钟 tokenSignKey: headline123456 #当前程序签名秘钥 自定义 导入工具类 封装jwt技术工具类 123456789101112131415161718192021222324252627282930313233343536373839404142package com.atguigu.utils;import com.alibaba.druid.util.StringUtils;import io.jsonwebtoken.*;import lombok.Data;import org.springframework.boot.context.properties.ConfigurationProperties;import org.springframework.context.annotation.Configuration;import org.springframework.stereotype.Component;import java.util.Date;@Data@Component@ConfigurationProperties(prefix = &quot;jwt.token&quot;)public class JwtHelper &#123; private long tokenExpiration; //有效时间,单位毫秒 1000毫秒 == 1秒 private String tokenSignKey; //当前程序签名秘钥 //生成token字符串 public String createToken(Long userId) &#123; System.out.println(&quot;tokenExpiration = &quot; + tokenExpiration); System.out.println(&quot;tokenSignKey = &quot; + tokenSignKey); String token = Jwts.builder() .setSubject(&quot;YYGH-USER&quot;) .setExpiration(new Date(System.currentTimeMillis() + tokenExpiration*1000*60)) //单位分钟 .claim(&quot;userId&quot;, userId) .signWith(SignatureAlgorithm.HS512, tokenSignKey) .compressWith(CompressionCodecs.GZIP) .compact(); return token; &#125; //从token字符串获取userid public Long getUserId(String token) &#123; if(StringUtils.isEmpty(token)) return null; Jws&lt;Claims&gt; claimsJws = Jwts.parser().setSigningKey(tokenSignKey).parseClaimsJws(token); Claims claims = claimsJws.getBody(); Integer userId = (Integer)claims.get(&quot;userId&quot;); return userId.longValue(); &#125; //判断token是否有效 public boolean isExpiration(String token)&#123; try &#123; boolean isExpire = Jwts.parser() .setSigningKey(tokenSignKey) .parseClaimsJws(token) .getBody() .getExpiration().before(new Date()); //没有过期，有效，返回false return isExpire; &#125;catch(Exception e) &#123; //过期出现异常，返回true return true; &#125; &#125; &#125; 1234567891011121314151617181920212223244. 使用和测试 ```java @org.springframework.boot.test.context.SpringBootTest public class SpringBootTest &#123; @Autowired private JwtHelper jwtHelper; @Test public void test()&#123; //生成 传入用户标识 String token = jwtHelper.createToken(1L); System.out.println(&quot;token = &quot; + token); //解析用户标识 int userId = jwtHelper.getUserId(token).intValue(); System.out.println(&quot;userId = &quot; + userId); //校验是否到期! false 未到期 true到期 boolean expiration = jwtHelper.isExpiration(token); System.out.println(&quot;expiration = &quot; + expiration); &#125; &#125; 1.2 登录功能实现 需求描述 用户在客户端输入用户名密码并向后端提交,后端根据用户名和密码判断登录是否成功,用户有误或者密码有误响应不同的提示信息！ 接口描述 url地址： user&#x2F;login 请求方式：POST 请求参数： 1234&#123; &quot;username&quot;:&quot;zhangsan&quot;, //用户名 &quot;userPwd&quot;:&quot;123456&quot; //明文密码&#125; 响应数据： 成功 1234567&#123; &quot;code&quot;:&quot;200&quot;, // 成功状态码 &quot;message&quot;:&quot;success&quot; // 成功状态描述 &quot;data&quot;:&#123; &quot;token&quot;:&quot;... ...&quot; // 用户id的token &#125;&#125; 失败 12345&#123; &quot;code&quot;:&quot;501&quot;, &quot;message&quot;:&quot;用户名有误&quot; &quot;data&quot;:&#123;&#125;&#125; 12345&#123; &quot;code&quot;:&quot;503&quot;, &quot;message&quot;:&quot;密码有误&quot; &quot;data&quot;:&#123;&#125;&#125; 实现代码 controller1234@RestController@RequestMapping(&quot;user&quot;)@CrossOriginpublic class UserController &#123; @Autowired private UserService userService; /** * 登录需求 * 地址: /user/login * 方式: post * 参数: * &#123; * &quot;username&quot;:&quot;zhangsan&quot;, //用户名 * &quot;userPwd&quot;:&quot;123456&quot; //明文密码 * &#125; * 返回: * &#123; * &quot;code&quot;:&quot;200&quot;, // 成功状态码 * &quot;message&quot;:&quot;success&quot; // 成功状态描述 * &quot;data&quot;:&#123; * &quot;token&quot;:&quot;... ...&quot; // 用户id的token * &#125; * &#125; * * 大概流程: * 1. 账号进行数据库查询 返回用户对象 * 2. 对比用户密码(md5加密) * 3. 成功,根据userId生成token -&gt; map key=token value=token值 - result封装 * 4. 失败,判断账号还是密码错误,封装对应的枚举错误即可 */ @PostMapping(&quot;login&quot;) public Result login(@RequestBody User user)&#123; Result result = userService.login(user); System.out.println(&quot;result = &quot; + result); return result; &#125; &#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546472. service ```java @Service public class UserServiceImpl extends ServiceImpl&lt;UserMapper, User&gt; implements UserService&#123; @Autowired private JwtHelper jwtHelper; @Autowired private UserMapper userMapper; /** * 登录业务实现 * @param user * @return result封装 */ @Override public Result login(User user) &#123; //根据账号查询 LambdaQueryWrapper&lt;User&gt; queryWrapper = new LambdaQueryWrapper&lt;&gt;(); queryWrapper.eq(User::getUsername,user.getUsername()); User loginUser = userMapper.selectOne(queryWrapper); //账号判断 if (loginUser == null) &#123; //账号错误 return Result.build(null, ResultCodeEnum.USERNAME_ERROR); &#125; //判断密码 if (!StringUtils.isEmpty(user.getUserPwd()) &amp;&amp; loginUser.getUserPwd().equals(MD5Util.encrypt(user.getUserPwd()))) &#123; //账号密码正确 //根据用户唯一标识生成token String token = jwtHelper.createToken(Long.valueOf(loginUser.getUid())); Map data = new HashMap(); data.put(&quot;token&quot;,token); return Result.ok(data); &#125; //密码错误 return Result.build(null,ResultCodeEnum.PASSWORD_ERROR); &#125; &#125; 1.3 根据token获取用户数据 需求描述 客户端发送请求,提交token请求头,后端根据token请求头获取登录用户的详细信息并响应给客户端进行存储 接口描述 url地址：user&#x2F;getUserInfo 请求方式：GET 请求头： 1token: token内容 响应数据： 成功 123456789101112&#123; &quot;code&quot;: 200, &quot;message&quot;: &quot;success&quot;, &quot;data&quot;: &#123; &quot;loginUser&quot;: &#123; &quot;uid&quot;: 1, &quot;username&quot;: &quot;zhangsan&quot;, &quot;userPwd&quot;: &quot;&quot;, &quot;nickName&quot;: &quot;张三&quot; &#125; &#125;&#125; 失败 12345&#123; &quot;code&quot;: 504, &quot;message&quot;: &quot;notLogin&quot;, &quot;data&quot;: null&#125; 代码实现 controller1234567891011121314151617181920212223242526272829/** * 地址: user/getUserInfo * 方式: get * 请求头: token = token内容 * 返回: * &#123; * &quot;code&quot;: 200, * &quot;message&quot;: &quot;success&quot;, * &quot;data&quot;: &#123; * &quot;loginUser&quot;: &#123; * &quot;uid&quot;: 1, * &quot;username&quot;: &quot;zhangsan&quot;, * &quot;userPwd&quot;: &quot;&quot;, * &quot;nickName&quot;: &quot;张三&quot; * &#125; * &#125; * &#125; * * 大概流程: * 1.获取token,解析token对应的userId * 2.根据userId,查询用户数据 * 3.将用户数据的密码置空,并且把用户数据封装到结果中key = loginUser * 4.失败返回504 (本次先写到当前业务,后期提取到拦截器和全局异常处理器) */@GetMapping(&quot;getUserInfo&quot;)public Result userInfo(@RequestHeader String token)&#123; Result result = userService.getUserInfo(token); return result;&#125; service1234567891011121314151617181920212223242526272829/** * 查询用户数据 * @param token * @return result封装 */@Overridepublic Result getUserInfo(String token) &#123; //1.判定是否有效期 if (jwtHelper.isExpiration(token)) &#123; //true过期,直接返回未登录 return Result.build(null,ResultCodeEnum.NOTLOGIN); &#125; //2.获取token对应的用户 int userId = jwtHelper.getUserId(token).intValue(); //3.查询数据 User user = userMapper.selectById(userId); if (user != null) &#123; user.setUserPwd(null); Map data = new HashMap(); data.put(&quot;loginUser&quot;,user); return Result.ok(data); &#125; return Result.build(null,ResultCodeEnum.NOTLOGIN);&#125; 1.4 注册用户名检查 需求描述 用户在注册时输入用户名时,立刻将用户名发送给后端,后端根据用户名查询用户名是否可用并做出响应 接口描述 url地址：user&#x2F;checkUserName 请求方式：POST 请求参数：param形式 1username=zhangsan 响应数据： 成功 12345&#123; &quot;code&quot;:&quot;200&quot;, &quot;message&quot;:&quot;success&quot; &quot;data&quot;:&#123;&#125;&#125; 失败 12345&#123; &quot;code&quot;:&quot;505&quot;, &quot;message&quot;:&quot;用户名占用&quot; &quot;data&quot;:&#123;&#125;&#125; 代码实现 controller12345678910111213141516171819202122/** * url地址：user/checkUserName * 请求方式：POST * 请求参数：param形式 * username=zhangsan * 响应数据: * &#123; * &quot;code&quot;:&quot;200&quot;, * &quot;message&quot;:&quot;success&quot; * &quot;data&quot;:&#123;&#125; * &#125; * * 实现步骤: * 1. 获取账号数据 * 2. 根据账号进行数据库查询 * 3. 结果封装 */@PostMapping(&quot;checkUserName&quot;)public Result checkUserName(String username)&#123; Result result = userService.checkUserName(username); return result;&#125; service&#x20;12345678910111213141516171819/** * 检查账号是否可以注册 * * @param username 账号信息 * @return */@Overridepublic Result checkUserName(String username) &#123; LambdaQueryWrapper&lt;User&gt; queryWrapper = new LambdaQueryWrapper&lt;&gt;(); queryWrapper.eq(User::getUsername,username); User user = userMapper.selectOne(queryWrapper); if (user != null)&#123; return Result.build(null,ResultCodeEnum.USERNAME_USED); &#125; return Result.ok(null);&#125; 1.5 用户注册功能 需求描述 客户端将新用户信息发送给服务端,服务端将新用户存入数据库,存入之前做用户名是否被占用校验,校验通过响应成功提示,否则响应失败提示 接口描述 url地址：user&#x2F;regist 请求方式：POST 请求参数： 12345&#123; &quot;username&quot;:&quot;zhangsan&quot;, &quot;userPwd&quot;:&quot;123456&quot;, &quot;nickName&quot;:&quot;张三&quot;&#125; 响应数据： 成功 12345&#123; &quot;code&quot;:&quot;200&quot;, &quot;message&quot;:&quot;success&quot; &quot;data&quot;:&#123;&#125;&#125; 失败 12345&#123; &quot;code&quot;:&quot;505&quot;, &quot;message&quot;:&quot;用户名占用&quot; &quot;data&quot;:&#123;&#125;&#125; 代码实现 controller123456789101112131415161718192021222324252627/*** url地址：user/regist* 请求方式：POST* 请求参数：* &#123;* &quot;username&quot;:&quot;zhangsan&quot;,* &quot;userPwd&quot;:&quot;123456&quot;,* &quot;nickName&quot;:&quot;张三&quot;* &#125;* 响应数据：* &#123;* &quot;code&quot;:&quot;200&quot;,* &quot;message&quot;:&quot;success&quot;* &quot;data&quot;:&#123;&#125;* &#125;** 实现步骤:* 1. 将密码加密* 2. 将数据插入* 3. 判断结果,成 返回200 失败 505*/@PostMapping(&quot;regist&quot;)public Result regist(@RequestBody User user)&#123; Result result = userService.regist(user); return result;&#125; service&#x20;123456789101112131415@Overridepublic Result regist(User user) &#123; LambdaQueryWrapper&lt;User&gt; queryWrapper = new LambdaQueryWrapper&lt;&gt;(); queryWrapper.eq(User::getUsername,user.getUsername()); Long count = userMapper.selectCount(queryWrapper); if (count &gt; 0)&#123; return Result.build(null,ResultCodeEnum.USERNAME_USED); &#125; user.setUserPwd(MD5Util.encrypt(user.getUserPwd())); int rows = userMapper.insert(user); System.out.println(&quot;rows = &quot; + rows); return Result.ok(null);&#125; 4.2 首页模块开发 2.1 查询首页分类 需求描述 进入新闻首页,查询所有分类并动态展示新闻类别栏位 接口描述 url地址：portal&#x2F;findAllTypes 请求方式：get 请求参数：无 响应数据： 成功 12345678910111213141516171819202122232425262728&#123; &quot;code&quot;:&quot;200&quot;, &quot;message&quot;:&quot;OK&quot; &quot;data&quot;:&#123; [ &#123; &quot;tid&quot;:&quot;1&quot;, &quot;tname&quot;:&quot;新闻&quot; &#125;, &#123; &quot;tid&quot;:&quot;2&quot;, &quot;tname&quot;:&quot;体育&quot; &#125;, &#123; &quot;tid&quot;:&quot;3&quot;, &quot;tname&quot;:&quot;娱乐&quot; &#125;, &#123; &quot;tid&quot;:&quot;4&quot;, &quot;tname&quot;:&quot;科技&quot; &#125;, &#123; &quot;tid&quot;:&quot;5&quot;, &quot;tname&quot;:&quot;其他&quot; &#125; ] &#125;&#125; 代码实现 controller12345678910111213141516171819@RestController@RequestMapping(&quot;portal&quot;)@CrossOriginpublic class PortalController &#123; @Autowired private TypeService typeService; /** * 查询全部类别信息 * @return */ @GetMapping(&quot;findAllTypes&quot;) public Result findAllTypes()&#123; //直接调用业务层,查询全部数据 List&lt;Type&gt; list = typeService.list(); return Result.ok(list); &#125;&#125; 2.2 分页查询首页头条信息 需求描述 客户端向服务端发送查询关键字,新闻类别,页码数,页大小 服务端根据条件搜索分页信息,返回含页码数,页大小,总页数,总记录数,当前页数据等信息,并根据时间降序,浏览量降序排序 接口描述 url地址：portal&#x2F;findNewsPage 请求方式：post 请求参数: 123456&#123; &quot;keyWords&quot;:&quot;马斯克&quot;, // 搜索标题关键字 &quot;type&quot;:0, // 新闻类型 &quot;pageNum&quot;:1, // 页码数 &quot;pageSize&quot;:10 // 页大小&#125; 响应数据： 成功 1234567891011121314151617181920212223242526272829303132333435363738&#123; &quot;code&quot;:&quot;200&quot;, &quot;message&quot;:&quot;success&quot; &quot;data&quot;:&#123; &quot;pageInfo&quot;:&#123; &quot;pageData&quot;:[ &#123; &quot;hid&quot;:&quot;1&quot;, // 新闻id &quot;title&quot;:&quot;尚硅谷宣布 ... ...&quot;, // 新闻标题 &quot;type&quot;:&quot;1&quot;, // 新闻所属类别编号 &quot;pageViews&quot;:&quot;40&quot;, // 新闻浏览量 &quot;pastHours&quot;:&quot;3&quot; , // 发布时间已过小时数 &quot;publisher&quot;:&quot;1&quot; // 发布用户ID &#125;, &#123; &quot;hid&quot;:&quot;1&quot;, // 新闻id &quot;title&quot;:&quot;尚硅谷宣布 ... ...&quot;, // 新闻标题 &quot;type&quot;:&quot;1&quot;, // 新闻所属类别编号 &quot;pageViews&quot;:&quot;40&quot;, // 新闻浏览量 &quot;pastHours&quot;:&quot;3&quot;, // 发布时间已过小时数 &quot;publisher&quot;:&quot;1&quot; // 发布用户ID &#125;, &#123; &quot;hid&quot;:&quot;1&quot;, // 新闻id &quot;title&quot;:&quot;尚硅谷宣布 ... ...&quot;, // 新闻标题 &quot;type&quot;:&quot;1&quot;, // 新闻所属类别编号 &quot;pageViews&quot;:&quot;40&quot;, // 新闻浏览量 &quot;pastHours&quot;:&quot;3&quot;, // 发布时间已过小时数 &quot;publisher&quot;:&quot;1&quot; // 发布用户ID &#125; ], &quot;pageNum&quot;:1, //页码数 &quot;pageSize&quot;:10, // 页大小 &quot;totalPage&quot;:20, // 总页数 &quot;totalSize&quot;:200 // 总记录数 &#125; &#125;&#125; 代码实现 准备条件实体类 12345678@Datapublic class PortalVo &#123; private String keyWords; private Integer type; private Integer pageNum = 1; private Integer pageSize =10;&#125; controller 123456789/** * 首页分页查询 * @return */@PostMapping(&quot;findNewPage&quot;)public Result findNewPage(@RequestBody PortalVo portalVo)&#123; Result result = headlineService.findNewPage(portalVo); return result;&#125; service 12345678910111213141516171819202122232425262728293031323334353637383940414243@Servicepublic class HeadlineServiceImpl extends ServiceImpl&lt;HeadlineMapper, Headline&gt; implements HeadlineService&#123; @Autowired private HeadlineMapper headlineMapper; /** * 首页数据查询 * @param portalVo * @return */ @Override public Result findNewPage(PortalVo portalVo) &#123; //1.条件拼接 需要非空判断 LambdaQueryWrapper&lt;Headline&gt; queryWrapper = new LambdaQueryWrapper&lt;&gt;(); queryWrapper.like(!StringUtils.isEmpty(portalVo.getKeyWords()),Headline::getTitle,portalVo.getKeyWords()) .eq(portalVo.getType()!= null,Headline::getType,portalVo.getType()); //2.分页参数 IPage&lt;Headline&gt; page = new Page&lt;&gt;(portalVo.getPageNum(),portalVo.getPageSize()); //3.分页查询 //查询的结果 &quot;pastHours&quot;:&quot;3&quot; // 发布时间已过小时数 我们查询返回一个map //自定义方法 headlineMapper.selectPageMap(page, portalVo); //4.结果封装 //分页数据封装 Map&lt;String,Object&gt; pageInfo =new HashMap&lt;&gt;(); pageInfo.put(&quot;pageData&quot;,page.getRecords()); pageInfo.put(&quot;pageNum&quot;,page.getCurrent()); pageInfo.put(&quot;pageSize&quot;,page.getSize()); pageInfo.put(&quot;totalPage&quot;,page.getPages()); pageInfo.put(&quot;totalSize&quot;,page.getTotal()); Map&lt;String,Object&gt; pageInfoMap=new HashMap&lt;&gt;(); pageInfoMap.put(&quot;pageInfo&quot;,pageInfo); // 响应JSON return Result.ok(pageInfoMap); &#125;&#125; mapper 接口: 123456public interface HeadlineMapper extends BaseMapper&lt;Headline&gt; &#123; //自定义分页查询方法 IPage&lt;Map&gt; selectPageMap(IPage&lt;Headline&gt; page, @Param(&quot;portalVo&quot;) PortalVo portalVo);&#125; mapperxml: 12345678910&lt;select id=&quot;selectPageMap&quot; resultType=&quot;map&quot;&gt; select hid,title,type,page_views pageViews,TIMESTAMPDIFF(HOUR,create_time,NOW()) pastHours, publisher from news_headline where is_deleted=0 &lt;if test=&quot;portalVo.keyWords !=null and portalVo.keyWords.length()&gt;0 &quot;&gt; and title like concat(&#x27;%&#x27;,#&#123;portalVo.keyWords&#125;,&#x27;%&#x27;) &lt;/if&gt; &lt;if test=&quot;portalVo.type != null and portalVo.type != 0&quot;&gt; and type = #&#123;portalVo.type&#125; &lt;/if&gt;&lt;/select&gt; 2.3 查询头条详情 需求描述 用户点击”查看全文”时,向服务端发送新闻id 后端根据新闻id查询完整新闻文章信息并返回 后端要同时让新闻的浏览量+1 接口描述 url地址：portal&#x2F;showHeadlineDetail 请求方式：post 请求参数: 1hid=1 param形成参数 响应数据： 成功 1234567891011121314151617&#123; &quot;code&quot;:&quot;200&quot;, &quot;message&quot;:&quot;success&quot;, &quot;data&quot;:&#123; &quot;headline&quot;:&#123; &quot;hid&quot;:&quot;1&quot;, // 新闻id &quot;title&quot;:&quot;马斯克宣布 ... ...&quot;, // 新闻标题 &quot;article&quot;:&quot;... ...&quot; // 新闻正文 &quot;type&quot;:&quot;1&quot;, // 新闻所属类别编号 &quot;typeName&quot;:&quot;科技&quot;, // 新闻所属类别 &quot;pageViews&quot;:&quot;40&quot;, // 新闻浏览量 &quot;pastHours&quot;:&quot;3&quot; , // 发布时间已过小时数 &quot;publisher&quot;:&quot;1&quot; , // 发布用户ID &quot;author&quot;:&quot;张三&quot; // 新闻作者 &#125; &#125;&#125; 代码实现 controller 12345678910 /** * 首页详情接口 * @param hid * @return */@PostMapping(&quot;showHeadlineDetail&quot;)public Result showHeadlineDetail(Integer hid)&#123; Result result = headlineService.showHeadlineDetail(hid); return result;&#125; service 12345678910111213141516171819202122232425262728293031323334/** * 详情数据查询 * &quot;headline&quot;:&#123; * &quot;hid&quot;:&quot;1&quot;, // 新闻id * &quot;title&quot;:&quot;马斯克宣布 ... ...&quot;, // 新闻标题 * &quot;article&quot;:&quot;... ...&quot; // 新闻正文 * &quot;type&quot;:&quot;1&quot;, // 新闻所属类别编号 * &quot;typeName&quot;:&quot;科技&quot;, // 新闻所属类别 * &quot;pageViews&quot;:&quot;40&quot;, // 新闻浏览量 * &quot;pastHours&quot;:&quot;3&quot; , // 发布时间已过小时数 * &quot;publisher&quot;:&quot;1&quot; , // 发布用户ID * &quot;author&quot;:&quot;张三&quot; // 新闻作者 * &#125; * 注意: 是多表查询 , 需要更新浏览量+1 * * @param hid * @return */@Overridepublic Result showHeadlineDetail(Integer hid) &#123; //1.实现根据id的查询(多表 Map headLineDetail = headlineMapper.selectDetailMap(hid); //2.拼接头条对象(阅读量和version)进行数据更新 Headline headline = new Headline(); headline.setHid(hid); headline.setPageViews((Integer) headLineDetail.get(&quot;pageViews&quot;)+1); //阅读量+1 headline.setVersion((Integer) headLineDetail.get(&quot;version&quot;)); //设置版本 headlineMapper.updateById(headline); Map&lt;String,Object&gt; pageInfoMap=new HashMap&lt;&gt;(); pageInfoMap.put(&quot;headline&quot;,headLineDetail); return Result.ok(pageInfoMap);&#125; mapper 接口: 123456/** * 分页查询头条详情 * @param hid * @return */Map selectDetailMap(Integer hid); mapperxml: 123456789&lt;!-- Map selectDetailMap(Integer hid);--&gt;&lt;select id=&quot;selectDetailMap&quot; resultType=&quot;map&quot;&gt; select hid,title,article,type, h.version ,tname typeName ,page_views pageViews ,TIMESTAMPDIFF(HOUR,create_time,NOW()) pastHours,publisher ,nick_name author from news_headline h left join news_type t on h.type = t.tid left join news_user u on h.publisher = u.uid where hid = #&#123;hid&#125;&lt;/select&gt; 4.3 头条模块开发 **3.1 登陆验证和保护 ** 需求描述 客户端在进入发布页前、发布新闻前、进入修改页前、修改前、删除新闻前先向服务端发送请求携带token请求头 后端接收token请求头后,校验用户登录是否过期并做响应 前端根据响应信息提示用户进入登录页还是进入正常业务页面 接口描述 url地址：user&#x2F;checkLogin 请求方式：get 请求参数: 无 请求头： token: 用户token 响应数据： 未过期： 12345&#123; &quot;code&quot;:&quot;200&quot;, &quot;message&quot;:&quot;success&quot;, &quot;data&quot;:&#123;&#125;&#125; 过期： 12345&#123; &quot;code&quot;:&quot;504&quot;, &quot;message&quot;:&quot;loginExpired&quot;, &quot;data&quot;:&#123;&#125;&#125; 代码实现 controller 【登录检查】123456789@GetMapping(&quot;checkLogin&quot;)public Result checkLogin(@RequestHeader String token)&#123; if (StringUtils.isEmpty(token) || jwtHelper.isExpiration(token))&#123; //没有传或者过期 未登录 return Result.build(null, ResultCodeEnum.NOTLOGIN); &#125; return Result.ok(null);&#125; 拦截器 【所有&#x2F;headline开头都需要检查登陆】1234567891011121314151617181920212223@Componentpublic class LoginProtectInterceptor implements HandlerInterceptor &#123; @Autowired private JwtHelper jwtHelper; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; String token = request.getHeader(&quot;token&quot;); if (StringUtils.isEmpty(token) || jwtHelper.isExpiration(token))&#123; Result result = Result.build(null, ResultCodeEnum.NOTLOGIN); ObjectMapper objectMapper = new ObjectMapper(); String json = objectMapper.writeValueAsString(result); response.getWriter().print(json); //拦截 return false; &#125;else&#123; //放行 return true; &#125; &#125;&#125; 拦截器配置1234567891011@Configurationpublic class WebMvcConfig implements WebMvcConfigurer &#123; @Autowired private LoginProtectInterceptor loginProtectInterceptor; @Override public void addInterceptors(InterceptorRegistry registry) &#123; registry.addInterceptor(loginProtectInterceptor).addPathPatterns(&quot;/headline/**&quot;); &#125;&#125; 3.2 头条发布实现 需求描述 用户在客户端输入发布的新闻信息完毕后 发布前先请求后端的登录校验接口验证登录 登录通过则提交新闻信息 后端将新闻信息存入数据库 接口描述 url地址：headline&#x2F;publish 请求方式：post 请求头:&#x20; 1token: ... ... 请求参数: 12345&#123; &quot;title&quot;:&quot;尚硅谷宣布 ... ...&quot;, // 文章标题 &quot;article&quot;:&quot;... ...&quot;, // 文章内容 &quot;type&quot;:&quot;1&quot; // 文章类别&#125; 响应数据： 未登录 12345&#123; &quot;code&quot;:&quot;504&quot;, &quot;message&quot;:&quot;loginExpired&quot;, &quot;data&quot;:&#123;&#125;&#125; 成功 123456&#123; &quot;code&quot;:&quot;200&quot;, &quot;message&quot;:&quot;success&quot;, &quot;data&quot;:&#123;&#125;&#125; 代码实现 controller1234567891011121314/** * 实现步骤: * 1. token获取userId [无需校验,拦截器会校验] * 2. 封装headline数据 * 3. 插入数据即可 */@PostMapping(&quot;publish&quot;)public Result publish(@RequestBody Headline headline,@RequestHeader String token)&#123; int userId = jwtHelper.getUserId(token).intValue(); headline.setPublisher(userId); Result result = headlineService.publish(headline); return result;&#125; service12345678910111213/** * 发布数据 * @param headline * @return */@Overridepublic Result publish(Headline headline) &#123; headline.setCreateTime(new Date()); headline.setUpdateTime(new Date()); headline.setPageViews(0); headlineMapper.insert(headline); return Result.ok(null);&#125; 3.3 修改头条回显 需求描述 前端先调用登录校验接口,校验登录是否过期 登录校验通过后 ,则根据新闻id查询新闻的完整信息并响应给前端 接口描述 url地址：headline&#x2F;findHeadlineByHid 请求方式：post 请求参数: 1hid=1 param形成参数 响应数据： 成功 123456789101112&#123; &quot;code&quot;:&quot;200&quot;, &quot;message&quot;:&quot;success&quot;, &quot;data&quot;:&#123; &quot;headline&quot;:&#123; &quot;hid&quot;:&quot;1&quot;, &quot;title&quot;:&quot;马斯克宣布&quot;, &quot;article&quot;:&quot;... ... &quot;, &quot;type&quot;:&quot;2&quot; &#125; &#125;&#125; 代码实现 controller12345@PostMapping(&quot;findHeadlineByHid&quot;)public Result findHeadlineByHid(Integer hid)&#123; Result result = headlineService.findHeadlineByHid(hid); return result;&#125; service123456789101112/** * 根据id查询详情 * @param hid * @return */@Overridepublic Result findHeadlineByHid(Integer hid) &#123; Headline headline = headlineMapper.selectById(hid); Map&lt;String,Object&gt; pageInfoMap=new HashMap&lt;&gt;(); pageInfoMap.put(&quot;headline&quot;,headline); return Result.ok(pageInfoMap);&#125; 3.4 头条修改实现 需求描述 客户端将新闻信息修改后,提交前先请求登录校验接口校验登录状态 登录校验通过则提交修改后的新闻信息,后端接收并更新进入数据库 接口描述 url地址：headline&#x2F;update 请求方式：post 请求参数: 123456&#123; &quot;hid&quot;:&quot;1&quot;, &quot;title&quot;:&quot;尚硅谷宣布 ... ...&quot;, &quot;article&quot;:&quot;... ...&quot;, &quot;type&quot;:&quot;2&quot;&#125; 响应数据： 成功 12345&#123; &quot;code&quot;:&quot;200&quot;, &quot;message&quot;:&quot;success&quot;, &quot;data&quot;:&#123;&#125;&#125; 代码实现 controller12345@PostMapping(&quot;update&quot;)public Result update(@RequestBody Headline headline)&#123; Result result = headlineService.updateHeadLine(headline); return result;&#125; service123456789101112131415161718192021 /** * 修改业务 * 1.查询version版本 * 2.补全属性,修改时间 , 版本! * * @param headline * @return */@Overridepublic Result updateHeadLine(Headline headline) &#123; //读取版本 Integer version = headlineMapper.selectById(headline.getHid()).getVersion(); headline.setVersion(version); headline.setUpdateTime(new Date()); headlineMapper.updateById(headline); return Result.ok(null);&#125; 3.5 删除头条功能 需求描述 将要删除的新闻id发送给服务端 服务端校验登录是否过期,未过期则直接删除,过期则响应登录过期信息 接口描述 url地址：headline&#x2F;removeByHid 请求方式：post 请求参数: 1hid=1 param形成参数 响应数据： 成功 12345&#123; &quot;code&quot;:&quot;200&quot;, &quot;message&quot;:&quot;success&quot;, &quot;data&quot;:&#123;&#125;&#125; 代码实现 controller12345@PostMapping(&quot;removeByHid&quot;)public Result removeById(Integer hid)&#123; headlineService.removeById(hid); return Result.ok(null);&#125; 五、前后端联调","categories":[{"name":"SSM框架","slug":"SSM框架","permalink":"http://example.com/categories/SSM%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"ssm","slug":"ssm","permalink":"http://example.com/tags/ssm/"}]},{"title":"七、MyBatis-Plus高级用法：最优化持久层开发","slug":"SSM/七、MyBatis-Plus高级用法：最优化持久层开发/七、MyBatis-Plus高级用法：最优化持久层开发","date":"2022-10-02T09:55:54.000Z","updated":"2023-09-28T00:33:12.215Z","comments":true,"path":"2022/10/02/SSM/七、MyBatis-Plus高级用法：最优化持久层开发/七、MyBatis-Plus高级用法：最优化持久层开发/","link":"","permalink":"http://example.com/2022/10/02/SSM/%E4%B8%83%E3%80%81MyBatis-Plus%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95%EF%BC%9A%E6%9C%80%E4%BC%98%E5%8C%96%E6%8C%81%E4%B9%85%E5%B1%82%E5%BC%80%E5%8F%91/%E4%B8%83%E3%80%81MyBatis-Plus%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95%EF%BC%9A%E6%9C%80%E4%BC%98%E5%8C%96%E6%8C%81%E4%B9%85%E5%B1%82%E5%BC%80%E5%8F%91/","excerpt":"","text":"七、MyBatis-Plus高级用法：最优化持久层开发目录 一、MyBatis-Plus快速入门 1.1 简介 1.2 快速入门 二、MyBatis-Plus核心功能 2.1 基于Mapper接口CRUD Insert方法 Delete方法 Update方法 Select方法 自定义和多表映射 2.2 基于Service接口CRUD 对比Mapper接口CRUD区别： 使用Iservice接口方式 CRUD方法介绍 2.3 分页查询实现 2.4 条件构造器使用 2.4.1 条件构造器作用 2.4.2 条件构造器继承结构 2.4.3 基于QueryWrapper 组装条件 2.3.4 基于 UpdateWrapper组装条件 2.3.5 基于LambdaQueryWrapper组装条件 2.3.6 基于LambdaUpdateWrapper组装条件 2.5 核心注解使用 三、MyBatis-Plus高级扩展 3.1 逻辑删除实现 3.2 乐观锁实现 3.2.1 悲观锁和乐观锁场景和介绍 3.2.2 使用mybatis-plus数据使用乐观锁 3.3 防全表更新和删除实现 四、MyBatis-Plus代码生成器(MyBatisX插件) 4.1 Mybatisx插件逆向工程 4.2 MyBatisX快速代码生成 一、MyBatis-Plus快速入门1.1 简介 课程版本：3.5.3.1 https://baomidou.com/ MyBatis-Plus (opens new window)（简称 MP）是一个 MyBatis (opens new window) 的增强工具，在 MyBatis 的基础上只做增强不做改变，为简化开发、提高效率而生。 特性： 无侵入：只做增强不做改变，引入它不会对现有工程产生影响，如丝般顺滑 损耗小：启动即会自动注入基本 CURD，性能基本无损耗，直接面向对象操作 强大的 CRUD 操作：内置通用 Mapper、通用 Service，仅仅通过少量配置即可实现单表大部分 CRUD 操作，更有强大的条件构造器，满足各类使用需求 支持 Lambda 形式调用：通过 Lambda 表达式，方便的编写各类查询条件，无需再担心字段写错 支持主键自动生成：支持多达 4 种主键策略（内含分布式唯一 ID 生成器 - Sequence），可自由配置，完美解决主键问题 支持 ActiveRecord 模式：支持 ActiveRecord 形式调用，实体类只需继承 Model 类即可进行强大的 CRUD 操作 支持自定义全局通用操作：支持全局通用方法注入（ Write once, use anywhere ） 内置代码生成器：采用代码或者 Maven 插件可快速生成 Mapper 、 Model 、 Service 、 Controller 层代码，支持模板引擎，更有超多自定义配置等您来使用 内置分页插件：基于 MyBatis 物理分页，开发者无需关心具体操作，配置好插件之后，写分页等同于普通 List 查询 分页插件支持多种数据库：支持 MySQL、MariaDB、Oracle、DB2、H2、HSQL、SQLite、Postgre、SQLServer 等多种数据库 内置性能分析插件：可输出 SQL 语句以及其执行时间，建议开发测试时启用该功能，能快速揪出慢查询 内置全局拦截插件：提供全表 delete 、 update 操作智能分析阻断，也可自定义拦截规则，预防误操作 支持数据库： MySQL，Oracle，DB2，H2，HSQL，SQLite，PostgreSQL，SQLServer，Phoenix，Gauss ，ClickHouse，Sybase，OceanBase，Firebird，Cubrid，Goldilocks，csiidb，informix，TDengine，redshift 达梦数据库，虚谷数据库，人大金仓数据库，南大通用(华库)数据库，南大通用数据库，神通数据库，瀚高数据库，优炫数据库 mybatis-plus总结： 自动生成单表的CRUD功能 提供丰富的条件拼接方式 全自动ORM类型持久层框架 1.2 快速入门 准备数据库脚本 现有一张 User 表，其表结构如下： id name age email 1 Jone 18 test1@baomidou.com 2 Jack 20 test2@baomidou.com 3 Tom 28 test3@baomidou.com 4 Sandy 21 test4@baomidou.com 5 Billie 24 test5@baomidou.com 12345678910DROP TABLE IF EXISTS user;CREATE TABLE user( id BIGINT(20) NOT NULL COMMENT &#x27;主键ID&#x27;, name VARCHAR(30) NULL DEFAULT NULL COMMENT &#x27;姓名&#x27;, age INT(11) NULL DEFAULT NULL COMMENT &#x27;年龄&#x27;, email VARCHAR(50) NULL DEFAULT NULL COMMENT &#x27;邮箱&#x27;, PRIMARY KEY (id)); INSERT INTO user (id, name, age, email) VALUES (1, ‘Jone’, 18, ‘&#116;&#x65;&#x73;&#116;&#x31;&#x40;&#x62;&#x61;&#x6f;&#109;&#x69;&#x64;&#111;&#117;&#46;&#99;&#111;&#109;‘), (2, ‘Jack’, 20, ‘&#116;&#x65;&#115;&#x74;&#x32;&#x40;&#x62;&#97;&#x6f;&#109;&#105;&#x64;&#x6f;&#x75;&#46;&#x63;&#x6f;&#109;‘), (3, ‘Tom’, 28, ‘&#116;&#x65;&#115;&#x74;&#51;&#x40;&#98;&#97;&#x6f;&#x6d;&#105;&#100;&#x6f;&#117;&#46;&#x63;&#x6f;&#109;‘), (4, ‘Sandy’, 21, ‘&#116;&#x65;&#x73;&#x74;&#52;&#64;&#98;&#x61;&#111;&#109;&#x69;&#x64;&#111;&#117;&#x2e;&#99;&#111;&#109;‘), (5, ‘Billie’, 24, ‘&#x74;&#x65;&#115;&#116;&#x35;&#x40;&#x62;&#97;&#111;&#x6d;&#105;&#100;&#x6f;&#x75;&#46;&#x63;&#x6f;&#109;‘); 12345678910111213141516171819202122232. 准备boot工程3. 导入依赖 ```xml &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;3.0.5&lt;/version&gt; &lt;/parent&gt; &lt;groupId&gt;com.atguigu&lt;/groupId&gt; &lt;artifactId&gt;springboot-starter-mybatis-plus-06&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;17&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;17&lt;/maven.compiler.target&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- 测试环境 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- mybatis-plus --&gt; &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.5.3.1&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 数据库相关配置启动器 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- druid启动器的依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-3-starter&lt;/artifactId&gt; &lt;version&gt;1.2.18&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 驱动类--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.28&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.28&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;!-- SpringBoot应用打包插件--&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; 1234567891011121314151617181920212223244. 配置文件和启动类 完善连接池配置： 文件夹：META-INF.spring 文件名： org.springframework.boot.autoconfigure.AutoConfiguration.imports 内容：com.alibaba.druid.spring.boot3.autoconfigure.DruidDataSourceAutoConfigure application.yaml ```yaml # 连接池配置 spring: datasource: type: com.alibaba.druid.pool.DruidDataSource druid: url: jdbc:mysql:///day01 username: root password: root driver-class-name: com.mysql.cj.jdbc.Driver 启动类 12345678910@MapperScan(&quot;com.atguigu.mapper&quot;)@SpringBootApplicationpublic class MainApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(MainApplication.class,args); &#125; &#125; 功能编码 编写实体类 User.java（此处使用了 Lombok 简化代码） 12345678@Datapublic class User &#123; private Long id; private String name; private Integer age; private String email;&#125; 编写 Mapper 包下的 UserMapper接口 1234public interface UserMapper extends BaseMapper&lt;User&gt; &#123;&#125; 继承mybatis-plus提供的基础Mapper接口，自带crud方法！ 测试和使用 添加测试类，进行功能测试： 1234567891011121314@SpringBootTest //springboot下测试环境注解public class SampleTest &#123; @Autowired private UserMapper userMapper; @Test public void testSelect() &#123; System.out.println((&quot;----- selectAll method test ------&quot;)); List&lt;User&gt; userList = userMapper.selectList(null); userList.forEach(System.out::println); &#125;&#125; 小结 通过以上几个简单的步骤，我们就实现了 User 表的 CRUD 功能，甚至连 XML 文件都不用编写！ 从以上步骤中，我们可以看到集成MyBatis-Plus非常的简单，只需要引入 starter 工程，并配置 mapper 扫描路径即可。 二、MyBatis-Plus核心功能2.1 基于Mapper接口CRUD 通用 CRUD 封装BaseMapper (opens new window)接口， Mybatis-Plus 启动时自动解析实体表关系映射转换为 Mybatis 内部对象注入容器! 内部包含常见的单表操作！ Insert方法1234// 插入一条记录// T 就是要插入的实体对象// 默认主键生成策略为雪花算法（后面讲解）int insert(T entity); 类型 参数名 描述 T entity 实体对象 Delete方法1234567891011// 根据 entity 条件，删除记录int delete(@Param(Constants.WRAPPER) Wrapper&lt;T&gt; wrapper);// 删除（根据ID 批量删除）int deleteBatchIds(@Param(Constants.COLLECTION) Collection&lt;? extends Serializable&gt; idList);// 根据 ID 删除int deleteById(Serializable id);// 根据 columnMap 条件，删除记录int deleteByMap(@Param(Constants.COLUMN_MAP) Map&lt;String, Object&gt; columnMap); 类型 参数名 描述 Wrapper&lt;T&gt; wrapper 实体对象封装操作类（可以为 null） Collection&lt;? extends Serializable&gt; idList 主键 ID 列表(不能为 null 以及 empty) Serializable id 主键 ID Map&lt;String, Object&gt; columnMap 表字段 map 对象 Update方法123456// 根据 whereWrapper 条件，更新记录int update(@Param(Constants.ENTITY) T updateEntity, @Param(Constants.WRAPPER) Wrapper&lt;T&gt; whereWrapper);// 根据 ID 修改 主键属性必须值int updateById(@Param(Constants.ENTITY) T entity); 类型 参数名 描述 T entity 实体对象 (set 条件值,可为 null) Wrapper&lt;T&gt; updateWrapper 实体对象封装操作类（可以为 null,里面的 entity 用于生成 where 语句） Select方法1234567891011121314151617181920212223242526272829// 根据 ID 查询T selectById(Serializable id);// 根据 entity 条件，查询一条记录T selectOne(@Param(Constants.WRAPPER) Wrapper&lt;T&gt; queryWrapper);// 查询（根据ID 批量查询）List&lt;T&gt; selectBatchIds(@Param(Constants.COLLECTION) Collection&lt;? extends Serializable&gt; idList);// 根据 entity 条件，查询全部记录List&lt;T&gt; selectList(@Param(Constants.WRAPPER) Wrapper&lt;T&gt; queryWrapper);// 查询（根据 columnMap 条件）List&lt;T&gt; selectByMap(@Param(Constants.COLUMN_MAP) Map&lt;String, Object&gt; columnMap);// 根据 Wrapper 条件，查询全部记录List&lt;Map&lt;String, Object&gt;&gt; selectMaps(@Param(Constants.WRAPPER) Wrapper&lt;T&gt; queryWrapper);// 根据 Wrapper 条件，查询全部记录。注意： 只返回第一个字段的值List&lt;Object&gt; selectObjs(@Param(Constants.WRAPPER) Wrapper&lt;T&gt; queryWrapper);// 根据 entity 条件，查询全部记录（并翻页）IPage&lt;T&gt; selectPage(IPage&lt;T&gt; page, @Param(Constants.WRAPPER) Wrapper&lt;T&gt; queryWrapper);// 根据 Wrapper 条件，查询全部记录（并翻页）IPage&lt;Map&lt;String, Object&gt;&gt; selectMapsPage(IPage&lt;T&gt; page, @Param(Constants.WRAPPER) Wrapper&lt;T&gt; queryWrapper);// 根据 Wrapper 条件，查询总记录数Integer selectCount(@Param(Constants.WRAPPER) Wrapper&lt;T&gt; queryWrapper); 参数说明 类型 参数名 描述 Serializable id 主键 ID Wrapper&lt;T&gt; queryWrapper 实体对象封装操作类（可以为 null） Collection&lt;? extends Serializable&gt; idList 主键 ID 列表(不能为 null 以及 empty) Map&lt;String, Object&gt; columnMap 表字段 map 对象 IPage&lt;T&gt; page 分页查询条件（可以为 RowBounds.DEFAULT） 自定义和多表映射mybatis-plus的默认mapperxml位置 123mybatis-plus: # mybatis-plus的配置 # 默认位置 private String[] mapperLocations = new String[]&#123;&quot;classpath*:/mapper/**/*.xml&quot;&#125;; mapper-locations: classpath:/mapper/*.xml 自定义mapper方法： 1234567public interface UserMapper extends BaseMapper&lt;User&gt; &#123; //正常自定义方法！ //可以使用注解@Select或者mapper.xml实现 List&lt;User&gt; queryAll();&#125; 基于mapper.xml实现： 1234567891011&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;https://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;!-- namespace = 接口的全限定符 --&gt;&lt;mapper namespace=&quot;com.atguigu.mapper.UserMapper&quot;&gt; &lt;select id=&quot;queryAll&quot; resultType=&quot;user&quot; &gt; select * from user &lt;/select&gt;&lt;/mapper&gt; 2.2 基于Service接口CRUD通用 Service CRUD 封装IService (opens new window)接口，进一步封装 CRUD 采用 get 查询单行 remove 删除 list 查询集合 page 分页 前缀命名方式区分 Mapper 层避免混淆， 对比Mapper接口CRUD区别： service添加了批量方法 service层的方法自动添加事务 使用Iservice接口方式接口继承IService接口 123public interface UserService extends IService&lt;User&gt; &#123;&#125; 类继承ServiceImpl实现类 12345@Servicepublic class UserServiceImpl extends ServiceImpl&lt;UserMapper,User&gt; implements UserService&#123;&#125; CRUD方法介绍1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980保存：// 插入一条记录（选择字段，策略插入）boolean save(T entity);// 插入（批量）boolean saveBatch(Collection&lt;T&gt; entityList);// 插入（批量）boolean saveBatch(Collection&lt;T&gt; entityList, int batchSize);修改或者保存：// TableId 注解存在更新记录，否插入一条记录boolean saveOrUpdate(T entity);// 根据updateWrapper尝试更新，否继续执行saveOrUpdate(T)方法boolean saveOrUpdate(T entity, Wrapper&lt;T&gt; updateWrapper);// 批量修改插入boolean saveOrUpdateBatch(Collection&lt;T&gt; entityList);// 批量修改插入boolean saveOrUpdateBatch(Collection&lt;T&gt; entityList, int batchSize);移除：// 根据 queryWrapper 设置的条件，删除记录boolean remove(Wrapper&lt;T&gt; queryWrapper);// 根据 ID 删除boolean removeById(Serializable id);// 根据 columnMap 条件，删除记录boolean removeByMap(Map&lt;String, Object&gt; columnMap);// 删除（根据ID 批量删除）boolean removeByIds(Collection&lt;? extends Serializable&gt; idList);更新：// 根据 UpdateWrapper 条件，更新记录 需要设置sqlsetboolean update(Wrapper&lt;T&gt; updateWrapper);// 根据 whereWrapper 条件，更新记录boolean update(T updateEntity, Wrapper&lt;T&gt; whereWrapper);// 根据 ID 选择修改boolean updateById(T entity);// 根据ID 批量更新boolean updateBatchById(Collection&lt;T&gt; entityList);// 根据ID 批量更新boolean updateBatchById(Collection&lt;T&gt; entityList, int batchSize);数量： // 查询总记录数int count();// 根据 Wrapper 条件，查询总记录数int count(Wrapper&lt;T&gt; queryWrapper);查询：// 根据 ID 查询T getById(Serializable id);// 根据 Wrapper，查询一条记录。结果集，如果是多个会抛出异常，随机取一条加上限制条件 wrapper.last(&quot;LIMIT 1&quot;)T getOne(Wrapper&lt;T&gt; queryWrapper);// 根据 Wrapper，查询一条记录T getOne(Wrapper&lt;T&gt; queryWrapper, boolean throwEx);// 根据 Wrapper，查询一条记录Map&lt;String, Object&gt; getMap(Wrapper&lt;T&gt; queryWrapper);// 根据 Wrapper，查询一条记录&lt;V&gt; V getObj(Wrapper&lt;T&gt; queryWrapper, Function&lt;? super Object, V&gt; mapper);集合：// 查询所有List&lt;T&gt; list();// 查询列表List&lt;T&gt; list(Wrapper&lt;T&gt; queryWrapper);// 查询（根据ID 批量查询）Collection&lt;T&gt; listByIds(Collection&lt;? extends Serializable&gt; idList);// 查询（根据 columnMap 条件）Collection&lt;T&gt; listByMap(Map&lt;String, Object&gt; columnMap);// 查询所有列表List&lt;Map&lt;String, Object&gt;&gt; listMaps();// 查询列表List&lt;Map&lt;String, Object&gt;&gt; listMaps(Wrapper&lt;T&gt; queryWrapper);// 查询全部记录List&lt;Object&gt; listObjs();// 查询全部记录&lt;V&gt; List&lt;V&gt; listObjs(Function&lt;? super Object, V&gt; mapper);// 根据 Wrapper 条件，查询全部记录List&lt;Object&gt; listObjs(Wrapper&lt;T&gt; queryWrapper);// 根据 Wrapper 条件，查询全部记录&lt;V&gt; List&lt;V&gt; listObjs(Wrapper&lt;T&gt; queryWrapper, Function&lt;? super Object, V&gt; mapper); 2.3 分页查询实现 导入分页插件 123456@Beanpublic MybatisPlusInterceptor mybatisPlusInterceptor() &#123; MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor(); interceptor.addInnerInterceptor(new PaginationInnerInterceptor(DbType.MYSQL)); return interceptor;&#125; 使用分页查询 123456789101112131415@Testpublic void testPageQuery()&#123; //设置分页参数 Page&lt;User&gt; page = new Page&lt;&gt;(1, 5); userMapper.selectPage(page, null); //获取分页数据 List&lt;User&gt; list = page.getRecords(); list.forEach(System.out::println); System.out.println(&quot;当前页：&quot;+page.getCurrent()); System.out.println(&quot;每页显示的条数：&quot;+page.getSize()); System.out.println(&quot;总记录数：&quot;+page.getTotal()); System.out.println(&quot;总页数：&quot;+page.getPages()); System.out.println(&quot;是否有上一页：&quot;+page.hasPrevious()); System.out.println(&quot;是否有下一页：&quot;+page.hasNext());&#125; 自定义的mapper方法使用分页 方法 1234//传入参数携带Ipage接口//返回结果为IPageIPage&lt;User&gt; selectPageVo(IPage&lt;?&gt; page, Integer id); 接口实现 123&lt;select id=&quot;selectPageVo&quot; resultType=&quot;xxx.xxx.xxx.User&quot;&gt; SELECT * FROM user WHERE id &gt; #&#123;id&#125;&lt;/select&gt; 测试 1234567891011121314151617@Testpublic void testQuick()&#123; IPage page = new Page(1,2); userMapper.selectPageVo(page,2); long current = page.getCurrent(); System.out.println(&quot;current = &quot; + current); long pages = page.getPages(); System.out.println(&quot;pages = &quot; + pages); long total = page.getTotal(); System.out.println(&quot;total = &quot; + total); List records = page.getRecords(); System.out.println(&quot;records = &quot; + records);&#125; 2.4 条件构造器使用2.4.1 条件构造器作用实例代码： 123456789QueryWrapper&lt;User&gt; queryWrapper = new QueryWrapper&lt;&gt;();queryWrapper.eq(&quot;name&quot;, &quot;John&quot;); // 添加等于条件queryWrapper.ne(&quot;age&quot;, 30); // 添加不等于条件queryWrapper.like(&quot;email&quot;, &quot;@gmail.com&quot;); // 添加模糊匹配条件等同于： delete from user where name = &quot;John&quot; and age != 30 and email like &quot;%@gmail.com%&quot;// 根据 entity 条件，删除记录int delete(@Param(Constants.WRAPPER) Wrapper&lt;T&gt; wrapper); 使用MyBatis-Plus的条件构造器，你可以构建灵活、高效的查询条件，而不需要手动编写复杂的 SQL 语句。它提供了许多方法来支持各种条件操作符，并且可以通过链式调用来组合多个条件。这样可以简化查询的编写过程，并提高开发效率。 2.4.2 条件构造器继承结构条件构造器类结构： Wrapper ： 条件构造抽象类，最顶端父类 AbstractWrapper ： 用于查询条件封装，生成 sql 的 where 条件 QueryWrapper ： 查询&#x2F;删除条件封装 UpdateWrapper ： 修改条件封装 AbstractLambdaWrapper ： 使用Lambda 语法 LambdaQueryWrapper ：用于Lambda语法使用的查询Wrapper LambdaUpdateWrapper ： Lambda 更新封装Wrapper 2.4.3 基于QueryWrapper 组装条件 组装查询条件： 1234567891011@Testpublic void test01()&#123; //查询用户名包含a，年龄在20到30之间，并且邮箱不为null的用户信息 //SELECT id,username AS name,age,email,is_deleted FROM t_user WHERE is_deleted=0 AND (username LIKE ? AND age BETWEEN ? AND ? AND email IS NOT NULL) QueryWrapper&lt;User&gt; queryWrapper = new QueryWrapper&lt;&gt;(); queryWrapper.like(&quot;username&quot;, &quot;a&quot;) .between(&quot;age&quot;, 20, 30) .isNotNull(&quot;email&quot;); List&lt;User&gt; list = userMapper.selectList(queryWrapper); list.forEach(System.out::println); 组装排序条件: 1234567891011@Testpublic void test02()&#123; //按年龄降序查询用户，如果年龄相同则按id升序排列 //SELECT id,username AS name,age,email,is_deleted FROM t_user WHERE is_deleted=0 ORDER BY age DESC,id ASC QueryWrapper&lt;User&gt; queryWrapper = new QueryWrapper&lt;&gt;(); queryWrapper .orderByDesc(&quot;age&quot;) .orderByAsc(&quot;id&quot;); List&lt;User&gt; users = userMapper.selectList(queryWrapper); users.forEach(System.out::println);&#125; 组装删除条件: 12345678910@Testpublic void test03()&#123; //删除email为空的用户 //DELETE FROM t_user WHERE (email IS NULL) QueryWrapper&lt;User&gt; queryWrapper = new QueryWrapper&lt;&gt;(); queryWrapper.isNull(&quot;email&quot;); //条件构造器也可以构建删除语句的条件 int result = userMapper.delete(queryWrapper); System.out.println(&quot;受影响的行数：&quot; + result);&#125; and和or关键字使用(修改)： 12345678910111213141516@Testpublic void test04() &#123; QueryWrapper&lt;User&gt; queryWrapper = new QueryWrapper&lt;&gt;(); //将年龄大于20并且用户名中包含有a或邮箱为null的用户信息修改 //UPDATE t_user SET age=?, email=? WHERE username LIKE ? AND age &gt; ? OR email IS NULL) queryWrapper .like(&quot;username&quot;, &quot;a&quot;) .gt(&quot;age&quot;, 20) .or() .isNull(&quot;email&quot;); User user = new User(); user.setAge(18); user.setEmail(&quot;user@atguigu.com&quot;); int result = userMapper.update(user, queryWrapper); System.out.println(&quot;受影响的行数：&quot; + result);&#125; 指定列映射查询： 12345678910@Testpublic void test05() &#123; //查询用户信息的username和age字段 //SELECT username,age FROM t_user QueryWrapper&lt;User&gt; queryWrapper = new QueryWrapper&lt;&gt;(); queryWrapper.select(&quot;username&quot;, &quot;age&quot;); //selectMaps()返回Map集合列表，通常配合select()使用，避免User对象中没有被查询到的列值为null List&lt;Map&lt;String, Object&gt;&gt; maps = userMapper.selectMaps(queryWrapper); maps.forEach(System.out::println);&#125; condition判断组织条件: 1234567891011121314151617181920212223 @Testpublic void testQuick3()&#123; String name = &quot;root&quot;; int age = 18; QueryWrapper&lt;User&gt; queryWrapper = new QueryWrapper&lt;&gt;(); //判断条件拼接 //当name不为null拼接等于, age &gt; 1 拼接等于判断 //方案1: 手动判断 if (!StringUtils.isEmpty(name))&#123; queryWrapper.eq(&quot;name&quot;,name); &#125; if (age &gt; 1)&#123; queryWrapper.eq(&quot;age&quot;,age); &#125; //方案2: 拼接condition判断 //每个条件拼接方法都condition参数,这是一个比较运算,为true追加当前条件! //eq(condition,列名,值) queryWrapper.eq(!StringUtils.isEmpty(name),&quot;name&quot;,name) .eq(age&gt;1,&quot;age&quot;,age); &#125; 2.3.4 基于 UpdateWrapper组装条件使用queryWrapper: 12345678910111213141516@Testpublic void test04() &#123; QueryWrapper&lt;User&gt; queryWrapper = new QueryWrapper&lt;&gt;(); //将年龄大于20并且用户名中包含有a或邮箱为null的用户信息修改 //UPDATE t_user SET age=?, email=? WHERE username LIKE ? AND age &gt; ? OR email IS NULL) queryWrapper .like(&quot;username&quot;, &quot;a&quot;) .gt(&quot;age&quot;, 20) .or() .isNull(&quot;email&quot;); User user = new User(); user.setAge(18); user.setEmail(&quot;user@atguigu.com&quot;); int result = userMapper.update(user, queryWrapper); System.out.println(&quot;受影响的行数：&quot; + result);&#125; 注意：使用queryWrapper + 实体类形式可以实现修改，但是无法将列值修改为null值！ 使用updateWrapper: 12345678910111213@Testpublic void testQuick2()&#123; UpdateWrapper&lt;User&gt; updateWrapper = new UpdateWrapper&lt;&gt;(); //将id = 3 的email设置为null, age = 18 updateWrapper.eq(&quot;id&quot;,3) .set(&quot;email&quot;,null) // set 指定列和结果 .set(&quot;age&quot;,18); //如果使用updateWrapper 实体对象写null即可! int result = userMapper.update(null, updateWrapper); System.out.println(&quot;result = &quot; + result);&#125; 使用updateWrapper可以随意设置列的值！！ 2.3.5 基于LambdaQueryWrapper组装条件1. LambdaQueryWrapper对比QueryWrapper优势 QueryWrapper 示例代码： 123456QueryWrapper&lt;User&gt; queryWrapper = new QueryWrapper&lt;&gt;();queryWrapper.eq(&quot;name&quot;, &quot;John&quot;) .ge(&quot;age&quot;, 18) .orderByDesc(&quot;create_time&quot;) .last(&quot;limit 10&quot;);List&lt;User&gt; userList = userMapper.selectList(queryWrapper); LambdaQueryWrapper 示例代码： 1234567LambdaQueryWrapper&lt;User&gt; lambdaQueryWrapper = new LambdaQueryWrapper&lt;&gt;();lambdaQueryWrapper.eq(User::getName, &quot;John&quot;) .ge(User::getAge, 18) .orderByDesc(User::getCreateTime) .last(&quot;limit 10&quot;);List&lt;User&gt; userList = userMapper.selectList(lambdaQueryWrapper); 从上面的代码对比可以看出，相比于 QueryWrapper，LambdaQueryWrapper 使用了实体类的属性引用（例如 User::getName、User::getAge），而不是字符串来表示字段名，这提高了代码的可读性和可维护性。 2. lambda表达式回顾 Lambda 表达式是 Java 8 引入的一种函数式编程特性，它提供了一种更简洁、更直观的方式来表示匿名函数或函数式接口的实现。Lambda 表达式可以用于简化代码，提高代码的可读性和可维护性。 Lambda 表达式的语法可以分为以下几个部分： 参数列表： 参数列表用小括号 () 括起来，可以指定零个或多个参数。如果没有参数，可以省略小括号；如果只有一个参数，可以省略小括号。 示例：(a, b), x -&gt;, () -&gt; 箭头符号： 箭头符号 -&gt; 分割参数列表和 Lambda 表达式的主体部分。 示例：-&gt; Lambda 表达式的主体： Lambda 表达式的主体部分可以是一个表达式或一个代码块。如果是一个表达式，可以省略 return 关键字；如果是多条语句的代码块，需要使用大括号 &#123;&#125; 括起来，并且需要明确指定 return 关键字。 示例： 单个表达式：x -&gt; x * x 代码块：(x, y) -&gt; &#123; int sum = x + y; return sum; &#125; Lambda 表达式的语法可以更具体地描述如下： 123456789101112131415161718192021222324252627// 使用 Lambda 表达式实现一个接口的方法interface Greeting &#123; void sayHello();&#125;public class LambdaExample &#123; public static void main(String[] args) &#123; //原始匿名内部类方式 Greeting greeting = new Greeting() &#123; @Override public void sayHello(int a) &#123; System.out.println(&quot;Hello, world!&quot;); &#125; &#125;; a-&gt;System.out.println(&quot;Hello, world!&quot;) // 使用 Lambda 表达式实现接口的方法 greeting = () -&gt; System.out.println(&quot;Hello, world!&quot;); System.out::println; () -&gt; 类.XXX(); -&gt; 类：：方法名 // 调用接口的方法 greeting.sayHello(); &#125;&#125; 3. 方法引用回顾: 方法引用是 Java 8 中引入的一种语法特性，它提供了一种简洁的方式来直接引用已有的方法或构造函数。方法引用可以替代 Lambda 表达式，使代码更简洁、更易读。 Java 8 支持以下几种方法引用的形式： 静态方法引用： 引用静态方法，语法为 类名::静态方法名。 实例方法引用： 引用实例方法，语法为 实例对象::实例方法名。 对象方法引用： 引用特定对象的实例方法，语法为 类名::实例方法名。 构造函数引用： 引用构造函数，语法为 类名::new。 演示代码: 12345678910111213import java.util.Arrays;import java.util.List;import java.util.function.Consumer;public class MethodReferenceExample &#123; public static void main(String[] args) &#123; List&lt;String&gt; names = Arrays.asList(&quot;John&quot;, &quot;Tom&quot;, &quot;Alice&quot;); // 使用 Lambda 表达式 names.forEach(name -&gt; System.out.println(name)); // 使用方法引用 names.forEach(System.out::println); &#125;&#125; 4. lambdaQueryWrapper使用案例: 1234567891011121314151617181920@Testpublic void testQuick4()&#123; String name = &quot;root&quot;; int age = 18; QueryWrapper&lt;User&gt; queryWrapper = new QueryWrapper&lt;&gt;(); //每个条件拼接方法都condition参数,这是一个比较运算,为true追加当前条件! //eq(condition,列名,值) queryWrapper.eq(!StringUtils.isEmpty(name),&quot;name&quot;,name) .eq(age&gt;1,&quot;age&quot;,age); //TODO: 使用lambdaQueryWrapper LambdaQueryWrapper&lt;User&gt; lambdaQueryWrapper = new LambdaQueryWrapper&lt;&gt;(); //注意: 需要使用方法引用 //技巧: 类名::方法名 lambdaQueryWrapper.eq(!StringUtils.isEmpty(name), User::getName,name); List&lt;User&gt; users= userMapper.selectList(lambdaQueryWrapper); System.out.println(users);&#125; 2.3.6 基于LambdaUpdateWrapper组装条件使用案例: 12345678910111213141516171819@Testpublic void testQuick2()&#123; UpdateWrapper&lt;User&gt; updateWrapper = new UpdateWrapper&lt;&gt;(); //将id = 3 的email设置为null, age = 18 updateWrapper.eq(&quot;id&quot;,3) .set(&quot;email&quot;,null) // set 指定列和结果 .set(&quot;age&quot;,18); //使用lambdaUpdateWrapper LambdaUpdateWrapper&lt;User&gt; updateWrapper1 = new LambdaUpdateWrapper&lt;&gt;(); updateWrapper1.eq(User::getId,3) .set(User::getEmail,null) .set(User::getAge,18); //如果使用updateWrapper 实体对象写null即可! int result = userMapper.update(null, updateWrapper); System.out.println(&quot;result = &quot; + result);&#125; 2.5 核心注解使用 理解和介绍 MyBatis-Plus是一个基于MyBatis框架的增强工具，提供了一系列简化和增强的功能，用于加快开发人员在使用MyBatis进行数据库访问时的效率。 MyBatis-Plus提供了一种基于注解的方式来定义和映射数据库操作，其中的注解起到了重要作用。 理解： 123public interface UserMapper extends BaseMapper&lt;User&gt; &#123;&#125; 此接口对应的方法为什么会自动触发 user表的crud呢？ 默认情况下， 根据指定的&lt;实体类&gt;的名称对应数据库表名，属性名对应数据库的列名！ 但是不是所有数据库的信息和实体类都完全映射！ 例如： 表名 t_user → 实体类 User 这时候就不对应了！ 自定义映射关系就可以使用mybatis-plus提供的注解即可！ @TableName注解 描述：表名注解，标识实体类对应的表 使用位置：实体类12345678@TableName(&quot;sys_user&quot;) //对应数据库表名public class User &#123; private Long id; private String name; private Integer age; private String email;&#125; 特殊情况：如果表名和实体类名相同（忽略大小写）可以省略该注解！ 其他解决方案：全局设置前缀 (https://www.baomidou.com/pages/56bac0/#基本配置) 1234mybatis-plus: # mybatis-plus的配置 global-config: db-config: table-prefix: sys_ # 表名前缀字符串 @TableId 注解 描述：主键注解 使用位置：实体类主键字段123456789@TableName(&quot;sys_user&quot;)public class User &#123; @TableId(value=&quot;主键列名&quot;,type=主键策略) private Long id; private String name; private Integer age; private String email;&#125; | 属性 | 类型 | 必须指定 | 默认值 | 描述 | | —————————————————————————————————————————————————————- | —— | —- | ———– | —— || value | String | 否 | “” | 主键字段名 || type | Enum | 否 | IdType.NONE | 指定主键类型 || IdType属性可选值： | | | | | 值 描述 AUTO 数据库 ID 自增 (mysql配置主键自增长) ASSIGN_ID（默认） 分配 ID(主键类型为 Number(Long )或 String)(since 3.3.0),使用接口IdentifierGenerator的方法nextId(默认实现类为DefaultIdentifierGenerator雪花算法) 全局配置修改主键策略: 12345678910mybatis-plus: configuration: # 配置MyBatis日志 log-impl: org.apache.ibatis.logging.stdout.StdOutImpl global-config: db-config: # 配置MyBatis-Plus操作表的默认前缀 table-prefix: t_ # 配置MyBatis-Plus的主键策略 id-type: auto 在以下场景下，添加@TableId注解是必要的： 实体类的字段与数据库表的主键字段不同名：如果实体类中的字段与数据库表的主键字段不一致，需要使用@TableId注解来指定实体类中表示主键的字段。 主键生成策略不是默认策略：如果需要使用除了默认主键生成策略以外的策略，也需要添加@TableId注解，并通过value属性指定生成策略。 雪花算法使用场景 雪花算法（Snowflake Algorithm）是一种用于生成唯一ID的算法。它由Twitter公司提出，用于解决分布式系统中生成全局唯一ID的需求。 在传统的自增ID生成方式中，使用单点数据库生成ID会成为系统的瓶颈，而雪花算法通过在分布式系统中生成唯一ID，避免了单点故障和性能瓶颈的问题。 雪花算法生成的ID是一个64位的整数，由以下几个部分组成： 时间戳：41位，精确到毫秒级，可以使用69年。 节点ID：10位，用于标识分布式系统中的不同节点。 序列号：12位，表示在同一毫秒内生成的不同ID的序号。通过将这三个部分组合在一起，雪花算法可以在分布式系统中生成全局唯一的ID，并保证ID的生成顺序性。雪花算法的工作方式如下： 当前时间戳从某一固定的起始时间开始计算，可以用于计算ID的时间部分。 节点ID是分布式系统中每个节点的唯一标识，可以通过配置或自动分配的方式获得。 序列号用于记录在同一毫秒内生成的不同ID的序号，从0开始自增，最多支持4096个ID生成。需要注意的是，雪花算法依赖于系统的时钟，需要确保系统时钟的准确性和单调性，否则可能会导致生成的ID不唯一或不符合预期的顺序。雪花算法是一种简单但有效的生成唯一ID的算法，广泛应用于分布式系统中，如微服务架构、分布式数据库、分布式锁等场景，以满足全局唯一标识的需求。 你需要记住的: 雪花算法生成的数字,需要使用Long 或者 String类型主键!! @TableField 描述：字段注解（非主键） 123456789@TableName(&quot;sys_user&quot;)public class User &#123; @TableId private Long id; @TableField(&quot;nickname&quot;) private String name; private Integer age; private String email;&#125; 属性 类型 必须指定 默认值 描述value String 否 “” 数据库字段名exist boolean 否 true 是否为数据库表字段 MyBatis-Plus会自动开启驼峰命名风格映射!!! 三、MyBatis-Plus高级扩展3.1 逻辑删除实现概念: 逻辑删除，可以方便地实现对数据库记录的逻辑删除而不是物理删除。逻辑删除是指通过更改记录的状态或添加标记字段来模拟删除操作，从而保留了删除前的数据，便于后续的数据分析和恢复。 物理删除：真实删除，将对应数据从数据库中删除，之后查询不到此条被删除的数据 逻辑删除：假删除，将对应数据中代表是否被删除字段的状态修改为“被删除状态”，之后在数据库中仍旧能看到此条数据记录 逻辑删除实现: 数据库和实体类添加逻辑删除字段 表添加逻辑删除字段 可以是一个布尔类型、整数类型或枚举类型。 1ALTER TABLE USER ADD deleted INT DEFAULT 0 ; # int 类型 1 逻辑删除 0 未逻辑删除 实体类添加逻辑删除属性 1234567891011121314@Datapublic class User &#123; // @TableId private Integer id; private String name; private Integer age; private String email; @TableLogic //逻辑删除字段 int mybatis-plus下,默认 逻辑删除值为1 未逻辑删除 1 private Integer deleted;&#125; 指定逻辑删除字段和属性值 单一指定123456789101112@Datapublic class User &#123; // @TableId private Integer id; private String name; private Integer age; private String email; @TableLogic //逻辑删除字段 int mybatis-plus下,默认 逻辑删除值为1 未逻辑删除 1 private Integer deleted;&#125; 全局指定123456mybatis-plus: global-config: db-config: logic-delete-field: deleted # 全局逻辑删除的实体字段名(since 3.3.0,配置后可以忽略不配置步骤2) logic-delete-value: 1 # 逻辑已删除值(默认为 1) logic-not-delete-value: 0 # 逻辑未删除值(默认为 0) 演示逻辑删除操作 逻辑删除以后,没有真正的删除语句,删除改为修改语句!删除代码: 123456//逻辑删除@Testpublic void testQuick5()&#123; //逻辑删除 userMapper.deleteById(5);&#125; 执行效果: JDBC Connection [com.alibaba.druid.proxy.jdbc.ConnectionProxyImpl@5871a482] will not be managed by Spring=&#x3D;&gt; Preparing: UPDATE user SET deleted&#x3D;1 WHERE id&#x3D;? AND deleted&#x3D;0=&#x3D;&gt; Parameters: 5(Integer)&lt;&#x3D;&#x3D; Updates: 1 测试查询数据 1234567@Testpublic void testQuick6()&#123; //正常查询.默认查询非逻辑删除数据 userMapper.selectList(null);&#125;//SELECT id,name,age,email,deleted FROM user WHERE deleted=0 3.2 乐观锁实现3.2.1 悲观锁和乐观锁场景和介绍并发问题场景演示: **解决思路: ** 乐观锁和悲观锁是在并发编程中用于处理并发访问和资源竞争的两种不同的锁机制!! 悲观锁： &#x20;悲观锁的基本思想是，在整个数据访问过程中，将共享资源锁定，以确保其他线程或进程不能同时访问和修改该资源。悲观锁的核心思想是”先保护，再修改”。在悲观锁的应用中，线程在访问共享资源之前会获取到锁，并在整个操作过程中保持锁的状态，阻塞其他线程的访问。只有当前线程完成操作后，才会释放锁，让其他线程继续操作资源。这种锁机制可以确保资源独占性和数据的一致性，但是在高并发环境下，悲观锁的效率相对较低。 乐观锁： &#x20;乐观锁的基本思想是，认为并发冲突的概率较低，因此不需要提前加锁，而是在数据更新阶段进行冲突检测和处理。乐观锁的核心思想是”先修改，后校验”。在乐观锁的应用中，线程在读取共享资源时不会加锁，而是记录特定的版本信息。当线程准备更新资源时，会先检查该资源的版本信息是否与之前读取的版本信息一致，如果一致则执行更新操作，否则说明有其他线程修改了该资源，需要进行相应的冲突处理。乐观锁通过避免加锁操作，提高了系统的并发性能和吞吐量，但是在并发冲突较为频繁的情况下，乐观锁会导致较多的冲突处理和重试操作。 理解点: 悲观锁和乐观锁是两种解决并发数据问题的思路,不是具体技术!!! 具体技术和方案: 乐观锁实现方案和技术： 版本号&#x2F;时间戳：为数据添加一个版本号或时间戳字段，每次更新数据时，比较当前版本号或时间戳与期望值是否一致，若一致则更新成功，否则表示数据已被修改，需要进行冲突处理。 CAS（Compare-and-Swap）：使用原子操作比较当前值与旧值是否一致，若一致则进行更新操作，否则重新尝试。 无锁数据结构：采用无锁数据结构，如无锁队列、无锁哈希表等，通过使用原子操作实现并发安全。 悲观锁实现方案和技术： 锁机制：使用传统的锁机制，如互斥锁（Mutex Lock）或读写锁（Read-Write Lock）来保证对共享资源的独占访问。 数据库锁：在数据库层面使用行级锁或表级锁来控制并发访问。 信号量（Semaphore）：使用信号量来限制对资源的并发访问。 介绍版本号乐观锁技术的实现流程: 每条数据添加一个版本号字段version 取出记录时，获取当前 version 更新时，检查获取版本号是不是数据库当前最新版本号 如果是[证明没有人修改数据], 执行更新, set 数据更新 , version &#x3D; version+ 1&#x20; 如果 version 不对[证明有人已经修改了]，我们现在的其他记录就是失效数据!就更新失败 3.2.2 使用mybatis-plus数据使用乐观锁&#x20;1. 添加版本号更新插件 123456@Beanpublic MybatisPlusInterceptor mybatisPlusInterceptor() &#123; MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor(); interceptor.addInnerInterceptor(new OptimisticLockerInnerInterceptor()); return interceptor;&#125; 乐观锁字段添加@Version注解 注意: 数据库也需要添加version字段 1ALTER TABLE USER ADD VERSION INT DEFAULT 1 ; # int 类型 乐观锁字段 支持的数据类型只有:int,Integer,long,Long,Date,Timestamp,LocalDateTime 仅支持 updateById(id) 与 update(entity, wrapper) 方法12@Versionprivate Integer version; 正常更新使用即可 123456789101112131415//演示乐观锁生效场景@Testpublic void testQuick7()&#123; //步骤1: 先查询,在更新 获取version数据 //同时查询两条,但是version唯一,最后更新的失败 User user = userMapper.selectById(5); User user1 = userMapper.selectById(5); user.setAge(20); user1.setAge(30); userMapper.updateById(user); //乐观锁生效,失败! userMapper.updateById(user1);&#125; 3.3 防全表更新和删除实现针对 update 和 delete 语句 作用: 阻止恶意的全表更新删除 添加防止全表更新和删除拦截器 1234567@Beanpublic MybatisPlusInterceptor mybatisPlusInterceptor() &#123; MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor(); interceptor.addInnerInterceptor(new BlockAttackInnerInterceptor()); return interceptor;&#125;&#125; 测试全部更新或者删除 123456789@Testpublic void testQuick8()&#123; User user = new User(); user.setName(&quot;custom_name&quot;); user.setEmail(&quot;xxx@mail.com&quot;); //Caused by: com.baomidou.mybatisplus.core.exceptions.MybatisPlusException: Prohibition of table update operation //全局更新,报错 userService.saveOrUpdate(user,null);&#125; 四、MyBatis-Plus代码生成器(MyBatisX插件)4.1 Mybatisx插件逆向工程MyBatis-Plus为我们提供了强大的mapper和service模板，能够大大的提高开发效率 但是在真正开发过程中，MyBatis-Plus并不能为我们解决所有问题，例如一些复杂的SQL，多表联查，我们就需要自己去编写代码和SQL语句，我们该如何快速的解决这个问题呢，这个时候可以使用MyBatisX插件 MyBatisX一款基于 IDEA 的快速开发插件，为效率而生。 4.2 MyBatisX快速代码生成使用mybatisX插件,自动生成sql语句实现 https://baomidou.com/pages/ba5b24/#功能","categories":[{"name":"SSM框架","slug":"SSM框架","permalink":"http://example.com/categories/SSM%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"ssm","slug":"ssm","permalink":"http://example.com/tags/ssm/"}]},{"title":"六、快速启动框架：SpringBoot3实战","slug":"SSM/六、快速启动框架：SpringBoot3实战/六、快速启动框架：SpringBoot3实战","date":"2022-10-01T11:55:54.000Z","updated":"2023-09-28T00:34:09.604Z","comments":true,"path":"2022/10/01/SSM/六、快速启动框架：SpringBoot3实战/六、快速启动框架：SpringBoot3实战/","link":"","permalink":"http://example.com/2022/10/01/SSM/%E5%85%AD%E3%80%81%E5%BF%AB%E9%80%9F%E5%90%AF%E5%8A%A8%E6%A1%86%E6%9E%B6%EF%BC%9ASpringBoot3%E5%AE%9E%E6%88%98/%E5%85%AD%E3%80%81%E5%BF%AB%E9%80%9F%E5%90%AF%E5%8A%A8%E6%A1%86%E6%9E%B6%EF%BC%9ASpringBoot3%E5%AE%9E%E6%88%98/","excerpt":"","text":"六、快速启动框架：SpringBoot3实战目录 一、SpringBoot3介绍 1.1 SpringBoot3简介 1.2 系统要求 1.3 快速入门 1.4 入门总结 二、SpringBoot3配置文件 2.1 统一配置管理概述 2.2 属性配置文件使用 2.3 YAML配置文件使用 2.4 批量配置文件注入 2.5 多环境配置和使用 三、SpringBoot3整合SpringMVC 3.1 实现过程 3.2 web相关配置 3.3 静态资源处理 3.4 自定义拦截器(SpringMVC配置) 四、SpringBoot3整合Druid数据源 五、SpringBoot3整合Mybatis 5.1 MyBatis整合步骤 5.2 Mybatis整合实践 5.3 声明式事务整合配置 5.4 AOP整合配置 六、SpringBoot3项目打包和运行 6.1 添加打包插件 6.2 执行打包 6.3 命令启动和参数说明 一、SpringBoot3介绍1.1 SpringBoot3简介 课程使用SpringBoot版本：3.0.5 https://docs.spring.io/spring-boot/docs/current/reference/html/getting-started.html#getting-started.introducing-spring-boot 到目前为止，你已经学习了多种配置Spring程序的方式。但是无论使用XML、注解、Java配置类还是他们的混合用法，你都会觉得配置文件过于复杂和繁琐，让人头疼！ SpringBoot 帮我们简单、快速地创建一个独立的、生产级别的 Spring 应用（说明：SpringBoot底层是Spring），大多数 SpringBoot 应用只需要编写少量配置即可快速整合 Spring 平台以及第三方技术！ SpringBoot的主要目标是： 为所有 Spring 开发提供更快速、可广泛访问的入门体验。 开箱即用，设置合理的默认值，但是也可以根据需求进行适当的调整。 提供一系列大型项目通用的非功能性程序（如嵌入式服务器、安全性、指标、运行检查等）。 约定大于配置，基本不需要主动编写配置类、也不需要 XML 配置文件。 总结：简化开发，简化配置，简化整合，简化部署，简化监控，简化运维。 1.2 系统要求 技术&amp;工具 版本（or later） maven 3.6.3 or later 3.6.3 或更高版本 Tomcat 10.0+ Servlet 9.0+ JDK 17+ 1.3 快速入门 场景：浏览器发送 &#x2F;hello请求，返回”Hello,Spring Boot 3!“ 开发步骤 创建Maven工程 添加依赖(springboot父工程依赖 , web启动器依赖) 编写启动引导类(springboot项目运行的入口) 编写处理器Controller 启动项目 创建项目 添加依赖 3.1 添加父工程坐标 SpringBoot可以帮我们方便的管理项目依赖 , 在Spring Boot提供了一个名为spring-boot-starter-parent的工程，里面已经对各种常用依赖的版本进行了管理，我们的项目需要以这个项目为父工程，这样我们就不用操心依赖的版本问题了，需要什么依赖，直接引入坐标(不需要添加版本)即可！ 123456&lt;!--所有springboot项目都必须继承自 spring-boot-starter-parent--&gt;&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;3.0.5&lt;/version&gt;&lt;/parent&gt; 3.2 添加web启动器 为了让Spring Boot帮我们完成各种自动配置，我们必须引入Spring Boot提供的自动配置依赖，我们称为启动器。因为我们是web项目，这里我们引入web启动器，在 pom.xml 文件中加入如下依赖： 1234567&lt;dependencies&gt;&lt;!--web开发的场景启动器--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 创建启动类 创建package：com.atguigu 创建启动类：MainApplication 12345678910111213141516171819202122232425package com.atguigu;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;/** * @SpringBootApplication是一个特殊的注解，用于标识一个Spring Boot应用程序的入口类。它的主要作用是将三个常用注解组合在一起，简化了配置的过程。 * * 具体而言，@SpringBootApplication注解包含以下三个注解的功能： * @Configuration：将该类标识为应用程序的配置类。它允许使用Java代码定义和配置Bean。 * @EnableAutoConfiguration：启用Spring Boot的自动配置机制。它根据项目的依赖项自动配置Spring应用程序的行为。自动配置根据类路径、注解和配置属性等条件来决定要使用的功能和配置。 * @ComponentScan：自动扫描并加载应用程序中的组件，如控制器、服务、存储库等。它默认扫描@SpringBootApplication注解所在类的包及其子包中的组件。 * * 使用@SpringBootApplication注解，可以将上述三个注解的功能集中在一个注解上，简化了配置文件的编写和组件的加载和扫描过程。它是Spring Boot应用程序的入口点，标识了应用程序的主类， * 并告诉Spring Boot在启动时应如何配置和加载应用程序。 */@SpringBootApplicationpublic class MainApplication &#123; //SpringApplication.run() 方法是启动 Spring Boot 应用程序的关键步骤。它创建应用程序上下文、 // 自动配置应用程序、启动应用程序，并处理命令行参数，使应用程序能够运行和提供所需的功能 public static void main(String[] args) &#123; SpringApplication.run(MainApplication.class,args); &#125;&#125; 编写处理器Controller 创建package：com.atguigu.controller 创建类：HelloController 注意： IoC和DI注解需要在启动类的同包或者子包下方可生效！无需指定，约束俗称。 1234567891011121314package com.atguigu.controller;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RestController;@RestControllerpublic class HelloController &#123; @GetMapping(&quot;/hello&quot;) public String hello()&#123; return &quot;Hello,Spring Boot 3!&quot;; &#125;&#125; 启动测试 1.4 入门总结 为什么依赖不需要写版本？ 每个boot项目都有一个父项目spring-boot-starter-parent parent的父项目是spring-boot-dependencies 父项目 版本仲裁中心，把所有常见的jar的依赖版本都声明好了。 比如：mysql-connector-j 启动器(Starter)是何方神圣？ Spring Boot提供了一种叫做Starter的概念，它是一组预定义的依赖项集合，旨在简化Spring应用程序的配置和构建过程。Starter包含了一组相关的依赖项，以便在启动应用程序时自动引入所需的库、配置和功能。 主要作用如下： 简化依赖管理：Spring Boot Starter通过捆绑和管理一组相关的依赖项，减少了手动解析和配置依赖项的工作。只需引入一个相关的Starter依赖，即可获取应用程序所需的全部依赖。 自动配置：Spring Boot Starter在应用程序启动时自动配置所需的组件和功能。通过根据类路径和其他设置的自动检测，Starter可以自动配置Spring Bean、数据源、消息传递等常见组件，从而使应用程序的配置变得简单和维护成本降低。 提供约定优于配置：Spring Boot Starter遵循“约定优于配置”的原则，通过提供一组默认设置和约定，减少了手动配置的需要。它定义了标准的配置文件命名约定、默认属性值、日志配置等，使得开发者可以更专注于业务逻辑而不是繁琐的配置细节。 快速启动和开发应用程序：Spring Boot Starter使得从零开始构建一个完整的Spring Boot应用程序变得容易。它提供了主要领域（如Web开发、数据访问、安全性、消息传递等）的Starter，帮助开发者快速搭建一个具备特定功能的应用程序原型。 模块化和可扩展性：Spring Boot Starter的组织结构使得应用程序的不同模块可以进行分离和解耦。每个模块可以有自己的Starter和依赖项，使得应用程序的不同部分可以按需进行开发和扩展。Spring Boot提供了许多预定义的Starter，例如spring-boot-starter-web用于构建Web应用程序，spring-boot-starter-data-jpa用于使用JPA进行数据库访问，spring-boot-starter-security用于安全认证和授权等等。 使用Starter非常简单，只需要在项目的构建文件（例如Maven的pom.xml）中添加所需的Starter依赖，Spring Boot会自动处理依赖管理和配置。 通过使用Starter，开发人员可以方便地引入和配置应用程序所需的功能，避免了手动添加大量的依赖项和编写冗长的配置文件的繁琐过程。同时，Starter也提供了一致的依赖项版本管理，确保依赖项之间的兼容性和稳定性。 spring boot提供的全部启动器地址： https://docs.spring.io/spring-boot/docs/current/reference/html/using.html#using.build-systems.starters 命名规范： 官方提供的场景：命名为：spring-boot-starter-* 第三方提供场景：命名为：*-spring-boot-starter @SpringBootApplication注解的功效？ @SpringBootApplication添加到启动类上，是一个组合注解，他的功效有具体的子注解实现！ 12345@SpringBootConfiguration@EnableAutoConfiguration@ComponentScanpublic @interface SpringBootApplication &#123;&#125; @SpringBootApplication注解是Spring Boot框架中的核心注解，它的主要作用是简化和加速Spring Boot应用程序的配置和启动过程。 具体而言，@SpringBootApplication注解起到以下几个主要作用： 自动配置：@SpringBootApplication注解包含了@EnableAutoConfiguration注解，用于启用Spring Boot的自动配置机制。自动配置会根据应用程序的依赖项和类路径，自动配置各种常见的Spring配置和功能，减少开发者的手动配置工作。它通过智能地分析类路径、加载配置和条件判断，为应用程序提供适当的默认配置。 组件扫描：@SpringBootApplication注解包含了@ComponentScan注解，用于自动扫描并加载应用程序中的组件，例如控制器（Controllers）、服务（Services）、存储库（Repositories）等。它默认会扫描@SpringBootApplication注解所在类的包及其子包中的组件，并将它们纳入Spring Boot应用程序的上下文中，使它们可被自动注入和使用。 声明配置类：@SpringBootApplication注解本身就是一个组合注解，它包含了@Configuration注解，将被标注的类声明为配置类。配置类可以包含Spring框架相关的配置、Bean定义，以及其他的自定义配置。通过@SpringBootApplication注解，开发者可以将配置类与启动类合并在一起，使得配置和启动可以同时发生。总的来说，@SpringBootApplication注解的主要作用是简化Spring Boot应用程序的配置和启动过程。它自动配置应用程序、扫描并加载组件，并将配置和启动类合二为一，简化了开发者的工作量，提高了开发效率。 二、SpringBoot3配置文件2.1 统一配置管理概述SpringBoot工程下，进行统一的配置管理，你想设置的任何参数（端口号、项目根路径、数据库连接信息等等)都集中到一个固定位置和命名的配置文件（application.properties或application.yml）中！ 配置文件应该放置在Spring Boot工程的src/main/resources目录下。这是因为src/main/resources目录是Spring Boot默认的类路径（classpath），配置文件会被自动加载并可供应用程序访问。 功能配置参数说明： https://docs.spring.io/spring-boot/docs/current/reference/html/application-properties.html#appendix.application-properties 细节总结： 集中式管理配置。统一在一个文件完成程序功能参数设置和自定义参数声明 。 位置：resources文件夹下，必须命名application 后缀 .properties &#x2F; .yaml &#x2F; .yml 。 如果同时存在application.properties | application.yml(.yaml) , properties的优先级更高。 配置基本都有默认值。 2.2 属性配置文件使用 配置文件 在 resource 文件夹下面新建 application.properties 配置文件 12345678910111213# application.properties 为统一配置文件# 内部包含: 固定功能的key,自定义的key# 此处的配置信息,我们都可以在程序中@Value等注解读取# 固定的key# 启动端口号server.port=80 # 自定义spring.jdbc.datasource.driverClassName=com.mysql.cj.jdbc.driverspring.jdbc.datasource.url=jdbc:mysql:///springboot_01spring.jdbc.datasource.username=rootspring.jdbc.datasource.password=root 读取配置文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263package com.atguigu.properties;import org.springframework.beans.factory.annotation.Value;import org.springframework.stereotype.Component;@Componentpublic class DataSourceProperties &#123; @Value(&quot;$&#123;spring.jdbc.datasource.driverClassName&#125;&quot;) private String driverClassName; @Value(&quot;$&#123;spring.jdbc.datasource.url&#125;&quot;) private String url; @Value(&quot;$&#123;spring.jdbc.datasource.username&#125;&quot;) private String username; @Value(&quot;$&#123;spring.jdbc.datasource.password&#125;&quot;) private String password; // 生成get set 和 toString方法 public String getDriverClassName() &#123; return driverClassName; &#125; public void setDriverClassName(String driverClassName) &#123; this.driverClassName = driverClassName; &#125; public String getUrl() &#123; return url; &#125; public void setUrl(String url) &#123; this.url = url; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; @Override public String toString() &#123; return &quot;DataSourceProperties&#123;&quot; + &quot;driverClassName=&#x27;&quot; + driverClassName + &#x27;\\&#x27;&#x27; + &quot;, url=&#x27;&quot; + url + &#x27;\\&#x27;&#x27; + &quot;, username=&#x27;&quot; + username + &#x27;\\&#x27;&#x27; + &quot;, password=&#x27;&quot; + password + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125;&#125; 测试效果 在controller注入，输出进行测试 12345678@Autowiredprivate DataSourceProperties dataSourceProperties ;@RequestMapping(path = &quot;/hello&quot;)public String sayHello() &#123; System.out.println(dataSourceProperties); return &quot;Hello Spring Boot ! &quot; ;&#125; 浏览器访问路径，控制台查看效果 2.3 YAML配置文件使用 yaml格式介绍 YAML（YAML Ain’t Markup Language）是一种基于层次结构的数据序列化格式，旨在提供一种易读、人类友好的数据表示方式。 与.properties文件相比，YAML格式有以下优势： 层次结构：YAML文件使用缩进和冒号来表示层次结构，使得数据之间的关系更加清晰和直观。这样可以更容易理解和维护复杂的配置，特别适用于深层次嵌套的配置情况。 自我描述性：YAML文件具有自我描述性，字段和值之间使用冒号分隔，并使用缩进表示层级关系。这使得配置文件更易于阅读和理解，并且可以减少冗余的标点符号和引号。 注释支持：YAML格式支持注释，可以在配置文件中添加说明性的注释，使配置更具可读性和可维护性。相比之下，.properties文件不支持注释，无法提供类似的解释和说明。 多行文本：YAML格式支持多行文本的表示，可以更方便地表示长文本或数据块。相比之下，.properties文件需要使用转义符或将长文本拆分为多行。 类型支持：YAML格式天然支持复杂的数据类型，如列表、映射等。这使得在配置文件中表示嵌套结构或数据集合更加容易，而不需要进行额外的解析或转换。 更好的可读性：由于YAML格式的特点，它更容易被人类读懂和解释。它减少了配置文件中需要的特殊字符和语法，让配置更加清晰明了，从而减少了错误和歧义。综上所述，YAML格式相对于.properties文件具有更好的层次结构表示、自我描述性、注释支持、多行文本表示、复杂数据类型支持和更好的可读性。这些特点使YAML成为一种有力的配置文件格式，尤其适用于复杂的配置需求和人类可读的场景。然而，选择使用YAML还是.properties取决于实际需求和团队的偏好，简单的配置可以使用.properties，而复杂的配置可以选择YAML以获得更多的灵活性和可读性 yaml语法说明 数据结构用树形结构呈现，通过缩进来表示层级， 连续的项目（集合）通过减号 ” - ” 来表示 键值结构里面的key&#x2F;value对用冒号 ” : ” 来分隔。 YAML配置文件的扩展名是yaml 或 yml 例如：12345678910111213141516171819# YAML配置文件示例app_name: 我的应用程序version: 1.0.0author: 张三database: host: localhost port: 5432 username: admin password: password123features: - 登录 - 注册 - 仪表盘settings: analytics: true theme: dark 配置文件 12345678910spring: jdbc: datasource: driverClassName: com.mysql.jdbc.Driver url: jdbc:mysql:///springboot_02 username: root password: root server: port: 80 读取配置文件 读取方式和properties一致 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263package com.atguigu.properties;import org.springframework.beans.factory.annotation.Value;import org.springframework.stereotype.Component;@Componentpublic class DataSourceProperties &#123; @Value(&quot;$&#123;spring.jdbc.datasource.driverClassName&#125;&quot;) private String driverClassName; @Value(&quot;$&#123;spring.jdbc.datasource.url&#125;&quot;) private String url; @Value(&quot;$&#123;spring.jdbc.datasource.username&#125;&quot;) private String username; @Value(&quot;$&#123;spring.jdbc.datasource.password&#125;&quot;) private String password; // 生成get set 和 toString方法 public String getDriverClassName() &#123; return driverClassName; &#125; public void setDriverClassName(String driverClassName) &#123; this.driverClassName = driverClassName; &#125; public String getUrl() &#123; return url; &#125; public void setUrl(String url) &#123; this.url = url; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; @Override public String toString() &#123; return &quot;DataSourceProperties&#123;&quot; + &quot;driverClassName=&#x27;&quot; + driverClassName + &#x27;\\&#x27;&#x27; + &quot;, url=&#x27;&quot; + url + &#x27;\\&#x27;&#x27; + &quot;, username=&#x27;&quot; + username + &#x27;\\&#x27;&#x27; + &quot;, password=&#x27;&quot; + password + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125;&#125; 测试效果 在controller注入，输出进行测试 12345678@Autowiredprivate DataSourceProperties dataSourceProperties ;@RequestMapping(path = &quot;/hello&quot;)public String sayHello() &#123; System.out.println(dataSourceProperties); return &quot;Hello Spring Boot ! &quot; ;&#125; 浏览器访问路径，控制台查看效果 2.4 批量配置文件注入 &#x20;@ConfigurationProperties是SpringBoot提供的重要注解, 他可以将一些配置属性批量注入到bean对象。 创建类，添加属性和注解 在类上通过@ConfigurationProperties注解声明该类要读取属性配置 prefix&#x3D;”spring.jdbc.datasource” 读取属性文件中前缀为spring.jdbc.datasource的值。前缀和属性名称和配置文件中的key必须要保持一致才可以注入成功 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556package com.atguigu.properties;import org.springframework.boot.context.properties.ConfigurationProperties;import org.springframework.stereotype.Component;@Component@ConfigurationProperties(prefix = &quot;spring.jdbc.datasource&quot;)public class DataSourceConfigurationProperties &#123; private String driverClassName; private String url; private String username; private String password; public String getDriverClassName() &#123; return driverClassName; &#125; public void setDriverClassName(String driverClassName) &#123; this.driverClassName = driverClassName; &#125; public String getUrl() &#123; return url; &#125; public void setUrl(String url) &#123; this.url = url; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; @Override public String toString() &#123; return &quot;DataSourceConfigurationProperties&#123;&quot; + &quot;driverClassName=&#x27;&quot; + driverClassName + &#x27;\\&#x27;&#x27; + &quot;, url=&#x27;&quot; + url + &#x27;\\&#x27;&#x27; + &quot;, username=&#x27;&quot; + username + &#x27;\\&#x27;&#x27; + &quot;, password=&#x27;&quot; + password + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125;&#125; 测试效果 12345678910111213141516@RestControllerpublic class HelloController &#123; @Autowired private DataSourceProperties dataSourceProperties; @Autowired private DataSourceConfigurationProperties dataSourceConfigurationProperties; @GetMapping(&quot;/hello&quot;) public String hello()&#123; System.out.println(&quot;dataSourceProperties = &quot; + dataSourceProperties); System.out.println(&quot;dataSourceConfigurationProperties = &quot; + dataSourceConfigurationProperties); return &quot;Hello,Spring Boot 3!&quot;; &#125;&#125; 浏览器访问路径，控制台查看效果 2.5 多环境配置和使用 需求 在Spring Boot中，可以使用多环境配置来根据不同的运行环境（如开发、测试、生产）加载不同的配置。SpringBoot支持多环境配置让应用程序在不同的环境中使用不同的配置参数，例如数据库连接信息、日志级别、缓存配置等。 以下是实现Spring Boot多环境配置的常见方法： 属性文件分离：将应用程序的配置参数分离到不同的属性文件中，每个环境对应一个属性文件。例如，可以创建application-dev.properties、application-prod.properties和application-test.properties等文件。在这些文件中，可以定义各自环境的配置参数，如数据库连接信息、端口号等。然后，在application.properties中通过spring.profiles.active属性指定当前使用的环境。Spring Boot会根据该属性来加载对应环境的属性文件，覆盖默认的配置。 YAML配置文件：与属性文件类似，可以将配置参数分离到不同的YAML文件中，每个环境对应一个文件。例如，可以创建application-dev.yml、application-prod.yml和application-test.yml等文件。在这些文件中，可以使用YAML语法定义各自环境的配置参数。同样，通过spring.profiles.active属性指定当前的环境，Spring Boot会加载相应的YAML文件。 命令行参数(动态)：可以通过命令行参数来指定当前的环境。例如，可以使用--spring.profiles.active=dev来指定使用开发环境的配置。通过上述方法，Spring Boot会根据当前指定的环境来加载相应的配置文件或参数，从而实现多环境配置。这样可以简化在不同环境之间的配置切换，并且确保应用程序在不同环境中具有正确的配置。 多环境配置（基于方式b实践） 创建开发、测试、生产三个环境的配置文件application-dev.yml（开发） 1234567spring: jdbc: datasource: driverClassName: com.mysql.cj.jdbc.Driver url: jdbc:mysql:///dev username: root password: root application-test.yml（测试） 1234567spring: jdbc: datasource: driverClassName: com.mysql.cj.jdbc.Driver url: jdbc:mysql:///test username: root password: root application-prod.yml（生产） 1234567spring: jdbc: datasource: driverClassName: com.mysql.cj.jdbc.Driver url: jdbc:mysql:///prod username: root password: root 环境激活 123spring: profiles: active: dev 测试效果 注意 : 如果设置了spring.profiles.active，并且和application有重叠属性，以active设置优先。 如果设置了spring.profiles.active，和application无重叠属性，application设置依然生效！ 三、SpringBoot3整合SpringMVC3.1 实现过程 创建程序 引入依赖 12345678910111213141516171819202122232425262728293031&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;3.0.5&lt;/version&gt; &lt;/parent&gt; &lt;groupId&gt;com.atguigu&lt;/groupId&gt; &lt;artifactId&gt;springboot-starter-springmvc-03&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;17&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;17&lt;/maven.compiler.target&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!-- web开发的场景启动器 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 创建启动类 12345678@SpringBootApplicationpublic class MainApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(MainApplication.class,args); &#125;&#125; 创建实体类 12345678910111213141516171819202122232425262728293031323334353637383940package com.atguigu.pojo;public class User &#123; private String username ; private String password ; private Integer age ; private String sex ; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; public Integer getAge() &#123; return age; &#125; public void setAge(Integer age) &#123; this.age = age; &#125; public String getSex() &#123; return sex; &#125; public void setSex(String sex) &#123; this.sex = sex; &#125;&#125; 编写Controller 123456789101112131415161718192021222324package com.atguigu.controller;import com.atguigu.pojo.User;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.ResponseBody;@Controller@RequestMapping(&quot;/user&quot;)public class UserController &#123; @GetMapping(&quot;/getUser&quot;) @ResponseBody public User getUser()&#123; User user = new User(); user.setUsername(&quot;杨过&quot;); user.setPassword(&quot;123456&quot;); user.setAge(18); user.setSex(&quot;男&quot;); return user; &#125;&#125; 访问测试 3.2 web相关配置位置：application.yml 12345678# web相关的配置# https://docs.spring.io/spring-boot/docs/current/reference/html/application-properties.html#appendix.application-properties.serverserver: # 端口号设置 port: 80 # 项目根路径 servlet: context-path: /boot 当涉及Spring Boot的Web应用程序配置时，以下是五个重要的配置参数： server.port: 指定应用程序的HTTP服务器端口号。默认情况下，Spring Boot使用8080作为默认端口。您可以通过在配置文件中设置server.port来更改端口号。 server.servlet.context-path: 设置应用程序的上下文路径。这是应用程序在URL中的基本路径。默认情况下，上下文路径为空。您可以通过在配置文件中设置server.servlet.context-path属性来指定自定义的上下文路径。 spring.mvc.view.prefix和spring.mvc.view.suffix: 这两个属性用于配置视图解析器的前缀和后缀。视图解析器用于解析控制器返回的视图名称，并将其映射到实际的视图页面。spring.mvc.view.prefix定义视图的前缀，spring.mvc.view.suffix定义视图的后缀。 spring.resources.static-locations: 配置静态资源的位置。静态资源可以是CSS、JavaScript、图像等。默认情况下，Spring Boot会将静态资源放在classpath:/static目录下。您可以通过在配置文件中设置spring.resources.static-locations属性来自定义静态资源的位置。 spring.http.encoding.charset和spring.http.encoding.enabled: 这两个属性用于配置HTTP请求和响应的字符编码。spring.http.encoding.charset定义字符编码的名称（例如UTF-8），spring.http.encoding.enabled用于启用或禁用字符编码的自动配置。 这些是在Spring Boot的配置文件中与Web应用程序相关的一些重要配置参数。根据您的需求，您可以在配置文件中设置这些参数来定制和配置您的Web应用程序 3.3 静态资源处理 在WEB开发中我们需要引入一些静态资源 , 例如 : HTML , CSS , JS , 图片等 , 如果是普通的项目静态资源可以放在项目的webapp目录下。现在使用Spring Boot做开发 , 项目中没有webapp目录 , 我们的项目是一个jar工程，那么就没有webapp，我们的静态资源该放哪里呢？ 默认路径 在springboot中就定义了静态资源的默认查找路径： 123456789101112131415161718package org.springframework.boot.autoconfigure.web;//..................public static class Resources &#123; private static final String[] CLASSPATH_RESOURCE_LOCATIONS = new String[]&#123;&quot;classpath:/META-INF/resources/&quot;, &quot;classpath:/resources/&quot;, &quot;classpath:/static/&quot;, &quot;classpath:/public/&quot;&#125;; private String[] staticLocations; private boolean addMappings; private boolean customized; private final Chain chain; private final Cache cache; public Resources() &#123; this.staticLocations = CLASSPATH_RESOURCE_LOCATIONS; this.addMappings = true; this.customized = false; this.chain = new Chain(); this.cache = new Cache(); &#125;//........... 默认的静态资源路径为： · classpath:&#x2F;META-INF&#x2F;resources&#x2F; · classpath:&#x2F;resources&#x2F; · classpath:&#x2F;static&#x2F; · classpath:&#x2F;public&#x2F; 我们只要静态资源放在这些目录中任何一个，SpringMVC都会帮我们处理。 我们习惯会把静态资源放在classpath:&#x2F;static&#x2F; 目录下。在resources目录下创建index.html文件 打开浏览器输入 : http://localhost:8080/index.html 覆盖路径 12345678910111213# web相关的配置# https://docs.spring.io/spring-boot/docs/current/reference/html/application-properties.html#appendix.application-properties.serverserver: # 端口号设置 port: 80 # 项目根路径 servlet: context-path: /bootspring: web: resources: # 配置静态资源地址,如果设置,会覆盖默认值 static-locations: classpath:/webapp 访问地址：http://localhost/boot/login.html 3.4 自定义拦截器(SpringMVC配置) 拦截器声明 1234567891011121314151617181920212223242526package com.atguigu.interceptor;import jakarta.servlet.http.HttpServletRequest;import jakarta.servlet.http.HttpServletResponse;import org.springframework.stereotype.Component;import org.springframework.web.servlet.HandlerInterceptor;import org.springframework.web.servlet.ModelAndView;@Componentpublic class MyInterceptor implements HandlerInterceptor &#123; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; System.out.println(&quot;MyInterceptor拦截器的preHandle方法执行....&quot;); return true; &#125; @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; System.out.println(&quot;MyInterceptor拦截器的postHandle方法执行....&quot;); &#125; @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; System.out.println(&quot;MyInterceptor拦截器的afterCompletion方法执行....&quot;); &#125;&#125; 拦截器配置 正常使用配置类，只要保证，配置类要在启动类的同包或者子包方可生效！ 123456789101112131415161718192021222324package com.atguigu.config;import com.atguigu.interceptor.MyInterceptor;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.context.annotation.Configuration;import org.springframework.web.servlet.config.annotation.InterceptorRegistry;import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;@Configurationpublic class MvcConfig implements WebMvcConfigurer &#123; @Autowired private MyInterceptor myInterceptor ; /** * /** 拦截当前目录及子目录下的所有路径 /user/** /user/findAll /user/order/findAll * /* 拦截当前目录下的以及子路径 /user/* /user/findAll * @param registry */ @Override public void addInterceptors(InterceptorRegistry registry) &#123; registry.addInterceptor(myInterceptor).addPathPatterns(&quot;/**&quot;); &#125;&#125; 拦截器效果测试 四、SpringBoot3整合Druid数据源 创建程序 引入依赖 1234567891011121314151617181920&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;3.0.5&lt;/version&gt; &lt;/parent&gt; &lt;groupId&gt;com.atguigu&lt;/groupId&gt; &lt;artifactId&gt;springboot-starter-druid-04&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;17&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;17&lt;/maven.compiler.target&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!-- web开发的场景启动器 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- 数据库相关配置启动器 jdbctemplate 事务相关--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- druid启动器的依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-3-starter&lt;/artifactId&gt; &lt;version&gt;1.2.18&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 驱动类--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.28&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.28&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;!-- SpringBoot应用打包插件--&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; 123456789103. 启动类 ```java @SpringBootApplication public class MainApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(MainApplication.class,args); &#125; &#125; 配置文件编写 添加druid连接池的基本配置 1234567891011121314151617181920212223242526272829303132333435363738394041spring: datasource: # 连接池类型 type: com.alibaba.druid.pool.DruidDataSource # Druid的其他属性配置 springboot3整合情况下,数据库连接信息必须在Druid属性下! druid: url: jdbc:mysql://localhost:3306/day01 username: root password: root driver-class-name: com.mysql.cj.jdbc.Driver # 初始化时建立物理连接的个数 initial-size: 5 # 连接池的最小空闲数量 min-idle: 5 # 连接池最大连接数量 max-active: 20 # 获取连接时最大等待时间，单位毫秒 max-wait: 60000 # 申请连接的时候检测，如果空闲时间大于timeBetweenEvictionRunsMillis，执行validationQuery检测连接是否有效。 test-while-idle: true # 既作为检测的间隔时间又作为testWhileIdel执行的依据 time-between-eviction-runs-millis: 60000 # 销毁线程时检测当前连接的最后活动时间和当前时间差大于该值时，关闭当前连接(配置连接在池中的最小生存时间) min-evictable-idle-time-millis: 30000 # 用来检测数据库连接是否有效的sql 必须是一个查询语句(oracle中为 select 1 from dual) validation-query: select 1 # 申请连接时会执行validationQuery检测连接是否有效,开启会降低性能,默认为true test-on-borrow: false # 归还连接时会执行validationQuery检测连接是否有效,开启会降低性能,默认为true test-on-return: false # 是否缓存preparedStatement, 也就是PSCache,PSCache对支持游标的数据库性能提升巨大，比如说oracle,在mysql下建议关闭。 pool-prepared-statements: false # 要启用PSCache，必须配置大于0，当大于0时，poolPreparedStatements自动触发修改为true。在Druid中，不会存在Oracle下PSCache占用内存过多的问题，可以把这个数值配置大一些，比如说100 max-pool-prepared-statement-per-connection-size: -1 # 合并多个DruidDataSource的监控数据 use-global-data-source-stat: truelogging: level: root: debug 编写Controller 123456789101112131415161718@Slf4j@Controller@RequestMapping(&quot;/user&quot;)public class UserController &#123; @Autowired private JdbcTemplate jdbcTemplate; @GetMapping(&quot;/getUser&quot;) @ResponseBody public User getUser()&#123; String sql = &quot;select * from users where id = ? ; &quot;; User user = jdbcTemplate.queryForObject(sql, new BeanPropertyRowMapper&lt;&gt;(User.class), 1); log.info(&quot;查询的user数据为:&#123;&#125;&quot;,user.toString()); return user; &#125; &#125; 启动测试 问题解决 通过源码分析，druid-spring-boot-3-starter目前最新版本是1.2.18，虽然适配了SpringBoot3，但缺少自动装配的配置文件，需要手动在resources目录下创建META-INF&#x2F;spring&#x2F;org.springframework.boot.autoconfigure.AutoConfiguration.imports，文件内容如下! 1com.alibaba.druid.spring.boot3.autoconfigure.DruidDataSourceAutoConfigure 五、SpringBoot3整合Mybatis5.1 MyBatis整合步骤 导入依赖：在您的Spring Boot项目的构建文件（如pom.xml）中添加MyBatis和数据库驱动的相关依赖。例如，如果使用MySQL数据库，您需要添加MyBatis和MySQL驱动的依赖。 配置数据源：在application.properties或application.yml中配置数据库连接信息，包括数据库URL、用户名、密码、mybatis的功能配置等。 创建实体类：创建与数据库表对应的实体类。 创建Mapper接口：创建与数据库表交互的Mapper接口。 创建Mapper接口SQL实现： 可以使用mapperxml文件或者注解方式 创建程序启动类 注解扫描：在Spring Boot的主应用类上添加@MapperScan注解，用于扫描和注册Mapper接口。 使用Mapper接口：在需要使用数据库操作的地方，通过依赖注入或直接实例化Mapper接口，并调用其中的方法进行数据库操作。 5.2 Mybatis整合实践 创建项目 导入依赖 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;3.0.5&lt;/version&gt;&lt;/parent&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.0.1&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 数据库相关配置启动器 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- druid启动器的依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-3-starter&lt;/artifactId&gt; &lt;version&gt;1.2.18&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 驱动类--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.28&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.28&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 配置文件 1234567891011121314151617181920server: port: 80 servlet: context-path: /spring: datasource: type: com.alibaba.druid.pool.DruidDataSource druid: url: jdbc:mysql:///day01 username: root password: root driver-class-name: com.mysql.cj.jdbc.Driver mybatis: configuration: # setting配置 auto-mapping-behavior: full map-underscore-to-camel-case: true log-impl: org.apache.ibatis.logging.slf4j.Slf4jImpl type-aliases-package: com.atguigu.pojo # 配置别名 mapper-locations: classpath:/mapper/*.xml # mapperxml位置 实体类准备 12345678910111213141516171819202122232425262728293031323334353637383940package com.atguigu.pojo;public class User &#123; private String account ; private String password ; private Integer id ; public String getAccount() &#123; return account; &#125; public void setAccount(String account) &#123; this.account = account; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; @Override public String toString() &#123; return &quot;User&#123;&quot; + &quot;account=&#x27;&quot; + account + &#x27;\\&#x27;&#x27; + &quot;, password=&#x27;&quot; + password + &#x27;\\&#x27;&#x27; + &quot;, id=&quot; + id + &#x27;&#125;&#x27;; &#125;&#125; Mapper接口准备 1234public interface UserMapper &#123; List&lt;User&gt; queryAll();&#125; Mapper接口实现（XML） 位置：resources&#x2F;mapper&#x2F;UserMapper.xml 123456789101112&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;https://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;!-- namespace = 接口的全限定符 --&gt;&lt;mapper namespace=&quot;com.atguigu.mapper.UserMapper&quot;&gt; &lt;select id=&quot;queryAll&quot; resultType=&quot;user&quot;&gt; select * from users &lt;/select&gt;&lt;/mapper&gt; 编写三层架构代码 伪代码，不添加业务接口！ controller1234@Slf4j@Controller@RequestMapping(&quot;/user&quot;)public class UserController &#123; @Autowired private UserService userService; @GetMapping(&quot;/list&quot;) @ResponseBody public List&lt;User&gt; getUser()&#123; List&lt;User&gt; userList = userService.findList(); log.info(&quot;查询的user数据为:&#123;&#125;&quot;,userList); return userList; &#125; &#125; 1234567891011121314152. service ```java @Slf4j @Service public class UserService &#123; @Autowired private UserMapper userMapper; public List&lt;User&gt; findList()&#123; List&lt;User&gt; users = userMapper.queryAll(); log.info(&quot;查询全部数据:&#123;&#125;&quot;,users); return users; &#125; &#125; 启动类和接口扫描 123456789@MapperScan(&quot;com.atguigu.mapper&quot;) //mapper接口扫描配置@SpringBootApplicationpublic class MainApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(MainApplication.class,args); &#125;&#125; 启动测试 5.3 声明式事务整合配置依赖导入: 1234 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;&lt;/dependency&gt; 注：SpringBoot项目会自动配置一个 DataSourceTransactionManager，所以我们只需在方法（或者类）加上 @Transactional 注解，就自动纳入 Spring 的事务管理了 12345678@Transactionalpublic void update()&#123; User user = new User(); user.setId(1); user.setPassword(&quot;test2&quot;); user.setAccount(&quot;test2&quot;); userMapper.update(user);&#125; 5.4 AOP整合配置依赖导入: 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt;&lt;/dependency&gt; 直接使用aop注解即可:&#x20; 1234567891011@Component@Aspectpublic class LogAdvice &#123; @Before(&quot;execution(* com..service.*.*(..))&quot;) public void before(JoinPoint joinPoint)&#123; System.out.println(&quot;LogAdvice.before&quot;); System.out.println(&quot;joinPoint = &quot; + joinPoint); &#125;&#125; 六、SpringBoot3项目打包和运行6.1 添加打包插件 在Spring Boot项目中添加spring-boot-maven-plugin插件是为了支持将项目打包成可执行的可运行jar包。如果不添加spring-boot-maven-plugin插件配置，使用常规的java -jar命令来运行打包后的Spring Boot项目是无法找到应用程序的入口点，因此导致无法运行。 123456789&lt;!-- SpringBoot应用打包插件--&gt;&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 6.2 执行打包在idea点击package进行打包 可以在编译的target文件中查看jar包 6.3 命令启动和参数说明java -jar命令用于在Java环境中执行可执行的JAR文件。下面是关于java -jar命令的说明： 1命令格式：java -jar [选项] [参数] &lt;jar文件名&gt; -D&lt;name&gt;=&lt;value&gt;：设置系统属性，可以通过System.getProperty()方法在应用程序中获取该属性值。例如：java -jar -Dserver.port=8080 myapp.jar。 -X：设置JVM参数，例如内存大小、垃圾回收策略等。常用的选项包括： -Xmx&lt;size&gt;：设置JVM的最大堆内存大小，例如 -Xmx512m 表示设置最大堆内存为512MB。 -Xms&lt;size&gt;：设置JVM的初始堆内存大小，例如 -Xms256m 表示设置初始堆内存为256MB。 -Dspring.profiles.active=&lt;profile&gt;：指定Spring Boot的激活配置文件，可以通过application-&lt;profile&gt;.properties或application-&lt;profile&gt;.yml文件来加载相应的配置。例如：java -jar -Dspring.profiles.active=dev myapp.jar。 启动和测试： 注意： -D 参数必须要在jar之前！否者不生效！","categories":[{"name":"SSM框架","slug":"SSM框架","permalink":"http://example.com/categories/SSM%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"ssm","slug":"ssm","permalink":"http://example.com/tags/ssm/"}]},{"title":"五、框架实战：SSM整合原理和实战","slug":"SSM/五、框架实战：SSM整合原理和实战/五、框架实战：SSM整合原理和实战","date":"2022-10-01T09:55:54.000Z","updated":"2023-09-28T00:32:42.246Z","comments":true,"path":"2022/10/01/SSM/五、框架实战：SSM整合原理和实战/五、框架实战：SSM整合原理和实战/","link":"","permalink":"http://example.com/2022/10/01/SSM/%E4%BA%94%E3%80%81%E6%A1%86%E6%9E%B6%E5%AE%9E%E6%88%98%EF%BC%9ASSM%E6%95%B4%E5%90%88%E5%8E%9F%E7%90%86%E5%92%8C%E5%AE%9E%E6%88%98/%E4%BA%94%E3%80%81%E6%A1%86%E6%9E%B6%E5%AE%9E%E6%88%98%EF%BC%9ASSM%E6%95%B4%E5%90%88%E5%8E%9F%E7%90%86%E5%92%8C%E5%AE%9E%E6%88%98/","excerpt":"","text":"五、框架实战：SSM整合原理和实战目录 一、SSM整合理解 1.1 什么是SSM整合？ 1.2 SSM整合核心问题明确 1.2.1 第一问：SSM整合需要几个IoC容器？ 1.2.2 第二问：每个IoC容器对应哪些类型组件？ 1.2.3 第三问：IoC容器之间关系和调用方向？ 1.2.4 第四问：具体多少配置类以及对应容器关系？ 1.2.5 第五问：IoC初始化方式和配置位置？ 二、SSM整合配置实战 2.1 依赖整合和添加 2.2 控制层配置编写(SpringMVC整合) 2.3 业务层配置编写(AOP &#x2F; TX整合） 2.4 持久层配置编写(MyBatis整合) 2.5 容器初始化配置类 2.6 整合测试 三、《任务列表案例》前端程序搭建和运行 3.1 整合案例介绍和接口分析 3.1.1 案例功能预览 3.1.2接口分析 3.2 前端工程导入 3.2.1 前端环境搭建 3.2.2 导入前端程序 3.3 启动测试 四、《任务列表案例》后端程序实现和测试 4.1 准备工作 4.2 功能实现 4.3 前后联调 一、SSM整合理解1.1 什么是SSM整合？微观：将学习的Spring SpringMVC Mybatis框架应用到项目中! SpringMVC框架负责控制层 Spring 框架负责整体和业务层的声明式事务管理 MyBatis框架负责数据库访问层 宏观：Spring接管一切（将框架核心组件交给Spring进行IoC管理），代码更加简洁。 SpringMVC管理表述层、SpringMVC相关组件 Spring管理业务层、持久层、以及数据库相关（DataSource,MyBatis）的组件 使用IoC的方式管理一切所需组件 实施：通过编写配置文件，实现SpringIoC容器接管一切组件。 1.2 SSM整合核心问题明确1.2.1 第一问：SSM整合需要几个IoC容器？两个容器 本质上说，整合就是将三层架构和框架核心API组件交给SpringIoC容器管理！ 一个容器可能就够了，但是我们常见的操作是创建两个IoC容器（web容器和root容器），组件分类管理！ 这种做法有以下好处和目的： 分离关注点：通过初始化两个容器，可以将各个层次的关注点进行分离。这种分离使得各个层次的组件能够更好地聚焦于各自的责任和功能。 解耦合：各个层次组件分离装配不同的IoC容器，这样可以进行解耦。这种解耦合使得各个模块可以独立操作和测试，提高了代码的可维护性和可测试性。 灵活配置：通过使用两个容器，可以为每个容器提供各自的配置，以满足不同层次和组件的特定需求。每个配置文件也更加清晰和灵活。 总的来说，初始化两个容器在SSM整合中可以实现关注点分离、解耦合、灵活配置等好处。它们各自负责不同的层次和功能，并通过合适的集成方式协同工作，提供一个高效、可维护和可扩展的应用程序架构！ 1.2.2 第二问：每个IoC容器对应哪些类型组件？图解： 总结： 容器名 盛放组件 web容器 web相关组件（controller,springmvc核心组件） root容器 业务和持久层相关组件（service,aop,tx,dataSource,mybatis,mapper等） 1.2.3 第三问：IoC容器之间关系和调用方向？情况1：两个无关联IoC容器之间的组件无法注入！ 情况2：子IoC容器可以单向的注入父IoC容器的组件！ 结论：web容器是root容器的子容器，父子容器关系。 父容器：root容器，盛放service、mapper、mybatis等相关组件 子容器：web容器，盛放controller、web相关组件 源码体现： FrameworkServlet 655行！ 123456789101112131415161718192021222324protected WebApplicationContext createWebApplicationContext(@Nullable ApplicationContext parent) &#123; Class&lt;?&gt; contextClass = getContextClass(); if (!ConfigurableWebApplicationContext.class.isAssignableFrom(contextClass)) &#123; throw new ApplicationContextException( &quot;Fatal initialization error in servlet with name &#x27;&quot; + getServletName() + &quot;&#x27;: custom WebApplicationContext class [&quot; + contextClass.getName() + &quot;] is not of type ConfigurableWebApplicationContext&quot;); &#125; ConfigurableWebApplicationContext wac = (ConfigurableWebApplicationContext) BeanUtils.instantiateClass(contextClass); wac.setEnvironment(getEnvironment()); //wac 就是web ioc容器 //parent 就是root ioc容器 //web容器设置root容器为父容器，所以web容器可以引用root容器 wac.setParent(parent); String configLocation = getContextConfigLocation(); if (configLocation != null) &#123; wac.setConfigLocation(configLocation); &#125; configureAndRefreshWebApplicationContext(wac); return wac; &#125; 调用流程图解： 1.2.4 第四问：具体多少配置类以及对应容器关系？配置类的数量不是固定的，但是至少要两个，为了方便编写，我们可以三层架构每层对应一个配置类，分别指定两个容器加载即可！ 建议配置文件： 配置名 对应内容 对应容器 WebJavaConfig controller,springmvc相关 web容器 ServiceJavaConfig service,aop,tx相关 root容器 MapperJavaConfig mapper,datasource,mybatis相关 root容器 1.2.5 第五问：IoC初始化方式和配置位置？在web项目下，我们可以选择web.xml和配置类方式进行ioc配置，推荐配置类。 对于使用基于 web 的 Spring 配置的应用程序，建议这样做，如以下示例所示： 123456789101112131415161718192021public class MyWebAppInitializer extends AbstractAnnotationConfigDispatcherServletInitializer &#123; //指定root容器对应的配置类 //root容器的配置类 @Override protected Class&lt;?&gt;[] getRootConfigClasses() &#123; return new Class&lt;?&gt;[] &#123; ServiceJavaConfig.class,MapperJavaConfig.class &#125;; &#125; //指定web容器对应的配置类 webioc容器的配置类 @Override protected Class&lt;?&gt;[] getServletConfigClasses() &#123; return new Class&lt;?&gt;[] &#123; WebJavaConfig.class &#125;; &#125; //指定dispatcherServlet处理路径，通常为 / @Override protected String[] getServletMappings() &#123; return new String[] &#123; &quot;/&quot; &#125;; &#125;&#125; 图解配置类和容器配置： 二、SSM整合配置实战2.1 依赖整合和添加 数据库准备 依然沿用mybatis数据库测试脚本！ 1234567891011121314CREATE DATABASE `mybatis-example`;USE `mybatis-example`;CREATE TABLE `t_emp`( emp_id INT AUTO_INCREMENT, emp_name CHAR(100), emp_salary DOUBLE(10,5), PRIMARY KEY(emp_id));INSERT INTO `t_emp`(emp_name,emp_salary) VALUES(&quot;tom&quot;,200.33);INSERT INTO `t_emp`(emp_name,emp_salary) VALUES(&quot;jerry&quot;,666.66);INSERT INTO `t_emp`(emp_name,emp_salary) VALUES(&quot;andy&quot;,777.77); 准备项目 part04-ssm-integration 转成web项目 依赖导入 pom.xml 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.atguigu&lt;/groupId&gt; &lt;artifactId&gt;part04-ssm-integration&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;properties&gt; &lt;spring.version&gt;6.0.6&lt;/spring.version&gt; &lt;jakarta.annotation-api.version&gt;2.1.1&lt;/jakarta.annotation-api.version&gt; &lt;jakarta.jakartaee-web-api.version&gt;9.1.0&lt;/jakarta.jakartaee-web-api.version&gt; &lt;jackson-databind.version&gt;2.15.0&lt;/jackson-databind.version&gt; &lt;hibernate-validator.version&gt;8.0.0.Final&lt;/hibernate-validator.version&gt; &lt;mybatis.version&gt;3.5.11&lt;/mybatis.version&gt; &lt;mysql.version&gt;8.0.25&lt;/mysql.version&gt; &lt;pagehelper.version&gt;5.1.11&lt;/pagehelper.version&gt; &lt;druid.version&gt;1.2.8&lt;/druid.version&gt; &lt;mybatis-spring.version&gt;3.0.2&lt;/mybatis-spring.version&gt; &lt;jakarta.servlet.jsp.jstl-api.version&gt;3.0.0&lt;/jakarta.servlet.jsp.jstl-api.version&gt; &lt;logback.version&gt;1.2.3&lt;/logback.version&gt; &lt;lombok.version&gt;1.18.26&lt;/lombok.version&gt; &lt;maven.compiler.source&gt;17&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;17&lt;/maven.compiler.target&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;/properties&gt; &lt;!-- 需要依赖清单分析: spring ioc/di spring-context / 6.0.6 jakarta.annotation-api / 2.1.1 jsr250 aop spring-aspects / 6.0.6 tx spring-tx / 6.0.6 spring-jdbc / 6.0.6 springmvc spring-webmvc 6.0.6 jakarta.jakartaee-web-api 9.1.0 jackson-databind 2.15.0 hibernate-validator / hibernate-validator-annotation-processor 8.0.0.Final mybatis mybatis / 3.5.11 mysql / 8.0.25 pagehelper / 5.1.11 整合需要 加载spring容器 spring-web / 6.0.6 整合mybatis mybatis-spring x x 数据库连接池 druid / x lombok lombok / 1.18.26 logback logback/ 1.2.3 --&gt; &lt;dependencies&gt; &lt;!--spring pom.xml依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;jakarta.annotation&lt;/groupId&gt; &lt;artifactId&gt;jakarta.annotation-api&lt;/artifactId&gt; &lt;version&gt;$&#123;jakarta.annotation-api.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- springmvc spring-webmvc 6.0.6 jakarta.jakartaee-web-api 9.1.0 jackson-databind 2.15.0 hibernate-validator / hibernate-validator-annotation-processor 8.0.0.Final --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;jakarta.platform&lt;/groupId&gt; &lt;artifactId&gt;jakarta.jakartaee-web-api&lt;/artifactId&gt; &lt;version&gt;$&#123;jakarta.jakartaee-web-api.version&#125;&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- jsp需要依赖! jstl--&gt; &lt;dependency&gt; &lt;groupId&gt;jakarta.servlet.jsp.jstl&lt;/groupId&gt; &lt;artifactId&gt;jakarta.servlet.jsp.jstl-api&lt;/artifactId&gt; &lt;version&gt;$&#123;jakarta.servlet.jsp.jstl-api.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;$&#123;jackson-databind.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.hibernate.validator/hibernate-validator --&gt; &lt;dependency&gt; &lt;groupId&gt;org.hibernate.validator&lt;/groupId&gt; &lt;artifactId&gt;hibernate-validator&lt;/artifactId&gt; &lt;version&gt;$&#123;hibernate-validator.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.hibernate.validator/hibernate-validator-annotation-processor --&gt; &lt;dependency&gt; &lt;groupId&gt;org.hibernate.validator&lt;/groupId&gt; &lt;artifactId&gt;hibernate-validator-annotation-processor&lt;/artifactId&gt; &lt;version&gt;$&#123;hibernate-validator.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- mybatis mybatis / 3.5.11 mysql / 8.0.25 pagehelper / 5.1.11 --&gt; &lt;!-- mybatis依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;$&#123;mybatis.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- MySQL驱动 mybatis底层依赖jdbc驱动实现,本次不需要导入连接池,mybatis自带! --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;$&#123;mysql.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper&lt;/artifactId&gt; &lt;version&gt;$&#123;pagehelper.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 整合第三方特殊依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;$&#123;mybatis-spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 日志 ， 会自动传递slf4j门面--&gt; &lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-classic&lt;/artifactId&gt; &lt;version&gt;$&#123;logback.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;$&#123;lombok.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;$&#123;druid.version&#125;&lt;/version&gt; &lt;/dependency&gt; 12345678910114. 实体类添加 com.atguigu.pojo ```java @Data public class Employee &#123; private Integer empId; private String empName; private Double empSalary; &#125; logback配置 位置：resources&#x2F;logback.xml 123456789101112131415161718192021222324&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;configuration debug=&quot;true&quot;&gt; &lt;!-- 指定日志输出的位置，ConsoleAppender表示输出到控制台 --&gt; &lt;appender name=&quot;STDOUT&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt; &lt;encoder&gt; &lt;!-- 日志输出的格式 --&gt; &lt;!-- 按照顺序分别是：时间、日志级别、线程名称、打印日志的类、日志主体内容、换行 --&gt; &lt;pattern&gt;[%d&#123;HH:mm:ss.SSS&#125;] [%-5level] [%thread] [%logger] [%msg]%n&lt;/pattern&gt; &lt;charset&gt;UTF-8&lt;/charset&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;!-- 设置全局日志级别。日志级别按顺序分别是：TRACE、DEBUG、INFO、WARN、ERROR --&gt; &lt;!-- 指定任何一个日志级别都只打印当前级别和后面级别的日志。 --&gt; &lt;root level=&quot;DEBUG&quot;&gt; &lt;!-- 指定打印日志的appender，这里通过“STDOUT”引用了前面配置的appender --&gt; &lt;appender-ref ref=&quot;STDOUT&quot; /&gt; &lt;/root&gt; &lt;!-- 根据特殊需求指定局部日志级别，可也是包名或全类名。 --&gt; &lt;logger name=&quot;com.atguigu.mybatis&quot; level=&quot;DEBUG&quot; /&gt;&lt;/configuration&gt; 2.2 控制层配置编写(SpringMVC整合) 主要配置controller,springmvc相关组件配置&#x20; 位置：WebJavaConfig.java(命名随意) 123456789101112131415161718192021/** * projectName: com.atguigu.config * * 1.实现Springmvc组件声明标准化接口WebMvcConfigurer 提供了各种组件对应的方法 * 2.添加配置类注解@Configuration * 3.添加mvc复合功能开关@EnableWebMvc * 4.添加controller层扫描注解 * 5.开启默认处理器,支持静态资源处理 */@Configuration@EnableWebMvc@ComponentScan(&quot;com.atguigu.controller&quot;)public class WebJavaConfig implements WebMvcConfigurer &#123; //开启静态资源 @Override public void configureDefaultServletHandling(DefaultServletHandlerConfigurer configurer) &#123; configurer.enable(); &#125;&#125; 2.3 业务层配置编写(AOP &#x2F; TX整合） 主要配置service,注解aop和声明事务相关配置 位置：ServiceJavaConfig.java(命名随意) 1234567891011121314151617181920212223/** * projectName: com.atguigu.config * * 1. 声明@Configuration注解,代表配置类 * 2. 声明@EnableTransactionManagement注解,开启事务注解支持 * 3. 声明@EnableAspectJAutoProxy注解,开启aspect aop注解支持 * 4. 声明@ComponentScan(&quot;com.atguigu.service&quot;)注解,进行业务组件扫描 * 5. 声明transactionManager(DataSource dataSource)方法,指定具体的事务管理器 */@EnableTransactionManagement@EnableAspectJAutoProxy@Configuration@ComponentScan(&quot;com.atguigu.service&quot;)public class ServiceJavaConfig &#123; @Bean public DataSourceTransactionManager transactionManager(DataSource dataSource)&#123; DataSourceTransactionManager transactionManager = new DataSourceTransactionManager(); transactionManager.setDataSource(dataSource); return transactionManager; &#125; &#125; 2.4 持久层配置编写(MyBatis整合) 主要配置mapper代理对象，连接池和mybatis核心组件配置 mybatis整合思路 mybatis核心api使用回顾： 12345678910111213141516//1.读取外部配置文件InputStream ips = Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;);//2.创建sqlSessionFactorySqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(ips);//3.创建sqlSessionSqlSession sqlSession = sqlSessionFactory.openSession();//4.获取mapper代理对象EmpMapper empMapper = sqlSession.getMapper(EmpMapper.class);//5.数据库方法调用int rows = empMapper.deleteEmpById(1);System.out.println(&quot;rows = &quot; + rows);//6.提交和回滚sqlSession.commit();sqlSession.close(); mybatis核心api介绍回顾： SqlSessionFactoryBuilder 这个类可以被实例化、使用和丢弃，一旦创建了 SqlSessionFactory，就不再需要它了。&#x20;因此 SqlSessionFactoryBuilder 实例的最佳作用域是方法作用域（也就是局部方法变量）。 无需ioc容器管理！ SqlSessionFactory 一旦被创建就应该在应用的运行期间一直存在，没有任何理由丢弃它或重新创建另一个实例。 使用 SqlSessionFactory 的最佳实践是在应用运行期间不要重复创建多次，因此 SqlSessionFactory 的最佳作用域是应用作用域。 需要ioc容器管理！ SqlSession 每个线程都应该有它自己的 SqlSession 实例。SqlSession 的实例不是线程安全的，因此是不能被共享的，所以它的最佳的作用域是请求或方法作用域。 无需ioc容器管理！ Mapper映射器实例 映射器是一些绑定映射语句的接口。映射器接口的实例是从 SqlSession 中获得的。虽然从技术层面上来讲，任何映射器实例的最大作用域与请求它们的 SqlSession 相同。但方法作用域才是映射器实例的最合适的作用域。 从作用域的角度来说，映射器实例不应该交给ioc容器管理！ 但是从使用的角度来说，业务类（service）需要注入mapper接口，所以mapper应该交给ioc容器管理！ 总结 将SqlSessionFactory实例存储到IoC容器 将Mapper实例存储到IoC容器mybatis整合思路理解： mybatis的api实例化需要复杂的过程。 例如，自己实现sqlSessionFactory加入ioc容器： 12345678910@Beanpublic SqlSessionFactory sqlSessionFactory()&#123; //1.读取外部配置文件 InputStream ips = Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;); //2.创建sqlSessionFactory SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(ips); return sqlSessionFactory;&#125; 过程比较繁琐，为了提高整合效率，mybatis提供了提供封装SqlSessionFactory和Mapper实例化的逻辑的FactoryBean组件，我们只需要声明和指定少量的配置即可！ SqlSessionFactoryBean源码展示(mybatis提供)： 12345678910111213141516package org.mybatis.spring;public class SqlSessionFactoryBean implements FactoryBean&lt;SqlSessionFactory&gt;, InitializingBean, ApplicationListener&lt;ContextRefreshedEvent&gt; &#123; //封装了实例化流程 public SqlSessionFactory getObject() throws Exception &#123; if (this.sqlSessionFactory == null) &#123; //实例化对象逻辑 afterPropertiesSet(); &#125; //返回对象逻辑 return this.sqlSessionFactory; &#125; &#125; mybatis整合思路总结： 需要将SqlSessionFactory和Mapper实例加入到IoC容器 使用mybatis整合包提供的FactoryBean快速整合 准备外部配置文件 数据库连接信息位置：resources&#x2F;jdbc.properties 1234jdbc.user=rootjdbc.password=rootjdbc.url=jdbc:mysql:///mybatis-examplejdbc.driver=com.mysql.cj.jdbc.Driver 整合方式1 （保留mybatis-config.xml） 介绍 依然保留mybatis的外部配置文件（xml）, 但是数据库连接信息交给Druid连接池配置！ 缺点：依然需要mybatis-config.xml文件，进行xml文件解析，效率偏低！ mybatis配置文件 数据库信息以及mapper扫描包设置使用Java配置类处理！mybatis其他的功能（别名、settings、插件等信息）依然在mybatis-config.xml配置！ 1234567891011121314151617181920212223242526272829303132&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt; &lt;settings&gt; &lt;!-- 开启驼峰式映射--&gt; &lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;true&quot;/&gt; &lt;!-- 开启logback日志输出--&gt; &lt;setting name=&quot;logImpl&quot; value=&quot;SLF4J&quot;/&gt; &lt;!--开启resultMap自动映射 --&gt; &lt;setting name=&quot;autoMappingBehavior&quot; value=&quot;FULL&quot;/&gt; &lt;/settings&gt; &lt;typeAliases&gt; &lt;!-- 给实体类起别名 --&gt; &lt;package name=&quot;com.atguigu.pojo&quot;/&gt; &lt;/typeAliases&gt; &lt;plugins&gt; &lt;plugin interceptor=&quot;com.github.pagehelper.PageInterceptor&quot;&gt; &lt;!-- helperDialect：分页插件会自动检测当前的数据库链接，自动选择合适的分页方式。 你可以配置helperDialect属性来指定分页插件使用哪种方言。配置时，可以使用下面的缩写值： oracle,mysql,mariadb,sqlite,hsqldb,postgresql,db2,sqlserver,informix,h2,sqlserver2012,derby （完整内容看 PageAutoDialect） 特别注意：使用 SqlServer2012 数据库时， https://github.com/pagehelper/Mybatis-PageHelper/blob/master/wikis/zh/HowToUse.md#%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AE%E6%95%B0%E6%8D%AE%E5%BA%93%E6%96%B9%E8%A8%80 --&gt; &lt;property name=&quot;helperDialect&quot; value=&quot;mysql&quot;/&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/configuration&gt; mybatis和持久层配置类 持久层Mapper配置、数据库配置、Mybatis配置信息位置：MapperJavaConfig.java(命名随意) 123456789101112@Configuration@PropertySource(&quot;classpath:jdbc.properties&quot;)public class MapperJavaConfig &#123; @Value(&quot;$&#123;jdbc.user&#125;&quot;) private String user; @Value(&quot;$&#123;jdbc.password&#125;&quot;) private String password; @Value(&quot;$&#123;jdbc.url&#125;&quot;) private String url; @Value(&quot;$&#123;jdbc.driver&#125;&quot;) private String driver; //数据库连接池配置 @Bean public DataSource dataSource()&#123; DruidDataSource dataSource = new DruidDataSource(); dataSource.setUsername(user); dataSource.setPassword(password); dataSource.setUrl(url); dataSource.setDriverClassName(driver); return dataSource; &#125; /** * 配置SqlSessionFactoryBean,指定连接池对象和外部配置文件即可 * @param dataSource 需要注入连接池对象 * @return 工厂Bean */ @Bean public SqlSessionFactoryBean sqlSessionFactoryBean(DataSource dataSource)&#123; //实例化SqlSessionFactory工厂 SqlSessionFactoryBean sqlSessionFactoryBean = new SqlSessionFactoryBean(); //设置连接池 sqlSessionFactoryBean.setDataSource(dataSource); //设置配置文件 //包裹外部配置文件地址对象 Resource resource = new ClassPathResource(&quot;mybatis-config.xml&quot;); sqlSessionFactoryBean.setConfigLocation(resource); return sqlSessionFactoryBean; &#125; /** * 配置Mapper实例扫描工厂,配置 &lt;mapper &lt;package 对应接口和mapperxml文件所在的包 * @return */ @Bean public MapperScannerConfigurer mapperScannerConfigurer()&#123; MapperScannerConfigurer mapperScannerConfigurer = new MapperScannerConfigurer(); //设置mapper接口和xml文件所在的共同包 mapperScannerConfigurer.setBasePackage(&quot;com.atguigu.mapper&quot;); return mapperScannerConfigurer; &#125; } 123456789101112131415161718192021222324252627282930313233343536373839404142 问题： 当你在Spring配置类中添加了`sqlSessionFactoryBean`和`mapperScannerConfigurer`配置方法时，可能会导致`@Value`注解读取不到值为null的问题。这是因为`SqlSessionFactoryBean`和`MapperScannerConfigurer`是基于MyBatis框架的配置，它们的初始化顺序可能会导致属性注入的问题。 `SqlSessionFactoryBean`和`MapperScannerConfigurer`在配置类中通常是用来配置MyBatis相关的Bean，例如数据源、事务管理器、Mapper扫描等。这些配置类通常在`@Configuration`注解下定义，并且使用`@Value`注解来注入属性值。 当配置类被加载时，Spring容器会首先处理Bean的定义和初始化，其中包括`sqlSessionFactoryBean`和`mapperScannerConfigurer`的初始化。在这个过程中，如果`@Value`注解所在的Bean还没有被完全初始化，可能会导致注入的属性值为null。 解决方案： 分成两个配置类独立配置，互不影响，数据库提取一个配置类，mybatis提取一个配置类即可解决！4. 拆分配置 数据库配置类（DataSourceJavaConfig.java） ```java @Configuration @PropertySource(&quot;classpath:jdbc.properties&quot;) public class DataSourceJavaConfig &#123; @Value(&quot;$&#123;jdbc.user&#125;&quot;) private String user; @Value(&quot;$&#123;jdbc.password&#125;&quot;) private String password; @Value(&quot;$&#123;jdbc.url&#125;&quot;) private String url; @Value(&quot;$&#123;jdbc.driver&#125;&quot;) private String driver; //数据库连接池配置 @Bean public DataSource dataSource()&#123; DruidDataSource dataSource = new DruidDataSource(); dataSource.setUsername(user); dataSource.setPassword(password); dataSource.setUrl(url); dataSource.setDriverClassName(driver); return dataSource; &#125; &#125; mybatis配置类（MapperJavaConfig.java） 12345678910111213141516171819202122232425262728293031323334353637@Configurationpublic class MapperJavaConfig &#123; /** * 配置SqlSessionFactoryBean,指定连接池对象和外部配置文件即可 * @param dataSource 需要注入连接池对象 * @return 工厂Bean */ @Bean public SqlSessionFactoryBean sqlSessionFactoryBean(DataSource dataSource)&#123; //实例化SqlSessionFactory工厂 SqlSessionFactoryBean sqlSessionFactoryBean = new SqlSessionFactoryBean(); //设置连接池 sqlSessionFactoryBean.setDataSource(dataSource); //设置配置文件 //包裹外部配置文件地址对象 Resource resource = new ClassPathResource(&quot;mybatis-config.xml&quot;); sqlSessionFactoryBean.setConfigLocation(resource); return sqlSessionFactoryBean; &#125; /** * 配置Mapper实例扫描工厂,配置 &lt;mapper &lt;package 对应接口和mapperxml文件所在的包 * @return */ @Bean public MapperScannerConfigurer mapperScannerConfigurer()&#123; MapperScannerConfigurer mapperScannerConfigurer = new MapperScannerConfigurer(); //设置mapper接口和xml文件所在的共同包 mapperScannerConfigurer.setBasePackage(&quot;com.atguigu.mapper&quot;); return mapperScannerConfigurer; &#125; &#125; 整合方式2（完全配置类 去掉mybatis-config.xml） 介绍 不在保留mybatis的外部配置文件（xml）, 所有配置信息（settings、插件、别名等）全部在声明SqlSessionFactoryBean的代码中指定！数据库信息依然使用DruidDataSource实例替代！ 优势：全部配置类，避免了XML文件解析效率低问题！ mapper配置类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687/** * projectName: com.atguigu.config * * description: 持久层配置和Druid和Mybatis配置 使用一个配置文件 */@Configurationpublic class MapperJavaConfigNew &#123; /** * 配置SqlSessionFactoryBean,指定连接池对象和外部配置文件即可 * @param dataSource 需要注入连接池对象 * @return 工厂Bean */ @Bean public SqlSessionFactoryBean sqlSessionFactoryBean(DataSource dataSource)&#123; //实例化SqlSessionFactory工厂 SqlSessionFactoryBean sqlSessionFactoryBean = new SqlSessionFactoryBean(); //设置连接池 sqlSessionFactoryBean.setDataSource(dataSource); //TODO: 替代xml文件的java配置 /* &lt;settings&gt; &lt;!-- 开启驼峰式映射--&gt; &lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;true&quot;/&gt; &lt;!-- 开启logback日志输出--&gt; &lt;setting name=&quot;logImpl&quot; value=&quot;SLF4J&quot;/&gt; &lt;!--开启resultMap自动映射 --&gt; &lt;setting name=&quot;autoMappingBehavior&quot; value=&quot;FULL&quot;/&gt; &lt;/settings&gt; &lt;typeAliases&gt; &lt;!-- 给实体类起别名 --&gt; &lt;package name=&quot;com.atguigu.pojo&quot;/&gt; &lt;/typeAliases&gt; &lt;plugins&gt; &lt;plugin interceptor=&quot;com.github.pagehelper.PageInterceptor&quot;&gt; &lt;!-- helperDialect：分页插件会自动检测当前的数据库链接，自动选择合适的分页方式。 你可以配置helperDialect属性来指定分页插件使用哪种方言。配置时，可以使用下面的缩写值： oracle,mysql,mariadb,sqlite,hsqldb,postgresql,db2,sqlserver,informix,h2,sqlserver2012,derby （完整内容看 PageAutoDialect） 特别注意：使用 SqlServer2012 数据库时， https://github.com/pagehelper/Mybatis-PageHelper/blob/master/wikis/zh/HowToUse.md#%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AE%E6%95%B0%E6%8D%AE%E5%BA%93%E6%96%B9%E8%A8%80 --&gt; &lt;property name=&quot;helperDialect&quot; value=&quot;mysql&quot;/&gt; &lt;/plugin&gt; &lt;/plugins&gt; */ //settings [包裹到一个configuration对象,切记别倒错包] org.apache.ibatis.session.Configuration configuration = new org.apache.ibatis.session.Configuration(); configuration.setMapUnderscoreToCamelCase(true); configuration.setLogImpl(Slf4jImpl.class); configuration.setAutoMappingBehavior(AutoMappingBehavior.FULL); sqlSessionFactoryBean.setConfiguration(configuration); //typeAliases sqlSessionFactoryBean.setTypeAliasesPackage(&quot;com.atguigu.pojo&quot;); //分页插件配置 PageInterceptor pageInterceptor = new PageInterceptor(); Properties properties = new Properties(); properties.setProperty(&quot;helperDialect&quot;,&quot;mysql&quot;); pageInterceptor.setProperties(properties); sqlSessionFactoryBean.addPlugins(pageInterceptor); return sqlSessionFactoryBean; &#125; /** * 配置Mapper实例扫描工厂,配置 &lt;mapper &lt;package 对应接口和mapperxml文件所在的包 * @return */ @Bean public MapperScannerConfigurer mapperScannerConfigurer()&#123; MapperScannerConfigurer mapperScannerConfigurer = new MapperScannerConfigurer(); //设置mapper接口和xml文件所在的共同包 mapperScannerConfigurer.setBasePackage(&quot;com.atguigu.mapper&quot;); return mapperScannerConfigurer; &#125;&#125; 2.5 容器初始化配置类1234567891011121314151617181920public class MyWebAppInitializer extends AbstractAnnotationConfigDispatcherServletInitializer &#123; //指定root容器对应的配置类 @Override protected Class&lt;?&gt;[] getRootConfigClasses() &#123; return new Class&lt;?&gt;[] &#123;MapperJavaConfig.class, ServiceJavaConfig.class, DataSourceJavaConfig.class &#125;; &#125; //指定web容器对应的配置类 @Override protected Class&lt;?&gt;[] getServletConfigClasses() &#123; return new Class&lt;?&gt;[] &#123; WebJavaConfig.class &#125;; &#125; //指定dispatcherServlet处理路径，通常为 / @Override protected String[] getServletMappings() &#123; return new String[] &#123; &quot;/&quot; &#125;; &#125;&#125; 2.6 整合测试 需求 查询所有员工信息,返回对应json数据！ controller 12345678910111213141516@Slf4j@RestController@RequestMapping(&quot;/employee&quot;)public class EmployeeController &#123; @Autowired private EmployeeService employeeService; @GetMapping(&quot;list&quot;) public List&lt;Employee&gt; retList()&#123; List&lt;Employee&gt; employees = employeeService.findAll(); log.info(&quot;员工数据:&#123;&#125;&quot;,employees); return employees; &#125;&#125; service&#x20; 12345678910111213141516@Servicepublic class EmployeeServiceImpl implements EmployeeService &#123; @Autowired private EmployeeMapper employeeMapper; /** * 查询所有员工信息 */ @Override public List&lt;Employee&gt; findAll() &#123; List&lt;Employee&gt; employeeList = employeeMapper.queryAll(); return employeeList; &#125;&#125; mapper mapper接口 包：com.atguigu.mapper&#x20; 12345public interface EmployeeMapper &#123; List&lt;Employee&gt; queryAll();&#125; mapper XML 文件位置： resources&#x2F;mappers 12345678910111213&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;https://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;!-- namespace等于mapper接口类的全限定名,这样实现对应 --&gt;&lt;mapper namespace=&quot;com.atguigu.mapper.EmployeeMapper&quot;&gt; &lt;select id=&quot;queryAll&quot; resultType=&quot;employee&quot;&gt; &lt;!-- #&#123;empId&#125;代表动态传入的参数,并且进行赋值!后面详细讲解 --&gt; select emp_id empId,emp_name empName, emp_salary empSalary from t_emp &lt;/select&gt;&lt;/mapper&gt; 三、《任务列表案例》前端程序搭建和运行3.1 整合案例介绍和接口分析3.1.1 案例功能预览 3.1.2接口分析 学习计划分页查询12345678910111213141516171819202122232425262728/* 需求说明 查询全部数据页数据请求uri schedule/&#123;pageSize&#125;/&#123;currentPage&#125;请求方式 get 响应的json &#123; &quot;code&quot;:200, &quot;flag&quot;:true, &quot;data&quot;:&#123; //本页数据 data: [ &#123;id:1,title:&#x27;学习java&#x27;,completed:true&#125;, &#123;id:2,title:&#x27;学习html&#x27;,completed:true&#125;, &#123;id:3,title:&#x27;学习css&#x27;,completed:true&#125;, &#123;id:4,title:&#x27;学习js&#x27;,completed:true&#125;, &#123;id:5,title:&#x27;学习vue&#x27;,completed:true&#125; ], //分页参数 pageSize:5, // 每页数据条数 页大小 total:0 , // 总记录数 currentPage:1 // 当前页码 &#125; &#125;*/ 学习计划删除1234567891011121314/* 需求说明 根据id删除日程请求uri schedule/&#123;id&#125;请求方式 delete响应的json &#123; &quot;code&quot;:200, &quot;flag&quot;:true, &quot;data&quot;:null &#125;*/ 学习计划保存12345678910111213141516171819/* 需求说明 增加日程请求uri schedule请求方式 post请求体中的JSON &#123; title: &#x27;&#x27;, completed: false &#125;响应的json &#123; &quot;code&quot;:200, &quot;flag&quot;:true, &quot;data&quot;:null &#125;*/ 学习计划修改1234567891011121314151617181920/* 需求说明 根据id修改数据请求uri schedule请求方式 put请求体中的JSON &#123; id: 1, title: &#x27;&#x27;, completed: false &#125;响应的json &#123; &quot;code&quot;:200, &quot;flag&quot;:true, &quot;data&quot;:null &#125;*/ 3.2 前端工程导入3.2.1 前端环境搭建 &#x20;Node.js 是前端程序运行的服务器，类似Java程序运行的服务器Tomcat Npm 是前端依赖包管理工具，类似maven依赖管理工具软件 node安装 课程node版本：16.16.0 https://nodejs.org/download/release/v16.16.0/ node安装和测试： 打开官网 https://nodejs.org/en/ 下载对应操作系统的 LTS 版本。（16.16.0） node-v16.16.0-x64.msi 双击安装包进行安装，安装过程中遵循默认选项即可。安装完成后，可以在命令行终端输入 node -v 和 npm -v 查看 Node.js 和 npm 的版本号。 npm使用 （maven） NPM全称Node Package Manager，是Node.js包管理工具，是全球最大的模块生态系统，里面所有的模块都是开源免费的；也是Node.js的包管理工具，相当于后端的Maven 。 配置阿里镜像1npm config set registry https://registry.npmjs.org/ 更新npm版本 node16.16.0对应的npm版本过低！需要升级！ 1npm install -g npm@9.6.6 npm依赖下载命令1npm install 依赖名 / npm install 依赖名@版本 安装vscode&#x20; VSCodeUserSetup-x64-1.74.0.exe 3.2.2 导入前端程序vue3-demo2.rar 点击加载前端程序！ 3.3 启动测试12npm install //安装依赖npm run dev //运行测试 四、《任务列表案例》后端程序实现和测试4.1 准备工作 准备数据库脚本 123456789101112131415161718192021222324252627282930CREATE TABLE schedule ( id INT NOT NULL AUTO_INCREMENT, title VARCHAR(255) NOT NULL, completed BOOLEAN NOT NULL, PRIMARY KEY (id));INSERT INTO schedule (title, completed)VALUES (&#x27;学习java&#x27;, true), (&#x27;学习Python&#x27;, false), (&#x27;学习C++&#x27;, true), (&#x27;学习JavaScript&#x27;, false), (&#x27;学习HTML5&#x27;, true), (&#x27;学习CSS3&#x27;, false), (&#x27;学习Vue.js&#x27;, true), (&#x27;学习React&#x27;, false), (&#x27;学习Angular&#x27;, true), (&#x27;学习Node.js&#x27;, false), (&#x27;学习Express&#x27;, true), (&#x27;学习Koa&#x27;, false), (&#x27;学习MongoDB&#x27;, true), (&#x27;学习MySQL&#x27;, false), (&#x27;学习Redis&#x27;, true), (&#x27;学习Git&#x27;, false), (&#x27;学习Docker&#x27;, true), (&#x27;学习Kubernetes&#x27;, false), (&#x27;学习AWS&#x27;, true), (&#x27;学习Azure&#x27;, false); 准备pojo 包：com.atguigu.pojo 12345678910111213/** * projectName: com.atguigu.pojo * * description: 任务实体类 */@Datapublic class Schedule &#123; private Integer id; private String title; private Boolean completed;&#125; 准备 R 包：com.atguigu.utils 123456789101112** * projectName: com.atguigu.utils * * description: 返回结果类 */public class R &#123; private int code = 200; //200成功状态码 private boolean flag = true; //返回状态 private Object data; //返回具体数据 public static R ok(Object data)&#123; R r = new R(); r.data = data; return r; &#125; public static R fail(Object data)&#123; R r = new R(); r.code = 500; //错误码 r.flag = false; //错误状态 r.data = data; return r; &#125; public int getCode() &#123; return code; &#125; public void setCode(int code) &#123; this.code = code; &#125; public boolean isFlag() &#123; return flag; &#125; public void setFlag(boolean flag) &#123; this.flag = flag; &#125; public Object getData() &#123; return data; &#125; public void setData(Object data) &#123; this.data = data; &#125; } 12345678910111213144. 准备 PageBean 包：com.atguigu.utils ```java @Data @NoArgsConstructor @AllArgsConstructor public class PageBean&lt;T&gt; &#123; private int currentPage; // 当前页码 private int pageSize; // 每页显示的数据量 private long total; // 总数据条数 private List&lt;T&gt; data; // 当前页的数据集合 &#125; 4.2 功能实现 分页查询 controller 123456789101112131415161718/* @CrossOrigin 注释在带注释的控制器方法上启用跨源请求 */@CrossOrigin@RequestMapping(&quot;schedule&quot;)@RestControllerpublic class ScheduleController&#123; @Autowired private ScheduleService scheduleService; @GetMapping(&quot;/&#123;pageSize&#125;/&#123;currentPage&#125;&quot;) public R showList(@PathVariable(name = &quot;pageSize&quot;) int pageSize, @PathVariable(name = &quot;currentPage&quot;) int currentPage)&#123; PageBean&lt;Schedule&gt; pageBean = scheduleService.findByPage(pageSize,currentPage); return R.ok(pageBean); &#125;&#125; service 12345678910111213141516171819202122232425262728293031@Slf4j@Servicepublic class ScheduleServiceImpl implements ScheduleService &#123; @Autowired private ScheduleMapper scheduleMapper; /** * 分页数据查询,返回分页pageBean * * @param pageSize * @param currentPage * @return */ @Override public PageBean&lt;Schedule&gt; findByPage(int pageSize, int currentPage) &#123; //1.设置分页参数 PageHelper.startPage(currentPage,pageSize); //2.数据库查询 List&lt;Schedule&gt; list = scheduleMapper.queryPage(); //3.结果获取 PageInfo&lt;Schedule&gt; pageInfo = new PageInfo&lt;&gt;(list); //4.pageBean封装 PageBean&lt;Schedule&gt; pageBean = new PageBean&lt;&gt;(pageInfo.getPageNum(),pageInfo.getPageSize(),pageInfo.getTotal(),pageInfo.getList()); log.info(&quot;分页查询结果:&#123;&#125;&quot;,pageBean); return pageBean; &#125;&#125; mapper mapper接口 1234public interface ScheduleMapper &#123; List&lt;Schedule&gt; queryPage();&#125; mapperxml文件 1234567891011&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;https://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;!-- namespace等于mapper接口类的全限定名,这样实现对应 --&gt;&lt;mapper namespace=&quot;com.atguigu.mapper.ScheduleMapper&quot;&gt; &lt;select id=&quot;queryPage&quot; resultType=&quot;schedule&quot;&gt; select * from schedule &lt;/select&gt;&lt;/mapper&gt; 计划添加 controller 12345@PostMappingpublic R saveSchedule(@RequestBody Schedule schedule)&#123; scheduleService.saveSchedule(schedule); return R.ok(null);&#125; service 123456789/** * 保存学习计划 * * @param schedule */@Overridepublic void saveSchedule(Schedule schedule) &#123; scheduleMapper.insert(schedule);&#125; mapper mapper接口 1void insert(Schedule schedule); mapperxml文件 12345&lt;insert id=&quot;insert&quot;&gt; insert into schedule (title, completed) values (#&#123;title&#125;, #&#123;completed&#125;);&lt;/insert&gt; 计划删除 controller12345@DeleteMapping(&quot;/&#123;id&#125;&quot;)public R removeSchedule(@PathVariable Integer id)&#123; scheduleService.removeById(id); return R.ok(null);&#125; service123456789/** * 移除学习计划 * * @param id */@Overridepublic void removeById(Integer id) &#123; scheduleMapper.delete(id);&#125; mappermapper接口1void delete(Integer id); mapperxml文件123&lt;delete id=&quot;delete&quot;&gt; delete from schedule where id = #&#123;id&#125;&lt;/delete&gt; 计划修改 controller12345@PutMapping public R changeSchedule(@RequestBody Schedule schedule)&#123; scheduleService.updateSchedule(schedule); return R.ok(null);&#125; service123456789/** * 更新学习计划 * * @param schedule */@Overridepublic void updateSchedule(Schedule schedule) &#123; scheduleMapper.update(schedule);&#125; mappermapper接口1void update(Schedule schedule); mapperxml文件1234&lt;update id=&quot;update&quot;&gt; update schedule set title = #&#123;title&#125; , completed = #&#123;completed&#125; where id = #&#123;id&#125;&lt;/update&gt; 4.3 前后联调 后台项目根路径设计 启动测试即可","categories":[{"name":"SSM框架","slug":"SSM框架","permalink":"http://example.com/categories/SSM%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"ssm","slug":"ssm","permalink":"http://example.com/tags/ssm/"}]},{"title":"四、SpringMVC实战：构建高效表述层框架","slug":"SSM/四、SpringMVC实战：构建高效表述层框架/四、SpringMVC实战：构建高效表述层框架","date":"2022-09-29T23:55:54.000Z","updated":"2023-09-28T00:31:22.144Z","comments":true,"path":"2022/09/30/SSM/四、SpringMVC实战：构建高效表述层框架/四、SpringMVC实战：构建高效表述层框架/","link":"","permalink":"http://example.com/2022/09/30/SSM/%E5%9B%9B%E3%80%81SpringMVC%E5%AE%9E%E6%88%98%EF%BC%9A%E6%9E%84%E5%BB%BA%E9%AB%98%E6%95%88%E8%A1%A8%E8%BF%B0%E5%B1%82%E6%A1%86%E6%9E%B6/%E5%9B%9B%E3%80%81SpringMVC%E5%AE%9E%E6%88%98%EF%BC%9A%E6%9E%84%E5%BB%BA%E9%AB%98%E6%95%88%E8%A1%A8%E8%BF%B0%E5%B1%82%E6%A1%86%E6%9E%B6/","excerpt":"","text":"四、SpringMVC实战：构建高效表述层框架目录 一、SpringMVC简介和体验 1.1 介绍 1.2 主要作用 1.3 核心组件和调用流程理解 1.4 快速体验 二、SpringMVC接收数据 2.1 访问路径设置 2.2 接收参数（重点） 2.2.1 param 和 json参数比较 2.2.2 param参数接收 2.2.3 路径 参数接收 2.2.4 json参数接收 2.3 接收Cookie数据 2.4 接收请求头数据 2.5 原生Api对象操作 2.6 共享域对象操作 2.6.1 属性（共享）域作用回顾 2.6.2 Request级别属性（共享）域 2.6.3 Session级别属性（共享）域 2.6.4 Application级别属性（共享）域 三、SpringMVC响应数据 3.1 handler方法分析 3.2 页面跳转控制 3.2.1 快速返回模板视图 3.2.2 转发和重定向 3.3 返回JSON数据（重点） 3.3.1 前置准备 3.3.2 @ResponseBody 3.3.3 @RestController 3.4 返回静态资源处理 四、RESTFul风格设计和实战 4.1 RESTFul风格概述 4.1.1 RESTFul风格简介 4.1.2 RESTFul风格特点 4.1.3 RESTFul风格设计规范 4.1.4 RESTFul风格好处 4.2 RESTFul风格实战 4.2.1 需求分析 4.2.2 RESTFul风格接口设计 4.2.3 后台接口实现 五、SpringMVC其他扩展 5.1 全局异常处理机制 5.1.1 异常处理两种方式 5.1.2 基于注解异常声明异常处理 5.2 拦截器使用 5.2.1 拦截器概念 5.2.2 拦截器使用 5.3 参数校验 六、SpringMVC总结 一、SpringMVC简介和体验1.1 介绍https://docs.spring.io/spring-framework/reference/web/webmvc.html Spring Web MVC是基于Servlet API构建的原始Web框架，从一开始就包含在Spring Framework中。正式名称“Spring Web MVC”来自其源模块的名称（ spring-webmvc ），但它通常被称为“Spring MVC”。 在控制层框架历经Strust、WebWork、Strust2等诸多产品的历代更迭之后，目前业界普遍选择了SpringMVC作为Java EE项目表述层开发的首选方案。之所以能做到这一点，是因为SpringMVC具备如下显著优势： Spring 家族原生产品，与IOC容器等基础设施无缝对接 表述层各细分领域需要解决的问题全方位覆盖，提供全面解决方案 代码清新简洁，大幅度提升开发效率 内部组件化程度高，可插拔式组件即插即用，想要什么功能配置相应组件即可 性能卓著，尤其适合现代大型、超大型互联网项目要求 原生Servlet API开发代码片段 123456protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; String userName = request.getParameter(&quot;userName&quot;); System.out.println(&quot;userName=&quot;+userName);&#125; 基于SpringMVC开发代码片段 12345678@RequestMapping(&quot;/user/login&quot;)public String login(@RequestParam(&quot;userName&quot;) String userName,Sting password)&#123; log.debug(&quot;userName=&quot;+userName); //调用业务即可 return &quot;result&quot;;&#125; 1.2 主要作用 SSM框架构建起单体项目的技术栈需求！其中的SpringMVC负责表述层（控制层）实现简化！ SpringMVC的作用主要覆盖的是表述层，例如： 请求映射 数据输入 视图界面 请求分发 表单回显 会话控制 过滤拦截 异步交互 文件上传 文件下载 数据校验 类型转换 等等等 最终总结： 简化前端参数接收( 形参列表 ) 简化后端数据响应(返回值) 以及其他…… 1.3 核心组件和调用流程理解Spring MVC与许多其他Web框架一样，是围绕前端控制器模式设计的，其中中央 Servlet DispatcherServlet 做整体请求处理调度！ 除了DispatcherServletSpringMVC还会提供其他特殊的组件协作完成请求处理和响应呈现。 SpringMVC处理请求流程： SpringMVC涉及组件理解： DispatcherServlet : SpringMVC提供，我们需要使用web.xml配置使其生效，它是整个流程处理的核心，所有请求都经过它的处理和分发！[ CEO ] HandlerMapping : SpringMVC提供，我们需要进行IoC配置使其加入IoC容器方可生效，它内部缓存handler(controller方法)和handler访问路径数据，被DispatcherServlet调用，用于查找路径对应的handler！[秘书] HandlerAdapter : SpringMVC提供，我们需要进行IoC配置使其加入IoC容器方可生效，它可以处理请求参数和处理响应数据数据，每次DispatcherServlet都是通过handlerAdapter间接调用handler，他是handler和DispatcherServlet之间的适配器！[经理] Handler : handler又称处理器，他是Controller类内部的方法简称，是由我们自己定义，用来接收参数，向后调用业务，最终返回响应结果！[打工人] ViewResovler : SpringMVC提供，我们需要进行IoC配置使其加入IoC容器方可生效！视图解析器主要作用简化模版视图页面查找的，但是需要注意，前后端分离项目，后端只返回JSON数据，不返回页面，那就不需要视图解析器！所以，视图解析器，相对其他的组件不是必须的！[财务] 1.4 快速体验 体验场景需求 配置分析 DispatcherServlet，设置处理所有请求！ HandlerMapping,HandlerAdapter,Handler需要加入到IoC容器，供DS调用！ Handler自己声明（Controller）需要配置到HandlerMapping中供DS查找！ 准备项目 创建项目 springmvc-base-quick 注意：需要转成maven&#x2F;web程序！！ 导入依赖 123456789101112131415161718192021222324252627282930313233343536373839&lt;properties&gt; &lt;spring.version&gt;6.0.6&lt;/spring.version&gt; &lt;servlet.api&gt;9.1.0&lt;/servlet.api&gt; &lt;maven.compiler.source&gt;17&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;17&lt;/maven.compiler.target&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;&lt;/properties&gt;&lt;dependencies&gt; &lt;!-- springioc相关依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- web相关依赖 --&gt; &lt;!-- 在 pom.xml 中引入 Jakarta EE Web API 的依赖 --&gt; &lt;!-- 在 Spring Web MVC 6 中，Servlet API 迁移到了 Jakarta EE API，因此在配置 DispatcherServlet 时需要使用 Jakarta EE 提供的相应类库和命名空间。错误信息 “‘org.springframework.web.servlet.DispatcherServlet’ is not assignable to ‘javax.servlet.Servlet,jakarta.servlet.Servlet’” 表明你使用了旧版本的 Servlet API，没有更新到 Jakarta EE 规范。 --&gt; &lt;dependency&gt; &lt;groupId&gt;jakarta.platform&lt;/groupId&gt; &lt;artifactId&gt;jakarta.jakartaee-web-api&lt;/artifactId&gt; &lt;version&gt;$&#123;servlet.api&#125;&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- springwebmvc相关依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; Controller声明 123456789101112131415161718@Controllerpublic class HelloController &#123; //handlers /** * handler就是controller内部的具体方法 * @RequestMapping(&quot;/springmvc/hello&quot;) 就是用来向handlerMapping中注册的方法注解! * @ResponseBody 代表向浏览器直接返回数据! */ @RequestMapping(&quot;/springmvc/hello&quot;) @ResponseBody public String hello()&#123; System.out.println(&quot;HelloController.hello&quot;); return &quot;hello springmvc!!&quot;; &#125;&#125; Spring MVC核心组件配置类 声明springmvc涉及组件信息的配置类 123456789101112131415161718192021222324//TODO: SpringMVC对应组件的配置类 [声明SpringMVC需要的组件信息]//TODO: 导入handlerMapping和handlerAdapter的三种方式 //1.自动导入handlerMapping和handlerAdapter [推荐] //2.可以不添加,springmvc会检查是否配置handlerMapping和handlerAdapter,没有配置默认加载 //3.使用@Bean方式配置handlerMapper和handlerAdapter@EnableWebMvc @Configuration@ComponentScan(basePackages = &quot;com.atguigu.controller&quot;) //TODO: 进行controller扫//WebMvcConfigurer springMvc进行组件配置的规范,配置组件,提供各种方法! 前期可以实现public class SpringMvcConfig implements WebMvcConfigurer &#123; @Bean public HandlerMapping handlerMapping()&#123; return new RequestMappingHandlerMapping(); &#125; @Bean public HandlerAdapter handlerAdapter()&#123; return new RequestMappingHandlerAdapter(); &#125; &#125; SpringMVC环境搭建 对于使用基于 Java 的 Spring 配置的应用程序，建议这样做，如以下示例所示： 12345678910111213141516171819202122232425262728293031//TODO: SpringMVC提供的接口,是替代web.xml的方案,更方便实现完全注解方式ssm处理!//TODO: Springmvc框架会自动检查当前类的实现类,会自动加载 getRootConfigClasses / getServletConfigClasses 提供的配置类//TODO: getServletMappings 返回的地址 设置DispatherServlet对应处理的地址public class MyWebAppInitializer extends AbstractAnnotationConfigDispatcherServletInitializer &#123; /** * 指定service / mapper层的配置类 */ @Override protected Class&lt;?&gt;[] getRootConfigClasses() &#123; return null; &#125; /** * 指定springmvc的配置类 * @return */ @Override protected Class&lt;?&gt;[] getServletConfigClasses() &#123; return new Class&lt;?&gt;[] &#123; SpringMvcConfig.class &#125;; &#125; /** * 设置dispatcherServlet的处理路径! * 一般情况下为 / 代表处理所有请求! */ @Override protected String[] getServletMappings() &#123; return new String[] &#123; &quot;/&quot; &#125;; &#125;&#125; 启动测试 注意： tomcat应该是10+版本！方可支持 Jakarta EE API! 二、SpringMVC接收数据2.1 访问路径设置@RequestMapping注解的作用就是将请求的 URL 地址和处理请求的方式（handler方法）关联起来，建立映射关系。 SpringMVC 接收到指定的请求，就会来找到在映射关系中对应的方法来处理这个请求。 精准路径匹配 在@RequestMapping注解指定 URL 地址时，不使用任何通配符，按照请求地址进行精确匹配。 12345678910111213141516171819202122232425@Controllerpublic class UserController &#123; /** * 精准设置访问地址 /user/login */ @RequestMapping(value = &#123;&quot;/user/login&quot;&#125;) @ResponseBody public String login()&#123; System.out.println(&quot;UserController.login&quot;); return &quot;login success!!&quot;; &#125; /** * 精准设置访问地址 /user/register */ @RequestMapping(value = &#123;&quot;/user/register&quot;&#125;) @ResponseBody public String register()&#123; System.out.println(&quot;UserController.register&quot;); return &quot;register success!!&quot;; &#125; &#125; 模糊路径匹配 在@RequestMapping注解指定 URL 地址时，通过使用通配符，匹配多个类似的地址。 12345678910111213141516171819@Controllerpublic class ProductController &#123; /** * 路径设置为 /product/* * /* 为单层任意字符串 /product/a /product/aaa 可以访问此handler * /product/a/a 不可以 * 路径设置为 /product/** * /** 为任意层任意字符串 /product/a /product/aaa 可以访问此handler * /product/a/a 也可以访问 */ @RequestMapping(&quot;/product/*&quot;) @ResponseBody public String show()&#123; System.out.println(&quot;ProductController.show&quot;); return &quot;product show!&quot;; &#125;&#125; 12345单层匹配和多层匹配： /*：只能匹配URL地址中的一层，如果想准确匹配两层，那么就写“/*/*”以此类推。 /**：可以匹配URL地址中的多层。其中所谓的一层或多层是指一个URL地址字符串被“/”划分出来的各个层次这个知识点虽然对于@RequestMapping注解来说实用性不大，但是将来配置拦截器的时候也遵循这个规则。 类和方法级别区别 @RequestMapping 注解可以用于类级别和方法级别，它们之间的区别如下： 设置到类级别：@RequestMapping 注解可以设置在控制器类上，用于映射整个控制器的通用请求路径。这样，如果控制器中的多个方法都需要映射同一请求路径，就不需要在每个方法上都添加映射路径。 设置到方法级别：@RequestMapping 注解也可以单独设置在控制器方法上，用于更细粒度地映射请求路径和处理方法。当多个方法处理同一个路径的不同操作时，可以使用方法级别的 @RequestMapping 注解进行更精细的映射。12345678910111213//1.标记到handler方法@RequestMapping(&quot;/user/login&quot;)@RequestMapping(&quot;/user/register&quot;)@RequestMapping(&quot;/user/logout&quot;)//2.优化标记类+handler方法//类上@RequestMapping(&quot;/user&quot;)//handler方法上@RequestMapping(&quot;/login&quot;)@RequestMapping(&quot;/register&quot;)@RequestMapping(&quot;/logout&quot;) 附带请求方式限制 HTTP 协议定义了八种请求方式，在 SpringMVC 中封装到了下面这个枚举类： 123public enum RequestMethod &#123; GET, HEAD, POST, PUT, PATCH, DELETE, OPTIONS, TRACE&#125; 默认情况下：@RequestMapping(“&#x2F;logout”) 任何请求方式都可以访问！ 如果需要特定指定： 1234567891011121314151617181920212223242526@Controllerpublic class UserController &#123; /** * 精准设置访问地址 /user/login * method = RequestMethod.POST 可以指定单个或者多个请求方式! * 注意:违背请求方式会出现405异常! */ @RequestMapping(value = &#123;&quot;/user/login&quot;&#125; , method = RequestMethod.POST) @ResponseBody public String login()&#123; System.out.println(&quot;UserController.login&quot;); return &quot;login success!!&quot;; &#125; /** * 精准设置访问地址 /user/register */ @RequestMapping(value = &#123;&quot;/user/register&quot;&#125;,method = &#123;RequestMethod.POST,RequestMethod.GET&#125;) @ResponseBody public String register()&#123; System.out.println(&quot;UserController.register&quot;); return &quot;register success!!&quot;; &#125;&#125; 注意：违背请求方式，会出现405异常！！！ 进阶注解 还有 @RequestMapping 的 HTTP 方法特定快捷方式变体： @GetMapping @PostMapping @PutMapping @DeleteMapping @PatchMapping123@RequestMapping(value=&quot;/login&quot;,method=RequestMethod.GET)||@GetMapping(value=&quot;/login&quot;) 注意：进阶注解只能添加到handler方法上，无法添加到类上！ 常见配置问题 出现原因：多个 handler 方法映射了同一个地址，导致 SpringMVC 在接收到这个地址的请求时该找哪个 handler 方法处理。 There is already ‘demo03MappingMethodHandler’ bean method com.atguigu.mvc.handler.Demo03MappingMethodHandler#empGet() mapped. 2.2 接收参数（重点）2.2.1 param 和 json参数比较在 HTTP 请求中，我们可以选择不同的参数类型，如 param 类型和 JSON 类型。下面对这两种参数类型进行区别和对比： 参数编码： &#x20; param 类型的参数会被编码为 ASCII 码。例如，假设 name=john doe，则会被编码为 name=john%20doe。而 JSON 类型的参数会被编码为 UTF-8。 参数顺序： &#x20; param 类型的参数没有顺序限制。但是，JSON 类型的参数是有序的。JSON 采用键值对的形式进行传递，其中键值对是有序排列的。 数据类型： &#x20; param 类型的参数仅支持字符串类型、数值类型和布尔类型等简单数据类型。而 JSON 类型的参数则支持更复杂的数据类型，如数组、对象等。 嵌套性： &#x20; param 类型的参数不支持嵌套。但是，JSON 类型的参数支持嵌套，可以传递更为复杂的数据结构。 可读性： &#x20; param 类型的参数格式比 JSON 类型的参数更加简单、易读。但是，JSON 格式在传递嵌套数据结构时更加清晰易懂。 总的来说，param 类型的参数适用于单一的数据传递，而 JSON 类型的参数则更适用于更复杂的数据结构传递。根据具体的业务需求，需要选择合适的参数类型。在实际开发中，常见的做法是：在 GET 请求中采用 param 类型的参数，而在 POST 请求中采用 JSON 类型的参数传递。 2.2.2 param参数接收 直接接值 客户端请求 handler接收参数 只要形参数名和类型与传递参数相同，即可自动接收! 1234567891011121314151617181920@Controller@RequestMapping(&quot;param&quot;)public class ParamController &#123; /** * 前端请求: http://localhost:8080/param/value?name=xx&amp;age=18 * * 可以利用形参列表,直接接收前端传递的param参数! * 要求: 参数名 = 形参名 * 类型相同 * 出现乱码正常，json接收具体解决！！ * @return 返回前端数据 */ @GetMapping(value=&quot;/value&quot;) @ResponseBody public String setupForm(String name,int age)&#123; System.out.println(&quot;name = &quot; + name + &quot;, age = &quot; + age); return name + age; &#125;&#125; @RequestParam注解 可以使用 @RequestParam 注释将 Servlet 请求参数（即查询参数或表单数据）绑定到控制器中的方法参数。 @RequestParam使用场景： 指定绑定的请求参数名 要求请求参数必须传递 为请求参数提供默认值基本用法：12345678910111213 /** * 前端请求: http://localhost:8080/param/data?name=xx&amp;stuAge=18 * * 使用@RequestParam注解标记handler方法的形参 * 指定形参对应的请求参数@RequestParam(请求参数名称) */@GetMapping(value=&quot;/data&quot;)@ResponseBodypublic Object paramForm(@RequestParam(&quot;name&quot;) String name, @RequestParam(&quot;stuAge&quot;) int age)&#123; System.out.println(&quot;name = &quot; + name + &quot;, age = &quot; + age); return name+age;&#125; 默认情况下，使用此批注的方法参数是必需的，但您可以通过将 @RequestParam 批注的 required 标志设置为 false！ 如果没有没有设置非必须，也没有传递参数会出现： 将参数设置非必须，并且设置默认值： 12345678@GetMapping(value=&quot;/data&quot;)@ResponseBodypublic Object paramForm(@RequestParam(&quot;name&quot;) String name, @RequestParam(value = &quot;stuAge&quot;,required = false,defaultValue = &quot;18&quot;) int age)&#123; System.out.println(&quot;name = &quot; + name + &quot;, age = &quot; + age); return name+age;&#125; 特殊场景接值 一名多值 多选框，提交的数据的时候一个key对应多个值，我们可以使用集合进行接收！ 1234567891011/** * 前端请求: http://localhost:8080/param/mul?hbs=吃&amp;hbs=喝 * * 一名多值,可以使用集合接收即可!但是需要使用@RequestParam注解指定 */@GetMapping(value=&quot;/mul&quot;)@ResponseBodypublic Object mulForm(@RequestParam List&lt;String&gt; hbs)&#123; System.out.println(&quot;hbs = &quot; + hbs); return hbs;&#125; 实体接收 Spring MVC 是 Spring 框架提供的 Web 框架，它允许开发者使用实体对象来接收 HTTP 请求中的参数。通过这种方式，可以在方法内部直接使用对象的属性来访问请求参数，而不需要每个参数都写一遍。下面是一个使用实体对象接收参数的示例： 定义一个用于接收参数的实体类： 12345678public class User &#123; private String name; private int age = 18; // getter 和 setter 略&#125; 在控制器中，使用实体对象接收，示例代码如下： 123456789101112@Controller@RequestMapping(&quot;param&quot;)public class ParamController &#123; @RequestMapping(value = &quot;/user&quot;, method = RequestMethod.POST) @ResponseBody public String addUser(User user) &#123; // 在这里可以使用 user 对象的属性来接收请求参数 System.out.println(&quot;user = &quot; + user); return &quot;success&quot;; &#125;&#125; 在上述代码中，将请求参数name和age映射到实体类属性上！要求属性名必须等于参数名！否则无法映射！ 使用postman传递参数测试： 2.2.3 路径 参数接收路径传递参数是一种在 URL 路径中传递参数的方式。在 RESTful 的 Web 应用程序中，经常使用路径传递参数来表示资源的唯一标识符或更复杂的表示方式。而 Spring MVC 框架提供了 @PathVariable 注解来处理路径传递参数。 @PathVariable 注解允许将 URL 中的占位符映射到控制器方法中的参数。 例如，如果我们想将 /user/&#123;id&#125; 路径下的 &#123;id&#125; 映射到控制器方法的一个参数中，则可以使用 @PathVariable 注解来实现。 下面是一个使用 @PathVariable 注解处理路径传递参数的示例： 1234567891011121314 /** * 动态路径设计: /user/&#123;动态部分&#125;/&#123;动态部分&#125; 动态部分使用&#123;&#125;包含即可! &#123;&#125;内部动态标识! * 形参列表取值: @PathVariable Long id 如果形参名 = &#123;动态标识&#125; 自动赋值! * @PathVariable(&quot;动态标识&quot;) Long id 如果形参名 != &#123;动态标识&#125; 可以通过指定动态标识赋值! * * 访问测试: /param/user/1/root -&gt; id = 1 uname = root */@GetMapping(&quot;/user/&#123;id&#125;/&#123;name&#125;&quot;)@ResponseBodypublic String getUser(@PathVariable Long id, @PathVariable(&quot;name&quot;) String uname) &#123; System.out.println(&quot;id = &quot; + id + &quot;, uname = &quot; + uname); return &quot;user_detail&quot;;&#125; 2.2.4 json参数接收前端传递 JSON 数据时，Spring MVC 框架可以使用 @RequestBody 注解来将 JSON 数据转换为 Java 对象。@RequestBody 注解表示当前方法参数的值应该从请求体中获取，并且需要指定 value 属性来指示请求体应该映射到哪个参数上。其使用方式和示例代码如下： 前端发送 JSON 数据的示例：（使用postman测试） 12345&#123; &quot;name&quot;: &quot;张三&quot;, &quot;age&quot;: 18, &quot;gender&quot;: &quot;男&quot;&#125; 定义一个用于接收 JSON 数据的 Java 类，例如： 123456public class Person &#123; private String name; private int age; private String gender; // getter 和 setter 略&#125; 在控制器中，使用 @RequestBody 注解来接收 JSON 数据，并将其转换为 Java 对象，例如： 1234567@PostMapping(&quot;/person&quot;)@ResponseBodypublic String addPerson(@RequestBody Person person) &#123; // 在这里可以使用 person 对象来操作 JSON 数据中包含的属性 return &quot;success&quot;;&#125; 在上述代码中，@RequestBody 注解将请求体中的 JSON 数据映射到 Person 类型的 person 参数上，并将其作为一个对象来传递给 addPerson() 方法进行处理。 完善配置 测试： 问题： org.springframework.web.HttpMediaTypeNotSupportedException: Content-Type ‘application&#x2F;json;charset&#x3D;UTF-8’ is not supported] 原因： 不支持json数据类型处理 没有json类型处理的工具（jackson）解决：springmvc handlerAdpater配置json转化器,配置类需要明确：123456789101112//TODO: SpringMVC对应组件的配置类 [声明SpringMVC需要的组件信息]//TODO: 导入handlerMapping和handlerAdapter的三种方式 //1.自动导入handlerMapping和handlerAdapter [推荐] //2.可以不添加,springmvc会检查是否配置handlerMapping和handlerAdapter,没有配置默认加载 //3.使用@Bean方式配置handlerMapper和handlerAdapter@EnableWebMvc //json数据处理,必须使用此注解,因为他会加入json处理器@Configuration@ComponentScan(basePackages = &quot;com.atguigu.controller&quot;) //TODO: 进行controller扫描//WebMvcConfigurer springMvc进行组件配置的规范,配置组件,提供各种方法! 前期可以实现public class SpringMvcConfig implements WebMvcConfigurer &#123; } 1234567pom.xml 加入jackson依赖```xml&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.15.0&lt;/version&gt;&lt;/dependency&gt; @EnableWebMvc注解说明 @EnableWebMvc注解效果等同于在 XML 配置中，可以使用 &lt;mvc:annotation-driven&gt; 元素！我们来解析&lt;mvc:annotation-driven&gt;对应的解析工作！ 让我们来查看下&lt;mvc:annotation-driven&gt;具体的动作！ 先查看&lt;mvc:annotation-driven&gt;标签最终对应解析的Java类 查看解析类中具体的动作即可 打开源码：org.springframework.web.servlet.config.MvcNamespaceHandler 打开源码：org.springframework.web.servlet.config.AnnotationDrivenBeanDefinitionParser 123456789101112131415161718class AnnotationDrivenBeanDefinitionParser implements BeanDefinitionParser &#123; public static final String HANDLER_MAPPING_BEAN_NAME = RequestMappingHandlerMapping.class.getName(); public static final String HANDLER_ADAPTER_BEAN_NAME = RequestMappingHandlerAdapter.class.getName(); static &#123; ClassLoader classLoader = AnnotationDrivenBeanDefinitionParser.class.getClassLoader(); javaxValidationPresent = ClassUtils.isPresent(&quot;jakarta.validation.Validator&quot;, classLoader); romePresent = ClassUtils.isPresent(&quot;com.rometools.rome.feed.WireFeed&quot;, classLoader); jaxb2Present = ClassUtils.isPresent(&quot;jakarta.xml.bind.Binder&quot;, classLoader); jackson2Present = ClassUtils.isPresent(&quot;com.fasterxml.jackson.databind.ObjectMapper&quot;, classLoader) &amp;&amp; ClassUtils.isPresent(&quot;com.fasterxml.jackson.core.JsonGenerator&quot;, classLoader); jackson2XmlPresent = ClassUtils.isPresent(&quot;com.fasterxml.jackson.dataformat.xml.XmlMapper&quot;, classLoader); jackson2SmilePresent = ClassUtils.isPresent(&quot;com.fasterxml.jackson.dataformat.smile.SmileFactory&quot;, classLoader); jackson2CborPresent = ClassUtils.isPresent(&quot;com.fasterxml.jackson.dataformat.cbor.CBORFactory&quot;, classLoader); gsonPresent = ClassUtils.isPresent(&quot;com.google.gson.Gson&quot;, classLoader); &#125; @Override @Nullable public BeanDefinition parse(Element element, ParserContext context) &#123; //handlerMapping加入到ioc容器 readerContext.getRegistry().registerBeanDefinition(HANDLER_MAPPING_BEAN_NAME, handlerMappingDef); //添加jackson转化器 addRequestBodyAdvice(handlerAdapterDef); addResponseBodyAdvice(handlerAdapterDef); //handlerAdapter加入到ioc容器 readerContext.getRegistry().registerBeanDefinition(HANDLER_ADAPTER_BEAN_NAME, handlerAdapterDef); return null; &#125; //具体添加jackson转化对象方法 protected void addRequestBodyAdvice(RootBeanDefinition beanDef) &#123; if (jackson2Present) &#123; beanDef.getPropertyValues().add(&quot;requestBodyAdvice&quot;, new RootBeanDefinition(JsonViewRequestBodyAdvice.class)); &#125; &#125; protected void addResponseBodyAdvice(RootBeanDefinition beanDef) &#123; if (jackson2Present) &#123; beanDef.getPropertyValues().add(&quot;responseBodyAdvice&quot;, new RootBeanDefinition(JsonViewResponseBodyAdvice.class)); &#125; &#125; 123456789### 2.3 接收Cookie数据可以使用 `@CookieValue` 注释将 HTTP Cookie 的值绑定到控制器中的方法参数。考虑使用以下 cookie 的请求：```javaJSESSIONID=415A4AC178C59DACE0B2C9CA727CDD84 下面的示例演示如何获取 cookie 值： 1234@GetMapping(&quot;/demo&quot;)public void handle(@CookieValue(&quot;JSESSIONID&quot;) String cookie) &#123; //...&#125; 2.4 接收请求头数据可以使用 @RequestHeader 批注将请求标头绑定到控制器中的方法参数。 请考虑以下带有标头的请求： 123456Host localhost:8080Accept text/html,application/xhtml+xml,application/xml;q=0.9Accept-Language fr,en-gb;q=0.7,en;q=0.3Accept-Encoding gzip,deflateAccept-Charset ISO-8859-1,utf-8;q=0.7,*;q=0.7Keep-Alive 300 下面的示例获取 Accept-Encoding 和 Keep-Alive 标头的值： 123456@GetMapping(&quot;/demo&quot;)public void handle( @RequestHeader(&quot;Accept-Encoding&quot;) String encoding, @RequestHeader(&quot;Keep-Alive&quot;) long keepAlive) &#123; //...&#125; 2.5 原生Api对象操作https://docs.spring.io/spring-framework/reference/web/webmvc/mvc-controller/ann-methods/arguments.html 下表描述了支持的控制器方法参数 Controller method argument 控制器方法参数 Description jakarta.servlet.ServletRequest, jakarta.servlet.ServletResponse 请求&#x2F;响应对象 jakarta.servlet.http.HttpSession 强制存在会话。因此，这样的参数永远不会为 null 。 java.io.InputStream, java.io.Reader 用于访问由 Servlet API 公开的原始请求正文。 java.io.OutputStream, java.io.Writer 用于访问由 Servlet API 公开的原始响应正文。 @PathVariable 接收路径参数注解 @RequestParam 用于访问 Servlet 请求参数，包括多部分文件。参数值将转换为声明的方法参数类型。 @RequestHeader 用于访问请求标头。标头值将转换为声明的方法参数类型。 @CookieValue 用于访问Cookie。Cookie 值将转换为声明的方法参数类型。 @RequestBody 用于访问 HTTP 请求正文。正文内容通过使用 HttpMessageConverter 实现转换为声明的方法参数类型。 java.util.Map, org.springframework.ui.Model, org.springframework.ui.ModelMap 共享域对象，并在视图呈现过程中向模板公开。 Errors, BindingResult 验证和数据绑定中的错误信息获取对象！ 获取原生对象示例： 123456789101112/** * 如果想要获取请求或者响应对象,或者会话等,可以直接在形参列表传入,并且不分先后顺序! * 注意: 接收原生对象,并不影响参数接收! */@GetMapping(&quot;api&quot;)@ResponseBodypublic String api(HttpSession session , HttpServletRequest request, HttpServletResponse response)&#123; String method = request.getMethod(); System.out.println(&quot;method = &quot; + method); return &quot;api&quot;;&#125; 2.6 共享域对象操作2.6.1 属性（共享）域作用回顾在 JavaWeb 中，共享域指的是在 Servlet 中存储数据，以便在同一 Web 应用程序的多个组件中进行共享和访问。常见的共享域有四种：ServletContext、HttpSession、HttpServletRequest、PageContext。 ServletContext 共享域：ServletContext 对象可以在整个 Web 应用程序中共享数据，是最大的共享域。一般可以用于保存整个 Web 应用程序的全局配置信息，以及所有用户都共享的数据。在 ServletContext 中保存的数据是线程安全的。 HttpSession 共享域：HttpSession 对象可以在同一用户发出的多个请求之间共享数据，但只能在同一个会话中使用。比如，可以将用户登录状态保存在 HttpSession 中，让用户在多个页面间保持登录状态。 HttpServletRequest 共享域：HttpServletRequest 对象可以在同一个请求的多个处理器方法之间共享数据。比如，可以将请求的参数和属性存储在 HttpServletRequest 中，让处理器方法之间可以访问这些数据。 PageContext 共享域：PageContext 对象是在 JSP 页面Servlet 创建时自动创建的。它可以在 JSP 的各个作用域中共享数据，包括pageScope、requestScope、sessionScope、applicationScope 等作用域。 共享域的作用是提供了方便实用的方式在同一 Web 应用程序的多个组件之间传递数据，并且可以将数据保存在不同的共享域中，根据需要进行选择和使用。 2.6.2 Request级别属性（共享）域 使用 Model 类型的形参12345678910111213@RequestMapping(&quot;/attr/request/model&quot;)@ResponseBodypublic String testAttrRequestModel( // 在形参位置声明Model类型变量，用于存储模型数据 Model model) &#123; // 我们将数据存入模型，SpringMVC 会帮我们把模型数据存入请求域 // 存入请求域这个动作也被称为暴露到请求域 model.addAttribute(&quot;requestScopeMessageModel&quot;,&quot;i am very happy[model]&quot;); return &quot;target&quot;;&#125; 使用 ModelMap 类型的形参12345678910111213@RequestMapping(&quot;/attr/request/model/map&quot;)@ResponseBodypublic String testAttrRequestModelMap( // 在形参位置声明ModelMap类型变量，用于存储模型数据 ModelMap modelMap) &#123; // 我们将数据存入模型，SpringMVC 会帮我们把模型数据存入请求域 // 存入请求域这个动作也被称为暴露到请求域 modelMap.addAttribute(&quot;requestScopeMessageModelMap&quot;,&quot;i am very happy[model map]&quot;); return &quot;target&quot;;&#125; 使用 Map 类型的形参12345678910111213@RequestMapping(&quot;/attr/request/map&quot;)@ResponseBodypublic String testAttrRequestMap( // 在形参位置声明Map类型变量，用于存储模型数据 Map&lt;String, Object&gt; map) &#123; // 我们将数据存入模型，SpringMVC 会帮我们把模型数据存入请求域 // 存入请求域这个动作也被称为暴露到请求域 map.put(&quot;requestScopeMessageMap&quot;, &quot;i am very happy[map]&quot;); return &quot;target&quot;;&#125; 使用原生 request 对象1234567891011@RequestMapping(&quot;/attr/request/original&quot;)@ResponseBodypublic String testAttrOriginalRequest( // 拿到原生对象，就可以调用原生方法执行各种操作 HttpServletRequest request) &#123; request.setAttribute(&quot;requestScopeMessageOriginal&quot;, &quot;i am very happy[original]&quot;); return &quot;target&quot;;&#125; 使用 ModelAndView 对象123456789101112@RequestMapping(&quot;/attr/request/mav&quot;)public ModelAndView testAttrByModelAndView() &#123; // 1.创建ModelAndView对象 ModelAndView modelAndView = new ModelAndView(); // 2.存入模型数据 modelAndView.addObject(&quot;requestScopeMessageMAV&quot;, &quot;i am very happy[mav]&quot;); // 3.设置视图名称 modelAndView.setViewName(&quot;target&quot;); return modelAndView;&#125; 2.6.3 Session级别属性（共享）域123456@RequestMapping(&quot;/attr/session&quot;)@ResponseBodypublic String testAttrSession(HttpSession session) &#123; //直接对session对象操作,即对会话范围操作! return &quot;target&quot;;&#125; 2.6.4 Application级别属性（共享）域解释：springmvc会在初始化容器的时候，讲servletContext对象存储到ioc容器中！ 1234567891011@Autowiredprivate ServletContext servletContext;@RequestMapping(&quot;/attr/application&quot;)@ResponseBodypublic String attrApplication() &#123; servletContext.setAttribute(&quot;appScopeMsg&quot;, &quot;i am hungry...&quot;); return &quot;target&quot;;&#125; 三、SpringMVC响应数据3.1 handler方法分析理解handler方法的作用和组成： 123456789101112131415161718/** * TODO: 一个controller的方法是控制层的一个处理器,我们称为handler * TODO: handler需要使用@RequestMapping/@GetMapping系列,声明路径,在HandlerMapping中注册,供DS查找! * TODO: handler作用总结: * 1.接收请求参数(param,json,pathVariable,共享域等) * 2.调用业务逻辑 * 3.响应前端数据(页面（不讲解模版页面跳转）,json,转发和重定向等) * TODO: handler如何处理呢 * 1.接收参数: handler(形参列表: 主要的作用就是用来接收参数) * 2.调用业务: &#123; 方法体 可以向后调用业务方法 service.xx() &#125; * 3.响应数据: return 返回结果,可以快速响应前端数据 */@GetMappingpublic Object handler(简化请求参数接收)&#123; 调用业务方法 返回的结果 （页面跳转，返回数据（json）） return 简化响应前端数据;&#125; 总结： 请求数据接收，我们都是通过handler的形参列表 &#x20; 前端数据响应，我们都是通过handler的return关键字快速处理！ &#x20; springmvc简化了参数接收和响应！ 3.2 页面跳转控制3.2.1 快速返回模板视图 开发模式回顾 在 Web 开发中，有两种主要的开发模式：前后端分离和混合开发。 前后端分离模式：[重点] 指将前端的界面和后端的业务逻辑通过接口分离开发的一种方式。开发人员使用不同的技术栈和框架，前端开发人员主要负责页面的呈现和用户交互，后端开发人员主要负责业务逻辑和数据存储。前后端通信通过 API 接口完成，数据格式一般使用 JSON 或 XML。前后端分离模式可以提高开发效率，同时也有助于代码重用和维护。 混合开发模式： 指将前端和后端的代码集成在同一个项目中，共享相同的技术栈和框架。这种模式在小型项目中比较常见，可以减少学习成本和部署难度。但是，在大型项目中，这种模式会导致代码耦合性很高，维护和升级难度较大。 对于混合开发，我们就需要使用动态页面技术，动态展示Java的共享域数据！！ jsp技术了解 JSP（JavaServer Pages）是一种动态网页开发技术，它是由 Sun 公司提出的一种基于 Java 技术的 Web 页面制作技术，可以在 HTML 文件中嵌入 Java 代码，使得生成动态内容的编写更加简单。 JSP 最主要的作用是生成动态页面。它允许将 Java 代码嵌入到 HTML 页面中，以便使用 Java 进行数据库查询、处理表单数据和生成 HTML 等动态内容。另外，JSP 还可以与 Servlet 结合使用，实现更加复杂的 Web 应用程序开发。 JSP 的主要特点包括： 简单：JSP 通过将 Java 代码嵌入到 HTML 页面中，使得生成动态内容的编写更加简单。 高效：JSP 首次运行时会被转换为 Servlet，然后编译为字节码，从而可以启用 Just-in-Time（JIT）编译器，实现更高效的运行。 多样化：JSP 支持多种标准标签库，包括 JSTL（JavaServer Pages 标准标签库）、EL（表达式语言）等，可以帮助开发人员更加方便的处理常见的 Web 开发需求。总之，JSP 是一种简单高效、多样化的动态网页开发技术，它可以方便地生成动态页面和与 Servlet 结合使用，是 Java Web 开发中常用的技术之一。 准备jsp页面和依赖 pom.xml依赖 123456&lt;!-- jsp需要依赖! jstl--&gt;&lt;dependency&gt; &lt;groupId&gt;jakarta.servlet.jsp.jstl&lt;/groupId&gt; &lt;artifactId&gt;jakarta.servlet.jsp.jstl-api&lt;/artifactId&gt; &lt;version&gt;3.0.0&lt;/version&gt;&lt;/dependency&gt; jsp页面创建 建议位置：&#x2F;WEB-INF&#x2F;下，避免外部直接访问！ 位置：&#x2F;WEB-INF&#x2F;views&#x2F;home.jsp 1234567891011&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 可以获取共享域的数据,动态展示! jsp== 后台vue --&gt; $&#123;msg&#125; &lt;/body&gt;&lt;/html&gt; 快速响应模版页面 配置jsp视图解析器1234567891011121314@EnableWebMvc //json数据处理,必须使用此注解,因为他会加入json处理器@Configuration@ComponentScan(basePackages = &quot;com.atguigu.controller&quot;) //TODO: 进行controller扫描//WebMvcConfigurer springMvc进行组件配置的规范,配置组件,提供各种方法! 前期可以实现public class SpringMvcConfig implements WebMvcConfigurer &#123; //配置jsp对应的视图解析器 @Override public void configureViewResolvers(ViewResolverRegistry registry) &#123; //快速配置jsp模板语言对应的 registry.jsp(&quot;/WEB-INF/views/&quot;,&quot;.jsp&quot;); &#125;&#125; handler返回视图12345678910111213141516/** * 跳转到提交文件页面 /save/jump * * 如果要返回jsp页面! * 1.方法返回值改成字符串类型 * 2.返回逻辑视图名即可 * &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/views/&quot;/&gt; * + 逻辑视图名 + * &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt; */@GetMapping(&quot;jump&quot;)public String jumpJsp(Model model)&#123; System.out.println(&quot;FileController.jumpJsp&quot;); model.addAttribute(&quot;msg&quot;,&quot;request data!!&quot;); return &quot;home&quot;;&#125; 3.2.2 转发和重定向在 Spring MVC 中，Handler 方法返回值来实现快速转发，可以使用 redirect 或者 forward 关键字来实现重定向。 12345678910111213@RequestMapping(&quot;/redirect-demo&quot;)public String redirectDemo() &#123; // 重定向到 /demo 路径 return &quot;redirect:/demo&quot;;&#125;@RequestMapping(&quot;/forward-demo&quot;)public String forwardDemo() &#123; // 转发到 /demo 路径 return &quot;forward:/demo&quot;;&#125;//注意： 转发和重定向到项目下资源路径都是相同，都不需要添加项目根路径！填写项目下路径即可！ 总结： 将方法的返回值，设置String类型 转发使用forward关键字，重定向使用redirect关键字 关键字: &#x2F;路径 注意：如果是项目下的资源，转发和重定向都一样都是项目下路径！都不需要添加项目根路径！ 3.3 返回JSON数据（重点）3.3.1 前置准备导入jackson依赖 12345&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.15.0&lt;/version&gt;&lt;/dependency&gt; 添加json数据转化器 @EnableWebMvc&#x20; 123456789101112131415//TODO: SpringMVC对应组件的配置类 [声明SpringMVC需要的组件信息]//TODO: 导入handlerMapping和handlerAdapter的三种方式 //1.自动导入handlerMapping和handlerAdapter [推荐] //2.可以不添加,springmvc会检查是否配置handlerMapping和handlerAdapter,没有配置默认加载 //3.使用@Bean方式配置handlerMapper和handlerAdapter@EnableWebMvc //json数据处理,必须使用此注解,因为他会加入json处理器@Configuration@ComponentScan(basePackages = &quot;com.atguigu.controller&quot;) //TODO: 进行controller扫描//WebMvcConfigurer springMvc进行组件配置的规范,配置组件,提供各种方法! 前期可以实现public class SpringMvcConfig implements WebMvcConfigurer &#123;&#125; 3.3.2 @ResponseBody 方法上使用@ResponseBody 可以在方法上使用 @ResponseBody注解，用于将方法返回的对象序列化为 JSON 或 XML 格式的数据，并发送给客户端。在前后端分离的项目中使用！ 测试方法： 123456@GetMapping(&quot;/accounts/&#123;id&#125;&quot;)@ResponseBodypublic Object handle() &#123; // ... return obj;&#125; 具体来说，@ResponseBody 注解可以用来标识方法或者方法返回值，表示方法的返回值是要直接返回给客户端的数据，而不是由视图解析器来解析并渲染生成响应体（viewResolver没用）。 测试方法： 12345678910@RequestMapping(value = &quot;/user/detail&quot;, method = RequestMethod.POST)@ResponseBodypublic User getUser(@RequestBody User userParam) &#123; System.out.println(&quot;userParam = &quot; + userParam); User user = new User(); user.setAge(18); user.setName(&quot;John&quot;); //返回的对象,会使用jackson的序列化工具,转成json返回给前端! return user;&#125; 返回结果： 类上使用@ResponseBody 如果类中每个方法上都标记了 @ResponseBody 注解，那么这些注解就可以提取到类上。 1234@ResponseBody //responseBody可以添加到类上,代表默认类中的所有方法都生效!@Controller@RequestMapping(&quot;param&quot;)public class ParamController &#123; 3.3.3 @RestController类上的 @ResponseBody 注解可以和 @Controller 注解合并为 @RestController 注解。所以使用了 @RestController 注解就相当于给类中的每个方法都加了 @ResponseBody 注解。 RestController源码: 1234567891011121314151617@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documented@Controller@ResponseBodypublic @interface RestController &#123; /** * The value may indicate a suggestion for a logical component name, * to be turned into a Spring bean in case of an autodetected component. * @return the suggested component name, if any (or empty String otherwise) * @since 4.0.1 */ @AliasFor(annotation = Controller.class) String value() default &quot;&quot;; &#125; 3.4 返回静态资源处理 静态资源概念 资源本身已经是可以直接拿到浏览器上使用的程度了，不需要在服务器端做任何运算、处理。典型的静态资源包括： 纯HTML文件 图片 CSS文件 JavaScript文件 …… 静态资源访问和问题解决 web应用加入静态资源 手动构建确保编译 访问静态资源 问题分析 DispatcherServlet 的 url-pattern 配置的是“&#x2F;” url-pattern 配置“&#x2F;”表示整个 Web 应用范围内所有请求都由 SpringMVC 来处理 对 SpringMVC 来说，必须有对应的 @RequestMapping 才能找到处理请求的方法 现在 images&#x2F;mi.jpg 请求没有对应的 @RequestMapping 所以返回 404 问题解决 在 SpringMVC 配置配置类： 12345678910111213141516171819@EnableWebMvc //json数据处理,必须使用此注解,因为他会加入json处理器@Configuration@ComponentScan(basePackages = &quot;com.atguigu.controller&quot;) //TODO: 进行controller扫描//WebMvcConfigurer springMvc进行组件配置的规范,配置组件,提供各种方法! 前期可以实现public class SpringMvcConfig implements WebMvcConfigurer &#123; //配置jsp对应的视图解析器 @Override public void configureViewResolvers(ViewResolverRegistry registry) &#123; //快速配置jsp模板语言对应的 registry.jsp(&quot;/WEB-INF/views/&quot;,&quot;.jsp&quot;); &#125; //开启静态资源处理 &lt;mvc:default-servlet-handler/&gt; @Override public void configureDefaultServletHandling(DefaultServletHandlerConfigurer configurer) &#123; configurer.enable(); &#125;&#125; 再次测试访问图片： 新的问题：其他原本正常的handler请求访问不了了 handler无法访问 解决方案： 1@EnableWebMvc //json数据处理,必须使用此注解,因为他会加入json处理器 四、RESTFul风格设计和实战4.1 RESTFul风格概述4.1.1 RESTFul风格简介 RESTful（Representational State Transfer）是一种软件架构风格，用于设计网络应用程序和服务之间的通信。它是一种基于标准 HTTP 方法的简单和轻量级的通信协议，广泛应用于现代的Web服务开发。 通过遵循 RESTful 架构的设计原则，可以构建出易于理解、可扩展、松耦合和可重用的 Web 服务。RESTful API 的特点是简单、清晰，并且易于使用和理解，它们使用标准的 HTTP 方法和状态码进行通信，不需要额外的协议和中间件。 总而言之，RESTful 是一种基于 HTTP 和标准化的设计原则的软件架构风格，用于设计和实现可靠、可扩展和易于集成的 Web 服务和应用程序！ 学习RESTful设计原则可以帮助我们更好去设计HTTP协议的API接口！！ 4.1.2 RESTFul风格特点 每一个URI代表1种资源（URI 是名词）； 客户端使用GET、POST、PUT、DELETE 4个表示操作方式的动词对服务端资源进行操作：GET用来获取资源，POST用来新建资源（也可以用于更新资源），PUT用来更新资源，DELETE用来删除资源； 资源的表现形式是XML或者JSON； 客户端与服务端之间的交互在请求之间是无状态的，从客户端到服务端的每个请求都必须包含理解请求所必需的信息。 4.1.3 RESTFul风格设计规范 HTTP协议请求方式要求 REST 风格主张在项目设计、开发过程中，具体的操作符合HTTP协议定义的请求方式的语义。 操作 请求方式 查询操作 GET 保存操作 POST 删除操作 DELETE 更新操作 PUT URL路径风格要求 REST风格下每个资源都应该有一个唯一的标识符，例如一个 URI（统一资源标识符）或者一个 URL（统一资源定位符）。资源的标识符应该能明确地说明该资源的信息，同时也应该是可被理解和解释的！ 使用URL+请求方式确定具体的动作，他也是一种标准的HTTP协议请求！ 操作 传统风格 REST 风格 保存 &#x2F;CRUD&#x2F;saveEmp URL 地址：&#x2F;CRUD&#x2F;emp&#xA;请求方式：POST 删除 &#x2F;CRUD&#x2F;removeEmp?empId&#x3D;2 URL 地址：&#x2F;CRUD&#x2F;emp&#x2F;2&#xA;请求方式：DELETE 更新 &#x2F;CRUD&#x2F;updateEmp URL 地址：&#x2F;CRUD&#x2F;emp&#xA;请求方式：PUT 查询 &#x2F;CRUD&#x2F;editEmp?empId&#x3D;2 URL 地址：&#x2F;CRUD&#x2F;emp&#x2F;2&#xA;请求方式：GET 总结 根据接口的具体动作，选择具体的HTTP协议请求方式 路径设计从原来携带动标识，改成名词，对应资源的唯一标识即可！ 4.1.4 RESTFul风格好处 含蓄，安全 使用问号键值对的方式给服务器传递数据太明显，容易被人利用来对系统进行破坏。使用 REST 风格携带数据不再需要明显的暴露数据的名称。 风格统一 URL 地址整体格式统一，从前到后始终都使用斜杠划分各个单词，用简单一致的格式表达语义。 无状态 在调用一个接口（访问、操作资源）的时候，可以不用考虑上下文，不用考虑当前状态，极大的降低了系统设计的复杂度。 严谨，规范 严格按照 HTTP1.1 协议中定义的请求方式本身的语义进行操作。 简洁，优雅 过去做增删改查操作需要设计4个不同的URL，现在一个就够了。 操作 传统风格 REST 风格 保存 &#x2F;CRUD&#x2F;saveEmp URL 地址：&#x2F;CRUD&#x2F;emp&#xA;请求方式：POST 删除 &#x2F;CRUD&#x2F;removeEmp?empId&#x3D;2 URL 地址：&#x2F;CRUD&#x2F;emp&#x2F;2&#xA;请求方式：DELETE 更新 &#x2F;CRUD&#x2F;updateEmp URL 地址：&#x2F;CRUD&#x2F;emp&#xA;请求方式：PUT 查询 &#x2F;CRUD&#x2F;editEmp?empId&#x3D;2 URL 地址：&#x2F;CRUD&#x2F;emp&#x2F;2&#xA;请求方式：GET 丰富的语义 通过 URL 地址就可以知道资源之间的关系。它能够把一句话中的很多单词用斜杠连起来，反过来说就是可以在 URL 地址中用一句话来充分表达语义。 http://localhost:8080/shop http://localhost:8080/shop/product http://localhost:8080/shop/product/cellPhone http://localhost:8080/shop/product/cellPhone/iPhone 4.2 RESTFul风格实战4.2.1 需求分析 数据结构： User {id 唯一标识,name 用户名，age 用户年龄} 功能分析 用户数据分页展示功能（条件：page 页数 默认1，size 每页数量 默认 10） 保存用户功能 根据用户id查询用户详情功能 根据用户id更新用户数据功能 根据用户id删除用户数据功能 多条件模糊查询用户功能（条件：keyword 模糊关键字，page 页数 默认1，size 每页数量 默认 10） 4.2.2 RESTFul风格接口设计 接口设计 功能 接口和请求方式 请求参数 返回值 分页查询 GET &#x2F;user page&#x3D;1&amp;size&#x3D;10 { 响应数据 } 用户添加 POST &#x2F;user { user 数据 } {响应数据} 用户详情 GET &#x2F;user&#x2F;1 路径参数 {响应数据} 用户更新 PUT &#x2F;user { user 更新数据} {响应数据} 用户删除 DELETE &#x2F;user&#x2F;1 路径参数 {响应数据} 条件模糊 GET &#x2F;user&#x2F;search page&#x3D;1&amp;size&#x3D;10&amp;keywork&#x3D;关键字 {响应数据} 问题讨论 为什么查询用户详情，就使用路径传递参数，多条件模糊查询，就使用请求参数传递？ 误区：restful风格下，不是所有请求参数都是路径传递！可以使用其他方式传递！ 在 RESTful API 的设计中，路径和请求参数和请求体都是用来向服务器传递信息的方式。 对于查询用户详情，使用路径传递参数是因为这是一个单一资源的查询，即查询一条用户记录。使用路径参数可以明确指定所请求的资源，便于服务器定位并返回对应的资源，也符合 RESTful 风格的要求。 而对于多条件模糊查询，使用请求参数传递参数是因为这是一个资源集合的查询，即查询多条用户记录。使用请求参数可以通过组合不同参数来限制查询结果，路径参数的组合和排列可能会很多，不如使用请求参数更加灵活和简洁。此外，还有一些通用的原则可以遵循： 路径参数应该用于指定资源的唯一标识或者 ID，而请求参数应该用于指定查询条件或者操作参数。 请求参数应该限制在 10 个以内，过多的请求参数可能导致接口难以维护和使用。 对于敏感信息，最好使用 POST 和请求体来传递参数。 4.2.3 后台接口实现准备用户实体类： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package com.atguigu.pojo;/** * projectName: com.atguigu.pojo * 用户实体类 */public class User &#123; private Integer id; private String name; private Integer age; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Integer getAge() &#123; return age; &#125; public void setAge(Integer age) &#123; this.age = age; &#125; @Override public String toString() &#123; return &quot;User&#123;&quot; + &quot;id=&quot; + id + &quot;, name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, age=&quot; + age + &#x27;&#125;&#x27;; &#125;&#125; 准备用户Controller: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465/** * projectName: com.atguigu.controller * * description: 用户模块的控制器 */@RequestMapping(&quot;user&quot;)@RestControllerpublic class UserController &#123; /** * 模拟分页查询业务接口 */ @GetMapping public Object queryPage(@RequestParam(name = &quot;page&quot;,required = false,defaultValue = &quot;1&quot;)int page, @RequestParam(name = &quot;size&quot;,required = false,defaultValue = &quot;10&quot;)int size)&#123; System.out.println(&quot;page = &quot; + page + &quot;, size = &quot; + size); System.out.println(&quot;分页查询业务!&quot;); return &quot;&#123;&#x27;status&#x27;:&#x27;ok&#x27;&#125;&quot;; &#125; /** * 模拟用户保存业务接口 */ @PostMapping public Object saveUser(@RequestBody User user)&#123; System.out.println(&quot;user = &quot; + user); System.out.println(&quot;用户保存业务!&quot;); return &quot;&#123;&#x27;status&#x27;:&#x27;ok&#x27;&#125;&quot;; &#125; /** * 模拟用户详情业务接口 */ @PostMapping(&quot;/&#123;id&#125;&quot;) public Object detailUser(@PathVariable Integer id)&#123; System.out.println(&quot;id = &quot; + id); System.out.println(&quot;用户详情业务!&quot;); return &quot;&#123;&#x27;status&#x27;:&#x27;ok&#x27;&#125;&quot;; &#125; /** * 模拟用户更新业务接口 */ @PutMapping public Object updateUser(@RequestBody User user)&#123; System.out.println(&quot;user = &quot; + user); System.out.println(&quot;用户更新业务!&quot;); return &quot;&#123;&#x27;status&#x27;:&#x27;ok&#x27;&#125;&quot;; &#125; /** * 模拟条件分页查询业务接口 */ @GetMapping(&quot;search&quot;) public Object queryPage(@RequestParam(name = &quot;page&quot;,required = false,defaultValue = &quot;1&quot;)int page, @RequestParam(name = &quot;size&quot;,required = false,defaultValue = &quot;10&quot;)int size, @RequestParam(name = &quot;keyword&quot;,required= false)String keyword)&#123; System.out.println(&quot;page = &quot; + page + &quot;, size = &quot; + size + &quot;, keyword = &quot; + keyword); System.out.println(&quot;条件分页查询业务!&quot;); return &quot;&#123;&#x27;status&#x27;:&#x27;ok&#x27;&#125;&quot;; &#125;&#125; 五、SpringMVC其他扩展5.1 全局异常处理机制5.1.1 异常处理两种方式开发过程中是不可避免地会出现各种异常情况的，例如网络连接异常、数据格式异常、空指针异常等等。异常的出现可能导致程序的运行出现问题，甚至直接导致程序崩溃。因此，在开发过程中，合理处理异常、避免异常产生、以及对异常进行有效的调试是非常重要的。 对于异常的处理，一般分为两种方式： 编程式异常处理：是指在代码中显式地编写处理异常的逻辑。它通常涉及到对异常类型的检测及其处理，例如使用 try-catch 块来捕获异常，然后在 catch 块中编写特定的处理代码，或者在 finally 块中执行一些清理操作。在编程式异常处理中，开发人员需要显式地进行异常处理，异常处理代码混杂在业务代码中，导致代码可读性较差。 声明式异常处理：则是将异常处理的逻辑从具体的业务逻辑中分离出来，通过配置等方式进行统一的管理和处理。在声明式异常处理中，开发人员只需要为方法或类标注相应的注解（如 @Throws 或 @ExceptionHandler），就可以处理特定类型的异常。相较于编程式异常处理，声明式异常处理可以使代码更加简洁、易于维护和扩展。 站在宏观角度来看待声明式事务处理： 整个项目从架构这个层面设计的异常处理的统一机制和规范。 一个项目中会包含很多个模块，各个模块需要分工完成。如果张三负责的模块按照 A 方案处理异常，李四负责的模块按照 B 方案处理异常……各个模块处理异常的思路、代码、命名细节都不一样，那么就会让整个项目非常混乱。 使用声明式异常处理，可以统一项目处理异常思路，项目更加清晰明了！ 5.1.2 基于注解异常声明异常处理 声明异常处理控制器类 异常处理控制类，统一定义异常处理handler方法！ 123456789101112131415/** * projectName: com.atguigu.execptionhandler * * description: 全局异常处理器,内部可以定义异常处理Handler! *//** * @RestControllerAdvice = @ControllerAdvice + @ResponseBody * @ControllerAdvice 代表当前类的异常处理controller! */@RestControllerAdvicepublic class GlobalExceptionHandler &#123; &#125; 声明异常处理hander方法 异常处理handler方法和普通的handler方法参数接收和响应都一致！ 只不过异常处理handler方法要映射异常，发生对应的异常会调用！ 普通的handler方法要使用@RequestMapping注解映射路径，发生对应的路径调用！ 123456789101112131415161718192021222324252627282930313233343536373839/** * 异常处理handler * @ExceptionHandler(HttpMessageNotReadableException.class) * 该注解标记异常处理Handler,并且指定发生异常调用该方法! * * * @param e 获取异常对象! * @return 返回handler处理结果! */@ExceptionHandler(HttpMessageNotReadableException.class)public Object handlerJsonDateException(HttpMessageNotReadableException e)&#123; return null;&#125;/** * 当发生空指针异常会触发此方法! * @param e * @return */@ExceptionHandler(NullPointerException.class)public Object handlerNullException(NullPointerException e)&#123; return null;&#125;/** * 所有异常都会触发此方法!但是如果有具体的异常处理Handler! * 具体异常处理Handler优先级更高! * 例如: 发生NullPointerException异常! * 会触发handlerNullException方法,不会触发handlerException方法! * @param e * @return */@ExceptionHandler(Exception.class)public Object handlerException(Exception e)&#123; return null;&#125; 配置文件扫描控制器类配置 确保异常处理控制类被扫描 123&lt;!-- 扫描controller对应的包,将handler加入到ioc--&gt;@ComponentScan(basePackages = &#123;&quot;com.atguigu.controller&quot;,&quot;com.atguigu.exceptionhandler&quot;&#125;) 5.2 拦截器使用5.2.1 拦截器概念拦截器和过滤器解决问题 生活中 为了提高乘车效率，在乘客进入站台前统一检票 程序中 在程序中，使用拦截器在请求到达具体 handler 方法前，统一执行检测 拦截器 Springmvc VS 过滤器 javaWeb： 相似点 拦截：必须先把请求拦住，才能执行后续操作 过滤：拦截器或过滤器存在的意义就是对请求进行统一处理 放行：对请求执行了必要操作后，放请求过去，让它访问原本想要访问的资源 不同点 工作平台不同 过滤器工作在 Servlet 容器中 拦截器工作在 SpringMVC 的基础上 拦截的范围 过滤器：能够拦截到的最大范围是整个 Web 应用 拦截器：能够拦截到的最大范围是整个 SpringMVC 负责的请求 IOC 容器支持 过滤器：想得到 IOC 容器需要调用专门的工具方法，是间接的 拦截器：它自己就在 IOC 容器中，所以可以直接从 IOC 容器中装配组件，也就是可以直接得到 IOC 容器的支持 选择： 功能需要如果用 SpringMVC 的拦截器能够实现，就不使用过滤器。 5.2.2 拦截器使用 创建拦截器类 12345678910111213141516171819202122232425262728public class Process01Interceptor implements HandlerInterceptor &#123; // if( ! preHandler())&#123;return;&#125; // 在处理请求的目标 handler 方法前执行 @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; System.out.println(&quot;request = &quot; + request + &quot;, response = &quot; + response + &quot;, handler = &quot; + handler); System.out.println(&quot;Process01Interceptor.preHandle&quot;); // 返回true：放行 // 返回false：不放行 return true; &#125; // 在目标 handler 方法之后，handler报错不执行! @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; System.out.println(&quot;request = &quot; + request + &quot;, response = &quot; + response + &quot;, handler = &quot; + handler + &quot;, modelAndView = &quot; + modelAndView); System.out.println(&quot;Process01Interceptor.postHandle&quot;); &#125; // 渲染视图之后执行(最后),一定执行! @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; System.out.println(&quot;request = &quot; + request + &quot;, response = &quot; + response + &quot;, handler = &quot; + handler + &quot;, ex = &quot; + ex); System.out.println(&quot;Process01Interceptor.afterCompletion&quot;); &#125;&#125; 拦截器方法拦截位置： 修改配置类添加拦截器 1234567891011121314151617181920212223242526@EnableWebMvc //json数据处理,必须使用此注解,因为他会加入json处理器@Configuration@ComponentScan(basePackages = &#123;&quot;com.atguigu.controller&quot;,&quot;com.atguigu.exceptionhandler&quot;&#125;) //TODO: 进行controller扫描//WebMvcConfigurer springMvc进行组件配置的规范,配置组件,提供各种方法! 前期可以实现public class SpringMvcConfig implements WebMvcConfigurer &#123; //配置jsp对应的视图解析器 @Override public void configureViewResolvers(ViewResolverRegistry registry) &#123; //快速配置jsp模板语言对应的 registry.jsp(&quot;/WEB-INF/views/&quot;,&quot;.jsp&quot;); &#125; //开启静态资源处理 &lt;mvc:default-servlet-handler/&gt; @Override public void configureDefaultServletHandling(DefaultServletHandlerConfigurer configurer) &#123; configurer.enable(); &#125; //添加拦截器 @Override public void addInterceptors(InterceptorRegistry registry) &#123; //将拦截器添加到Springmvc环境,默认拦截所有Springmvc分发的请求 registry.addInterceptor(new Process01Interceptor()); &#125;&#125; 1234567893. 配置详解 1. 默认拦截全部 ```java @Override public void addInterceptors(InterceptorRegistry registry) &#123; //将拦截器添加到Springmvc环境,默认拦截所有Springmvc分发的请求 registry.addInterceptor(new Process01Interceptor()); &#125; 精准配置123456789101112@Overridepublic void addInterceptors(InterceptorRegistry registry) &#123; //将拦截器添加到Springmvc环境,默认拦截所有Springmvc分发的请求 registry.addInterceptor(new Process01Interceptor()); //精准匹配,设置拦截器处理指定请求 路径可以设置一个或者多个,为项目下路径即可 //addPathPatterns(&quot;/common/request/one&quot;) 添加拦截路径 //也支持 /* 和 /** 模糊路径。 * 任意一层字符串 ** 任意层 任意字符串 registry.addInterceptor(new Process01Interceptor()).addPathPatterns(&quot;/common/request/one&quot;,&quot;/common/request/tow&quot;);&#125; 排除配置12345678910111213141516171819//添加拦截器@Overridepublic void addInterceptors(InterceptorRegistry registry) &#123; //将拦截器添加到Springmvc环境,默认拦截所有Springmvc分发的请求 registry.addInterceptor(new Process01Interceptor()); //精准匹配,设置拦截器处理指定请求 路径可以设置一个或者多个,为项目下路径即可 //addPathPatterns(&quot;/common/request/one&quot;) 添加拦截路径 registry.addInterceptor(new Process01Interceptor()).addPathPatterns(&quot;/common/request/one&quot;,&quot;/common/request/tow&quot;); //排除匹配,排除应该在匹配的范围内排除 //addPathPatterns(&quot;/common/request/one&quot;) 添加拦截路径 //excludePathPatterns(&quot;/common/request/tow&quot;); 排除路径,排除应该在拦截的范围内 registry.addInterceptor(new Process01Interceptor()) .addPathPatterns(&quot;/common/request/one&quot;,&quot;/common/request/tow&quot;) .excludePathPatterns(&quot;/common/request/tow&quot;);&#125; 多个拦截器执行顺序 preHandle() 方法：SpringMVC 会把所有拦截器收集到一起，然后按照配置顺序调用各个 preHandle() 方法。 postHandle() 方法：SpringMVC 会把所有拦截器收集到一起，然后按照配置相反的顺序调用各个 postHandle() 方法。 afterCompletion() 方法：SpringMVC 会把所有拦截器收集到一起，然后按照配置相反的顺序调用各个 afterCompletion() 方法。 5.3 参数校验 在 Web 应用三层架构体系中，表述层负责接收浏览器提交的数据，业务逻辑层负责数据的处理。为了能够让业务逻辑层基于正确的数据进行处理，我们需要在表述层对数据进行检查，将错误的数据隔绝在业务逻辑层之外。 校验概述 JSR 303 是 Java 为 Bean 数据合法性校验提供的标准框架，它已经包含在 JavaEE 6.0 标准中。JSR 303 通过在 Bean 属性上标注类似于 @NotNull、@Max 等标准的注解指定校验规则，并通过标准的验证接口对Bean进行验证。 注解 规则 @Null 标注值必须为 null @NotNull 标注值不可为 null @AssertTrue 标注值必须为 true @AssertFalse 标注值必须为 false @Min(value) 标注值必须大于或等于 value @Max(value) 标注值必须小于或等于 value @DecimalMin(value) 标注值必须大于或等于 value @DecimalMax(value) 标注值必须小于或等于 value @Size(max,min) 标注值大小必须在 max 和 min 限定的范围内 @Digits(integer,fratction) 标注值值必须是一个数字，且必须在可接受的范围内 @Past 标注值只能用于日期型，且必须是过去的日期 @Future 标注值只能用于日期型，且必须是将来的日期 @Pattern(value) 标注值必须符合指定的正则表达式 JSR 303 只是一套标准，需要提供其实现才可以使用。Hibernate Validator 是 JSR 303 的一个参考实现，除支持所有标准的校验注解外，它还支持以下的扩展注解： 注解 规则 ————————————————————————————————————————————————————————————————————————————————————————————————————————————————- ——————– @Email 标注值必须是格式正确的 Email 地址 @Length 标注值字符串大小必须在指定的范围内 @NotEmpty 标注值字符串不能是空字符串 @Range 标注值必须在指定的范围内 Spring 4.0 版本已经拥有自己独立的数据校验框架，同时支持 JSR 303 标准的校验框架。Spring 在进行数据绑定时，可同时调用校验框架完成数据校验工作。在SpringMVC 中，可直接通过注解驱动 @EnableWebMvc 的方式进行数据校验。Spring 的 LocalValidatorFactoryBean 既实现了 Spring 的 Validator 接口，也实现了 JSR 303 的 Validator 接口。只要在Spring容器中定义了一个LocalValidatorFactoryBean，即可将其注入到需要数据校验的 Bean中。Spring本身并没有提供JSR 303的实现，所以必须将JSR 303的实现者的jar包放到类路径下。 配置 @EnableWebMvc后，SpringMVC 会默认装配好一个 LocalValidatorFactoryBean，通过在处理方法的入参上标注 @Validated 注解即可让 SpringMVC 在完成数据绑定后执行数据校验的工作。 操作演示 导入依赖 123456789101112131415161718192021&lt;!-- 校验注解 --&gt;&lt;dependency&gt; &lt;groupId&gt;jakarta.platform&lt;/groupId&gt; &lt;artifactId&gt;jakarta.jakartaee-web-api&lt;/artifactId&gt; &lt;version&gt;9.1.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt; &lt;!-- 校验注解实现--&gt; &lt;!-- https://mvnrepository.com/artifact/org.hibernate.validator/hibernate-validator --&gt;&lt;dependency&gt; &lt;groupId&gt;org.hibernate.validator&lt;/groupId&gt; &lt;artifactId&gt;hibernate-validator&lt;/artifactId&gt; &lt;version&gt;8.0.0.Final&lt;/version&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/org.hibernate.validator/hibernate-validator-annotation-processor --&gt;&lt;dependency&gt; &lt;groupId&gt;org.hibernate.validator&lt;/groupId&gt; &lt;artifactId&gt;hibernate-validator-annotation-processor&lt;/artifactId&gt; &lt;version&gt;8.0.0.Final&lt;/version&gt;&lt;/dependency&gt; 应用校验注解 123456789101112131415161718192021222324252627282930313233343536373839404142434445import jakarta.validation.constraints.Email;import jakarta.validation.constraints.Min;import org.hibernate.validator.constraints.Length;/** * projectName: com.atguigu.pojo */public class User &#123; //age 1 &lt;= age &lt; = 150 @Min(10) private int age; //name 3 &lt;= name.length &lt;= 6 @Length(min = 3,max = 10) private String name; //email 邮箱格式 @Email private String email; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getEmail() &#123; return email; &#125; public void setEmail(String email) &#123; this.email = email; &#125;&#125; handler标记和绑定错误收集 12345678910111213141516171819202122@RestController@RequestMapping(&quot;user&quot;)public class UserController &#123; /** * @Validated 代表应用校验注解! 必须添加! */ @PostMapping(&quot;save&quot;) public Object save(@Validated @RequestBody User user, //在实体类参数和 BindingResult 之间不能有任何其他参数, BindingResult可以接受错误信息,避免信息抛出! BindingResult result)&#123; //判断是否有信息绑定错误! 有可以自行处理! if (result.hasErrors())&#123; System.out.println(&quot;错误&quot;); String errorMsg = result.getFieldError().toString(); return errorMsg; &#125; //没有,正常处理业务即可 System.out.println(&quot;正常&quot;); return user; &#125;&#125; 测试效果 易混总结 @NotNull、@NotEmpty、@NotBlank 都是用于在数据校验中检查字段值是否为空的注解，但是它们的用法和校验规则有所不同。 @NotNull (包装类型不为null) @NotNull 注解是 JSR 303 规范中定义的注解，当被标注的字段值为 null 时，会认为校验失败而抛出异常。该注解不能用于字符串类型的校验，若要对字符串进行校验，应该使用 @NotBlank 或 @NotEmpty 注解。 @NotEmpty (集合类型长度大于0) @NotEmpty 注解同样是 JSR 303 规范中定义的注解，对于 CharSequence、Collection、Map 或者数组对象类型的属性进行校验，校验时会检查该属性是否为 Null 或者 size()&#x3D;&#x3D;0，如果是的话就会校验失败。但是对于其他类型的属性，该注解无效。需要注意的是只校验空格前后的字符串，如果该字符串中间只有空格，不会被认为是空字符串，校验不会失败。 @NotBlank （字符串，不为null，切不为” “字符串） @NotBlank 注解是 Hibernate Validator 附加的注解，对于字符串类型的属性进行校验，校验时会检查该属性是否为 Null 或 “” 或者只包含空格，如果是的话就会校验失败。需要注意的是，@NotBlank 注解只能用于字符串类型的校验。总之，这三种注解都是用于校验字段值是否为空的注解，但是其校验规则和用法有所不同。在进行数据校验时，需要根据具体情况选择合适的注解进行校验。 六、SpringMVC总结 核心点 掌握目标 springmvc框架 主要作用、核心组件、调用流程 简化参数接收 路径设计、参数接收、请求头接收、cookie接收 简化数据响应 模板页面、转发和重定向、JSON数据、静态资源 restful风格设计 主要作用、具体规范、请求方式和请求参数选择 功能扩展 全局异常处理、拦截器、参数校验注解","categories":[{"name":"SSM框架","slug":"SSM框架","permalink":"http://example.com/categories/SSM%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"ssm","slug":"ssm","permalink":"http://example.com/tags/ssm/"}]},{"title":"三、MyBatis实践：提高持久层数据处理效率","slug":"SSM/三、MyBatis实践：提高持久层数据处理效率/三、MyBatis实践：提高持久层数据处理效率","date":"2022-09-29T09:55:54.000Z","updated":"2023-09-28T00:31:34.403Z","comments":true,"path":"2022/09/29/SSM/三、MyBatis实践：提高持久层数据处理效率/三、MyBatis实践：提高持久层数据处理效率/","link":"","permalink":"http://example.com/2022/09/29/SSM/%E4%B8%89%E3%80%81MyBatis%E5%AE%9E%E8%B7%B5%EF%BC%9A%E6%8F%90%E9%AB%98%E6%8C%81%E4%B9%85%E5%B1%82%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E6%95%88%E7%8E%87/%E4%B8%89%E3%80%81MyBatis%E5%AE%9E%E8%B7%B5%EF%BC%9A%E6%8F%90%E9%AB%98%E6%8C%81%E4%B9%85%E5%B1%82%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E6%95%88%E7%8E%87/","excerpt":"","text":"三、MyBatis实践：提高持久层数据处理效率目录 一、Mybatis简介 1.1 简介 1.2 持久层框架对比 1.3 快速入门（基于Mybatis3方式） 二、MyBatis基本使用 2.1 向SQL语句传参 2.1.1 mybatis日志输出配置 2.1.2 #{}形式 2.1.3 ${}形式 2.2 数据输入 2.2.1 Mybatis总体机制概括 2.2.2 概念说明 2.2.3 单个简单类型参数 2.2.4 实体类类型参数 2.2.5 零散的简单类型数据 2.2.6 Map类型参数 2.3数据输出 2.3.1 输出概述 2.3.2 单个简单类型 2.3.3 返回实体类对象 2.3.4 返回Map类型 2.3.5 返回List类型 2.3.6 返回主键值 2.3.7 实体类属性和数据库字段对应关系 2.4 CRUD强化练习 2.5 mapperXML标签总结 三、MyBatis多表映射 3.1 多表映射概念 3.2 对一映射 3.3 对多映射 3.4 多表映射总结 3.4.1 多表映射优化 3.4.2 多表映射总结 四、MyBatis动态语句 4.1 动态语句需求和简介 4.2 if和where标签 4.3 set标签 4.4 trim标签(了解) 4.5 choose&#x2F;when&#x2F;otherwise标签 4.6 foreach标签 4.7 sql片段 五、MyBatis高级扩展 5.1 Mapper批量映射优化 5.2 插件和分页插件PageHelper 5.2.1 插件机制和PageHelper插件介绍 5.2.2 PageHelper插件使用 5.3 逆向工程和MybatisX插件 5.3.1 ORM思维介绍 5.3.2 逆向工程 5.3.3 逆向工程插件MyBatisX使用 六、MyBatis总结 一、Mybatis简介1.1 简介https://mybatis.org/mybatis-3/zh/index.html MyBatis最初是Apache的一个开源项目iBatis, 2010年6月这个项目由Apache Software Foundation迁移到了Google Code。随着开发团队转投Google Code旗下， iBatis3.x正式更名为MyBatis。代码于2013年11月迁移到Github。 MyBatis 是一款优秀的持久层框架，它支持自定义 SQL、存储过程以及高级映射。MyBatis 免除了几乎所有的 JDBC 代码以及设置参数和获取结果集的工作。MyBatis 可以通过简单的 XML 或注解来配置和映射原始类型、接口和 Java POJO（Plain Old Java Objects，普通老式 Java 对象）为数据库中的记录。 社区会持续更新开源项目，版本会不断变化，我们不必每个小版本都追，关注重大更新的大版本升级即可。 本课程使用：3.5.11版本 1.2 持久层框架对比 JDBC SQL 夹杂在Java代码中耦合度高，导致硬编码内伤 维护不易且实际开发需求中 SQL 有变化，频繁修改的情况多见 代码冗长，开发效率低 Hibernate 和 JPA 操作简便，开发效率高 程序中的长难复杂 SQL 需要绕过框架 内部自动生成的 SQL，不容易做特殊优化 基于全映射的全自动框架，大量字段的 POJO 进行部分映射时比较困难。 反射操作太多，导致数据库性能下降 MyBatis 轻量级，性能出色 SQL 和 Java 编码分开，功能边界清晰。Java代码专注业务、SQL语句专注数据 开发效率稍逊于 Hibernate，但是完全能够接收 开发效率：Hibernate&gt;Mybatis&gt;JDBC 运行效率：JDBC&gt;Mybatis&gt;Hibernate 1.3 快速入门（基于Mybatis3方式） 准备数据模型 1234567891011121314CREATE DATABASE `mybatis-example`;USE `mybatis-example`;CREATE TABLE `t_emp`( emp_id INT AUTO_INCREMENT, emp_name CHAR(100), emp_salary DOUBLE(10,5), PRIMARY KEY(emp_id));INSERT INTO `t_emp`(emp_name,emp_salary) VALUES(&quot;tom&quot;,200.33);INSERT INTO `t_emp`(emp_name,emp_salary) VALUES(&quot;jerry&quot;,666.66);INSERT INTO `t_emp`(emp_name,emp_salary) VALUES(&quot;andy&quot;,777.77); 项目搭建和准备 项目搭建 依赖导入 pom.xml 12345678910111213141516171819202122&lt;dependencies&gt; &lt;!-- mybatis依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.11&lt;/version&gt; &lt;/dependency&gt; &lt;!-- MySQL驱动 mybatis底层依赖jdbc驱动实现,本次不需要导入连接池,mybatis自带! --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.25&lt;/version&gt; &lt;/dependency&gt; &lt;!--junit5测试--&gt; &lt;dependency&gt; &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt; &lt;artifactId&gt;junit-jupiter-api&lt;/artifactId&gt; &lt;version&gt;5.3.1&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 实体类准备 12345678910public class Employee &#123; private Integer empId; private String empName; private Double empSalary; //getter | setter&#125; 准备Mapper接口和MapperXML文件 MyBatis 框架下，SQL语句编写位置发生改变，从原来的Java类，改成XML或者注解定义！ 推荐在XML文件中编写SQL语句，让用户能更专注于 SQL 代码，不用关注其他的JDBC代码。 如果拿它跟具有相同功能的 JDBC 代码进行对比，你会立即发现省掉了将近 95% 的代码！！ 一般编写SQL语句的文件命名：XxxMapper.xml Xxx一般取表名！！ Mybatis 中的 Mapper 接口相当于以前的 Dao。但是区别在于，Mapper 仅仅只是建接口即可，我们不需要提供实现类，具体的SQL写到对应的Mapper文件，该用法的思路如下图所示： 定义mapper接口 包：com.atguigu.mapper 12345678910111213141516171819package com.atguigu.mapper;import com.atguigu.pojo.Employee;/** * t_emp表对应数据库SQL语句映射接口! * 接口只规定方法,参数和返回值! * mapper.xml中编写具体SQL语句! */public interface EmployeeMapper &#123; /** * 根据员工id查询员工数据方法 * @param empId 员工id * @return 员工实体对象 */ Employee selectEmployee(Integer empId); &#125; 定义mapper xml 位置： resources&#x2F;mappers&#x2F;EmployeeMapper.xml 123456789101112131415161718&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;https://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;!-- namespace等于mapper接口类的全限定名,这样实现对应 --&gt;&lt;mapper namespace=&quot;com.atguigu.mapper.EmployeeMapper&quot;&gt; &lt;!-- 查询使用 select标签 id = 方法名 resultType = 返回值类型 标签内编写SQL语句 --&gt; &lt;select id=&quot;selectEmployee&quot; resultType=&quot;com.atguigu.pojo.Employee&quot;&gt; &lt;!-- #&#123;empId&#125;代表动态传入的参数,并且进行赋值!后面详细讲解 --&gt; select emp_id empId,emp_name empName, emp_salary empSalary from t_emp where emp_id = #&#123;empId&#125; &lt;/select&gt;&lt;/mapper&gt; 注意： 方法名和SQL的id一致 方法返回值和resultType一致 方法的参数和SQL的参数一致 接口的全类名和映射配置文件的名称空间一致 准备MyBatis配置文件 mybatis框架配置文件： 数据库连接信息，性能配置，mapper.xml配置等！ 习惯上命名为 mybatis-config.xml，这个文件名仅仅只是建议，并非强制要求。将来整合 Spring 之后，这个配置文件可以省略，所以大家操作时可以直接复制、粘贴。 1234567891011121314151617181920212223242526272829303132&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt; &lt;!-- environments表示配置Mybatis的开发环境，可以配置多个环境，在众多具体环境中，使用default属性指定实际运行时使用的环境。default属性的取值是environment标签的id属性的值。 --&gt; &lt;environments default=&quot;development&quot;&gt; &lt;!-- environment表示配置Mybatis的一个具体的环境 --&gt; &lt;environment id=&quot;development&quot;&gt; &lt;!-- Mybatis的内置的事务管理器 --&gt; &lt;transactionManager type=&quot;JDBC&quot;/&gt; &lt;!-- 配置数据源 --&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;!-- 建立数据库连接的具体信息 --&gt; &lt;property name=&quot;driver&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mybatis-example&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;root&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;!-- Mapper注册：指定Mybatis映射文件的具体位置 --&gt; &lt;!-- mapper标签：配置一个具体的Mapper映射文件 --&gt; &lt;!-- resource属性：指定Mapper映射文件的实际存储位置，这里需要使用一个以类路径根目录为基准的相对路径 --&gt; &lt;!-- 对Maven工程的目录结构来说，resources目录下的内容会直接放入类路径，所以这里我们可以以resources目录为基准 --&gt; &lt;mapper resource=&quot;mappers/EmployeeMapper.xml&quot;/&gt; &lt;/mappers&gt;&lt;/configuration&gt; 运行和测试 12345678910111213141516171819202122232425262728293031323334353637/** * projectName: com.atguigu.test * * description: 测试类 */public class MyBatisTest &#123; @Test public void testSelectEmployee() throws IOException &#123; // 1.创建SqlSessionFactory对象 // ①声明Mybatis全局配置文件的路径 String mybatisConfigFilePath = &quot;mybatis-config.xml&quot;; // ②以输入流的形式加载Mybatis配置文件 InputStream inputStream = Resources.getResourceAsStream(mybatisConfigFilePath); // ③基于读取Mybatis配置文件的输入流创建SqlSessionFactory对象 SqlSessionFactory sessionFactory = new SqlSessionFactoryBuilder().build(inputStream); // 2.使用SqlSessionFactory对象开启一个会话 SqlSession session = sessionFactory.openSession(); // 3.根据EmployeeMapper接口的Class对象获取Mapper接口类型的对象(动态代理技术) EmployeeMapper employeeMapper = session.getMapper(EmployeeMapper.class); // 4. 调用代理类方法既可以触发对应的SQL语句 Employee employee = employeeMapper.selectEmployee(1); System.out.println(&quot;employee = &quot; + employee); // 4.关闭SqlSession session.commit(); //提交事务 [DQL不需要,其他需要] session.close(); //关闭会话 &#125;&#125; 说明： SqlSession：代表Java程序和数据库之间的会话。（HttpSession是Java程序和浏览器之间的会话） SqlSessionFactory：是“生产”SqlSession的“工厂”。 工厂模式：如果创建某一个对象，使用的过程基本固定，那么我们就可以把创建这个对象的相关代码封装到一个“工厂类”中，以后都使用这个工厂类来“生产”我们需要的对象。 SqlSession和HttpSession区别 HttpSession：工作在Web服务器上，属于表述层。 代表浏览器和Web服务器之间的会话。 SqlSession：不依赖Web服务器，属于持久化层。 代表Java程序和数据库之间的会话。 二、MyBatis基本使用2.1 向SQL语句传参2.1.1 mybatis日志输出配置mybatis配置文件设计标签和顶层结构如下： configuration（配置） properties（属性） settings（设置） typeAliases（类型别名） typeHandlers（类型处理器） objectFactory（对象工厂） plugins（插件） environments（环境配置） environment（环境变量） transactionManager（事务管理器） dataSource（数据源） databaseIdProvider（数据库厂商标识） mappers（映射器） 我们可以在mybatis的配置文件使用settings标签设置，输出运过程SQL日志！ 通过查看日志，我们可以判定#{} 和 ${}的输出效果！ settings设置项： logImpl 指定 MyBatis 所用日志的具体实现，未指定时将自动查找。 SLF4J | LOG4J（3.5.9 起废弃） | LOG4J2 | JDK_LOGGING | COMMONS_LOGGING | STDOUT_LOGGING | NO_LOGGING 未设置 日志配置： 1234&lt;settings&gt; &lt;!-- SLF4J 选择slf4j输出！ --&gt; &lt;setting name=&quot;logImpl&quot; value=&quot;SLF4J&quot;/&gt;&lt;/settings&gt; 2.1.2 #{}形式Mybatis会将SQL语句中的#{}转换为问号占位符。 2.1.3 ${}形式${}形式传参，底层Mybatis做的是字符串拼接操作。 通常不会采用${}的方式传值。一个特定的适用场景是：通过Java程序动态生成数据库表，表名部分需要Java程序通过参数传入；而JDBC对于表名部分是不能使用问号占位符的，此时只能使用 结论：实际开发中，能用#{}实现的，肯定不用${}。 特殊情况： 动态的不是值，是列名或者关键字，需要使用${}拼接 1234//注解方式传入参数！！@Select(&quot;select * from user where $&#123;column&#125; = #&#123;value&#125;&quot;)User findByColumn(@Param(&quot;column&quot;) String column, @Param(&quot;value&quot;) String value); 2.2 数据输入2.2.1 Mybatis总体机制概括 2.2.2 概念说明这里数据输入具体是指上层方法（例如Service方法）调用Mapper接口时，数据传入的形式。 简单类型：只包含一个值的数据类型 基本数据类型：int、byte、short、double、…… 基本数据类型的包装类型：Integer、Character、Double、…… 字符串类型：String 复杂类型：包含多个值的数据类型 实体类类型：Employee、Department、…… 集合类型：List、Set、Map、…… 数组类型：int[]、String[]、…… 复合类型：List&lt;Employee&gt;、实体类中包含集合…… 2.2.3 单个简单类型参数Mapper接口中抽象方法的声明 1Employee selectEmployee(Integer empId); SQL语句 123&lt;select id=&quot;selectEmployee&quot; resultType=&quot;com.atguigu.mybatis.entity.Employee&quot;&gt; select emp_id empId,emp_name empName,emp_salary empSalary from t_emp where emp_id=#&#123;empId&#125;&lt;/select&gt; 单个简单类型参数，在#{}中可以随意命名，但是没有必要。通常还是使用和接口方法参数同名。 2.2.4 实体类类型参数Mapper接口中抽象方法的声明 1int insertEmployee(Employee employee); SQL语句 123&lt;insert id=&quot;insertEmployee&quot;&gt; insert into t_emp(emp_name,emp_salary) values(#&#123;empName&#125;,#&#123;empSalary&#125;)&lt;/insert&gt; 对应关系 结论 Mybatis会根据#{}中传入的数据，加工成getXxx()方法，通过反射在实体类对象中调用这个方法，从而获取到对应的数据。填充到#{}解析后的问号占位符这个位置。 2.2.5 零散的简单类型数据零散的多个简单类型参数，如果没有特殊处理，那么Mybatis无法识别自定义名称： Mapper接口中抽象方法的声明 1int updateEmployee(@Param(&quot;empId&quot;) Integer empId,@Param(&quot;empSalary&quot;) Double empSalary); SQL语句 123&lt;update id=&quot;updateEmployee&quot;&gt; update t_emp set emp_salary=#&#123;empSalary&#125; where emp_id=#&#123;empId&#125;&lt;/update&gt; 对应关系 2.2.6 Map类型参数Mapper接口中抽象方法的声明 1int updateEmployeeByMap(Map&lt;String, Object&gt; paramMap); SQL语句 12345&lt;update id=&quot;updateEmployeeByMap&quot;&gt; update t_emp set emp_salary=#&#123;empSalaryKey&#125; where emp_id=#&#123;empIdKey&#125;&lt;/update&gt; junit测试 123456789101112131415161718192021222324252627private SqlSession session;//junit5会在每一个@Test方法前执行@BeforeEach方法@BeforeEachpublic void init() throws IOException &#123; session = new SqlSessionFactoryBuilder() .build( Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;)) .openSession();&#125;@Testpublic void testUpdateEmpNameByMap() &#123; EmployeeMapper mapper = session.getMapper(EmployeeMapper.class); Map&lt;String, Object&gt; paramMap = new HashMap&lt;&gt;(); paramMap.put(&quot;empSalaryKey&quot;, 999.99); paramMap.put(&quot;empIdKey&quot;, 5); int result = mapper.updateEmployeeByMap(paramMap); log.info(&quot;result = &quot; + result);&#125;//junit5会在每一个@Test方法后执行@@AfterEach方法@AfterEachpublic void clear() &#123; session.commit(); session.close();&#125; 对应关系 #{}中写Map中的key 使用场景 有很多零散的参数需要传递，但是没有对应的实体类类型可以使用。使用@Param注解一个一个传入又太麻烦了。所以都封装到Map中。 2.3数据输出2.3.1 输出概述数据输出总体上有两种形式： 增删改操作返回的受影响行数：直接使用 int 或 long 类型接收即可 查询操作的查询结果 我们需要做的是，指定查询的输出数据类型即可！ 并且插入场景下，实现主键数据回显示！ 2.3.2 单个简单类型Mapper接口中的抽象方法 1int selectEmpCount(); SQL语句 123&lt;select id=&quot;selectEmpCount&quot; resultType=&quot;int&quot;&gt; select count(*) from t_emp&lt;/select&gt; Mybatis 内部给常用的数据类型设定了很多别名。 以 int 类型为例，可以写的名称有：int、integer、Integer、java.lang.Integer、Int、INT、INTEGER 等等。 junit测试 1234567891011@Testpublic void testEmpCount() &#123; EmployeeMapper employeeMapper = session.getMapper(EmployeeMapper.class); int count = employeeMapper.selectEmpCount(); log.info(&quot;count = &quot; + count);&#125; 细节解释： select标签，通过resultType指定查询返回值类型！ resultType &#x3D; “全限定符 ｜ 别名 ｜ 如果是返回集合类型，写范型类型即可” 别名问题： https://mybatis.org/mybatis-3/zh/configuration.html#typeAliases 类型别名可为 Java 类型设置一个缩写名字。 它仅用于 XML 配置，意在降低冗余的全限定类名书写。例如： 1234&lt;typeAliases&gt; &lt;typeAlias alias=&quot;Author&quot; type=&quot;domain.blog.Author&quot;/&gt; &lt;typeAlias alias=&quot;Blog&quot; type=&quot;domain.blog.Blog&quot;/&gt;&lt;/typeAliases&gt; 当这样配置时，Blog 可以用在任何使用 domain.blog.Blog 的地方。 也可以指定一个包名，MyBatis 会在包名下面搜索需要的 Java Bean，比如： 1&lt;typeAliases&gt; &lt;package name=&quot;domain.blog&quot;/&gt; &lt;/typeAliases&gt; 每一个在包 domain.blog 中的 Java Bean，在没有注解的情况下，会使用 Bean 的首字母小写的非限定类名来作为它的别名。 比如 domain.blog.Author 的别名为 author；若有注解，则别名为其注解值。见下面的例子： 1234@Alias(&quot;author&quot;)public class Author &#123; ...&#125; 下面是Mybatis为常见的 Java 类型内建的类型别名。它们都是不区分大小写的，注意，为了应对原始类型的命名重复，采取了特殊的命名风格。 别名 映射的类型 _byte byte _char (since 3.5.10) char _character (since 3.5.10) char _long long _short short _int int _integer int _double double _float float _boolean boolean string String byte Byte char (since 3.5.10) Character character (since 3.5.10) Character long Long short Short int Integer integer Integer double Double float Float boolean Boolean date Date decimal BigDecimal bigdecimal BigDecimal biginteger BigInteger object Object object[] Object[] map Map hashmap HashMap list List arraylist ArrayList collection Collection 2.3.3 返回实体类对象Mapper接口的抽象方法 12Employee selectEmployee(Integer empId); SQL语句 123456789&lt;!-- 编写具体的SQL语句，使用id属性唯一的标记一条SQL语句 --&gt;&lt;!-- resultType属性：指定封装查询结果的Java实体类的全类名 --&gt;&lt;select id=&quot;selectEmployee&quot; resultType=&quot;com.atguigu.mybatis.entity.Employee&quot;&gt; &lt;!-- Mybatis负责把SQL语句中的#&#123;&#125;部分替换成“?”占位符 --&gt; &lt;!-- 给每一个字段设置一个别名，让别名和Java实体类中属性名一致 --&gt; select emp_id empId,emp_name empName,emp_salary empSalary from t_emp where emp_id=#&#123;maomi&#125;&lt;/select&gt; 通过给数据库表字段加别名，让查询结果的每一列都和Java实体类中属性对应起来。 增加全局配置自动识别对应关系 在 Mybatis 全局配置文件中，做了下面的配置，select语句中可以不给字段设置别名 1234567891011&lt;!-- 在全局范围内对Mybatis进行配置 --&gt;&lt;settings&gt; &lt;!-- 具体配置 --&gt; &lt;!-- 从org.apache.ibatis.session.Configuration类中可以查看能使用的配置项 --&gt; &lt;!-- 将mapUnderscoreToCamelCase属性配置为true，表示开启自动映射驼峰式命名规则 --&gt; &lt;!-- 规则要求数据库表字段命名方式：单词_单词 --&gt; &lt;!-- 规则要求Java实体类属性名命名方式：首字母小写的驼峰式命名 --&gt; &lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;true&quot;/&gt;&lt;/settings&gt; 2.3.4 返回Map类型适用于SQL查询返回的各个字段综合起来并不和任何一个现有的实体类对应，没法封装到实体类对象中。能够封装成实体类类型的，就不使用Map类型。 Mapper接口的抽象方法 1Map&lt;String,Object&gt; selectEmpNameAndMaxSalary(); SQL语句 1234567891011&lt;!-- Map&lt;String,Object&gt; selectEmpNameAndMaxSalary(); --&gt;&lt;!-- 返回工资最高的员工的姓名和他的工资 --&gt;&lt;select id=&quot;selectEmpNameAndMaxSalary&quot; resultType=&quot;map&quot;&gt; SELECT emp_name 员工姓名, emp_salary 员工工资, (SELECT AVG(emp_salary) FROM t_emp) 部门平均工资 FROM t_emp WHERE emp_salary=( SELECT MAX(emp_salary) FROM t_emp )&lt;/select&gt; junit测试 12345678910111213141516171819@Testpublic void testQueryEmpNameAndSalary() &#123; EmployeeMapper employeeMapper = session.getMapper(EmployeeMapper.class); Map&lt;String, Object&gt; resultMap = employeeMapper.selectEmpNameAndMaxSalary(); Set&lt;Map.Entry&lt;String, Object&gt;&gt; entrySet = resultMap.entrySet(); for (Map.Entry&lt;String, Object&gt; entry : entrySet) &#123; String key = entry.getKey(); Object value = entry.getValue(); log.info(key + &quot;=&quot; + value); &#125;&#125; 2.3.5 返回List类型查询结果返回多个实体类对象，希望把多个实体类对象放在List集合中返回。此时不需要任何特殊处理，在resultType属性中还是设置实体类类型即可。 Mapper接口中抽象方法 1List&lt;Employee&gt; selectAll(); SQL语句 12345&lt;!-- List&lt;Employee&gt; selectAll(); --&gt;&lt;select id=&quot;selectAll&quot; resultType=&quot;com.atguigu.mybatis.entity.Employee&quot;&gt; select emp_id empId,emp_name empName,emp_salary empSalary from t_emp&lt;/select&gt; junit测试 12345678@Testpublic void testSelectAll() &#123; EmployeeMapper employeeMapper = session.getMapper(EmployeeMapper.class); List&lt;Employee&gt; employeeList = employeeMapper.selectAll(); for (Employee employee : employeeList) &#123; log.info(&quot;employee = &quot; + employee); &#125;&#125; 2.3.6 返回主键值 自增长类型主键 Mapper接口中的抽象方法 1int insertEmployee(Employee employee); SQL语句 1234567&lt;!-- int insertEmployee(Employee employee); --&gt;&lt;!-- useGeneratedKeys属性字面意思就是“使用生成的主键” --&gt;&lt;!-- keyProperty属性可以指定主键在实体类对象中对应的属性名，Mybatis会将拿到的主键值存入这个属性 --&gt;&lt;insert id=&quot;insertEmployee&quot; useGeneratedKeys=&quot;true&quot; keyProperty=&quot;empId&quot;&gt; insert into t_emp(emp_name,emp_salary) values(#&#123;empName&#125;,#&#123;empSalary&#125;)&lt;/insert&gt; junit测试 123456789@Testpublic void testSaveEmp() &#123; EmployeeMapper employeeMapper = session.getMapper(EmployeeMapper.class); Employee employee = new Employee(); employee.setEmpName(&quot;john&quot;); employee.setEmpSalary(666.66); employeeMapper.insertEmployee(employee); log.info(&quot;employee.getEmpId() = &quot; + employee.getEmpId());&#125; 注意 Mybatis是将自增主键的值设置到实体类对象中，而不是以Mapper接口方法返回值的形式返回。 非自增长类型主键 而对于不支持自增型主键的数据库（例如 Oracle）或者字符串类型主键，则可以使用 selectKey 子元素：selectKey 元素将会首先运行，id 会被设置，然后插入语句会被调用！ 使用 selectKey 帮助插入UUID作为字符串类型主键示例： 12345678910111213&lt;insert id=&quot;insertUser&quot; parameterType=&quot;User&quot;&gt; &lt;selectKey keyProperty=&quot;id&quot; resultType=&quot;java.lang.String&quot; order=&quot;BEFORE&quot;&gt; SELECT UUID() as id &lt;/selectKey&gt; INSERT INTO user (id, username, password) VALUES ( #&#123;id&#125;, #&#123;username&#125;, #&#123;password&#125; )&lt;/insert&gt; 在上例中，我们定义了一个 insertUser 的插入语句来将 User 对象插入到 user 表中。我们使用 selectKey 来查询 UUID 并设置到 id 字段中。 通过 keyProperty 属性来指定查询到的 UUID 赋值给对象中的 id 属性，而 resultType 属性指定了 UUID 的类型为 java.lang.String。 需要注意的是，我们将 selectKey 放在了插入语句的前面，这是因为 MySQL 在 insert 语句中只支持一个 select 子句，而 selectKey 中查询 UUID 的语句就是一个 select 子句，因此我们需要将其放在前面。 最后，在将 User 对象插入到 user 表中时，我们直接使用对象中的 id 属性来插入主键值。 使用这种方式，我们可以方便地插入 UUID 作为字符串类型主键。当然，还有其他插入方式可以使用，如使用Java代码生成UUID并在类中显式设置值等。需要根据具体应用场景和需求选择合适的插入方式。 2.3.7 实体类属性和数据库字段对应关系 别名对应 将字段的别名设置成和实体类属性一致。 123456789&lt;!-- 编写具体的SQL语句，使用id属性唯一的标记一条SQL语句 --&gt;&lt;!-- resultType属性：指定封装查询结果的Java实体类的全类名 --&gt;&lt;select id=&quot;selectEmployee&quot; resultType=&quot;com.atguigu.mybatis.entity.Employee&quot;&gt; &lt;!-- Mybatis负责把SQL语句中的#&#123;&#125;部分替换成“?”占位符 --&gt; &lt;!-- 给每一个字段设置一个别名，让别名和Java实体类中属性名一致 --&gt; select emp_id empId,emp_name empName,emp_salary empSalary from t_emp where emp_id=#&#123;maomi&#125;&lt;/select&gt; 关于实体类属性的约定：getXxx()方法、setXxx()方法把方法名中的get或set去掉，首字母小写。 全局配置自动识别驼峰式命名规则 在Mybatis全局配置文件加入如下配置： 1234567&lt;!-- 使用settings对Mybatis全局进行设置 --&gt;&lt;settings&gt; &lt;!-- 将xxx_xxx这样的列名自动映射到xxXxx这样驼峰式命名的属性名 --&gt; &lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;true&quot;/&gt;&lt;/settings&gt; SQL语句中可以不使用别名 123456&lt;!-- Employee selectEmployee(Integer empId); --&gt;&lt;select id=&quot;selectEmployee&quot; resultType=&quot;com.atguigu.mybatis.entity.Employee&quot;&gt; select emp_id,emp_name,emp_salary from t_emp where emp_id=#&#123;empId&#125;&lt;/select&gt; 使用resultMap 使用resultMap标签定义对应关系，再在后面的SQL语句中引用这个对应关系 1234567891011121314151617181920&lt;!-- 专门声明一个resultMap设定column到property之间的对应关系 --&gt;&lt;resultMap id=&quot;selectEmployeeByRMResultMap&quot; type=&quot;com.atguigu.mybatis.entity.Employee&quot;&gt; &lt;!-- 使用id标签设置主键列和主键属性之间的对应关系 --&gt; &lt;!-- column属性用于指定字段名；property属性用于指定Java实体类属性名 --&gt; &lt;id column=&quot;emp_id&quot; property=&quot;empId&quot;/&gt; &lt;!-- 使用result标签设置普通字段和Java实体类属性之间的关系 --&gt; &lt;result column=&quot;emp_name&quot; property=&quot;empName&quot;/&gt; &lt;result column=&quot;emp_salary&quot; property=&quot;empSalary&quot;/&gt;&lt;/resultMap&gt;&lt;!-- Employee selectEmployeeByRM(Integer empId); --&gt;&lt;select id=&quot;selectEmployeeByRM&quot; resultMap=&quot;selectEmployeeByRMResultMap&quot;&gt; select emp_id,emp_name,emp_salary from t_emp where emp_id=#&#123;empId&#125;&lt;/select&gt; 2.4 CRUD强化练习 准备数据库数据 首先，我们需要准备一张名为 user 的表。该表包含字段 id（主键）、username、password。创建SQL如下： 1234567CREATE TABLE `user` ( `id` INT(11) NOT NULL AUTO_INCREMENT, `username` VARCHAR(50) NOT NULL, `password` VARCHAR(50) NOT NULL, PRIMARY KEY (`id`)) ENGINE=INNODB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8; 实体类准备 接下来，我们需要定义一个实体类 User，来对应 user 表的一行数据。 123456@Data //lombokpublic class User &#123; private Integer id; private String username; private String password;&#125; Mapper接口定义 定义一个 Mapper 接口 UserMapper，并在其中添加 user 表的增、删、改、查方法。 123456789101112public interface UserMapper &#123; int insert(User user); int update(User user); int delete(Integer id); User selectById(Integer id); List&lt;User&gt; selectAll();&#125; MapperXML编写 在 resources &#x2F;mappers目录下创建一个名为 UserMapper.xml 的 XML 文件，包含与 Mapper 接口中相同的五个 SQL 语句，并在其中，将查询结果映射到 User 实体中。 1234567891011121314151617181920212223242526272829303132&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;https://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;!-- namespace等于mapper接口类的全限定名,这样实现对应 --&gt;&lt;mapper namespace=&quot;com.atguigu.mapper.UserMapper&quot;&gt; &lt;!-- 定义一个插入语句，并获取主键值 --&gt; &lt;insert id=&quot;insert&quot; useGeneratedKeys=&quot;true&quot; keyProperty=&quot;id&quot;&gt; INSERT INTO user(username, password) VALUES(#&#123;username&#125;, #&#123;password&#125;) &lt;/insert&gt; &lt;update id=&quot;update&quot;&gt; UPDATE user SET username=#&#123;username&#125;, password=#&#123;password&#125; WHERE id=#&#123;id&#125; &lt;/update&gt; &lt;delete id=&quot;delete&quot;&gt; DELETE FROM user WHERE id=#&#123;id&#125; &lt;/delete&gt; &lt;!-- resultType使用user别名，稍后需要配置！--&gt; &lt;select id=&quot;selectById&quot; resultType=&quot;user&quot;&gt; SELECT id, username, password FROM user WHERE id=#&#123;id&#125; &lt;/select&gt; &lt;!-- resultType返回值类型为集合，所以只写范型即可！ --&gt; &lt;select id=&quot;selectAll&quot; resultType=&quot;user&quot;&gt; SELECT id, username, password FROM user &lt;/select&gt; &lt;/mapper&gt; MyBatis配置文件 位置：resources: mybatis-config.xml&#x20; 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt; &lt;settings&gt; &lt;!-- 开启驼峰式映射--&gt; &lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;true&quot;/&gt; &lt;!-- 开启logback日志输出--&gt; &lt;setting name=&quot;logImpl&quot; value=&quot;SLF4J&quot;/&gt; &lt;/settings&gt; &lt;typeAliases&gt; &lt;!-- 给实体类起别名 --&gt; &lt;package name=&quot;com.atguigu.pojo&quot;/&gt; &lt;/typeAliases&gt; &lt;!-- environments表示配置Mybatis的开发环境，可以配置多个环境，在众多具体环境中，使用default属性指定实际运行时使用的环境。default属性的取值是environment标签的id属性的值。 --&gt; &lt;environments default=&quot;development&quot;&gt; &lt;!-- environment表示配置Mybatis的一个具体的环境 --&gt; &lt;environment id=&quot;development&quot;&gt; &lt;!-- Mybatis的内置的事务管理器 --&gt; &lt;transactionManager type=&quot;JDBC&quot;/&gt; &lt;!-- 配置数据源 --&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;!-- 建立数据库连接的具体信息 --&gt; &lt;property name=&quot;driver&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mybatis-example&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;root&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;!-- Mapper注册：指定Mybatis映射文件的具体位置 --&gt; &lt;!-- mapper标签：配置一个具体的Mapper映射文件 --&gt; &lt;!-- resource属性：指定Mapper映射文件的实际存储位置，这里需要使用一个以类路径根目录为基准的相对路径 --&gt; &lt;!-- 对Maven工程的目录结构来说，resources目录下的内容会直接放入类路径，所以这里我们可以以resources目录为基准 --&gt; &lt;mapper resource=&quot;mappers/UserMapper.xml&quot;/&gt; &lt;/mappers&gt;&lt;/configuration&gt; 效果测试 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081package com.atguigu.test;import com.atguigu.mapper.UserMapper;import com.atguigu.pojo.User;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import org.junit.jupiter.api.AfterEach;import org.junit.jupiter.api.BeforeEach;import org.junit.jupiter.api.Test;import java.io.IOException;import java.util.List;/** * projectName: com.atguigu.test */public class MyBatisTest &#123; private SqlSession session; // junit会在每一个@Test方法前执行@BeforeEach方法 @BeforeEach public void init() throws IOException &#123; session = new SqlSessionFactoryBuilder() .build( Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;)) .openSession(); &#125; @Test public void createTest() &#123; User user = new User(); user.setUsername(&quot;admin&quot;); user.setPassword(&quot;123456&quot;); UserMapper userMapper = session.getMapper(UserMapper.class); userMapper.insert(user); System.out.println(user); &#125; @Test public void updateTest() &#123; UserMapper userMapper = session.getMapper(UserMapper.class); User user = userMapper.selectById(1); user.setUsername(&quot;root&quot;); user.setPassword(&quot;111111&quot;); userMapper.update(user); user = userMapper.selectById(1); System.out.println(user); &#125; @Test public void deleteTest() &#123; UserMapper userMapper = session.getMapper(UserMapper.class); userMapper.delete(1); User user = userMapper.selectById(1); System.out.println(&quot;user = &quot; + user); &#125; @Test public void selectByIdTest() &#123; UserMapper userMapper = session.getMapper(UserMapper.class); User user = userMapper.selectById(1); System.out.println(&quot;user = &quot; + user); &#125; @Test public void selectAllTest() &#123; UserMapper userMapper = session.getMapper(UserMapper.class); List&lt;User&gt; userList = userMapper.selectAll(); System.out.println(&quot;userList = &quot; + userList); &#125; // junit会在每一个@Test方法后执行@@AfterEach方法 @AfterEach public void clear() &#123; session.commit(); session.close(); &#125;&#125; 2.5 mapperXML标签总结MyBatis 的真正强大在于它的语句映射，这是它的魔力所在。由于它的异常强大，映射器的 XML 文件就显得相对简单。如果拿它跟具有相同功能的 JDBC 代码进行对比，你会立即发现省掉了将近 95% 的代码。MyBatis 致力于减少使用成本，让用户能更专注于 SQL 代码。 SQL 映射文件只有很少的几个顶级元素（按照应被定义的顺序列出）： insert – 映射插入语句。 update – 映射更新语句。 delete – 映射删除语句。 select – 映射查询语句。 select标签： MyBatis 在查询和结果映射做了相当多的改进。一个简单查询的 select 元素是非常简单： 12&lt;select id=&quot;selectPerson&quot; resultType=&quot;hashmap&quot; resultMap=&quot;自定义结构&quot;&gt; SELECT * FROM PERSON WHERE ID = #&#123;id&#125; &lt;/select&gt; 这个语句名为 selectPerson，接受一个 int（或 Integer）类型的参数，并返回一个 HashMap 类型的对象，其中的键是列名，值便是结果行中的对应值。 注意参数符号：#{id} ${key} MyBatis 创建一个预处理语句（PreparedStatement）参数，在 JDBC 中，这样的一个参数在 SQL 中会由一个“?”来标识，并被传递到一个新的预处理语句中，就像这样： 1234// 近似的 JDBC 代码，非 MyBatis 代码...String selectPerson = &quot;SELECT * FROM PERSON WHERE ID=?&quot;;PreparedStatement ps = conn.prepareStatement(selectPerson);ps.setInt(1,id); select 元素允许你配置很多属性来配置每条语句的行为细节： 属性 描述 id 在命名空间中唯一的标识符，可以被用来引用这条语句。 resultType 期望从这条语句中返回结果的类全限定名或别名。 注意，如果返回的是集合，那应该设置为集合包含的类型，而不是集合本身的类型。 resultType 和 resultMap 之间只能同时使用一个。 resultMap 对外部 resultMap 的命名引用。结果映射是 MyBatis 最强大的特性，如果你对其理解透彻，许多复杂的映射问题都能迎刃而解。 resultType 和 resultMap 之间只能同时使用一个。 timeout 这个设置是在抛出异常之前，驱动程序等待数据库返回请求结果的秒数。默认值为未设置（unset）（依赖数据库驱动）。 statementType 可选 STATEMENT，PREPARED 或 CALLABLE。这会让 MyBatis 分别使用 Statement，PreparedStatement 或 CallableStatement，默认值：PREPARED。 insert, update 和 delete标签： 数据变更语句 insert，update 和 delete 的实现非常接近： 1234567891011121314151617&lt;insert id=&quot;insertAuthor&quot; statementType=&quot;PREPARED&quot; keyProperty=&quot;&quot; keyColumn=&quot;&quot; useGeneratedKeys=&quot;&quot; timeout=&quot;20&quot;&gt;&lt;update id=&quot;updateAuthor&quot; statementType=&quot;PREPARED&quot; timeout=&quot;20&quot;&gt;&lt;delete id=&quot;deleteAuthor&quot; statementType=&quot;PREPARED&quot; timeout=&quot;20&quot;&gt; 属性 描述 id 在命名空间中唯一的标识符，可以被用来引用这条语句。 timeout 这个设置是在抛出异常之前，驱动程序等待数据库返回请求结果的秒数。默认值为未设置（unset）（依赖数据库驱动）。 statementType 可选 STATEMENT，PREPARED 或 CALLABLE。这会让 MyBatis 分别使用 Statement，PreparedStatement 或 CallableStatement，默认值：PREPARED。 useGeneratedKeys （仅适用于 insert 和 update）这会令 MyBatis 使用 JDBC 的 getGeneratedKeys 方法来取出由数据库内部生成的主键（比如：像 MySQL 和 SQL Server 这样的关系型数据库管理系统的自动递增字段），默认值：false。 keyProperty （仅适用于 insert 和 update）指定能够唯一识别对象的属性，MyBatis 会使用 getGeneratedKeys 的返回值或 insert 语句的 selectKey 子元素设置它的值，默认值：未设置（unset）。如果生成列不止一个，可以用逗号分隔多个属性名称。 keyColumn （仅适用于 insert 和 update）设置生成键值在表中的列名，在某些数据库（像 PostgreSQL）中，当主键列不是表中的第一列的时候，是必须设置的。如果生成列不止一个，可以用逗号分隔多个属性名称。 三、MyBatis多表映射3.1 多表映射概念 多表查询结果映射思路 上面课程中，我全面讲解了单表的mybatis操作！但是开发中更多的是多表查询需求，这种情况我们如何让进行处理？ MyBatis 思想是：数据库不可能永远是你所想或所需的那个样子。 我们希望每个数据库都具备良好的第三范式或 BCNF 范式，可惜它们并不都是那样。 如果能有一种数据库映射模式，完美适配所有的应用程序查询需求，那就太好了，而 ResultMap 就是 MyBatis 就是完美答案。&#x20; 官方例子：我们如何映射下面这个语句？&#x20; 12345678910111213141516171819202122232425262728293031323334&lt;!-- 非常复杂的语句 --&gt;&lt;select id=&quot;selectBlogDetails&quot; resultMap=&quot;detailedBlogResultMap&quot;&gt; select B.id as blog_id, B.title as blog_title, B.author_id as blog_author_id, A.id as author_id, A.username as author_username, A.password as author_password, A.email as author_email, A.bio as author_bio, A.favourite_section as author_favourite_section, P.id as post_id, P.blog_id as post_blog_id, P.author_id as post_author_id, P.created_on as post_created_on, P.section as post_section, P.subject as post_subject, P.draft as draft, P.body as post_body, C.id as comment_id, C.post_id as comment_post_id, C.name as comment_name, C.comment as comment_text, T.id as tag_id, T.name as tag_name from Blog B left outer join Author A on B.author_id = A.id left outer join Post P on B.id = P.blog_id left outer join Comment C on P.id = C.post_id left outer join Post_Tag PT on PT.post_id = P.id left outer join Tag T on PT.tag_id = T.id where B.id = #&#123;id&#125;&lt;/select&gt; 你可能想把它映射到一个智能的对象模型，这个对象表示了一篇博客，它由某位作者所写，有很多的博文，每篇博文有零或多条的评论和标签。 我们先来看看下面这个完整的例子，它是一个非常复杂的结果映射（假设作者，博客，博文，评论和标签都是类型别名）。 虽然它看起来令人望而生畏，但其实非常简单。&#x20; 1234567891011121314151617181920212223242526&lt;!-- 非常复杂的结果映射 --&gt;&lt;resultMap id=&quot;detailedBlogResultMap&quot; type=&quot;Blog&quot;&gt; &lt;constructor&gt; &lt;idArg column=&quot;blog_id&quot; javaType=&quot;int&quot;/&gt; &lt;/constructor&gt; &lt;result property=&quot;title&quot; column=&quot;blog_title&quot;/&gt; &lt;association property=&quot;author&quot; javaType=&quot;Author&quot;&gt; &lt;id property=&quot;id&quot; column=&quot;author_id&quot;/&gt; &lt;result property=&quot;username&quot; column=&quot;author_username&quot;/&gt; &lt;result property=&quot;password&quot; column=&quot;author_password&quot;/&gt; &lt;result property=&quot;email&quot; column=&quot;author_email&quot;/&gt; &lt;result property=&quot;bio&quot; column=&quot;author_bio&quot;/&gt; &lt;result property=&quot;favouriteSection&quot; column=&quot;author_favourite_section&quot;/&gt; &lt;/association&gt; &lt;collection property=&quot;posts&quot; ofType=&quot;Post&quot;&gt; &lt;id property=&quot;id&quot; column=&quot;post_id&quot;/&gt; &lt;result property=&quot;subject&quot; column=&quot;post_subject&quot;/&gt; &lt;association property=&quot;author&quot; javaType=&quot;Author&quot;/&gt; &lt;collection property=&quot;comments&quot; ofType=&quot;Comment&quot;&gt; &lt;id property=&quot;id&quot; column=&quot;comment_id&quot;/&gt; &lt;/collection&gt; &lt;collection property=&quot;tags&quot; ofType=&quot;Tag&quot; &gt; &lt;id property=&quot;id&quot; column=&quot;tag_id&quot;/&gt; &lt;/collection&gt; &lt;/collection&gt;&lt;/resultMap&gt; 你现在可能看不懂，接下来我们要学习将多表查询结果使用ResultMap标签映射到实体类对象上！ 我们的学习目标： 多表查询语句使用 多表结果承接实体类设计 使用ResultMap完成多表结果映射 实体类设计方案 多表关系回顾：（双向查看） 一对一 夫妻关系，人和身份证号 一对多| 多对一 用户和用户的订单，锁和钥匙 多对多 老师和学生，部门和员工实体类设计关系(查询)：（单向查看） 对一 ： 夫妻一方对应另一方，订单对应用户都是对一关系 实体类设计：对一关系下，类中只要包含单个对方对象类型属性即可！ 例如： 123456789101112131415public class Customer &#123; private Integer customerId; private String customerName;&#125;public class Order &#123; private Integer orderId; private String orderName; private Customer customer;// 体现的是对一的关系&#125; 对多: 用户对应的订单，讲师对应的学生或者学生对应的讲师都是对多关系： 实体类设计：对多关系下，类中只要包含对方类型集合属性即可！ 12345678910111213141516public class Customer &#123; private Integer customerId; private String customerName; private List&lt;Order&gt; orderList;// 体现的是对多的关系&#125;public class Order &#123; private Integer orderId; private String orderName; private Customer customer;// 体现的是对一的关系 &#125;//查询客户和客户对应的订单集合 不要管! 多表结果实体类设计小技巧： 对一，属性中包含对方对象 对多，属性中包含对方对象集合 只有真实发生多表查询时，才需要设计和修改实体类，否则不提前设计和修改实体类！ 无论多少张表联查，实体类设计都是两两考虑! 在查询映射的时候，只需要关注本次查询相关的属性！例如：查询订单和对应的客户，就不要关注客户中的订单集合！ 多表映射案例准备 数据库： 123456789CREATE TABLE `t_customer` (`customer_id` INT NOT NULL AUTO_INCREMENT, `customer_name` CHAR(100), PRIMARY KEY (`customer_id`) );CREATE TABLE `t_order` ( `order_id` INT NOT NULL AUTO_INCREMENT, `order_name` CHAR(100), `customer_id` INT, PRIMARY KEY (`order_id`) ); INSERT INTO `t_customer` (`customer_name`) VALUES (&#x27;c01&#x27;);INSERT INTO `t_order` (`order_name`, `customer_id`) VALUES (&#x27;o1&#x27;, &#x27;1&#x27;);INSERT INTO `t_order` (`order_name`, `customer_id`) VALUES (&#x27;o2&#x27;, &#x27;1&#x27;);INSERT INTO `t_order` (`order_name`, `customer_id`) VALUES (&#x27;o3&#x27;, &#x27;1&#x27;); 实际开发时，一般在开发过程中，不给数据库表设置外键约束。原因是避免调试不方便。一般是功能开发完成，再加外键约束检查是否有bug。 实体类设计： 稍后会进行订单关联客户查询，也会进行客户关联订单查询，所以在这先练习设计 1234567891011121314151617@Datapublic class Customer &#123; private Integer customerId; private String customerName; private List&lt;Order&gt; orderList;// 体现的是对多的关系 &#125; @Datapublic class Order &#123; private Integer orderId; private String orderName; private Customer customer;// 体现的是对一的关系 &#125; 3.2 对一映射 需求说明 根据ID查询订单，以及订单关联的用户的信息！ OrderMapper接口 123public interface OrderMapper &#123; Order selectOrderWithCustomer(Integer orderId);&#125; OrderMapper.xml配置文件 123456789101112131415161718192021222324252627282930313233&lt;!-- 创建resultMap实现“对一”关联关系映射 --&gt;&lt;!-- id属性：通常设置为这个resultMap所服务的那条SQL语句的id加上“ResultMap” --&gt;&lt;!-- type属性：要设置为这个resultMap所服务的那条SQL语句最终要返回的类型 --&gt;&lt;resultMap id=&quot;selectOrderWithCustomerResultMap&quot; type=&quot;order&quot;&gt; &lt;!-- 先设置Order自身属性和字段的对应关系 --&gt; &lt;id column=&quot;order_id&quot; property=&quot;orderId&quot;/&gt; &lt;result column=&quot;order_name&quot; property=&quot;orderName&quot;/&gt; &lt;!-- 使用association标签配置“对一”关联关系 --&gt; &lt;!-- property属性：在Order类中对一的一端进行引用时使用的属性名 --&gt; &lt;!-- javaType属性：一的一端类的全类名 --&gt; &lt;association property=&quot;customer&quot; javaType=&quot;customer&quot;&gt; &lt;!-- 配置Customer类的属性和字段名之间的对应关系 --&gt; &lt;id column=&quot;customer_id&quot; property=&quot;customerId&quot;/&gt; &lt;result column=&quot;customer_name&quot; property=&quot;customerName&quot;/&gt; &lt;/association&gt;&lt;/resultMap&gt;&lt;!-- Order selectOrderWithCustomer(Integer orderId); --&gt;&lt;select id=&quot;selectOrderWithCustomer&quot; resultMap=&quot;selectOrderWithCustomerResultMap&quot;&gt; SELECT order_id,order_name,c.customer_id,customer_name FROM t_order o LEFT JOIN t_customer c ON o.customer_id=c.customer_id WHERE o.order_id=#&#123;orderId&#125;&lt;/select&gt; 对应关系可以参考下图： Mybatis全局注册Mapper文件 1234567&lt;!-- 注册Mapper配置文件：告诉Mybatis我们的Mapper配置文件的位置 --&gt;&lt;mappers&gt; &lt;!-- 在mapper标签的resource属性中指定Mapper配置文件以“类路径根目录”为基准的相对路径 --&gt; &lt;mapper resource=&quot;mappers/OrderMapper.xml&quot;/&gt;&lt;/mappers&gt; junit测试程序 12345678910111213141516171819202122232425262728293031@Slf4jpublic class MyBatisTest &#123; private SqlSession session; // junit会在每一个@Test方法前执行@BeforeEach方法 @BeforeEach public void init() throws IOException &#123; session = new SqlSessionFactoryBuilder() .build( Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;)) .openSession(); &#125; @Test public void testRelationshipToOne() &#123; OrderMapper orderMapper = session.getMapper(OrderMapper.class); // 查询Order对象，检查是否同时查询了关联的Customer对象 Order order = orderMapper.selectOrderWithCustomer(2); log.info(&quot;order = &quot; + order); &#125; // junit会在每一个@Test方法后执行@@AfterEach方法 @AfterEach public void clear() &#123; session.commit(); session.close(); &#125;&#125; 关键词 在“对一”关联关系中，我们的配置比较多，但是关键词就只有：association和javaType 3.3 对多映射 需求说明 查询客户和客户关联的订单信息！ CustomerMapper接口 12345public interface CustomerMapper &#123; Customer selectCustomerWithOrderList(Integer customerId);&#125; CustomerMapper.xml文件 1234567891011121314151617181920212223242526272829303132&lt;!-- 配置resultMap实现从Customer到OrderList的“对多”关联关系 --&gt;&lt;resultMap id=&quot;selectCustomerWithOrderListResultMap&quot; type=&quot;customer&quot;&gt; &lt;!-- 映射Customer本身的属性 --&gt; &lt;id column=&quot;customer_id&quot; property=&quot;customerId&quot;/&gt; &lt;result column=&quot;customer_name&quot; property=&quot;customerName&quot;/&gt; &lt;!-- collection标签：映射“对多”的关联关系 --&gt; &lt;!-- property属性：在Customer类中，关联“多”的一端的属性名 --&gt; &lt;!-- ofType属性：集合属性中元素的类型 --&gt; &lt;collection property=&quot;orderList&quot; ofType=&quot;order&quot;&gt; &lt;!-- 映射Order的属性 --&gt; &lt;id column=&quot;order_id&quot; property=&quot;orderId&quot;/&gt; &lt;result column=&quot;order_name&quot; property=&quot;orderName&quot;/&gt; &lt;/collection&gt;&lt;/resultMap&gt;&lt;!-- Customer selectCustomerWithOrderList(Integer customerId); --&gt;&lt;select id=&quot;selectCustomerWithOrderList&quot; resultMap=&quot;selectCustomerWithOrderListResultMap&quot;&gt; SELECT c.customer_id,c.customer_name,o.order_id,o.order_name FROM t_customer c LEFT JOIN t_order o ON c.customer_id=o.customer_id WHERE c.customer_id=#&#123;customerId&#125;&lt;/select&gt; 对应关系可以参考下图： Mybatis全局注册Mapper文件 123456&lt;!-- 注册Mapper配置文件：告诉Mybatis我们的Mapper配置文件的位置 --&gt;&lt;mappers&gt; &lt;!-- 在mapper标签的resource属性中指定Mapper配置文件以“类路径根目录”为基准的相对路径 --&gt; &lt;mapper resource=&quot;mappers/OrderMapper.xml&quot;/&gt; &lt;mapper resource=&quot;mappers/CustomerMapper.xml&quot;/&gt;&lt;/mappers&gt; junit测试程序 12345678910111213@Testpublic void testRelationshipToMulti() &#123; CustomerMapper customerMapper = session.getMapper(CustomerMapper.class); // 查询Customer对象同时将关联的Order集合查询出来 Customer customer = customerMapper.selectCustomerWithOrderList(1); log.info(&quot;customer.getCustomerId() = &quot; + customer.getCustomerId()); log.info(&quot;customer.getCustomerName() = &quot; + customer.getCustomerName()); List&lt;Order&gt; orderList = customer.getOrderList(); for (Order order : orderList) &#123; log.info(&quot;order = &quot; + order); &#125;&#125; 关键词 在“对多”关联关系中，同样有很多配置，但是提炼出来最关键的就是：“collection”和“ofType” 3.4 多表映射总结3.4.1 多表映射优化 setting属性 属性含义 可选值 默认值 autoMappingBehavior 指定 MyBatis 应如何自动映射列到字段或属性。 NONE 表示关闭自动映射；PARTIAL 只会自动映射没有定义嵌套结果映射的字段。 FULL 会自动映射任何复杂的结果集（无论是否嵌套）。 NONE, PARTIAL, FULL PARTIAL 我们可以将autoMappingBehavior设置为full,进行多表resultMap映射的时候，可以省略符合列和属性命名映射规则（列名&#x3D;属性名，或者开启驼峰映射也可以自定映射）的result标签！ 修改mybati-sconfig.xml: 12&lt;!--开启resultMap自动映射 --&gt;&lt;setting name=&quot;autoMappingBehavior&quot; value=&quot;FULL&quot;/&gt; 修改teacherMapper.xml 123456789&lt;resultMap id=&quot;teacherMap&quot; type=&quot;teacher&quot;&gt; &lt;id property=&quot;tId&quot; column=&quot;t_id&quot; /&gt; &lt;!-- 开启自动映射,并且开启驼峰式支持!可以省略 result!--&gt;&lt;!-- &lt;result property=&quot;tName&quot; column=&quot;t_name&quot; /&gt;--&gt; &lt;collection property=&quot;students&quot; ofType=&quot;student&quot; &gt; &lt;id property=&quot;sId&quot; column=&quot;s_id&quot; /&gt;&lt;!-- &lt;result property=&quot;sName&quot; column=&quot;s_name&quot; /&gt;--&gt; &lt;/collection&gt;&lt;/resultMap&gt; 3.4.2 多表映射总结 关联关系 配置项关键词 所在配置文件和具体位置 对一 association标签&#x2F;javaType属性&#x2F;property属性 Mapper配置文件中的resultMap标签内 对多 collection标签&#x2F;ofType属性&#x2F;property属性 Mapper配置文件中的resultMap标签内 四、MyBatis动态语句4.1 动态语句需求和简介经常遇到很多按照很多查询条件进行查询的情况，比如智联招聘的职位搜索等。其中经常出现很多条件不取值的情况，在后台应该如何完成最终的SQL语句呢？ 动态 SQL 是 MyBatis 的强大特性之一。如果你使用过 JDBC 或其它类似的框架，你应该能理解根据不同条件拼接 SQL 语句有多痛苦，例如拼接时要确保不能忘记添加必要的空格，还要注意去掉列表最后一个列名的逗号。利用动态 SQL，可以彻底摆脱这种痛苦。 使用动态 SQL 并非一件易事，但借助可用于任何 SQL 映射语句中的强大的动态 SQL 语言，MyBatis 显著地提升了这一特性的易用性。 如果你之前用过 JSTL 或任何基于类 XML 语言的文本处理器，你对动态 SQL 元素可能会感觉似曾相识。在 MyBatis 之前的版本中，需要花时间了解大量的元素。借助功能强大的基于 OGNL 的表达式，MyBatis 3 替换了之前的大部分元素，大大精简了元素种类，现在要学习的元素种类比原来的一半还要少。 4.2 if和where标签使用动态 SQL 最常见情景是根据条件包含 where &#x2F; if 子句的一部分。比如： 123456789101112131415161718192021&lt;!-- List&lt;Employee&gt; selectEmployeeByCondition(Employee employee); --&gt;&lt;select id=&quot;selectEmployeeByCondition&quot; resultType=&quot;employee&quot;&gt; select emp_id,emp_name,emp_salary from t_emp &lt;!-- where标签会自动去掉“标签体内前面多余的and/or” --&gt; &lt;where&gt; &lt;!-- 使用if标签，让我们可以有选择的加入SQL语句的片段。这个SQL语句片段是否要加入整个SQL语句，就看if标签判断的结果是否为true --&gt; &lt;!-- 在if标签的test属性中，可以访问实体类的属性，不可以访问数据库表的字段 --&gt; &lt;if test=&quot;empName != null&quot;&gt; &lt;!-- 在if标签内部，需要访问接口的参数时还是正常写#&#123;&#125; --&gt; or emp_name=#&#123;empName&#125; &lt;/if&gt; &lt;if test=&quot;empSalary &amp;gt; 2000&quot;&gt; or emp_salary&gt;#&#123;empSalary&#125; &lt;/if&gt; &lt;!-- 第一种情况：所有条件都满足 WHERE emp_name=? or emp_salary&gt;? 第二种情况：部分条件满足 WHERE emp_salary&gt;? 第三种情况：所有条件都不满足 没有where子句 --&gt; &lt;/where&gt;&lt;/select&gt; 4.3 set标签123456789101112131415161718192021&lt;!-- void updateEmployeeDynamic(Employee employee) --&gt;&lt;update id=&quot;updateEmployeeDynamic&quot;&gt; update t_emp &lt;!-- set emp_name=#&#123;empName&#125;,emp_salary=#&#123;empSalary&#125; --&gt; &lt;!-- 使用set标签动态管理set子句，并且动态去掉两端多余的逗号 --&gt; &lt;set&gt; &lt;if test=&quot;empName != null&quot;&gt; emp_name=#&#123;empName&#125;, &lt;/if&gt; &lt;if test=&quot;empSalary &amp;lt; 3000&quot;&gt; emp_salary=#&#123;empSalary&#125;, &lt;/if&gt; &lt;/set&gt; where emp_id=#&#123;empId&#125; &lt;!-- 第一种情况：所有条件都满足 SET emp_name=?, emp_salary=? 第二种情况：部分条件满足 SET emp_salary=? 第三种情况：所有条件都不满足 update t_emp where emp_id=? 没有set子句的update语句会导致SQL语法错误 --&gt;&lt;/update&gt; 4.4 trim标签(了解)使用trim标签控制条件部分两端是否包含某些字符 prefix属性：指定要动态添加的前缀 suffix属性：指定要动态添加的后缀 prefixOverrides属性：指定要动态去掉的前缀，使用“|”分隔有可能的多个值 suffixOverrides属性：指定要动态去掉的后缀，使用“|”分隔有可能的多个值 12345678910111213141516171819202122232425&lt;!-- List&lt;Employee&gt; selectEmployeeByConditionByTrim(Employee employee) --&gt;&lt;select id=&quot;selectEmployeeByConditionByTrim&quot; resultType=&quot;com.atguigu.mybatis.entity.Employee&quot;&gt; select emp_id,emp_name,emp_age,emp_salary,emp_gender from t_emp &lt;!-- prefix属性指定要动态添加的前缀 --&gt; &lt;!-- suffix属性指定要动态添加的后缀 --&gt; &lt;!-- prefixOverrides属性指定要动态去掉的前缀，使用“|”分隔有可能的多个值 --&gt; &lt;!-- suffixOverrides属性指定要动态去掉的后缀，使用“|”分隔有可能的多个值 --&gt; &lt;!-- 当前例子用where标签实现更简洁，但是trim标签更灵活，可以用在任何有需要的地方 --&gt; &lt;trim prefix=&quot;where&quot; suffixOverrides=&quot;and|or&quot;&gt; &lt;if test=&quot;empName != null&quot;&gt; emp_name=#&#123;empName&#125; and &lt;/if&gt; &lt;if test=&quot;empSalary &amp;gt; 3000&quot;&gt; emp_salary&gt;#&#123;empSalary&#125; and &lt;/if&gt; &lt;if test=&quot;empAge &amp;lt;= 20&quot;&gt; emp_age=#&#123;empAge&#125; or &lt;/if&gt; &lt;if test=&quot;empGender==&#x27;male&#x27;&quot;&gt; emp_gender=#&#123;empGender&#125; &lt;/if&gt; &lt;/trim&gt;&lt;/select&gt; 4.5 choose&#x2F;when&#x2F;otherwise标签在多个分支条件中，仅执行一个。 从上到下依次执行条件判断 遇到的第一个满足条件的分支会被采纳 被采纳分支后面的分支都将不被考虑 如果所有的when分支都不满足，那么就执行otherwise分支 12345678910111213141516&lt;!-- List&lt;Employee&gt; selectEmployeeByConditionByChoose(Employee employee) --&gt;&lt;select id=&quot;selectEmployeeByConditionByChoose&quot; resultType=&quot;com.atguigu.mybatis.entity.Employee&quot;&gt; select emp_id,emp_name,emp_salary from t_emp where &lt;choose&gt; &lt;when test=&quot;empName != null&quot;&gt;emp_name=#&#123;empName&#125;&lt;/when&gt; &lt;when test=&quot;empSalary &amp;lt; 3000&quot;&gt;emp_salary &amp;lt; 3000&lt;/when&gt; &lt;otherwise&gt;1=1&lt;/otherwise&gt; &lt;/choose&gt; &lt;!-- 第一种情况：第一个when满足条件 where emp_name=? 第二种情况：第二个when满足条件 where emp_salary &lt; 3000 第三种情况：两个when都不满足 where 1=1 执行了otherwise --&gt;&lt;/select&gt; 4.6 foreach标签基本用法 用批量插入举例 1234567891011121314&lt;!-- collection属性：要遍历的集合 item属性：遍历集合的过程中能得到每一个具体对象，在item属性中设置一个名字，将来通过这个名字引用遍历出来的对象 separator属性：指定当foreach标签的标签体重复拼接字符串时，各个标签体字符串之间的分隔符 open属性：指定整个循环把字符串拼好后，字符串整体的前面要添加的字符串 close属性：指定整个循环把字符串拼好后，字符串整体的后面要添加的字符串 index属性：这里起一个名字，便于后面引用 遍历List集合，这里能够得到List集合的索引值 遍历Map集合，这里能够得到Map集合的key --&gt;&lt;foreach collection=&quot;empList&quot; item=&quot;emp&quot; separator=&quot;,&quot; open=&quot;values&quot; index=&quot;myIndex&quot;&gt; &lt;!-- 在foreach标签内部如果需要引用遍历得到的具体的一个对象，需要使用item属性声明的名称 --&gt; (#&#123;emp.empName&#125;,#&#123;myIndex&#125;,#&#123;emp.empSalary&#125;,#&#123;emp.empGender&#125;)&lt;/foreach&gt; 批量更新时需要注意 上面批量插入的例子本质上是一条SQL语句，而实现批量更新则需要多条SQL语句拼起来，用分号分开。也就是一次性发送多条SQL语句让数据库执行。此时需要在数据库连接信息的URL地址中设置： 1atguigu.dev.url=jdbc:mysql:///mybatis-example?allowMultiQueries=true 对应的foreach标签如下： 123456&lt;!-- int updateEmployeeBatch(@Param(&quot;empList&quot;) List&lt;Employee&gt; empList) --&gt;&lt;update id=&quot;updateEmployeeBatch&quot;&gt; &lt;foreach collection=&quot;empList&quot; item=&quot;emp&quot; separator=&quot;;&quot;&gt; update t_emp set emp_name=#&#123;emp.empName&#125; where emp_id=#&#123;emp.empId&#125; &lt;/foreach&gt;&lt;/update&gt; 关于foreach标签的collection属性 如果没有给接口中List类型的参数使用@Param注解指定一个具体的名字，那么在collection属性中默认可以使用collection或list来引用这个list集合。这一点可以通过异常信息看出来： 1Parameter &#x27;empList&#x27; not found. Available parameters are [arg0, collection, list] 在实际开发中，为了避免隐晦的表达造成一定的误会，建议使用@Param注解明确声明变量的名称，然后在foreach标签的collection属性中按照@Param注解指定的名称来引用传入的参数。 4.7 sql片段抽取重复的SQL片段 1234&lt;!-- 使用sql标签抽取重复出现的SQL片段 --&gt;&lt;sql id=&quot;mySelectSql&quot;&gt; select emp_id,emp_name,emp_age,emp_salary,emp_gender from t_emp&lt;/sql&gt; 引用已抽取的SQL片段 12&lt;!-- 使用include标签引用声明的SQL片段 --&gt;&lt;include refid=&quot;mySelectSql&quot;/&gt; 五、MyBatis高级扩展5.1 Mapper批量映射优化 需求 Mapper 配置文件很多时，在全局配置文件中一个一个注册太麻烦，希望有一个办法能够一劳永逸。 配置方式 Mybatis 允许在指定 Mapper 映射文件时，只指定其所在的包： 123&lt;mappers&gt; &lt;package name=&quot;com.atguigu.mapper&quot;/&gt;&lt;/mappers&gt; 此时这个包下的所有 Mapper 配置文件将被自动加载、注册，比较方便。 资源创建要求 Mapper 接口和 Mapper 配置文件名称一致 Mapper 接口：EmployeeMapper.java Mapper 配置文件：EmployeeMapper.xml Mapper 配置文件放在 Mapper 接口所在的包内 可以将mapperxml文件放在mapper接口所在的包！ 可以在sources下创建mapper接口包一致的文件夹结构存放mapperxml文件 5.2 插件和分页插件PageHelper5.2.1 插件机制和PageHelper插件介绍MyBatis 对插件进行了标准化的设计，并提供了一套可扩展的插件机制。插件可以在用于语句执行过程中进行拦截，并允许通过自定义处理程序来拦截和修改 SQL 语句、映射语句的结果等。 具体来说，MyBatis 的插件机制包括以下三个组件： Interceptor（拦截器）：定义一个拦截方法 intercept，该方法在执行 SQL 语句、执行查询、查询结果的映射时会被调用。 Invocation（调用）：实际上是对被拦截的方法的封装，封装了 Object target、Method method 和 Object[] args 这三个字段。 InterceptorChain（拦截器链）：对所有的拦截器进行管理，包括将所有的 Interceptor 链接成一条链，并在执行 SQL 语句时按顺序调用。 插件的开发非常简单，只需要实现 Interceptor 接口，并使用注解 @Intercepts 来标注需要拦截的对象和方法，然后在 MyBatis 的配置文件中添加插件即可。 PageHelper 是 MyBatis 中比较著名的分页插件，它提供了多种分页方式（例如 MySQL 和 Oracle 分页方式），支持多种数据库，并且使用非常简单。下面就介绍一下 PageHelper 的使用方式。 https://github.com/pagehelper/Mybatis-PageHelper/blob/master/wikis/zh/HowToUse.md#如何配置数据库方言 5.2.2 PageHelper插件使用 pom.xml引入依赖 123456&lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper&lt;/artifactId&gt; &lt;version&gt;5.1.11&lt;/version&gt;&lt;/dependency&gt; mybatis-config.xml配置分页插件 在 MyBatis 的配置文件中添加 PageHelper 的插件： 123456&lt;plugins&gt; &lt;plugin interceptor=&quot;com.github.pagehelper.PageInterceptor&quot;&gt; &lt;property name=&quot;helperDialect&quot; value=&quot;mysql&quot;/&gt; &lt;/plugin&gt;&lt;/plugins&gt; 其中，com.github.pagehelper.PageInterceptor 是 PageHelper 插件的名称，dialect 属性用于指定数据库类型（支持多种数据库） 页插件使用 在查询方法中使用分页： 12345678910111213141516171819202122232425@Testpublic void testTeacherRelationshipToMulti() &#123; TeacherMapper teacherMapper = session.getMapper(TeacherMapper.class); PageHelper.startPage(1,2); // 查询Customer对象同时将关联的Order集合查询出来 List&lt;Teacher&gt; allTeachers = teacherMapper.findAllTeachers();// PageInfo&lt;Teacher&gt; pageInfo = new PageInfo&lt;&gt;(allTeachers); System.out.println(&quot;pageInfo = &quot; + pageInfo); long total = pageInfo.getTotal(); // 获取总记录数 System.out.println(&quot;total = &quot; + total); int pages = pageInfo.getPages(); // 获取总页数 System.out.println(&quot;pages = &quot; + pages); int pageNum = pageInfo.getPageNum(); // 获取当前页码 System.out.println(&quot;pageNum = &quot; + pageNum); int pageSize = pageInfo.getPageSize(); // 获取每页显示记录数 System.out.println(&quot;pageSize = &quot; + pageSize); List&lt;Teacher&gt; teachers = pageInfo.getList(); //获取查询页的数据集合 System.out.println(&quot;teachers = &quot; + teachers); teachers.forEach(System.out::println);&#125; 5.3 逆向工程和MybatisX插件5.3.1 ORM思维介绍ORM（Object-Relational Mapping，对象-关系映射）是一种将数据库和面向对象编程语言中的对象之间进行转换的技术。它将对象和关系数据库的概念进行映射，最后我们就可以通过方法调用进行数据库操作!! 最终: 让我们可以使用面向对象思维进行数据库操作！！！ ORM 框架通常有半自动和全自动两种方式。 半自动 ORM 通常需要程序员手动编写 SQL 语句或者配置文件，将实体类和数据表进行映射，还需要手动将查询的结果集转换成实体对象。 全自动 ORM 则是将实体类和数据表进行自动映射，使用 API 进行数据库操作时，ORM 框架会自动执行 SQL 语句并将查询结果转换成实体对象，程序员无需再手动编写 SQL 语句和转换代码。 下面是半自动和全自动 ORM 框架的区别： 映射方式：半自动 ORM 框架需要程序员手动指定实体类和数据表之间的映射关系，通常使用 XML 文件或注解方式来指定；全自动 ORM 框架则可以自动进行实体类和数据表的映射，无需手动干预。 查询方式：半自动 ORM 框架通常需要程序员手动编写 SQL 语句并将查询结果集转换成实体对象；全自动 ORM 框架可以自动组装 SQL 语句、执行查询操作，并将查询结果转换成实体对象。 性能：由于半自动 ORM 框架需要手动编写 SQL 语句，因此程序员必须对 SQL 语句和数据库的底层知识有一定的了解，才能编写高效的 SQL 语句；而全自动 ORM 框架通过自动优化生成的 SQL 语句来提高性能，程序员无需进行优化。 学习成本：半自动 ORM 框架需要程序员手动编写 SQL 语句和映射配置，要求程序员具备较高的数据库和 SQL 知识；全自动 ORM 框架可以自动生成 SQL 语句和映射配置，程序员无需了解过多的数据库和 SQL 知识。 常见的半自动 ORM 框架包括 MyBatis 等；常见的全自动 ORM 框架包括 Hibernate、Spring Data JPA、MyBatis-Plus 等。 5.3.2 逆向工程&#x20; MyBatis 的逆向工程是一种自动化生成持久层代码和映射文件的工具，它可以根据数据库表结构和设置的参数生成对应的实体类、Mapper.xml 文件、Mapper 接口等代码文件，简化了开发者手动生成的过程。逆向工程使开发者可以快速地构建起 DAO 层，并快速上手进行业务开发。&#x20; MyBatis 的逆向工程有两种方式：通过 MyBatis Generator 插件实现和通过 Maven 插件实现。无论是哪种方式，逆向工程一般需要指定一些配置参数，例如数据库连接 URL、用户名、密码、要生成的表名、生成的文件路径等等。&#x20; 总的来说，MyBatis 的逆向工程为程序员提供了一种方便快捷的方式，能够快速地生成持久层代码和映射文件，是半自动 ORM 思维像全自动发展的过程，提高程序员的开发效率。 注意：逆向工程只能生成单表crud的操作，多表查询依然需要我们自己编写！ 5.3.3 逆向工程插件MyBatisX使用&#x20; MyBatisX 是一个 MyBatis 的代码生成插件，可以通过简单的配置和操作快速生成 MyBatis Mapper、pojo 类和 Mapper.xml 文件。下面是使用 MyBatisX 插件实现逆向工程的步骤： 安装插件： 在 IntelliJ IDEA 中打开插件市场，搜索 MyBatisX 并安装。 使用 IntelliJ IDEA连接数据库 连接数据库 填写信息 展示库表 逆向工程使用 查看生成结果 逆向工程案例使用 正常使用即可，自动生成单表的crud方法！ 1234567891011121314151617181920212223242526package com.atguigu.mapper;import com.atguigu.pojo.User;/*** @author Jackiechan* @description 针对表【user】的数据库操作Mapper* @createDate 2023-06-02 16:55:32* @Entity com.atguigu.pojo.User*/public interface UserMapper &#123; int deleteByPrimaryKey(Long id); int insert(User record); int insertSelective(User record); User selectByPrimaryKey(Long id); int updateByPrimaryKeySelective(User record); int updateByPrimaryKey(User record);&#125; 六、MyBatis总结 核心点 掌握目标 mybatis基础 使用流程, 参数输入,#{} ${},参数输出 mybatis多表 实体类设计,resultMap多表结果映射 mybatis动态语句 Mybatis动态语句概念, where , if , foreach标签 mybatis扩展 Mapper批量处理,分页插件,逆向工程","categories":[{"name":"SSM框架","slug":"SSM框架","permalink":"http://example.com/categories/SSM%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"ssm","slug":"ssm","permalink":"http://example.com/tags/ssm/"}]},{"title":"二、SpringFramework实战指南","slug":"SSM/二、SpringFramework实战指南/二、SpringFramework实战指南","date":"2022-09-27T23:55:54.000Z","updated":"2023-09-28T00:25:50.767Z","comments":true,"path":"2022/09/28/SSM/二、SpringFramework实战指南/二、SpringFramework实战指南/","link":"","permalink":"http://example.com/2022/09/28/SSM/%E4%BA%8C%E3%80%81SpringFramework%E5%AE%9E%E6%88%98%E6%8C%87%E5%8D%97/%E4%BA%8C%E3%80%81SpringFramework%E5%AE%9E%E6%88%98%E6%8C%87%E5%8D%97/","excerpt":"","text":"二、SpringFramework实战指南目录 一、技术体系结构 1.1 总体技术体系 1.2 框架概念和理解 二、SpringFramework介绍 2.1 Spring 和 SpringFramework概念 2.2 SpringFramework主要功能模块 2.3 SpringFramework 主要优势 三、Spring IoC容器和核心概念 3.1 组件和组件管理概念 3.2 Spring IoC容器和容器实现 3.3 Spring IoC &#x2F; DI概念总结 四、Spring IoC实践和应用 4.1 Spring IoC &#x2F; DI 实现步骤 4.2 基于XML配置方式组件管理 4.2.1 实验一： 组件（Bean）信息声明配置（IoC） 4.2.2 实验二： 组件（Bean）依赖注入配置（DI） 4.2.3 实验三： IoC容器创建和使用 4.2.4 实验四： 高级特性：组件（Bean）作用域和周期方法配置 4.2.5 实验五： 高级特性：FactoryBean特性和使用 4.2.6 实验六： 基于XML方式整合三层架构组件 4.3 基于 注解 方式管理 Bean 4.3.1 实验一： Bean注解标记和扫描 (IoC) 4.3.2 实验二： 组件（Bean）作用域和周期方法注解 4.3.3 实验三： Bean属性赋值：引用类型自动装配 (DI) 4.3.4 实验四： Bean属性赋值：基本类型属性赋值 (DI) 4.3.5 实验五： 基于注解+XML方式整合三层架构组件 4.4 基于 配置类 方式管理 Bean 4.4.1 完全注解开发理解 4.4.2 实验一：配置类和扫描注解 4.4.3 实验二：@Bean定义组件 4.4.4 实验三：高级特性：@Bean注解细节 4.4.5 实验四：高级特性：@Import扩展 4.4.6 实验五：基于注解+配置类方式整合三层架构组件 4.5 三种配置方式总结 4.5.1 XML方式配置总结 4.5.2 XML+注解方式配置总结 4.5.3 完全注解方式配置总结 4.6 整合Spring5-Test5搭建测试环境 五、Spring AOP面向切面编程 5.1 场景设定和问题复现 5.2 解决技术代理模式 5.3 面向切面编程思维（AOP） 5.4 Spring AOP框架介绍和关系梳理 5.5 Spring AOP基于注解方式实现和细节 5.5.1 Spring AOP底层技术组成 5.5.2 初步实现 5.5.3 获取通知细节信息 5.5.4 切点表达式语法 5.5.5 重用（提取）切点表达式 5.5.6 环绕通知 5.5.7 切面优先级设置 5.5.8 CGLib动态代理生效 5.5.9 注解实现小结 5.6 Spring AOP基于XML方式实现(了解) 5.7 Spring AOP对获取Bean的影响理解 5.7.1 根据类型装配 bean 5.7.2 使用总结 六、Spring 声明式事务 6.1 声明式事务概念 6.1.1 编程式事务 6.1.2 声明式事务 6.1.3 Spring事务管理器 6.2 基于注解的声明式事务 6.2.1 准备工作 6.2.2 基本事务控制 6.2.3 事务属性：只读 6.2.4 事务属性：超时时间 6.2.5 事务属性：事务异常 6.2.6 事务属性：事务隔离级别 6.2.7 事务属性：事务传播行为 七、Spring核心掌握总结 一、技术体系结构1.1 总体技术体系 单一架构 一个项目，一个工程，导出为一个war包，在一个Tomcat上运行。也叫all in one。 单一架构，项目主要应用技术框架为：Spring , SpringMVC , Mybatis 分布式架构 一个项目（对应 IDEA 中的一个 project），拆分成很多个模块，每个模块是一个 IDEA 中的一个 module。每一个工程都是运行在自己的 Tomcat 上。模块之间可以互相调用。每一个模块内部可以看成是一个单一架构的应用。 分布式架构，项目主要应用技术框架：SpringBoot (SSM), SpringCloud , 中间件等 1.2 框架概念和理解框架( Framework )是一个集成了基本结构、规范、设计模式、编程语言和程序库等基础组件的软件系统，它可以用来构建更高级别的应用程序。框架的设计和实现旨在解决特定领域中的常见问题，帮助开发人员更高效、更稳定地实现软件开发目标。 框架的优点包括以下几点： 提高开发效率：框架提供了许多预先设计好了的组件和工具，能够帮助开发人员快速进行开发。相较于传统手写代码，在框架提供的规范化环境中，开发者可以更快地实现项目的各种要求。 降低开发成本：框架的提供标准化的编程语言、数据操作等代码片段，避免了重复开发的问题，降低了开发成本，提供深度优化的系统，降低了维护成本，增强了系统的可靠性。 提高应用程序的稳定性：框架通常经过了很长时间的开发和测试，其中的许多组件、代码片段和设计模式都得到了验证。重复利用这些组件有助于减少bug的出现，从而提高了应用程序的稳定性。 提供标准化的解决方案：框架通常是针对某个特定领域的，通过提供标准化的解决方案，可以为开发人员提供一种共同的语言和思想基础，有助于更好地沟通和协作。 框架的缺点包括以下几个方面： 学习成本高：框架通常具有特定的语言和编程范式。对于开发人员而言，需要花费时间学习其背后的架构、模式和逻辑，这对于新手而言可能会耗费较长时间。 可能存在局限性：虽然框架提高了开发效率并可以帮助开发人员解决常见问题，但是在某些情况下，特定的应用需求可能超出框架的范围，从而导致应用程序无法满足要求。开发人员可能需要更多的控制权和自由度，同时需要在框架和应用程序之间进行权衡取舍。 版本变更和兼容性问题：框架的版本发布和迭代通常会导致代码库的大规模变更，进而导致应用程序出现兼容性问题和漏洞。当框架变更时，需要考虑框架是否向下兼容，以及如何进行适当的测试、迁移和升级。 架构风险：框架涉及到很多抽象和概念，如果开发者没有足够的理解和掌握其架构，可能会导致系统出现设计和架构缺陷，从而影响系统的健康性和安全性。 站在文件结构的角度理解框架，可以将框架总结：框架 &#x3D; jar包+配置文件 莎士比亚说,”一千个观众眼中有一千个哈姆雷特” 即仁者见仁,智者见智.说每个人都会对作品有不同的理解，每个人对待任何事物都有自己的看法，同样的技术解决同样的问题会产生不同流程和风格的解决方案，而采用一种框架其实就是限制用户必须使用其规定的方案来实现，可以降低程序员之间沟通以及日后维护的成本！ 常用的单一架构JavaEE项目框架演进，从SSH、SSH2过渡到了SSM：SpringMVC、Spring、MyBatis。 总之，框架已经对基础的代码进行了封装并提供相应的API，开发者在使用框架是直接调用封装好的API可以省去很多代码编写，从而提高工作效率和开发速度。 二、SpringFramework介绍2.1 Spring 和 SpringFramework概念https://spring.io/projects 广义的 Spring：Spring 技术栈（全家桶） 广义上的 Spring 泛指以 Spring Framework 为基础的 Spring 技术栈。 经过十多年的发展，Spring 已经不再是一个单纯的应用框架，而是逐渐发展成为一个由多个不同子项目（模块）组成的成熟技术，例如 Spring Framework、Spring MVC、SpringBoot、Spring Cloud、Spring Data、Spring Security 等，其中 Spring Framework 是其他子项目的基础。 这些子项目涵盖了从企业级应用开发到云计算等各方面的内容，能够帮助开发人员解决软件发展过程中不断产生的各种实际问题，给开发人员带来了更好的开发体验。 狭义的 Spring：Spring Framework（基础框架） 狭义的 Spring 特指 Spring Framework，通常我们将它称为 Spring 框架。 Spring Framework（Spring框架）是一个开源的应用程序框架，由SpringSource公司开发，最初是为了解决企业级开发中各种常见问题而创建的。它提供了很多功能，例如：依赖注入（Dependency Injection）、面向切面编程（AOP）、声明式事务管理（TX）等。其主要目标是使企业级应用程序的开发变得更加简单和快速，并且Spring框架被广泛应用于Java企业开发领域。 Spring全家桶的其他框架都是以SpringFramework框架为基础！ 对比理解： QQ 和 腾讯 腾讯 &#x3D; Spring QQ &#x3D; SpringFramework 2.2 SpringFramework主要功能模块SpringFramework框架结构图： 功能模块 功能介绍 Core Container 核心容器，在 Spring 环境下使用任何功能都必须基于 IOC 容器。 AOP&amp;Aspects 面向切面编程 TX 声明式事务管理。 Spring MVC 提供了面向Web应用程序的集成功能。 2.3 SpringFramework 主要优势 丰富的生态系统：Spring 生态系统非常丰富，支持许多模块和库，如 Spring Boot、Spring Security、Spring Cloud 等等，可以帮助开发人员快速构建高可靠性的企业应用程序。 模块化的设计：框架组件之间的松散耦合和模块化设计使得 Spring Framework 具有良好的可重用性、可扩展性和可维护性。开发人员可以轻松地选择自己需要的模块，根据自己的需求进行开发。 简化 Java 开发：Spring Framework 简化了 Java 开发，提供了各种工具和 API，可以降低开发复杂度和学习成本。同时，Spring Framework 支持各种应用场景，包括 Web 应用程序、RESTful API、消息传递、批处理等等。 不断创新和发展：Spring Framework 开发团队一直在不断创新和发展，保持与最新技术的接轨，为开发人员提供更加先进和优秀的工具和框架。 因此，这些优点使得 Spring Framework 成为了一个稳定、可靠、且创新的框架，为企业级 Java 开发提供了一站式的解决方案。 Spring 使创建 Java 企业应用程序变得容易。它提供了在企业环境中采用 Java 语言所需的一切，支持 Groovy 和 Kotlin 作为 JVM 上的替代语言，并且可以根据应用程序的需求灵活地创建多种架构。从Spring Framework 6.0.6开始，Spring 需要 Java 17+。 三、Spring IoC容器和核心概念3.1 组件和组件管理概念 3.1.1 什么是组件? 回顾常规的三层架构处理请求流程： 整个项目就是由各种组件搭建而成的： 3.1.2 我们的期待 有人替我们创建组件的对象 有人帮我们保存组件的对象 有人帮助我们自动组装 有人替我们管理事务 有人协助我们整合其他框架 …… 3.1.3 Spring充当组件管理角色（IoC） 那么谁帮我们完成我们的期待，帮我们管理组件呢？ 当然是Spring 框架了！ 组件可以完全交给Spring 框架进行管理，Spring框架替代了程序员原有的new对象和对象属性赋值动作等！ Spring具体的组件管理动作包含： 组件对象实例化 组件属性属性赋值 组件对象之间引用 组件对象存活周期管理 ……我们只需要编写元数据（配置文件）告知Spring 管理哪些类组件和他们的关系即可！注意：组件是映射到应用程序中所有可重用组件的Java对象，应该是可复用的功能对象！ 组件一定是对象 对象不一定是组件综上所述，Spring 充当一个组件容器，创建、管理、存储组件，减少了我们的编码压力，让我们更加专注进行业务编写！ 3.1.4 组件交给Spring管理优势! 降低了组件之间的耦合性：Spring IoC容器通过依赖注入机制，将组件之间的依赖关系削弱，减少了程序组件之间的耦合性，使得组件更加松散地耦合。 提高了代码的可重用性和可维护性：将组件的实例化过程、依赖关系的管理等功能交给Spring IoC容器处理，使得组件代码更加模块化、可重用、更易于维护。 方便了配置和管理：Spring IoC容器通过XML文件或者注解，轻松的对组件进行配置和管理，使得组件的切换、替换等操作更加的方便和快捷。 交给Spring管理的对象（组件），方可享受Spring框架的其他功能（AOP,声明事务管理）等 3.2 Spring IoC容器和容器实现 3.2.1 普通和复杂容器 普通容器 生活中的普通容器 普通容器只能用来存储，没有更多功能。程序中的普通容器 数组 集合：List 集合：Set复杂容器生活中的复杂容器 政府管理我们的一生，生老病死都和政府有关。程序中的复杂容器Servlet 容器能够管理 Servlet(init,service,destroy)、Filter、Listener 这样的组件的一生，所以它是一个复杂容器。 名称 时机 次数 创建对象 默认情况：接收到第一次请求 &#xA;修改启动顺序后：Web应用启动过程中 一次 初始化操作 创建对象之后 一次 处理请求 接收到请求 多次 销毁操作 Web应用卸载之前 一次 我们即将要学习的 SpringIoC 容器也是一个复杂容器。它们不仅要负责创建组件的对象、存储组件的对象，还要负责调用组件的方法让它们工作，最终在特定情况下销毁组件。 总结：Spring管理组件的容器，就是一个复杂容器，不仅存储组件，也可以管理组件之间依赖关系，并且创建和销毁组件等！ 3.2.2 SpringIoC容器介绍 Spring IoC 容器，负责实例化、配置和组装 bean（组件）。容器通过读取配置元数据来获取有关要实例化、配置和组装组件的指令。配置元数据以 XML、Java 注解或 Java 代码形式表现。它允许表达组成应用程序的组件以及这些组件之间丰富的相互依赖关系。 上图显示了 Spring 容器工作原理的高级视图。应用程序类与配置元数据相结合，您拥有完全配置且可执行的系统或应用程序。 3.2.3 SpringIoC容器具体接口和实现类 SpringIoc容器接口：&#x20; BeanFactory 接口提供了一种高级配置机制，能够管理任何类型的对象，它是SpringIoC容器标准化超接口！ ApplicationContext 是 BeanFactory 的子接口。它扩展了以下功能： 更容易与 Spring 的 AOP 功能集成 消息资源处理（用于国际化） 特定于应用程序给予此接口实现，例如Web 应用程序的 WebApplicationContext简而言之， BeanFactory 提供了配置框架和基本功能，而 ApplicationContext 添加了更多特定于企业的功能。 ApplicationContext 是 BeanFactory 的完整超集！ApplicationContext容器实现类： 类型名 简介 ClassPathXmlApplicationContext 通过读取类路径下的 XML 格式的配置文件创建 IOC 容器对象 FileSystemXmlApplicationContext 通过文件系统路径读取 XML 格式的配置文件创建 IOC 容器对象 AnnotationConfigApplicationContext 通过读取Java配置类创建 IOC 容器对象 WebApplicationContext 专门为 Web 应用准备，基于 Web 环境创建 IOC 容器对象，并将对象引入存入 ServletContext 域中。 3.2.4 SpringIoC容器管理配置方式 Spring IoC 容器使用多种形式的配置元数据。此配置元数据表示您作为应用程序开发人员如何告诉 Spring 容器实例化、配置和组装应用程序中的对象。 Spring框架提供了多种配置方式：XML配置方式、注解方式和Java配置类方式 XML配置方式：是Spring框架最早的配置方式之一，通过在XML文件中定义Bean及其依赖关系、Bean的作用域等信息，让Spring IoC容器来管理Bean之间的依赖关系。该方式从Spring框架的第一版开始提供支持。 注解方式：从Spring 2.5版本开始提供支持，可以通过在Bean类上使用注解来代替XML配置文件中的配置信息。通过在Bean类上加上相应的注解（如@Component, @Service, @Autowired等），将Bean注册到Spring IoC容器中，这样Spring IoC容器就可以管理这些Bean之间的依赖关系。 Java配置类方式：从Spring 3.0版本开始提供支持，通过Java类来定义Bean、Bean之间的依赖关系和配置信息，从而代替XML配置文件的方式。Java配置类是一种使用Java编写配置信息的方式，通过@Configuration、@Bean等注解来实现Bean和依赖关系的配置。为了迎合当下开发环境，我们将以配置类+注解方式为主进行讲解！ 3.3 Spring IoC &#x2F; DI概念总结 IoC容器 Spring IoC 容器，负责实例化、配置和组装 bean（组件）核心容器。容器通过读取配置元数据来获取有关要实例化、配置和组装组件的指令。 IoC（Inversion of Control）控制反转 IoC 主要是针对对象的创建和调用控制而言的，也就是说，当应用程序需要使用一个对象时，不再是应用程序直接创建该对象，而是由 IoC 容器来创建和管理，即控制权由应用程序转移到 IoC 容器中，也就是“反转”了控制权。这种方式基本上是通过依赖查找的方式来实现的，即 IoC 容器维护着构成应用程序的对象，并负责创建这些对象。 DI (Dependency Injection) 依赖注入 DI 是指在组件之间传递依赖关系的过程中，将依赖关系在容器内部进行处理，这样就不必在应用程序代码中硬编码对象之间的依赖关系，实现了对象之间的解耦合。在 Spring 中，DI 是通过 XML 配置文件或注解的方式实现的。它提供了三种形式的依赖注入：构造函数注入、Setter 方法注入和接口注入。 四、Spring IoC实践和应用4.1 Spring IoC &#x2F; DI 实现步骤 我们总结下，组件交给Spring IoC容器管理，并且获取和使用的基本步骤！ 配置元数据（配置） 配置元数据，既是编写交给SpringIoC容器管理组件的信息，配置方式有三种。 基于 XML 的配置元数据的基本结构： &lt;bean id&#x3D;”…” [1] class&#x3D;”…” [2]&gt; &#x20;&#x20; &lt;!– collaborators and configuration for this bean go here –&gt;&#x20; &lt;&#x2F;bean&gt; 12345678910111213141516&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!-- 此处要添加一些约束，配置文件的标签并不是随意命名 --&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id=&quot;...&quot; [1] class=&quot;...&quot; [2]&gt; &lt;!-- collaborators and configuration for this bean go here --&gt; &lt;/bean&gt; &lt;bean id=&quot;...&quot; class=&quot;...&quot;&gt; &lt;!-- collaborators and configuration for this bean go here --&gt; &lt;/bean&gt; &lt;!-- more bean definitions go here --&gt;&lt;/beans&gt; Spring IoC 容器管理一个或多个组件。这些 组件是使用你提供给容器的配置元数据（例如，以 XML &lt;bean/&gt; 定义的形式）创建的。 &lt;bean &#x2F;&gt; 标签 &#x3D;&#x3D; 组件信息声明 id 属性是标识单个 Bean 定义的字符串。 class 属性定义 Bean 的类型并使用完全限定的类名。 实例化IoC容器 提供给 ApplicationContext 构造函数的位置路径是资源字符串地址，允许容器从各种外部资源（如本地文件系统、Java CLASSPATH 等）加载配置元数据。 我们应该选择一个合适的容器实现类，进行IoC容器的实例化工作： 123//实例化ioc容器,读取外部配置文件,最终会在容器内进行ioc和di动作ApplicationContext context = new ClassPathXmlApplicationContext(&quot;services.xml&quot;, &quot;daos.xml&quot;); 获取Bean（组件） ApplicationContext 是一个高级工厂的接口，能够维护不同 bean 及其依赖项的注册表。通过使用方法 T getBean(String name, Class&lt;T&gt; requiredType) ，您可以检索 bean 的实例。 允许读取 Bean 定义并访问它们，如以下示例所示： 123456//创建ioc容器对象，指定配置文件，ioc也开始实例组件对象ApplicationContext context = new ClassPathXmlApplicationContext(&quot;services.xml&quot;, &quot;daos.xml&quot;);//获取ioc容器的组件对象PetStoreService service = context.getBean(&quot;petStore&quot;, PetStoreService.class);//使用组件对象List&lt;String&gt; userList = service.getUsernameList(); 4.2 基于XML配置方式组件管理4.2.1 实验一： 组件（Bean）信息声明配置（IoC） 目标 Spring IoC 容器管理一个或多个 bean。这些 Bean 是使用您提供给容器的配置元数据创建的（例如，以 XML &lt;bean/&gt; 定义的形式）。 我们学习，如何通过定义XML配置文件，声明组件类信息，交给 Spring 的 IoC 容器进行组件管理！ 思路 准备项目 创建maven工程（spring-ioc-xml-01） 导入SpringIoC相关依赖 pom.xml 123456789101112131415&lt;dependencies&gt; &lt;!--spring context依赖--&gt; &lt;!--当你引入Spring Context依赖之后，表示将Spring的基础依赖引入了--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;6.0.6&lt;/version&gt; &lt;/dependency&gt; &lt;!--junit5测试--&gt; &lt;dependency&gt; &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt; &lt;artifactId&gt;junit-jupiter-api&lt;/artifactId&gt; &lt;version&gt;5.3.1&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 基于无参数构造函数 当通过构造函数方法创建一个 bean（组件对象） 时，所有普通类都可以由 Spring 使用并与之兼容。也就是说，正在开发的类不需要实现任何特定的接口或以特定的方式进行编码。只需指定 Bean 类信息就足够了。但是，默认情况下，我们需要一个默认（空）构造函数。 准备组件类1package com.atguigu.ioc; public class HappyComponent &#123; //默认包含无参数构造函数 public void doWork() &#123; System.out.println(&quot;HappyComponent.doWork&quot;); &#125; &#125; 1234567891011122. xml配置文件编写 创建携带spring约束的xml配置文件 ![](image/image_VcUvHx6Air.png) 编写配置文件： 文件：resources/spring-bean-01.xml ```java &lt;!-- 实验一 [重要]创建bean --&gt; &lt;bean id=&quot;happyComponent&quot; class=&quot;com.atguigu.ioc.HappyComponent&quot;/&gt; - bean标签：通过配置bean标签告诉IOC容器需要创建对象的组件信息 - id属性：bean的唯一标识,方便后期获取Bean！ - class属性：组件类的全限定符！ - 注意：要求当前组件类必须包含无参数构造函数！ 基于静态工厂方法实例化 除了使用构造函数实例化对象，还有一类是通过工厂模式实例化对象。接下来我们讲解如何定义使用静态工厂方法创建Bean的配置 ！ 准备组件类123public class ClientService &#123; private static ClientService clientService = new ClientService(); private ClientService() &#123;&#125; public static ClientService createInstance() &#123; return clientService; &#125; &#125; 12345672. xml配置文件编写 文件：resources/spring-bean-01.xml ```xml &lt;bean id=&quot;clientService&quot; class=&quot;examples.ClientService&quot; factory-method=&quot;createInstance&quot;/&gt; - class属性：指定工厂类的全限定符！ - factory-method: 指定静态工厂方法，注意，该方法必须是static方法。 基于实例工厂方法实例化 接下来我们讲解下如何定义使用实例工厂方法创建Bean的配置 ！ 准备组建类1public class DefaultServiceLocator &#123; private static ClientServiceImplclientService = new ClientServiceImpl(); public ClientService createClientServiceInstance() &#123; return clientService; &#125; &#125; 1234567891011122. xml配置文件编写 文件：resources/spring-bean-01.xml ```xml &lt;!-- 将工厂类进行ioc配置 --&gt; &lt;bean id=&quot;serviceLocator&quot; class=&quot;examples.DefaultServiceLocator&quot;&gt; &lt;/bean&gt; &lt;!-- 根据工厂对象的实例工厂方法进行实例化组件对象 --&gt; &lt;bean id=&quot;clientService&quot; factory-bean=&quot;serviceLocator&quot; factory-method=&quot;createClientServiceInstance&quot;/&gt; - factory-bean属性：指定当前容器中工厂Bean 的名称。 - factory-method: 指定实例工厂方法名。注意，实例方法必须是非static的！ 图解IoC配置流程 4.2.2 实验二： 组件（Bean）依赖注入配置（DI） 目标 通过配置文件,实现IoC容器中Bean之间的引用（依赖注入DI配置）。 主要涉及注入场景：基于构造函数的依赖注入和基于 Setter 的依赖注入。 思路 基于构造函数的依赖注入（单个构造参数） 介绍 基于构造函数的 DI 是通过容器调用具有多个参数的构造函数来完成的，每个参数表示一个依赖项。 下面的示例演示一个只能通过构造函数注入进行依赖项注入的类！ 准备组件类 12public class UserDao &#123;&#125; public class UserService { private UserDao userDao; public UserService(UserDao userDao) &#123; this.userDao = userDao; &#125; } 123456789101112133. 编写配置文件 文件：resources/spring-02.xml ```xml &lt;beans&gt; &lt;!-- 引用类bean声明 --&gt; &lt;bean id=&quot;userService&quot; class=&quot;x.y.UserService&quot;&gt; &lt;!-- 构造函数引用 --&gt; &lt;constructor-arg ref=&quot;userDao&quot;/&gt; &lt;/bean&gt; &lt;!-- 被引用类bean声明 --&gt; &lt;bean id=&quot;userDao&quot; class=&quot;x.y.UserDao&quot;/&gt; &lt;/beans&gt; constructor-arg标签：可以引用构造参数 ref引用其他bean的标识。 基于构造函数的依赖注入（多构造参数解析） 介绍 基于构造函数的 DI 是通过容器调用具有多个参数的构造函数来完成的，每个参数表示一个依赖项。 下面的示例演示通过构造函数注入多个参数，参数包含其他bean和基本数据类型！ 准备组件类 12public class UserDao &#123;&#125; public class UserService { private UserDao userDao; private int age; private String name; public UserService(int age , String name ,UserDao userDao) &#123; this.userDao = userDao; this.age = age; this.name = name; &#125; } 1234567891011121314151617181920212223242526272829303132333435363738394041423. 编写配置文件 ```xml &lt;!-- 场景1: 多参数，可以按照相应构造函数的顺序注入数据 --&gt; &lt;beans&gt; &lt;bean id=&quot;userService&quot; class=&quot;x.y.UserService&quot;&gt; &lt;!-- value直接注入基本类型值 --&gt; &lt;constructor-arg value=&quot;18&quot;/&gt; &lt;constructor-arg value=&quot;赵伟风&quot;/&gt; &lt;constructor-arg ref=&quot;userDao&quot;/&gt; &lt;/bean&gt; &lt;!-- 被引用类bean声明 --&gt; &lt;bean id=&quot;userDao&quot; class=&quot;x.y.UserDao&quot;/&gt; &lt;/beans&gt; &lt;!-- 场景2: 多参数，可以按照相应构造函数的名称注入数据 --&gt; &lt;beans&gt; &lt;bean id=&quot;userService&quot; class=&quot;x.y.UserService&quot;&gt; &lt;!-- value直接注入基本类型值 --&gt; &lt;constructor-arg name=&quot;name&quot; value=&quot;赵伟风&quot;/&gt; &lt;constructor-arg name=&quot;userDao&quot; ref=&quot;userDao&quot;/&gt; &lt;constructor-arg name=&quot;age&quot; value=&quot;18&quot;/&gt; &lt;/bean&gt; &lt;!-- 被引用类bean声明 --&gt; &lt;bean id=&quot;userDao&quot; class=&quot;x.y.UserDao&quot;/&gt; &lt;/beans&gt; &lt;!-- 场景2: 多参数，可以按照相应构造函数的角标注入数据 index从0开始 构造函数(0,1,2....) --&gt; &lt;beans&gt; &lt;bean id=&quot;userService&quot; class=&quot;x.y.UserService&quot;&gt; &lt;!-- value直接注入基本类型值 --&gt; &lt;constructor-arg index=&quot;1&quot; value=&quot;赵伟风&quot;/&gt; &lt;constructor-arg index=&quot;2&quot; ref=&quot;userDao&quot;/&gt; &lt;constructor-arg index=&quot;0&quot; value=&quot;18&quot;/&gt; &lt;/bean&gt; &lt;!-- 被引用类bean声明 --&gt; &lt;bean id=&quot;userDao&quot; class=&quot;x.y.UserDao&quot;/&gt; &lt;/beans&gt; constructor-arg标签：指定构造参数和对应的值 constructor-arg标签：name属性指定参数名、index属性指定参数角标、value属性指定普通属性值 基于Setter方法依赖注入 介绍 开发中，除了构造函数注入（DI）更多的使用的Setter方法进行注入！ 下面的示例演示一个只能使用纯 setter 注入进行依赖项注入的类。 准备组件类 1234567891011121314151617181920public Class MovieFinder&#123;&#125;public class SimpleMovieLister &#123; private MovieFinder movieFinder; private String movieName; public void setMovieFinder(MovieFinder movieFinder) &#123; this.movieFinder = movieFinder; &#125; public void setMovieName(String movieName)&#123; this.movieName = movieName; &#125; // business logic that actually uses the injected MovieFinder is omitted...&#125; 编写配置文件 1234567891011121314&lt;bean id=&quot;simpleMovieLister&quot; class=&quot;examples.SimpleMovieLister&quot;&gt; &lt;!-- setter方法，注入movieFinder对象的标识id name = 属性名 ref = 引用bean的id值 --&gt; &lt;property name=&quot;movieFinder&quot; ref=&quot;movieFinder&quot; /&gt; &lt;!-- setter方法，注入基本数据类型movieName name = 属性名 value= 基本类型值 --&gt; &lt;property name=&quot;movieName&quot; value=&quot;消失的她&quot;/&gt;&lt;/bean&gt;&lt;bean id=&quot;movieFinder&quot; class=&quot;examples.MovieFinder&quot;/&gt; property标签： 可以给setter方法对应的属性赋值 property 标签： name属性代表set方法标识、ref代表引用bean的标识id、value属性代表基本属性值 总结： 依赖注入（DI）包含引用类型和基本数据类型，同时注入的方式也有多种！主流的注入方式为setter方法注入和构造函数注入，两种注入语法都需要掌握！ 需要特别注意：引用其他bean，使用ref属性。直接注入基本类型值，使用value属性。 4.2.3 实验三： IoC容器创建和使用 介绍 上面的实验只是讲解了如何在XML格式的配置文件编写IoC和DI配置！ 如图： 想要配置文件中声明组件类信息真正的进行实例化成Bean对象和形成Bean之间的引用关系，我们需要声明IoC容器对象，读取配置文件，实例化组件和关系维护的过程都是在IoC容器中实现的！ 容器实例化 12345678910111213//方式1:实例化并且指定配置文件//参数：String...locations 传入一个或者多个配置文件ApplicationContext context = new ClassPathXmlApplicationContext(&quot;services.xml&quot;, &quot;daos.xml&quot;); //方式2:先实例化，再指定配置文件，最后刷新容器触发Bean实例化动作 [springmvc源码和contextLoadListener源码方式] ApplicationContext context = new ClassPathXmlApplicationContext(); //设置配置配置文件,方法参数为可变参数,可以设置一个或者多个配置iocContainer1.setConfigLocations(&quot;services.xml&quot;, &quot;daos.xml&quot;);//后配置的文件,需要调用refresh方法,触发刷新配置iocContainer1.refresh(); Bean对象读取 1234567891011121314151617181920//方式1: 根据id获取//没有指定类型,返回为Object,需要类型转化!HappyComponent happyComponent = (HappyComponent) iocContainer.getBean(&quot;bean的id标识&quot;); //使用组件对象 happyComponent.doWork();//方式2: 根据类型获取//根据类型获取,但是要求,同类型(当前类,或者之类,或者接口的实现类)只能有一个对象交给IoC容器管理//配置两个或者以上出现: org.springframework.beans.factory.NoUniqueBeanDefinitionException 问题HappyComponent happyComponent = iocContainer.getBean(HappyComponent.class);happyComponent.doWork();//方式3: 根据id和类型获取HappyComponent happyComponent = iocContainer.getBean(&quot;bean的id标识&quot;, HappyComponent.class);happyComponent.doWork();根据类型来获取bean时，在满足bean唯一性的前提下，其实只是看：『对象 instanceof 指定的类型』的返回结果，只要返回的是true就可以认定为和类型匹配，能够获取到。 4.2.4 实验四： 高级特性：组件（Bean）作用域和周期方法配置 组件周期方法配置 周期方法概念 我们可以在组件类中定义方法，然后当IoC容器实例化和销毁组件对象的时候进行调用！这两个方法我们成为生命周期方法！ 类似于Servlet的init&#x2F;destroy方法,我们可以在周期方法完成初始化和释放资源等工作。 周期方法声明 1234567891011121314public class BeanOne &#123; //周期方法要求： 方法命名随意，但是要求方法必须是 public void 无形参列表 public void init() &#123; // 初始化逻辑 &#125;&#125;public class BeanTwo &#123; public void cleanup() &#123; // 释放资源逻辑 &#125;&#125; 周期方法配置 1234&lt;beans&gt; &lt;bean id=&quot;beanOne&quot; class=&quot;examples.BeanOne&quot; init-method=&quot;init&quot; /&gt; &lt;bean id=&quot;beanTwo&quot; class=&quot;examples.BeanTwo&quot; destroy-method=&quot;cleanup&quot; /&gt;&lt;/beans&gt; 组件作用域配置 Bean作用域概念 &lt;bean 标签声明Bean，只是将Bean的信息配置给SpringIoC容器！ 在IoC容器中，这些&lt;bean标签对应的信息转成Spring内部 BeanDefinition 对象，BeanDefinition 对象内，包含定义的信息（id,class,属性等等）！ 这意味着，BeanDefinition与类概念一样，SpringIoC容器可以可以根据BeanDefinition对象反射创建多个Bean对象实例。 具体创建多少个Bean的实例对象，由Bean的作用域Scope属性指定！ 作用域可选值 取值 含义 创建对象的时机 默认值 singleton 在 IOC 容器中，这个 bean 的对象始终为单实例 IOC 容器初始化时 是 prototype 这个 bean 在 IOC 容器中有多个实例 获取 bean 时 否 如果是在WebApplicationContext环境下还会有另外两个作用域（但不常用）： 取值 含义 创建对象的时机 默认值 ——- ———- ——- — request 请求范围内有效的实例 每次请求 否 session 会话范围内有效的实例 每次会话 否 作用域配置 配置scope范围 123456789101112&lt;!--bean的作用域 准备两个引用关系的组件类即可！！--&gt;&lt;!-- scope属性：取值singleton（默认值），bean在IOC容器中只有一个实例，IOC容器初始化时创建对象 --&gt;&lt;!-- scope属性：取值prototype，bean在IOC容器中可以有多个实例，getBean()时创建对象 --&gt;&lt;bean id=&quot;happyMachine8&quot; scope=&quot;prototype&quot; class=&quot;com.atguigu.ioc.HappyMachine&quot;&gt; &lt;property name=&quot;machineName&quot; value=&quot;happyMachine&quot;/&gt;&lt;/bean&gt;&lt;bean id=&quot;happyComponent8&quot; scope=&quot;singleton&quot; class=&quot;com.atguigu.ioc.HappyComponent&quot;&gt; &lt;property name=&quot;componentName&quot; value=&quot;happyComponent&quot;/&gt;&lt;/bean&gt; 作用域测试 1234567891011121314@Testpublic void testExperiment08() &#123; ApplicationContext iocContainer = new ClassPathXmlApplicationContext(&quot;配置文件名&quot;); HappyMachine bean = iocContainer.getBean(HappyMachine.class); HappyMachine bean1 = iocContainer.getBean(HappyMachine.class); //多例对比 false System.out.println(bean == bean1); HappyComponent bean2 = iocContainer.getBean(HappyComponent.class); HappyComponent bean3 = iocContainer.getBean(HappyComponent.class); //单例对比 true System.out.println(bean2 == bean3);&#125; 4.2.5 实验五： 高级特性：FactoryBean特性和使用 FactoryBean简介 FactoryBean 接口是Spring IoC容器实例化逻辑的可插拔性点。 用于配置复杂的Bean对象，可以将创建过程存储在FactoryBean 的getObject方法！ FactoryBean&lt;T&gt; 接口提供三种方法： T getObject():&#x20; 返回此工厂创建的对象的实例。该返回值会被存储到IoC容器！ boolean isSingleton():&#x20; 如果此 FactoryBean 返回单例，则返回 true ，否则返回 false 。此方法的默认实现返回 true （注意，lombok插件使用，可能影响效果）。 Class&lt;?&gt; getObjectType(): 返回 getObject() 方法返回的对象类型，如果事先不知道类型，则返回 null 。 FactoryBean使用场景 代理类的创建 第三方框架整合 复杂对象实例化等 Factorybean应用 准备FactoryBean实现类1234567891011121314151617181920212223242526272829303132// 实现FactoryBean接口时需要指定泛型// 泛型类型就是当前工厂要生产的对象的类型public class HappyFactoryBean implements FactoryBean&lt;HappyMachine&gt; &#123; private String machineName; public String getMachineName() &#123; return machineName; &#125; public void setMachineName(String machineName) &#123; this.machineName = machineName; &#125; @Override public HappyMachine getObject() throws Exception &#123; // 方法内部模拟创建、设置一个对象的复杂过程 HappyMachine happyMachine = new HappyMachine(); happyMachine.setMachineName(this.machineName); return happyMachine; &#125; @Override public Class&lt;?&gt; getObjectType() &#123; // 返回要生产的对象的类型 return HappyMachine.class; &#125;&#125; 配置FactoryBean实现类123456&lt;!-- FactoryBean机制 --&gt;&lt;!-- 这个bean标签中class属性指定的是HappyFactoryBean，但是将来从这里获取的bean是HappyMachine对象 --&gt;&lt;bean id=&quot;happyMachine7&quot; class=&quot;com.atguigu.ioc.HappyFactoryBean&quot;&gt; &lt;!-- property标签仍然可以用来通过setXxx()方法给属性赋值 --&gt; &lt;property name=&quot;machineName&quot; value=&quot;iceCreamMachine&quot;/&gt;&lt;/bean&gt; 测试读取FactoryBean和FactoryBean.getObject对象12345678910111213@Testpublic void testExperiment07() &#123; ApplicationContext iocContainer = new ClassPathXmlApplicationContext(&quot;spring-bean-07.xml&quot;); //注意: 直接根据声明FactoryBean的id,获取的是getObject方法返回的对象 HappyMachine happyMachine = iocContainer.getBean(&quot;happyMachine7&quot;,HappyMachine.class); System.out.println(&quot;happyMachine = &quot; + happyMachine); //如果想要获取FactoryBean对象, 直接在id前添加&amp;符号即可! &amp;happyMachine7 这是一种固定的约束 Object bean = iocContainer.getBean(&quot;&amp;happyMachine7&quot;); System.out.println(&quot;bean = &quot; + bean);&#125; FactoryBean和BeanFactory区别 **FactoryBean **是 Spring 中一种特殊的 bean，可以在 getObject() 工厂方法自定义的逻辑创建Bean！是一种能够生产其他 Bean 的 Bean。FactoryBean 在容器启动时被创建，而在实际使用时则是通过调用 getObject() 方法来得到其所生产的 Bean。因此，FactoryBean 可以自定义任何所需的初始化逻辑，生产出一些定制化的 bean。 一般情况下，整合第三方框架，都是通过定义FactoryBean实现！！！ BeanFactory 是 Spring 框架的基础，其作为一个顶级接口定义了容器的基本行为，例如管理 bean 的生命周期、配置文件的加载和解析、bean 的装配和依赖注入等。BeanFactory 接口提供了访问 bean 的方式，例如 getBean() 方法获取指定的 bean 实例。它可以从不同的来源（例如 Mysql 数据库、XML 文件、Java 配置类等）获取 bean 定义，并将其转换为 bean 实例。同时，BeanFactory 还包含很多子类（例如，ApplicationContext 接口）提供了额外的强大功能。 总的来说，FactoryBean 和 BeanFactory 的区别主要在于前者是用于创建 bean 的接口，它提供了更加灵活的初始化定制功能，而后者是用于管理 bean 的框架基础接口，提供了基本的容器功能和 bean 生命周期管理。 4.2.6 实验六： 基于XML方式整合三层架构组件 需求分析 搭建一个三层架构案例，模拟查询全部学生（学生表）信息，持久层使用JdbcTemplate和Druid技术，使用XML方式进行组件管理！ 数据库准备 1234567891011121314151617181920212223create database studb;use studb;CREATE TABLE students ( id INT PRIMARY KEY, name VARCHAR(50) NOT NULL, gender VARCHAR(10) NOT NULL, age INT, class VARCHAR(50));INSERT INTO students (id, name, gender, age, class)VALUES (1, &#x27;张三&#x27;, &#x27;男&#x27;, 20, &#x27;高中一班&#x27;), (2, &#x27;李四&#x27;, &#x27;男&#x27;, 19, &#x27;高中二班&#x27;), (3, &#x27;王五&#x27;, &#x27;女&#x27;, 18, &#x27;高中一班&#x27;), (4, &#x27;赵六&#x27;, &#x27;女&#x27;, 20, &#x27;高中三班&#x27;), (5, &#x27;刘七&#x27;, &#x27;男&#x27;, 19, &#x27;高中二班&#x27;), (6, &#x27;陈八&#x27;, &#x27;女&#x27;, 18, &#x27;高中一班&#x27;), (7, &#x27;杨九&#x27;, &#x27;男&#x27;, 20, &#x27;高中三班&#x27;), (8, &#x27;吴十&#x27;, &#x27;男&#x27;, 19, &#x27;高中二班&#x27;); 项目准备 项目创建 spring-xml-practice-02 依赖导入 123456789101112131415161718192021222324252627282930&lt;dependencies&gt; &lt;!--spring context依赖--&gt; &lt;!--当你引入SpringContext依赖之后，表示将Spring的基础依赖引入了--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;6.0.6&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 数据库驱动和连接池--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.25&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.2.8&lt;/version&gt; &lt;/dependency&gt; &lt;!-- spring-jdbc --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;6.0.6&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 实体类准备 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960public class Student &#123; private Integer id; private String name; private String gender; private Integer age; private String classes; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getGender() &#123; return gender; &#125; public void setGender(String gender) &#123; this.gender = gender; &#125; public Integer getAge() &#123; return age; &#125; public void setAge(Integer age) &#123; this.age = age; &#125; public String getClasses() &#123; return classes; &#125; public void setClasses(String classes) &#123; this.classes = classes; &#125; @Override public String toString() &#123; return &quot;Student&#123;&quot; + &quot;id=&quot; + id + &quot;, name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, gender=&#x27;&quot; + gender + &#x27;\\&#x27;&#x27; + &quot;, age=&quot; + age + &quot;, classes=&#x27;&quot; + classes + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125;&#125; JdbcTemplate技术讲解 为了在特定领域帮助我们简化代码，Spring 封装了很多 『Template』形式的模板类。例如：RedisTemplate、RestTemplate 等等，包括我们今天要学习的 JdbcTemplate。jdbc.properties提取数据库连接信息 1234atguigu.url=jdbc:mysql://localhost:3306/studbatguigu.driver=com.mysql.cj.jdbc.Driveratguigu.username=rootatguigu.password=root springioc配置文件 123456&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;!-- 导入外部属性文件 --&gt; &lt;context:property-placeholder location=&quot;classpath:jdbc.properties&quot; /&gt; &lt;!-- 配置数据源 --&gt; &lt;bean id=&quot;druidDataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;atguigu.url&#125;&quot;/&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;$&#123;atguigu.driver&#125;&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;atguigu.username&#125;&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;atguigu.password&#125;&quot;/&gt; &lt;/bean&gt; &lt;!-- 配置 JdbcTemplate --&gt; &lt;bean id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt; &lt;!-- 装配数据源 --&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;druidDataSource&quot;/&gt; &lt;/bean&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788基于jdbcTemplate的CRUD使用```javapublic class JdbcTemplateTest &#123; /** * 使用jdbcTemplate进行DML动作 */ @Test public void testDML()&#123; ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;spring-ioc.xml&quot;); JdbcTemplate jdbcTemplate = applicationContext.getBean(JdbcTemplate.class); //TODO 执行插入一条学员数据 String sql = &quot;insert into students (id,name,gender,age,class) values (?,?,?,?,?);&quot;; /* 参数1: sql语句 参数2: 可变参数,占位符的值 */ int rows = jdbcTemplate.update(sql, 9,&quot;十一&quot;, &quot;男&quot;, 18, &quot;二年三班&quot;); System.out.println(&quot;rows = &quot; + rows); &#125; /** * 查询单条实体对象 * public class Student &#123; * private Integer id; * private String name; * private String gender; * private Integer age; * private String classes; */ @Test public void testDQLForPojo()&#123; String sql = &quot;select id , name , age , gender , class as classes from students where id = ? ;&quot;; ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;spring-ioc.xml&quot;); JdbcTemplate jdbcTemplate = applicationContext.getBean(JdbcTemplate.class); //根据id查询 Student student = jdbcTemplate.queryForObject(sql, (rs, rowNum) -&gt; &#123; //自己处理结果映射 Student stu = new Student(); stu.setId(rs.getInt(&quot;id&quot;)); stu.setName(rs.getString(&quot;name&quot;)); stu.setAge(rs.getInt(&quot;age&quot;)); stu.setGender(rs.getString(&quot;gender&quot;)); stu.setClasses(rs.getString(&quot;classes&quot;)); return stu; &#125;, 2); System.out.println(&quot;student = &quot; + student); &#125; /** * 查询实体类集合 */ @Test public void testDQLForListPojo()&#123; String sql = &quot;select id , name , age , gender , class as classes from students ;&quot;; ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;spring-ioc.xml&quot;); JdbcTemplate jdbcTemplate = applicationContext.getBean(JdbcTemplate.class); /* query可以返回集合! BeanPropertyRowMapper就是封装好RowMapper的实现,要求属性名和列名相同即可 */ List&lt;Student&gt; studentList = jdbcTemplate.query(sql, new BeanPropertyRowMapper&lt;&gt;(Student.class)); System.out.println(&quot;studentList = &quot; + studentList); &#125;&#125; 三层架构搭建和实现 持久层1234567891011121314151617181920212223242526272829303132333435363738//接口public interface StudentDao &#123; /** * 查询全部学生数据 * @return */ List&lt;Student&gt; queryAll();&#125;//实现类public class StudentDaoImpl implements StudentDao &#123; private JdbcTemplate jdbcTemplate; public void setJdbcTemplate(JdbcTemplate jdbcTemplate) &#123; this.jdbcTemplate = jdbcTemplate; &#125; /** * 查询全部学生数据 * @return */ @Override public List&lt;Student&gt; queryAll() &#123; String sql = &quot;select id , name , age , gender , class as classes from students ;&quot;; /* query可以返回集合! BeanPropertyRowMapper就是封装好RowMapper的实现,要求属性名和列名相同即可 */ List&lt;Student&gt; studentList = jdbcTemplate.query(sql, new BeanPropertyRowMapper&lt;&gt;(Student.class)); return studentList; &#125;&#125; 业务层123456789101112131415161718192021222324252627282930313233//接口public interface StudentService &#123; /** * 查询全部学员业务 * @return */ List&lt;Student&gt; findAll();&#125;//实现类public class StudentServiceImpl implements StudentService &#123; private StudentDao studentDao; public void setStudentDao(StudentDao studentDao) &#123; this.studentDao = studentDao; &#125; /** * 查询全部学员业务 * @return */ @Override public List&lt;Student&gt; findAll() &#123; List&lt;Student&gt; studentList = studentDao.queryAll(); return studentList; &#125;&#125; 表述层12345678910111213public class StudentController &#123; private StudentService studentService; public void setStudentService(StudentService studentService) &#123; this.studentService = studentService; &#125; public void findAll()&#123; List&lt;Student&gt; studentList = studentService.findAll(); System.out.println(&quot;studentList = &quot; + studentList); &#125;&#125; 三层架构IoC配置 12345&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;!-- 导入外部属性文件 --&gt; &lt;context:property-placeholder location=&quot;classpath:jdbc.properties&quot; /&gt; &lt;!-- 配置数据源 --&gt; &lt;bean id=&quot;druidDataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;atguigu.url&#125;&quot;/&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;$&#123;atguigu.driver&#125;&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;atguigu.username&#125;&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;atguigu.password&#125;&quot;/&gt; &lt;/bean&gt; &lt;!-- 配置 JdbcTemplate --&gt; &lt;bean id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt; &lt;!-- 装配数据源 --&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;druidDataSource&quot;/&gt; &lt;/bean&gt; &lt;bean id=&quot;studentDao&quot; class=&quot;com.atguigu.dao.impl.StudentDaoImpl&quot;&gt; &lt;property name=&quot;jdbcTemplate&quot; ref=&quot;jdbcTemplate&quot; /&gt; &lt;/bean&gt; &lt;bean id=&quot;studentService&quot; class=&quot;com.atguigu.service.impl.StudentServiceImpl&quot;&gt; &lt;property name=&quot;studentDao&quot; ref=&quot;studentDao&quot; /&gt; &lt;/bean&gt; &lt;bean id=&quot;studentController&quot; class=&quot;com.atguigu.controller.StudentController&quot;&gt; &lt;property name=&quot;studentService&quot; ref=&quot;studentService&quot; /&gt; &lt;/bean&gt; 1234567891011127. 运行测试 ```java public class ControllerTest &#123; @Test public void testRun()&#123; ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;spring-ioc.xml&quot;); StudentController studentController = applicationContext.getBean(StudentController.class); studentController.findAll(); &#125; &#125; XMLIoC方式问题总结 注入的属性必须添加setter方法、代码结构乱！ 配置文件和Java代码分离、编写不是很方便！ XML配置文件解析效率低 4.3 基于 注解 方式管理 Bean4.3.1 实验一： Bean注解标记和扫描 (IoC) 注解理解 和 XML 配置文件一样，注解本身并不能执行，注解本身仅仅只是做一个标记，具体的功能是框架检测到注解标记的位置，然后针对这个位置按照注解标记的功能来执行具体操作。 本质上：所有一切的操作都是 Java 代码来完成的，XML 和注解只是告诉框架中的 Java 代码如何执行。 举例：元旦联欢会要布置教室，蓝色的地方贴上元旦快乐四个字，红色的地方贴上拉花，黄色的地方贴上气球。 班长做了所有标记，同学们来完成具体工作。墙上的标记相当于我们在代码中使用的注解，后面同学们做的工作，相当于框架的具体操作。 扫描理解 Spring 为了知道程序员在哪些地方标记了什么注解，就需要通过扫描的方式，来进行检测。然后根据注解进行后续操作。 准备Spring项目和组件 准备项目pom.xml 12345678910111213141516&lt;dependencies&gt; &lt;!--spring context依赖--&gt; &lt;!--当你引入Spring Context依赖之后，表示将Spring的基础依赖引入了--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;6.0.6&lt;/version&gt; &lt;/dependency&gt; &lt;!--junit5测试--&gt; &lt;dependency&gt; &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt; &lt;artifactId&gt;junit-jupiter-api&lt;/artifactId&gt; &lt;version&gt;5.3.1&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 准备组件类 普通组件 12345678/** * projectName: com.atguigu.components * * description: 普通的组件 */public class CommonComponent &#123;&#125; Controller组件 12345678/** * projectName: com.atguigu.components * * description: controller类型组件 */public class XxxController &#123;&#125; Service组件 12345678/** * projectName: com.atguigu.components * * description: service类型组件 */public class XxxService &#123;&#125; Dao组件 12345678/** * projectName: com.atguigu.components * * description: dao类型组件 */public class XxxDao &#123;&#125; 组件添加标记注解 组件标记注解和区别 Spring 提供了以下多个注解，这些注解可以直接标注在 Java 类上，将它们定义成 Spring Bean。 注解 说明 @Component 该注解用于描述 Spring 中的 Bean，它是一个泛化的概念，仅仅表示容器中的一个组件（Bean），并且可以作用在应用的任何层次，例如 Service 层、Dao 层等。 使用时只需将该注解标注在相应类上即可。 @Repository 该注解用于将数据访问层（Dao 层）的类标识为 Spring 中的 Bean，其功能与 @Component 相同。 @Service 该注解通常作用在业务层（Service 层），用于将业务层的类标识为 Spring 中的 Bean，其功能与 @Component 相同。 @Controller 该注解通常作用在控制层（如SpringMVC 的 Controller），用于将控制层的类标识为 Spring 中的 Bean，其功能与 @Component 相同。 通过查看源码我们得知，@Controller、@Service、@Repository这三个注解只是在@Component注解的基础上起了三个新的名字。 对于Spring使用IOC容器管理这些组件来说没有区别，也就是语法层面没有区别。所以@Controller、@Service、@Repository这三个注解只是给开发人员看的，让我们能够便于分辨组件的作用。 注意：虽然它们本质上一样，但是为了代码的可读性、程序结构严谨！我们肯定不能随便胡乱标记。 使用注解标记 普通组件 123456789/** * projectName: com.atguigu.components * * description: 普通的组件 */@Componentpublic class CommonComponent &#123;&#125; Controller组件 123456789/** * projectName: com.atguigu.components * * description: controller类型组件 */@Controllerpublic class XxxController &#123;&#125; Service组件 123456789/** * projectName: com.atguigu.components * * description: service类型组件 */@Servicepublic class XxxService &#123;&#125; Dao组件 123456789/** * projectName: com.atguigu.components * * description: dao类型组件 */@Repositorypublic class XxxDao &#123;&#125; 配置文件确定扫描范围 情况1：基本扫描配置 12345678910111213&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;!-- 配置自动扫描的包 --&gt; &lt;!-- 1.包要精准,提高性能! 2.会扫描指定的包和子包内容 3.多个包可以使用,分割 例如: com.atguigu.controller,com.atguigu.service等 --&gt; &lt;context:component-scan base-package=&quot;com.atguigu.components&quot;/&gt; &lt;/beans&gt; 情况2：指定排除组件 12345678&lt;!-- 情况三：指定不扫描的组件 --&gt;&lt;context:component-scan base-package=&quot;com.atguigu.components&quot;&gt; &lt;!-- context:exclude-filter标签：指定排除规则 --&gt; &lt;!-- type属性：指定根据什么来进行排除，annotation取值表示根据注解来排除 --&gt; &lt;!-- expression属性：指定排除规则的表达式，对于注解来说指定全类名即可 --&gt; &lt;context:exclude-filter type=&quot;annotation&quot; expression=&quot;org.springframework.stereotype.Controller&quot;/&gt;&lt;/context:component-scan&gt; 情况3：指定扫描组件 12345678&lt;!-- 情况四：仅扫描指定的组件 --&gt;&lt;!-- 仅扫描 = 关闭默认规则 + 追加规则 --&gt;&lt;!-- use-default-filters属性：取值false表示关闭默认扫描规则 --&gt;&lt;context:component-scan base-package=&quot;com.atguigu.ioc.components&quot; use-default-filters=&quot;false&quot;&gt; &lt;!-- context:include-filter标签：指定在原有扫描规则的基础上追加的规则 --&gt; &lt;context:include-filter type=&quot;annotation&quot; expression=&quot;org.springframework.stereotype.Controller&quot;/&gt;&lt;/context:component-scan&gt; 组件BeanName问题 在我们使用 XML 方式管理 bean 的时候，每个 bean 都有一个唯一标识——id 属性的值，便于在其他地方引用。现在使用注解后，每个组件仍然应该有一个唯一标识。 默认情况： 类名首字母小写就是 bean 的 id。例如：SoldierController 类对应的 bean 的 id 就是 soldierController。 使用value属性指定： 123@Controller(value = &quot;tianDog&quot;)public class SoldierController &#123;&#125; 当注解中只设置一个属性时，value属性的属性名可以省略： 123@Service(&quot;smallDog&quot;)public class SoldierService &#123;&#125; 总结 注解方式IoC只是标记哪些类要被Spring管理 最终，我们还需要XML方式或者后面讲解Java配置类方式指定注解生效的包 现阶段配置方式为 注解 （标记）+ XML（扫描） 4.3.2 实验二： 组件（Bean）作用域和周期方法注解&#x20; 组件周期方法配置 周期方法概念 我们可以在组件类中定义方法，然后当IoC容器实例化和销毁组件对象的时候进行调用！这两个方法我们成为生命周期方法！ 类似于Servlet的init&#x2F;destroy方法,我们可以在周期方法完成初始化和释放资源等工作。 周期方法声明 12345678910111213141516public class BeanOne &#123; //周期方法要求： 方法命名随意，但是要求方法必须是 public void 无形参列表 @PostConstruct //注解制指定初始化方法 public void init() &#123; // 初始化逻辑 &#125;&#125;public class BeanTwo &#123; @PreDestroy //注解指定销毁方法 public void cleanup() &#123; // 释放资源逻辑 &#125;&#125; 组件作用域配置 Bean作用域概念 &lt;bean 标签声明Bean，只是将Bean的信息配置给SpringIoC容器！ 在IoC容器中，这些&lt;bean标签对应的信息转成Spring内部 BeanDefinition 对象，BeanDefinition 对象内，包含定义的信息（id,class,属性等等）！ 这意味着，BeanDefinition与类概念一样，SpringIoC容器可以可以根据BeanDefinition对象反射创建多个Bean对象实例。 具体创建多少个Bean的实例对象，由Bean的作用域Scope属性指定！ 作用域可选值 取值 含义 创建对象的时机 默认值 singleton 在 IOC 容器中，这个 bean 的对象始终为单实例 IOC 容器初始化时 是 prototype 这个 bean 在 IOC 容器中有多个实例 获取 bean 时 否 如果是在WebApplicationContext环境下还会有另外两个作用域（但不常用）： 取值 含义 创建对象的时机 默认值 ——- ———- ——- — request 请求范围内有效的实例 每次请求 否 session 会话范围内有效的实例 每次会话 否 作用域配置 12345678910@Scope(scopeName = ConfigurableBeanFactory.SCOPE_SINGLETON) //单例,默认值@Scope(scopeName = ConfigurableBeanFactory.SCOPE_PROTOTYPE) //多例 二选一public class BeanOne &#123; //周期方法要求： 方法命名随意，但是要求方法必须是 public void 无形参列表 @PostConstruct //注解制指定初始化方法 public void init() &#123; // 初始化逻辑 &#125;&#125; 4.3.3 实验三： Bean属性赋值：引用类型自动装配 (DI) 设定场景 SoldierController 需要 SoldierService SoldierService 需要 SoldierDao&#x20; 同时在各个组件中声明要调用的方法。 SoldierController中声明方法123456789101112import org.springframework.stereotype.Controller;@Controller(value = &quot;tianDog&quot;)public class SoldierController &#123; private SoldierService soldierService; public void getMessage() &#123; soldierService.getMessage(); &#125;&#125; SoldierService中声明方法123456789@Service(&quot;smallDog&quot;)public class SoldierService &#123; private SoldierDao soldierDao; public void getMessage() &#123; soldierDao.getMessage(); &#125;&#125; SoldierDao中声明方法12345678@Repositorypublic class SoldierDao &#123; public void getMessage() &#123; System.out.print(&quot;I am a soldier&quot;); &#125;&#125; 自动装配实现 前提 参与自动装配的组件（需要装配、被装配）全部都必须在IoC容器中。 注意：不区分IoC的方式！XML和注解都可以！ @Autowired注解 在成员变量上直接标记@Autowired注解即可，不需要提供setXxx()方法。以后我们在项目中的正式用法就是这样。 给Controller装配Service 1234567891011@Controller(value = &quot;tianDog&quot;)public class SoldierController &#123; @Autowired private SoldierService soldierService; public void getMessage() &#123; soldierService.getMessage(); &#125; &#125; 给Service装配Dao 12345678910@Service(&quot;smallDog&quot;)public class SoldierService &#123; @Autowired private SoldierDao soldierDao; public void getMessage() &#123; soldierDao.getMessage(); &#125;&#125; @Autowired注解细节 标记位置 成员变量 这是最主要的使用方式！ 与xml进行bean ref引用不同，他不需要有set方法！ 12345678910@Service(&quot;smallDog&quot;)public class SoldierService &#123; @Autowired private SoldierDao soldierDao; public void getMessage() &#123; soldierDao.getMessage(); &#125;&#125; 构造器 12345678910@Controller(value = &quot;tianDog&quot;)public class SoldierController &#123; private SoldierService soldierService; @Autowired public SoldierController(SoldierService soldierService) &#123; this.soldierService = soldierService; &#125; …… setXxx()方法 12345678910@Controller(value = &quot;tianDog&quot;)public class SoldierController &#123; private SoldierService soldierService; @Autowired public void setSoldierService(SoldierService soldierService) &#123; this.soldierService = soldierService; &#125; …… 工作流程 首先根据所需要的组件类型到 IOC 容器中查找 能够找到唯一的 bean：直接执行装配 如果完全找不到匹配这个类型的 bean：装配失败 和所需类型匹配的 bean 不止一个 没有 @Qualifier 注解：根据 @Autowired 标记位置成员变量的变量名作为 bean 的 id 进行匹配 能够找到：执行装配 找不到：装配失败 使用 @Qualifier 注解：根据 @Qualifier 注解中指定的名称作为 bean 的id进行匹配 能够找到：执行装配 找不到：装配失败 1234567@Controller(value = &quot;tianDog&quot;)public class SoldierController &#123; @Autowired @Qualifier(value = &quot;maomiService222&quot;) // 根据面向接口编程思想，使用接口类型引入Service组件 private ISoldierService soldierService; 佛系装配 给 @Autowired 注解设置 required &#x3D; false 属性表示：能装就装，装不上就不装。但是实际开发时，基本上所有需要装配组件的地方都是必须装配的，用不上这个属性 123456@Controller(value = &quot;tianDog&quot;)public class SoldierController &#123; // 给@Autowired注解设置required = false属性表示：能装就装，装不上就不装 @Autowired(required = false) private ISoldierService soldierService; 扩展JSR-250注解@Resource 理解JSR系列注解 JSR（Java Specification Requests）是Java平台标准化进程中的一种技术规范，而JSR注解是其中一部分重要的内容。按照JSR的分类以及注解语义的不同，可以将JSR注解分为不同的系列，主要有以下几个系列： JSR-175: 这个JSR是Java SE 5引入的，是Java注解最早的规范化版本，Java SE 5后的版本中都包含该JSR中定义的注解。主要包括以下几种标准注解： @Deprecated: 标识一个程序元素（如类、方法或字段）已过时，并且在将来的版本中可能会被删除。 @Override: 标识一个方法重写了父类中的方法。 @SuppressWarnings: 抑制编译时产生的警告消息。 @SafeVarargs: 标识一个有安全性警告的可变参数方法。 @FunctionalInterface: 标识一个接口只有一个抽象方法，可以作为lambda表达式的目标。 JSR-250: 这个JSR主要用于在Java EE 5中定义一些支持注解。该JSR主要定义了一些用于进行对象管理的注解，包括： @Resource: 标识一个需要注入的资源，是实现Java EE组件之间依赖关系的一种方式。 @PostConstruct: 标识一个方法作为初始化方法。 @PreDestroy: 标识一个方法作为销毁方法。 @Resource.AuthenticationType: 标识注入的资源的身份验证类型。 @Resource.AuthenticationType: 标识注入的资源的默认名称。 JSR-269: 这个JSR主要是Java SE 6中引入的一种支持编译时元数据处理的框架，即使用注解来处理Java源文件。该JSR定义了一些可以用注解标记的注解处理器，用于生成一些元数据，常用的注解有： @SupportedAnnotationTypes: 标识注解处理器所处理的注解类型。 @SupportedSourceVersion: 标识注解处理器支持的Java源码版本。 JSR-330: 该JSR主要为Java应用程序定义了一个依赖注入的标准，即Java依赖注入标准（javax.inject）。在此规范中定义了多种注解，包括： @Named: 标识一个被依赖注入的组件的名称。 @Inject: 标识一个需要被注入的依赖组件。 @Singleton: 标识一个组件的生命周期只有一个唯一的实例。 JSR-250: 这个JSR主要是Java EE 5中定义一些支持注解。该JSR包含了一些支持注解，可以用于对Java EE组件进行管理，包括： @RolesAllowed: 标识授权角色 @PermitAll: 标识一个活动无需进行身份验证。 @DenyAll: 标识不提供针对该方法的访问控制。 @DeclareRoles: 声明安全角色。但是你要理解JSR是Java提供的技术规范，也就是说，他只是规定了注解和注解的含义，JSR并不是直接提供特定的实现，而是提供标准和指导方针，由第三方框架（Spring）和库来实现和提供对应的功能。 JSR-250 @Resource注解 @Resource注解也可以完成属性注入。那它和@Autowired注解有什么区别？ @Resource注解是JDK扩展包中的，也就是说属于JDK的一部分。所以该注解是标准注解，更加具有通用性。(JSR-250标准中制定的注解类型。JSR是Java规范提案。) @Autowired注解是Spring框架自己的。 @Resource注解默认根据Bean名称装配，未指定name时，使用属性名作为name。通过name找不到的话会自动启动通过类型装配。 @Autowired注解默认根据类型装配，如果想根据名称装配，需要配合@Qualifier注解一起用。 @Resource注解用在属性上、setter方法上。 @Autowired注解用在属性上、setter方法上、构造方法上、构造方法参数上。@Resource注解属于JDK扩展包，所以不在JDK当中，需要额外引入以下依赖：【高于JDK11或低于JDK8需要引入以下依赖】12345&lt;dependency&gt; &lt;groupId&gt;jakarta.annotation&lt;/groupId&gt; &lt;artifactId&gt;jakarta.annotation-api&lt;/artifactId&gt; &lt;version&gt;2.1.1&lt;/version&gt;&lt;/dependency&gt; @Resource使用 123456789101112131415161718@Controllerpublic class XxxController &#123; /** * 1. 如果没有指定name,先根据属性名查找IoC中组件xxxService * 2. 如果没有指定name,并且属性名没有对应的组件,会根据属性类型查找 * 3. 可以指定name名称查找! @Resource(name=&#x27;test&#x27;) == @Autowired + @Qualifier(value=&#x27;test&#x27;) */ @Resource private XxxService xxxService; //@Resource(name = &quot;指定beanName&quot;) //private XxxService xxxService; public void show()&#123; System.out.println(&quot;XxxController.show&quot;); xxxService.show(); &#125;&#125; 4.3.4 实验四： Bean属性赋值：基本类型属性赋值 (DI)@Value 通常用于注入外部化属性 声明外部配置 application.properties 1catalog.name=MovieCatalog xml引入外部配置 12&lt;!-- 引入外部配置文件--&gt;&lt;context:property-placeholder location=&quot;application.properties&quot; /&gt; @Value注解读取配置 1234567891011121314151617181920212223242526272829package com.atguigu.components;import org.springframework.beans.factory.annotation.Value;import org.springframework.stereotype.Component;/** * projectName: com.atguigu.components * * description: 普通的组件 */@Componentpublic class CommonComponent &#123; /** * 情况1: $&#123;key&#125; 取外部配置key对应的值! * 情况2: $&#123;key:defaultValue&#125; 没有key,可以给与默认值 */ @Value(&quot;$&#123;catalog:hahaha&#125;&quot;) private String name; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125;&#125; catalog 4.3.5 实验五： 基于注解+XML方式整合三层架构组件 需求分析 搭建一个三层架构案例，模拟查询全部学生（学生表）信息，持久层使用JdbcTemplate和Druid技术，使用XML+注解方式进行组件管理！ 数据库准备 1234567891011121314151617181920212223create database studb;use studb;CREATE TABLE students ( id INT PRIMARY KEY, name VARCHAR(50) NOT NULL, gender VARCHAR(10) NOT NULL, age INT, class VARCHAR(50));INSERT INTO students (id, name, gender, age, class)VALUES (1, &#x27;张三&#x27;, &#x27;男&#x27;, 20, &#x27;高中一班&#x27;), (2, &#x27;李四&#x27;, &#x27;男&#x27;, 19, &#x27;高中二班&#x27;), (3, &#x27;王五&#x27;, &#x27;女&#x27;, 18, &#x27;高中一班&#x27;), (4, &#x27;赵六&#x27;, &#x27;女&#x27;, 20, &#x27;高中三班&#x27;), (5, &#x27;刘七&#x27;, &#x27;男&#x27;, 19, &#x27;高中二班&#x27;), (6, &#x27;陈八&#x27;, &#x27;女&#x27;, 18, &#x27;高中一班&#x27;), (7, &#x27;杨九&#x27;, &#x27;男&#x27;, 20, &#x27;高中三班&#x27;), (8, &#x27;吴十&#x27;, &#x27;男&#x27;, 19, &#x27;高中二班&#x27;); 项目准备 项目创建 spring-annotation-practice-04 依赖导入 123456789101112131415161718192021222324252627282930313233343536&lt;dependencies&gt; &lt;!--spring context依赖--&gt; &lt;!--当你引入SpringContext依赖之后，表示将Spring的基础依赖引入了--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;6.0.6&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 数据库驱动和连接池--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.25&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.2.8&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;jakarta.annotation&lt;/groupId&gt; &lt;artifactId&gt;jakarta.annotation-api&lt;/artifactId&gt; &lt;version&gt;2.1.1&lt;/version&gt; &lt;/dependency&gt; &lt;!-- spring-jdbc --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;6.0.6&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 实体类准备 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960public class Student &#123; private Integer id; private String name; private String gender; private Integer age; private String classes; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getGender() &#123; return gender; &#125; public void setGender(String gender) &#123; this.gender = gender; &#125; public Integer getAge() &#123; return age; &#125; public void setAge(Integer age) &#123; this.age = age; &#125; public String getClasses() &#123; return classes; &#125; public void setClasses(String classes) &#123; this.classes = classes; &#125; @Override public String toString() &#123; return &quot;Student&#123;&quot; + &quot;id=&quot; + id + &quot;, name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, gender=&#x27;&quot; + gender + &#x27;\\&#x27;&#x27; + &quot;, age=&quot; + age + &quot;, classes=&#x27;&quot; + classes + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125;&#125; 三层架构搭建和实现 持久层123456789101112131415161718192021222324252627282930313233343536//接口public interface StudentDao &#123; /** * 查询全部学生数据 * @return */ List&lt;Student&gt; queryAll();&#125;//实现类@Repositorypublic class StudentDaoImpl implements StudentDao &#123; @Autowired private JdbcTemplate jdbcTemplate; /** * 查询全部学生数据 * @return */ @Override public List&lt;Student&gt; queryAll() &#123; String sql = &quot;select id , name , age , gender , class as classes from students ;&quot;; /* query可以返回集合! BeanPropertyRowMapper就是封装好RowMapper的实现,要求属性名和列名相同即可 */ List&lt;Student&gt; studentList = jdbcTemplate.query(sql, new BeanPropertyRowMapper&lt;&gt;(Student.class)); return studentList; &#125;&#125; 业务层12345678910111213141516171819202122232425262728293031//接口public interface StudentService &#123; /** * 查询全部学员业务 * @return */ List&lt;Student&gt; findAll();&#125;//实现类@Servicepublic class StudentServiceImpl implements StudentService &#123; @Autowired private StudentDao studentDao; /** * 查询全部学员业务 * @return */ @Override public List&lt;Student&gt; findAll() &#123; List&lt;Student&gt; studentList = studentDao.queryAll(); return studentList; &#125;&#125; 表述层123456789101112@Controllerpublic class StudentController &#123; @Autowired private StudentService studentService; public void findAll()&#123; List&lt;Student&gt; studentList = studentService.findAll(); System.out.println(&quot;studentList = &quot; + studentList); &#125;&#125; 三层架构IoC配置 12345&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;!-- 导入外部属性文件 --&gt; &lt;context:property-placeholder location=&quot;classpath:jdbc.properties&quot; /&gt; &lt;!-- 配置数据源 --&gt; &lt;bean id=&quot;druidDataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;atguigu.url&#125;&quot;/&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;$&#123;atguigu.driver&#125;&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;atguigu.username&#125;&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;atguigu.password&#125;&quot;/&gt; &lt;/bean&gt; &lt;bean class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;druidDataSource&quot; /&gt; &lt;/bean&gt; &lt;!-- 扫描Ioc/DI注解 --&gt; &lt;context:component-scan base-package=&quot;com.atguigu.dao,com.atguigu.service,com.atguigu.controller&quot; /&gt; 1234567891011126. 运行测试 ```java public class ControllerTest &#123; @Test public void testRun()&#123; ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;spring-ioc.xml&quot;); StudentController studentController = applicationContext.getBean(StudentController.class); studentController.findAll(); &#125; &#125; 注解+XML IoC方式问题总结 自定义类可以使用注解方式，但是第三方依赖的类依然使用XML方式！ XML格式解析效率低！ 4.4 基于 配置类 方式管理 Bean4.4.1 完全注解开发理解Spring 完全注解配置（Fully Annotation-based Configuration）是指通过 Java配置类 代码来配置 Spring 应用程序，使用注解来替代原本在 XML 配置文件中的配置。相对于 XML 配置，完全注解配置具有更强的类型安全性和更好的可读性。 两种方式思维转化： 4.4.2 实验一：配置类和扫描注解xml+注解方式 配置文件application.xml 1234567891011121314151617&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;!-- 配置自动扫描的包 --&gt; &lt;!-- 1.包要精准,提高性能! 2.会扫描指定的包和子包内容 3.多个包可以使用,分割 例如: com.atguigu.controller,com.atguigu.service等 --&gt; &lt;context:component-scan base-package=&quot;com.atguigu.components&quot;/&gt; &lt;!-- 引入外部配置文件--&gt; &lt;context:property-placeholder location=&quot;application.properties&quot; /&gt;&lt;/beans&gt; 测试创建IoC容器 123// xml方式配置文件使用ClassPathXmlApplicationContext容器读取ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;application.xml&quot;); 配置类+注解方式（完全注解方式） 配置类 使用 @Configuration 注解将一个普通的类标记为 Spring 的配置类。 12345678910111213import org.springframework.context.annotation.ComponentScan;import org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.PropertySource;//标注当前类是配置类，替代application.xml @Configuration//使用注解读取外部配置，替代 &lt;context:property-placeholder标签@PropertySource(&quot;classpath:application.properties&quot;)//使用@ComponentScan注解,可以配置扫描包,替代&lt;context:component-scan标签@ComponentScan(basePackages = &#123;&quot;com.atguigu.components&quot;&#125;)public class MyConfiguration &#123; &#125; 测试创建IoC容器 123// AnnotationConfigApplicationContext 根据配置类创建 IOC 容器对象ApplicationContext iocContainerAnnotation = new AnnotationConfigApplicationContext(MyConfiguration.class); 可以使用 no-arg 构造函数实例化 AnnotationConfigApplicationContext ，然后使用 register() 方法对其进行配置。此方法在以编程方式生成 AnnotationConfigApplicationContext 时特别有用。以下示例演示如何执行此操作： 12345678// AnnotationConfigApplicationContext-IOC容器对象ApplicationContext iocContainerAnnotation = new AnnotationConfigApplicationContext();//外部设置配置类iocContainerAnnotation.register(MyConfiguration.class);//刷新后方可生效！！iocContainerAnnotation.refresh(); 总结： @Configuration指定一个类为配置类，可以添加配置注解，替代配置xml文件 @ComponentScan(basePackages &#x3D; {“包”,”包”}) 替代&lt;context:component-scan标签实现注解扫描 @PropertySource(“classpath:配置文件地址”) 替代 &lt;context:property-placeholder标签 配合IoC&#x2F;DI注解，可以进行完整注解开发！ 4.4.3 实验二：@Bean定义组件场景需求：将Druid连接池对象存储到IoC容器 需求分析：第三方jar包的类，添加到ioc容器，无法使用@Component等相关注解！因为源码jar包内容为只读模式！ xml方式实现： 12345678910111213141516171819&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;!-- 引入外部属性文件 --&gt; &lt;context:property-placeholder location=&quot;classpath:jdbc.properties&quot;/&gt; &lt;!-- 实验六 [重要]给bean的属性赋值：引入外部属性文件 --&gt; &lt;bean id=&quot;druidDataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot;/&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;$&#123;jdbc.driver&#125;&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.user&#125;&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;/&gt; &lt;/bean&gt;&lt;/beans&gt; 配置类方式实现： @Bean 注释用于指示方法实例化、配置和初始化要由 Spring IoC 容器管理的新对象。对于那些熟悉 Spring 的 &lt;beans/&gt; XML 配置的人来说， @Bean 注释与 &lt;bean/&gt; 元素起着相同的作用。 12345678910111213141516171819202122232425//标注当前类是配置类，替代application.xml @Configuration//引入jdbc.properties文件@PropertySource(&#123;&quot;classpath:application.properties&quot;,&quot;classpath:jdbc.properties&quot;&#125;)@ComponentScan(basePackages = &#123;&quot;com.atguigu.components&quot;&#125;)public class MyConfiguration &#123; //如果第三方类进行IoC管理,无法直接使用@Component相关注解 //解决方案: xml方式可以使用&lt;bean标签 //解决方案: 配置类方式,可以使用方法返回值+@Bean注解 @Bean public DataSource createDataSource(@Value(&quot;$&#123;jdbc.user&#125;&quot;) String username, @Value(&quot;$&#123;jdbc.password&#125;&quot;)String password, @Value(&quot;$&#123;jdbc.url&#125;&quot;)String url, @Value(&quot;$&#123;jdbc.driver&#125;&quot;)String driverClassName)&#123; //使用Java代码实例化 DruidDataSource dataSource = new DruidDataSource(); dataSource.setUsername(username); dataSource.setPassword(password); dataSource.setUrl(url); dataSource.setDriverClassName(driverClassName); //返回结果即可 return dataSource; &#125;&#125; 4.4.4 实验三：高级特性：@Bean注解细节 @Bean生成BeanName问题 @Bean注解源码： 123456789101112131415161718public @interface Bean &#123; //前两个注解可以指定Bean的标识 @AliasFor(&quot;name&quot;) String[] value() default &#123;&#125;; @AliasFor(&quot;value&quot;) String[] name() default &#123;&#125;; //autowireCandidate 属性来指示该 Bean 是否候选用于自动装配。 //autowireCandidate 属性默认值为 true，表示该 Bean 是一个默认的装配目标， //可被候选用于自动装配。如果将 autowireCandidate 属性设置为 false，则说明该 Bean 不是默认的装配目标，不会被候选用于自动装配。 boolean autowireCandidate() default true; //指定初始化方法 String initMethod() default &quot;&quot;; //指定销毁方法 String destroyMethod() default &quot;(inferred)&quot;;&#125; 指定@Bean的名称： 12345678@Configurationpublic class AppConfig &#123; @Bean(&quot;myThing&quot;) //指定名称 public Thing thing() &#123; return new Thing(); &#125;&#125; @Bean 注释注释方法。使用此方法在指定为方法返回值的类型的 ApplicationContext 中注册 Bean 定义。缺省情况下，Bean 名称与方法名称相同。下面的示例演示 @Bean 方法声明： 12345678@Configurationpublic class AppConfig &#123; @Bean public TransferServiceImpl transferService() &#123; return new TransferServiceImpl(); &#125;&#125; 前面的配置完全等同于下面的Spring XML： 123&lt;beans&gt; &lt;bean id=&quot;transferService&quot; class=&quot;com.acme.TransferServiceImpl&quot;/&gt;&lt;/beans&gt; @Bean 初始化和销毁方法指定 @Bean 注解支持指定任意初始化和销毁回调方法，非常类似于 Spring XML 在 bean 元素上的 init-method 和 destroy-method 属性，如以下示例所示： 123456789101112131415161718192021222324252627public class BeanOne &#123; public void init() &#123; // initialization logic &#125;&#125;public class BeanTwo &#123; public void cleanup() &#123; // destruction logic &#125;&#125;@Configurationpublic class AppConfig &#123; @Bean(initMethod = &quot;init&quot;) public BeanOne beanOne() &#123; return new BeanOne(); &#125; @Bean(destroyMethod = &quot;cleanup&quot;) public BeanTwo beanTwo() &#123; return new BeanTwo(); &#125;&#125; @Bean Scope作用域 可以指定使用 @Bean 注释定义的 bean 应具有特定范围。您可以使用在 Bean 作用域部分中指定的任何标准作用域。 默认作用域为 singleton ，但您可以使用 @Scope 注释覆盖此范围，如以下示例所示： 123456789@Configurationpublic class MyConfiguration &#123; @Bean @Scope(&quot;prototype&quot;) public Encryptor encryptor() &#123; // ... &#125;&#125; @Bean方法之间依赖 准备组件 123456789101112public class HappyMachine &#123; private String machineName; public String getMachineName() &#123; return machineName; &#125; public void setMachineName(String machineName) &#123; this.machineName = machineName; &#125;&#125; 1234567891011121314151617public class HappyComponent &#123; //引用新组件 private HappyMachine happyMachine; public HappyMachine getHappyMachine() &#123; return happyMachine; &#125; public void setHappyMachine(HappyMachine happyMachine) &#123; this.happyMachine = happyMachine; &#125; public void doWork() &#123; System.out.println(&quot;HappyComponent.doWork&quot;); &#125;&#125; Java配置类实现： 方案1： 直接调用方法返回 Bean 实例：在一个 @Bean 方法中直接调用其他 @Bean 方法来获取 Bean 实例，虽然是方法调用，也是通过IoC容器获取对应的Bean，例如： 1234567891011121314151617@Configurationpublic class JavaConfig &#123; @Bean public HappyMachine happyMachine()&#123; return new HappyMachine(); &#125; @Bean public HappyComponent happyComponent()&#123; HappyComponent happyComponent = new HappyComponent(); //直接调用方法即可! happyComponent.setHappyMachine(happyMachine()); return happyComponent; &#125;&#125; 方案2： 参数引用法：通过方法参数传递 Bean 实例的引用来解决 Bean 实例之间的依赖关系，例如： 123456789101112131415161718192021222324252627282930313233343536373839404142434445package com.atguigu.config;import com.atguigu.ioc.HappyComponent;import com.atguigu.ioc.HappyMachine;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;/** * projectName: com.atguigu.config * description: 配置HappyComponent和HappyMachine关系 */@Configurationpublic class JavaConfig &#123; @Bean public HappyMachine happyMachine()&#123; return new HappyMachine(); &#125; /** * 可以直接在形参列表接收IoC容器中的Bean! * 情况1: 直接指定类型即可 * 情况2: 如果有多个bean,(HappyMachine 名称 ) 形参名称等于要指定的bean名称! * 例如: * @Bean * public Foo foo1()&#123; * return new Foo(); * &#125; * @Bean * public Foo foo2()&#123; * return new Foo() * &#125; * @Bean * public Component component(Foo foo1 / foo2 通过此处指定引入的bean) */ @Bean public HappyComponent happyComponent(HappyMachine happyMachine)&#123; HappyComponent happyComponent = new HappyComponent(); //赋值 happyComponent.setHappyMachine(happyMachine); return happyComponent; &#125;&#125; 4.4.5 实验四：高级特性：@Import扩展@Import 注释允许从另一个配置类加载 @Bean 定义，如以下示例所示： 123456789101112131415161718@Configurationpublic class ConfigA &#123; @Bean public A a() &#123; return new A(); &#125;&#125;@Configuration@Import(ConfigA.class)public class ConfigB &#123; @Bean public B b() &#123; return new B(); &#125;&#125; 现在，在实例化上下文时不需要同时指定 ConfigA.class 和 ConfigB.class ，只需显式提供 ConfigB ，如以下示例所示： 1234567public static void main(String[] args) &#123; ApplicationContext ctx = new AnnotationConfigApplicationContext(ConfigB.class); // now both beans A and B will be available... A a = ctx.getBean(A.class); B b = ctx.getBean(B.class);&#125; 此方法简化了容器实例化，因为只需要处理一个类，而不是要求您在构造期间记住可能大量的 @Configuration 类。 4.4.6 实验五：基于注解+配置类方式整合三层架构组件 需求分析 搭建一个三层架构案例，模拟查询全部学生（学生表）信息，持久层使用JdbcTemplate和Druid技术，使用注解+配置类方式进行组件管理！ 数据库准备 1234567891011121314151617181920212223create database studb;use studb;CREATE TABLE students ( id INT PRIMARY KEY, name VARCHAR(50) NOT NULL, gender VARCHAR(10) NOT NULL, age INT, class VARCHAR(50));INSERT INTO students (id, name, gender, age, class)VALUES (1, &#x27;张三&#x27;, &#x27;男&#x27;, 20, &#x27;高中一班&#x27;), (2, &#x27;李四&#x27;, &#x27;男&#x27;, 19, &#x27;高中二班&#x27;), (3, &#x27;王五&#x27;, &#x27;女&#x27;, 18, &#x27;高中一班&#x27;), (4, &#x27;赵六&#x27;, &#x27;女&#x27;, 20, &#x27;高中三班&#x27;), (5, &#x27;刘七&#x27;, &#x27;男&#x27;, 19, &#x27;高中二班&#x27;), (6, &#x27;陈八&#x27;, &#x27;女&#x27;, 18, &#x27;高中一班&#x27;), (7, &#x27;杨九&#x27;, &#x27;男&#x27;, 20, &#x27;高中三班&#x27;), (8, &#x27;吴十&#x27;, &#x27;男&#x27;, 19, &#x27;高中二班&#x27;); 项目准备 项目创建 spring-java-practice-06 依赖导入 123456789101112131415161718192021222324252627282930313233343536&lt;dependencies&gt; &lt;!--spring context依赖--&gt; &lt;!--当你引入SpringContext依赖之后，表示将Spring的基础依赖引入了--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;6.0.6&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 数据库驱动和连接池--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.25&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.2.8&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;jakarta.annotation&lt;/groupId&gt; &lt;artifactId&gt;jakarta.annotation-api&lt;/artifactId&gt; &lt;version&gt;2.1.1&lt;/version&gt; &lt;/dependency&gt; &lt;!-- spring-jdbc --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;6.0.6&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 实体类准备 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960public class Student &#123; private Integer id; private String name; private String gender; private Integer age; private String classes; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getGender() &#123; return gender; &#125; public void setGender(String gender) &#123; this.gender = gender; &#125; public Integer getAge() &#123; return age; &#125; public void setAge(Integer age) &#123; this.age = age; &#125; public String getClasses() &#123; return classes; &#125; public void setClasses(String classes) &#123; this.classes = classes; &#125; @Override public String toString() &#123; return &quot;Student&#123;&quot; + &quot;id=&quot; + id + &quot;, name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, gender=&#x27;&quot; + gender + &#x27;\\&#x27;&#x27; + &quot;, age=&quot; + age + &quot;, classes=&#x27;&quot; + classes + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125;&#125; 三层架构搭建和实现 持久层123456789101112131415161718192021222324252627282930313233343536//接口public interface StudentDao &#123; /** * 查询全部学生数据 * @return */ List&lt;Student&gt; queryAll();&#125;//实现类@Repositorypublic class StudentDaoImpl implements StudentDao &#123; @Autowired private JdbcTemplate jdbcTemplate; /** * 查询全部学生数据 * @return */ @Override public List&lt;Student&gt; queryAll() &#123; String sql = &quot;select id , name , age , gender , class as classes from students ;&quot;; /* query可以返回集合! BeanPropertyRowMapper就是封装好RowMapper的实现,要求属性名和列名相同即可 */ List&lt;Student&gt; studentList = jdbcTemplate.query(sql, new BeanPropertyRowMapper&lt;&gt;(Student.class)); return studentList; &#125;&#125; 业务层12345678910111213141516171819202122232425262728293031//接口public interface StudentService &#123; /** * 查询全部学员业务 * @return */ List&lt;Student&gt; findAll();&#125;//实现类@Servicepublic class StudentServiceImpl implements StudentService &#123; @Autowired private StudentDao studentDao; /** * 查询全部学员业务 * @return */ @Override public List&lt;Student&gt; findAll() &#123; List&lt;Student&gt; studentList = studentDao.queryAll(); return studentList; &#125;&#125; 表述层123456789101112@Controllerpublic class StudentController &#123; @Autowired private StudentService studentService; public void findAll()&#123; List&lt;Student&gt; studentList = studentService.findAll(); System.out.println(&quot;studentList = &quot; + studentList); &#125;&#125; 三层架构IoC配置类 123456789101112131415161718192021222324252627282930313233@Configuration@ComponentScan(basePackages = &quot;com.atguigu&quot;)@PropertySource(&quot;classpath:jdbc.properties&quot;)public class JavaConfig &#123; @Value(&quot;$&#123;atguigu.url&#125;&quot;) private String url; @Value(&quot;$&#123;atguigu.driver&#125;&quot;) private String driver; @Value(&quot;$&#123;atguigu.username&#125;&quot;) private String username; @Value(&quot;$&#123;atguigu.password&#125;&quot;) private String password; @Bean(destroyMethod = &quot;close&quot;) public DruidDataSource dataSource()&#123; DruidDataSource dataSource = new DruidDataSource(); dataSource.setUrl(url); dataSource.setDriverClassName(driver); dataSource.setUsername(username); dataSource.setPassword(password); return dataSource; &#125; @Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE) @Bean public JdbcTemplate jdbcTemplate(DataSource dataSource)&#123; JdbcTemplate jdbcTemplate = new JdbcTemplate(); jdbcTemplate.setDataSource(dataSource); return jdbcTemplate; &#125;&#125; 运行测试 1234567891011121314public class ControllerTest &#123; @Test public void testRun()&#123; AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(JavaConfig.class); StudentController studentController = applicationContext.getBean(StudentController.class); studentController.findAll(); &#125;&#125; 注解+配置类 IoC方式总结 完全摒弃了XML配置文件 自定义类使用IoC和DI注解标记 第三方类使用配置类声明方法+@Bean方式处理 完全注解方式（配置类+注解）是现在主流配置方式 4.5 三种配置方式总结4.5.1 XML方式配置总结 所有内容写到xml格式配置文件中 声明bean通过&lt;bean标签 &lt;bean标签包含基本信息（id,class）和属性信息 &lt;property name value &#x2F; ref 引入外部的properties文件可以通过&lt;context:property-placeholder IoC具体容器实现选择ClassPathXmlApplicationContext对象 4.5.2 XML+注解方式配置总结 注解负责标记IoC的类和进行属性装配 xml文件依然需要，需要通过&lt;context:component-scan标签指定注解范围 标记IoC注解：@Component,@Service,@Controller,@Repository&#x20; 标记DI注解：@Autowired @Qualifier @Resource @Value IoC具体容器实现选择ClassPathXmlApplicationContext对象 4.5.3 完全注解方式配置总结 完全注解方式指的是去掉xml文件，使用配置类 + 注解实现 xml文件替换成使用@Configuration注解标记的类 标记IoC注解：@Component,@Service,@Controller,@Repository&#x20; 标记DI注解：@Autowired @Qualifier @Resource @Value &lt;context:component-scan标签指定注解范围使用@ComponentScan(basePackages &#x3D; {“com.atguigu.components”})替代 &lt;context:property-placeholder引入外部配置文件使用@PropertySource({“classpath:application.properties”,”classpath:jdbc.properties”})替代 &lt;bean 标签使用@Bean注解和方法实现 IoC具体容器实现选择AnnotationConfigApplicationContext对象 4.6 整合Spring5-Test5搭建测试环境 整合测试环境作用 好处1：不需要自己创建IOC容器对象了 好处2：任何需要的bean都可以在测试类中直接享受自动装配 导入相关依赖 123456789101112&lt;!--junit5测试--&gt;&lt;dependency&gt; &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt; &lt;artifactId&gt;junit-jupiter-api&lt;/artifactId&gt; &lt;version&gt;5.3.1&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;6.0.6&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt; 整合测试注解使用 123456789101112//@SpringJUnitConfig(locations = &#123;&quot;classpath:spring-context.xml&quot;&#125;) //指定配置文件xml@SpringJUnitConfig(value = &#123;BeanConfig.class&#125;) //指定配置类public class Junit5IntegrationTest &#123; @Autowired private User user; @Test public void testJunit5() &#123; System.out.println(user); &#125;&#125; 五、Spring AOP面向切面编程5.1 场景设定和问题复现 准备AOP项目 项目名：spring-aop-annotation pom.xml 123456789101112131415&lt;dependencies&gt; &lt;!--spring context依赖--&gt; &lt;!--当你引入Spring Context依赖之后，表示将Spring的基础依赖引入了--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;6.0.6&lt;/version&gt; &lt;/dependency&gt; &lt;!--junit5测试--&gt; &lt;dependency&gt; &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt; &lt;artifactId&gt;junit-jupiter-api&lt;/artifactId&gt; &lt;version&gt;5.3.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;6.0.6&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;jakarta.annotation&lt;/groupId&gt; &lt;artifactId&gt;jakarta.annotation-api&lt;/artifactId&gt; &lt;version&gt;2.1.1&lt;/version&gt; &lt;/dependency&gt; 123456789101112131415162. 声明接口 ```java /** * + - * / 运算的标准接口! */ public interface Calculator &#123; int add(int i, int j); int sub(int i, int j); int mul(int i, int j); int div(int i, int j); &#125; 接口实现 1package com.atguigu.proxy; &#x2F;** 实现计算接口,单纯添加 + - * &#x2F; 实现! 掺杂其他功能! *&#x2F; public class CalculatorPureImpl implements Calculator { @Override public int add(int i, int j) { int result = i + j; return result; } @Override public int sub(int i, int j) { int result = i - j; return result; } @Override public int mul(int i, int j) { int result = i * j; return result; } @Override public int div(int i, int j) { int result = i / j; return result; } } 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657584. 声明带日志接口实现 新需求： 需要在每个方法中，添加控制台输出，输出参数和输出计算后的返回值！ ![](http://heavy_code_industry.gitee.io/code_heavy_industry/assets/img/img002.f8e54219.png) ```java package com.atguigu.proxy; /** * 在每个方法中,输出传入的参数和计算后的返回结果! */ public class CalculatorLogImpl implements Calculator &#123; @Override public int add(int i, int j) &#123; System.out.println(&quot;参数是：&quot; + i + &quot;,&quot; + j); int result = i + j; System.out.println(&quot;方法内部 result = &quot; + result); return result; &#125; @Override public int sub(int i, int j) &#123; System.out.println(&quot;参数是：&quot; + i + &quot;,&quot; + j); int result = i - j; System.out.println(&quot;方法内部 result = &quot; + result); return result; &#125; @Override public int mul(int i, int j) &#123; System.out.println(&quot;参数是：&quot; + i + &quot;,&quot; + j); int result = i * j; System.out.println(&quot;方法内部 result = &quot; + result); return result; &#125; @Override public int div(int i, int j) &#123; System.out.println(&quot;参数是：&quot; + i + &quot;,&quot; + j); int result = i / j; System.out.println(&quot;方法内部 result = &quot; + result); return result; &#125; &#125; 代码问题分析 代码缺陷 对核心业务功能有干扰，导致程序员在开发核心业务功能时分散了精力 附加功能代码重复，分散在各个业务功能方法中！冗余，且不方便统一维护！ 解决思路 &#x20; 核心就是：解耦。我们需要把附加功能从业务功能代码中抽取出来。 &#x20; 将重复的代码统一提取，并且[[动态插入]]到每个业务方法！ 技术困难 解决问题的困难：提取重复附加功能代码到一个类中，可以实现 但是如何将代码插入到各个方法中，我们不会，我们需要引用新技术！！！ 5.2 解决技术代理模式 代理模式 二十三种设计模式中的一种，属于结构型模式。它的作用就是通过提供一个代理类，让我们在调用目标方法的时候，不再是直接对目标方法进行调用，而是通过代理类间接调用。让不属于目标方法核心逻辑的代码从目标方法中剥离出来——解耦。调用目标方法时先调用代理对象的方法，减少对目标方法的调用和打扰，同时让附加功能能够集中在一起也有利于统一维护。 无代理场景： 有代理场景： 生活中的代理： 广告商找大明星拍广告需要经过经纪人 合作伙伴找大老板谈合作要约见面时间需要经过秘书 房产中介是买卖双方的代理 太监是大臣和皇上之间的代理相关术语： 代理：将非核心逻辑剥离出来以后，封装这些非核心逻辑的类、对象、方法。(中介) 动词：指做代理这个动作，或这项工作 名词：扮演代理这个角色的类、对象、方法 目标：被代理“套用”了核心逻辑代码的类、对象、方法。(房东)代理在开发中实现的方式具体有两种：静态代理，[动态代理技术] 静态代理 主动创建代理类： 1234567891011121314151617181920212223public class CalculatorStaticProxy implements Calculator &#123; // 将被代理的目标对象声明为成员变量 private Calculator target; public CalculatorStaticProxy(Calculator target) &#123; this.target = target; &#125; @Override public int add(int i, int j) &#123; // 附加功能由代理类中的代理方法来实现 System.out.println(&quot;参数是：&quot; + i + &quot;,&quot; + j); // 通过目标对象来实现核心业务逻辑 int addResult = target.add(i, j); System.out.println(&quot;方法内部 result = &quot; + result); return addResult; &#125; …… 静态代理确实实现了解耦，但是由于代码都写死了，完全不具备任何的灵活性。就拿日志功能来说，将来其他地方也需要附加日志，那还得再声明更多个静态代理类，那就产生了大量重复的代码，日志功能还是分散的，没有统一管理。 提出进一步的需求：将日志功能集中到一个代理类中，将来有任何日志需求，都通过这一个代理类来实现。这就需要使用动态代理技术了。 动态代理 动态代理技术分类 JDK动态代理：JDK原生的实现方式，需要被代理的目标类必须实现接口！他会根据目标类的接口动态生成一个代理对象！代理对象和目标对象有相同的接口！（拜把子） cglib：通过继承被代理的目标类实现代理，所以不需要目标类实现接口！（认干爹）JDK动态代理技术实现（了解） 代理工程：基于jdk代理技术，生成代理对象 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class ProxyFactory &#123; private Object target; public ProxyFactory(Object target) &#123; this.target = target; &#125; public Object getProxy()&#123; /** * newProxyInstance()：创建一个代理实例 * 其中有三个参数： * 1、classLoader：加载动态生成的代理类的类加载器 * 2、interfaces：目标对象实现的所有接口的class对象所组成的数组 * 3、invocationHandler：设置代理对象实现目标对象方法的过程，即代理类中如何重写接口中的抽象方法 */ ClassLoader classLoader = target.getClass().getClassLoader(); Class&lt;?&gt;[] interfaces = target.getClass().getInterfaces(); InvocationHandler invocationHandler = new InvocationHandler() &#123; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; /** * proxy：代理对象 * method：代理对象需要实现的方法，即其中需要重写的方法 * args：method所对应方法的参数 */ Object result = null; try &#123; System.out.println(&quot;[动态代理][日志] &quot;+method.getName()+&quot;，参数：&quot;+ Arrays.toString(args)); result = method.invoke(target, args); System.out.println(&quot;[动态代理][日志] &quot;+method.getName()+&quot;，结果：&quot;+ result); &#125; catch (Exception e) &#123; e.printStackTrace(); System.out.println(&quot;[动态代理][日志] &quot;+method.getName()+&quot;，异常：&quot;+e.getMessage()); &#125; finally &#123; System.out.println(&quot;[动态代理][日志] &quot;+method.getName()+&quot;，方法执行完毕&quot;); &#125; return result; &#125; &#125;; return Proxy.newProxyInstance(classLoader, interfaces, invocationHandler); &#125;&#125; 测试代码： 1234567@Testpublic void testDynamicProxy()&#123; ProxyFactory factory = new ProxyFactory(new CalculatorLogImpl()); Calculator proxy = (Calculator) factory.getProxy(); proxy.div(1,0); //proxy.div(1,1);&#125; 代理总结 代理方式可以解决附加功能代码干扰核心代码和不方便统一维护的问题！ 他主要是将附加功能代码提取到代理中执行，不干扰目标核心代码！ 但是我们也发现，无论使用静态代理和动态代理(jdk,cglib)，程序员的工作都比较繁琐！ 需要自己编写代理工厂等！ 但是，提前剧透，我们在实际开发中，不需要编写代理代码，我们可以使用[Spring AOP]框架， 他会简化动态代理的实现！！！ 5.3 面向切面编程思维（AOP） 面向切面编程思想AOP AOP：Aspect Oriented Programming面向切面编程 AOP可以说是OOP（Object Oriented Programming，面向对象编程）的补充和完善。OOP引入封装、继承、多态等概念来建立一种对象层次结构，用于模拟公共行为的一个集合。不过OOP允许开发者定义纵向的关系，但并不适合定义横向的关系，例如日志功能。日志代码往往横向地散布在所有对象层次中，而与它对应的对象的核心功能毫无关系对于其他类型的代码，如安全性、异常处理和透明的持续性也都是如此，这种散布在各处的无关的代码被称为横切（cross cutting），在OOP设计中，它导致了大量代码的重复，而不利于各个模块的重用。 AOP技术恰恰相反，它利用一种称为”横切”的技术，剖解开封装的对象内部，并将那些影响了多个类的公共行为封装到一个可重用模块，并将其命名为”Aspect”，即切面。所谓”切面”，简单说就是那些与业务无关，却为业务模块所共同调用的逻辑或责任封装起来，便于减少系统的重复代码，降低模块之间的耦合度，并有利于未来的可操作性和可维护性。 使用AOP，可以在不修改原来代码的基础上添加新功能。 AOP思想主要的应用场景 AOP（面向切面编程）是一种编程范式，它通过将通用的横切关注点（如日志、事务、权限控制等）与业务逻辑分离，使得代码更加清晰、简洁、易于维护。AOP可以应用于各种场景，以下是一些常见的AOP应用场景： 日志记录：在系统中记录日志是非常重要的，可以使用AOP来实现日志记录的功能，可以在方法执行前、执行后或异常抛出时记录日志。 事务处理：在数据库操作中使用事务可以保证数据的一致性，可以使用AOP来实现事务处理的功能，可以在方法开始前开启事务，在方法执行完毕后提交或回滚事务。 安全控制：在系统中包含某些需要安全控制的操作，如登录、修改密码、授权等，可以使用AOP来实现安全控制的功能。可以在方法执行前进行权限判断，如果用户没有权限，则抛出异常或转向到错误页面，以防止未经授权的访问。 性能监控：在系统运行过程中，有时需要对某些方法的性能进行监控，以找到系统的瓶颈并进行优化。可以使用AOP来实现性能监控的功能，可以在方法执行前记录时间戳，在方法执行完毕后计算方法执行时间并输出到日志中。 异常处理：系统中可能出现各种异常情况，如空指针异常、数据库连接异常等，可以使用AOP来实现异常处理的功能，在方法执行过程中，如果出现异常，则进行异常处理（如记录日志、发送邮件等）。 缓存控制：在系统中有些数据可以缓存起来以提高访问速度，可以使用AOP来实现缓存控制的功能，可以在方法执行前查询缓存中是否有数据，如果有则返回，否则执行方法并将方法返回值存入缓存中。 动态代理：AOP的实现方式之一是通过动态代理，可以代理某个类的所有方法，用于实现各种功能。综上所述，AOP可以应用于各种场景，它的作用是将通用的横切关注点与业务逻辑分离，使得代码更加清晰、简洁、易于维护。 AOP术语名词介绍 1-横切关注点 从每个方法中抽取出来的同一类非核心业务。在同一个项目中，我们可以使用多个横切关注点对相关方法进行多个不同方面的增强。 这个概念不是语法层面天然存在的，而是根据附加功能的逻辑上的需要：有十个附加功能，就有十个横切关注点。 AOP把软件系统分为两个部分：核心关注点和横切关注点。业务处理的主要流程是核心关注点，与之关系不大的部分是横切关注点。横切关注点的一个特点是，他们经常发生在核心关注点的多处，而各处基本相似，比如权限认证、日志、事务、异常等。AOP的作用在于分离系统中的各种关注点，将核心关注点和横切关注点分离开来。 2-通知(增强) 每一个横切关注点上要做的事情都需要写一个方法来实现，这样的方法就叫通知方法。 前置通知：在被代理的目标方法前执行 返回通知：在被代理的目标方法成功结束后执行（寿终正寝） 异常通知：在被代理的目标方法异常结束后执行（死于非命） 后置通知：在被代理的目标方法最终结束后执行（盖棺定论） 环绕通知：使用try…catch…finally结构围绕整个被代理的目标方法，包括上面四种通知对应的所有位置3-连接点 joinpoint 这也是一个纯逻辑概念，不是语法定义的。 指那些被拦截到的点。在 Spring 中，可以被动态代理拦截目标类的方法 4-切入点 pointcut 定位连接点的方式，或者可以理解成被选中的连接点！ 是一个表达式，比如execution(* com.spring.service.impl..(..))。符合条件的每个方法都是一个具体的连接点。 5-切面 aspect 切入点和通知的结合。是一个类。 6-目标 target 被代理的目标对象。 7-代理 proxy 向目标对象应用通知之后创建的代理对象。 8-织入 weave 指把通知应用到目标上，生成代理对象的过程。可以在编译期织入，也可以在运行期织入，Spring采用后者。 5.4 Spring AOP框架介绍和关系梳理 AOP一种区别于OOP的编程思维，用来完善和解决OOP的非核心代码冗余和不方便统一维护问题！ 代理技术（动态代理|静态代理）是实现AOP思维编程的具体技术，但是自己使用动态代理实现代码比较繁琐！ Spring AOP框架，基于AOP编程思维，封装动态代理技术，简化动态代理技术实现的框架！SpringAOP内部帮助我们实现动态代理，我们只需写少量的配置，指定生效范围即可,即可完成面向切面思维编程的实现！ 5.5 Spring AOP基于注解方式实现和细节5.5.1 Spring AOP底层技术组成 动态代理（InvocationHandler）：JDK原生的实现方式，需要被代理的目标类必须实现接口。因为这个技术要求代理对象和目标对象实现同样的接口（兄弟两个拜把子模式）。 cglib：通过继承被代理的目标类（认干爹模式）实现代理，所以不需要目标类实现接口。 AspectJ：早期的AOP实现的框架，SpringAOP借用了AspectJ中的AOP注解。 5.5.2 初步实现 加入依赖123456789101112&lt;!-- spring-aspects会帮我们传递过来aspectjweaver --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;version&gt;6.0.6&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt; &lt;version&gt;6.0.6&lt;/version&gt;&lt;/dependency&gt; 准备接口1234567891011public interface Calculator &#123; int add(int i, int j); int sub(int i, int j); int mul(int i, int j); int div(int i, int j); &#125; 纯净实现类1package com.atguigu.proxy; &#x2F;** 实现计算接口,单纯添加 + - * &#x2F; 实现! 掺杂其他功能! *&#x2F; @Component public class CalculatorPureImpl implements Calculator { @Override public int add(int i, int j) { int result = i + j; return result; } @Override public int sub(int i, int j) { int result = i - j; return result; } @Override public int mul(int i, int j) { int result = i * j; return result; } @Override public int div(int i, int j) { int result = i / j; return result; } } 1234567891011121314151617181920212223242526272829303132333435364. 声明切面类 ```java package com.atguigu.advice; import org.aspectj.lang.annotation.*; import org.springframework.stereotype.Component; // @Aspect表示这个类是一个切面类 @Aspect // @Component注解保证这个切面类能够放入IOC容器 @Component public class LogAspect &#123; // @Before注解：声明当前方法是前置通知方法 // value属性：指定切入点表达式，由切入点表达式控制当前通知方法要作用在哪一个目标方法上 @Before(value = &quot;execution(public int com.atguigu.proxy.CalculatorPureImpl.add(int,int))&quot;) public void printLogBeforeCore() &#123; System.out.println(&quot;[AOP前置通知] 方法开始了&quot;); &#125; @AfterReturning(value = &quot;execution(public int com.atguigu.proxy.CalculatorPureImpl.add(int,int))&quot;) public void printLogAfterSuccess() &#123; System.out.println(&quot;[AOP返回通知] 方法成功返回了&quot;); &#125; @AfterThrowing(value = &quot;execution(public int com.atguigu.proxy.CalculatorPureImpl.add(int,int))&quot;) public void printLogAfterException() &#123; System.out.println(&quot;[AOP异常通知] 方法抛异常了&quot;); &#125; @After(value = &quot;execution(public int com.atguigu.proxy.CalculatorPureImpl.add(int,int))&quot;) public void printLogFinallyEnd() &#123; System.out.println(&quot;[AOP后置通知] 方法最终结束了&quot;); &#125; &#125; 开启aspectj注解支持 xml方式123456789101112&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt; &lt;!-- 进行包扫描--&gt; &lt;context:component-scan base-package=&quot;com.atguigu&quot; /&gt; &lt;!-- 开启aspectj框架注解支持--&gt; &lt;aop:aspectj-autoproxy /&gt;&lt;/beans&gt; 配置类方式1234567@Configuration@ComponentScan(basePackages = &quot;com.atguigu&quot;)//作用等于 &lt;aop:aspectj-autoproxy /&gt; 配置类上开启 Aspectj注解支持!@EnableAspectJAutoProxypublic class MyConfig &#123;&#125; 测试效果12345678910111213//@SpringJUnitConfig(locations = &quot;classpath:spring-aop.xml&quot;)@SpringJUnitConfig(value = &#123;MyConfig.class&#125;)public class AopTest &#123; @Autowired private Calculator calculator; @Test public void testCalculator()&#123; calculator.add(1,1); &#125;&#125; 输出结果：1234&quot;C:\\Program Files\\Java\\jdk-17\\bin\\java.exe&quot; -ea -Didea.test.cyclic.buffer.size=1048576 &quot;-javaagent:D:\\Program Files\\JetBrains\\IntelliJ IDEA 2022.3.2\\lib\\idea_rt.jar=65511:D:\\Program Files\\JetBrains\\IntelliJ IDEA 2022.3.2\\bin&quot; -Dfile.encoding=UTF-8 -classpath &quot;C:\\Users\\Jackiechan\\.m2\\repository\\org\\junit\\platform\\junit-platform-launcher\\1.3.1\\junit-platform-launcher-1.3.1.jar;C:\\Users\\Jackiechan\\.m2\\repository\\org\\apiguardian\\apiguardian-api\\1.0.0\\apiguardian-api-1.0.0.jar;C:\\Users\\Jackiechan\\.m2\\repository\\org\\junit\\platform\\junit-platform-engine\\1.3.1\\junit-platform-engine-1.3.1.jar;C:\\Users\\Jackiechan\\.m2\\repository\\org\\junit\\platform\\junit-platform-commons\\1.3.1\\junit-platform-commons-1.3.1.jar;C:\\Users\\Jackiechan\\.m2\\repository\\org\\opentest4j\\opentest4j\\1.1.1\\opentest4j-1.1.1.jar;C:\\Users\\Jackiechan\\.m2\\repository\\org\\junit\\jupiter\\junit-jupiter-engine\\5.3.1\\junit-jupiter-engine-5.3.1.jar;C:\\Users\\Jackiechan\\.m2\\repository\\org\\junit\\jupiter\\junit-jupiter-api\\5.3.1\\junit-jupiter-api-5.3.1.jar;D:\\Program Files\\JetBrains\\IntelliJ IDEA 2022.3.2\\lib\\idea_rt.jar;D:\\Program Files\\JetBrains\\IntelliJ IDEA 2022.3.2\\plugins\\junit\\lib\\junit5-rt.jar;D:\\Program Files\\JetBrains\\IntelliJ IDEA 2022.3.2\\plugins\\junit\\lib\\junit-rt.jar;D:\\javaprojects\\backend-engineering\\part01-spring\\spring-aop-annotation\\target\\test-classes;D:\\javaprojects\\backend-engineering\\part01-spring\\spring-aop-annotation\\target\\classes;D:\\repository\\org\\springframework\\spring-context\\6.0.6\\spring-context-6.0.6.jar;D:\\repository\\org\\springframework\\spring-beans\\6.0.6\\spring-beans-6.0.6.jar;D:\\repository\\org\\springframework\\spring-core\\6.0.6\\spring-core-6.0.6.jar;D:\\repository\\org\\springframework\\spring-jcl\\6.0.6\\spring-jcl-6.0.6.jar;D:\\repository\\org\\springframework\\spring-expression\\6.0.6\\spring-expression-6.0.6.jar;D:\\repository\\org\\junit\\jupiter\\junit-jupiter-api\\5.3.1\\junit-jupiter-api-5.3.1.jar;D:\\repository\\org\\apiguardian\\apiguardian-api\\1.0.0\\apiguardian-api-1.0.0.jar;D:\\repository\\org\\opentest4j\\opentest4j\\1.1.1\\opentest4j-1.1.1.jar;D:\\repository\\org\\junit\\platform\\junit-platform-commons\\1.3.1\\junit-platform-commons-1.3.1.jar;D:\\repository\\org\\springframework\\spring-test\\6.0.6\\spring-test-6.0.6.jar;D:\\repository\\jakarta\\annotation\\jakarta.annotation-api\\2.1.1\\jakarta.annotation-api-2.1.1.jar;D:\\repository\\mysql\\mysql-connector-java\\8.0.25\\mysql-connector-java-8.0.25.jar;D:\\repository\\com\\google\\protobuf\\protobuf-java\\3.11.4\\protobuf-java-3.11.4.jar;D:\\repository\\com\\alibaba\\druid\\1.2.8\\druid-1.2.8.jar;D:\\repository\\javax\\annotation\\javax.annotation-api\\1.3.2\\javax.annotation-api-1.3.2.jar;D:\\repository\\org\\springframework\\spring-aop\\6.0.6\\spring-aop-6.0.6.jar;D:\\repository\\org\\springframework\\spring-aspects\\6.0.6\\spring-aspects-6.0.6.jar;D:\\repository\\org\\aspectj\\aspectjweaver\\1.9.9.1\\aspectjweaver-1.9.9.1.jar&quot; com.intellij.rt.junit.JUnitStarter -ideVersion5 -junit5 com.atguigu.test.AopTest,testCalculator[AOP前置通知] 方法开始了[AOP返回通知] 方法成功返回了[AOP后置通知] 方法最终结束了 5.5.3 获取通知细节信息 JointPoint接口 需要获取方法签名、传入的实参等信息时，可以在通知方法声明JoinPoint类型的形参。 要点1：JoinPoint 接口通过 getSignature() 方法获取目标方法的签名（方法声明时的完整信息） 要点2：通过目标方法签名对象获取方法名 要点3：通过 JoinPoint 对象获取外界调用目标方法时传入的实参列表组成的数组1234567891011121314151617181920212223242526272829// @Before注解标记前置通知方法// value属性：切入点表达式，告诉Spring当前通知方法要套用到哪个目标方法上// 在前置通知方法形参位置声明一个JoinPoint类型的参数，Spring就会将这个对象传入// 根据JoinPoint对象就可以获取目标方法名称、实际参数列表@Before(value = &quot;execution(public int com.atguigu.aop.api.Calculator.add(int,int))&quot;)public void printLogBeforeCore(JoinPoint joinPoint) &#123; // 1.通过JoinPoint对象获取目标方法签名对象 // 方法的签名：一个方法的全部声明信息 Signature signature = joinPoint.getSignature(); // 2.通过方法的签名对象获取目标方法的详细信息 String methodName = signature.getName(); System.out.println(&quot;methodName = &quot; + methodName); int modifiers = signature.getModifiers(); System.out.println(&quot;modifiers = &quot; + modifiers); String declaringTypeName = signature.getDeclaringTypeName(); System.out.println(&quot;declaringTypeName = &quot; + declaringTypeName); // 3.通过JoinPoint对象获取外界调用目标方法时传入的实参列表 Object[] args = joinPoint.getArgs(); // 4.由于数组直接打印看不到具体数据，所以转换为List集合 List&lt;Object&gt; argList = Arrays.asList(args); System.out.println(&quot;[AOP前置通知] &quot; + methodName + &quot;方法开始了，参数列表：&quot; + argList);&#125; 方法返回值 在返回通知中，通过 @AfterReturning注解的returning属性获取目标方法的返回值！ 1234567891011121314// @AfterReturning注解标记返回通知方法// 在返回通知中获取目标方法返回值分两步：// 第一步：在@AfterReturning注解中通过returning属性设置一个名称// 第二步：使用returning属性设置的名称在通知方法中声明一个对应的形参@AfterReturning( value = &quot;execution(public int com.atguigu.aop.api.Calculator.add(int,int))&quot;, returning = &quot;targetMethodReturnValue&quot;)public void printLogAfterCoreSuccess(JoinPoint joinPoint, Object targetMethodReturnValue) &#123; String methodName = joinPoint.getSignature().getName(); System.out.println(&quot;[AOP返回通知] &quot;+methodName+&quot;方法成功结束了，返回值是：&quot; + targetMethodReturnValue);&#125; 异常对象捕捉 在异常通知中，通过@AfterThrowing注解的throwing属性获取目标方法抛出的异常对象 1234567891011121314// @AfterThrowing注解标记异常通知方法// 在异常通知中获取目标方法抛出的异常分两步：// 第一步：在@AfterThrowing注解中声明一个throwing属性设定形参名称// 第二步：使用throwing属性指定的名称在通知方法声明形参，Spring会将目标方法抛出的异常对象从这里传给我们@AfterThrowing( value = &quot;execution(public int com.atguigu.aop.api.Calculator.add(int,int))&quot;, throwing = &quot;targetMethodException&quot;)public void printLogAfterCoreException(JoinPoint joinPoint, Throwable targetMethodException) &#123; String methodName = joinPoint.getSignature().getName(); System.out.println(&quot;[AOP异常通知] &quot;+methodName+&quot;方法抛异常了，异常类型是：&quot; + targetMethodException.getClass().getName());&#125; 5.5.4 切点表达式语法 切点表达式作用 AOP切点表达式（Pointcut Expression）是一种用于指定切点的语言，它可以通过定义匹配规则，来选择需要被切入的目标对象。 切点表达式语法 切点表达式总结 语法细节 第一位：execution( ) 固定开头 第二位：方法访问修饰符 1public private 直接描述对应修饰符即可 第三位：方法返回值 12int String void 直接描述返回值类型 注意： 特殊情况 不考虑 访问修饰符和返回值 execution(* * ) 这是错误语法 execution( *) &#x3D;&#x3D; 你只要考虑返回值 或者 不考虑访问修饰符 相当于全部不考虑了 第四位：指定包的地址 12345固定的包: com.atguigu.api | service | dao单层的任意命名: com.atguigu.* = com.atguigu.api com.atguigu.dao * = 任意一层的任意命名任意层任意命名: com.. = com.atguigu.api.erdaye com.a.a.a.a.a.a.a ..任意层,任意命名 用在包上!注意: ..不能用作包开头 public int .. 错误语法 com..找到任何包下: *.. 第五位：指定类名称 12345固定名称: UserService任意类名: *部分任意: com..service.impl.*Impl任意包任意类: *..* 第六位：指定方法名称 12语法和类名一致任意访问修饰符,任意类的任意方法: * *..*.* 第七位：方法参数 12345678第七位: 方法的参数描述 具体值: (String,int) != (int,String) 没有参数 () 模糊值: 任意参数 有 或者 没有 (..) ..任意参数的意识 部分具体和模糊: 第一个参数是字符串的方法 (String..) 最后一个参数是字符串 (..String) 字符串开头,int结尾 (String..int) 包含int类型(..int..) 切点表达式案例 1234561.查询某包某类下，访问修饰符是公有，返回值是int的全部方法2.查询某包下类中第一个参数是String的方法3.查询全部包下，无参数的方法！4.查询com包下，以int参数类型结尾的方法5.查询指定包下，Service开头类的私有返回值int的无参数方法 5.5.5 重用（提取）切点表达式 重用切点表达式优点 123456789101112131415161718192021 // @Before注解：声明当前方法是前置通知方法// value属性：指定切入点表达式，由切入点表达式控制当前通知方法要作用在哪一个目标方法上@Before(value = &quot;execution(public int com.atguigu.proxy.CalculatorPureImpl.add(int,int))&quot;)public void printLogBeforeCore() &#123; System.out.println(&quot;[AOP前置通知] 方法开始了&quot;);&#125;@AfterReturning(value = &quot;execution(public int com.atguigu.proxy.CalculatorPureImpl.add(int,int))&quot;)public void printLogAfterSuccess() &#123; System.out.println(&quot;[AOP返回通知] 方法成功返回了&quot;);&#125;@AfterThrowing(value = &quot;execution(public int com.atguigu.proxy.CalculatorPureImpl.add(int,int))&quot;)public void printLogAfterException() &#123; System.out.println(&quot;[AOP异常通知] 方法抛异常了&quot;);&#125;@After(value = &quot;execution(public int com.atguigu.proxy.CalculatorPureImpl.add(int,int))&quot;)public void printLogFinallyEnd() &#123; System.out.println(&quot;[AOP后置通知] 方法最终结束了&quot;);&#125; 上面案例，是我们之前编写切点表达式的方式，发现， 所有增强方法的切点表达式相同！ 出现了冗余，如果需要切换也不方便统一维护！ 我们可以将切点提取，在增强上进行引用即可！ 同一类内部引用 提取 123// 切入点表达式重用@Pointcut(&quot;execution(public int com.atguigu.aop.api.Calculator.add(int,int)))&quot;)public void declarPointCut() &#123;&#125; 注意：提取切点注解使用@Pointcut(切点表达式) ， 需要添加到一个无参数无返回值方法上即可！ 引用 12@Before(value = &quot;declarPointCut()&quot;)public void printLogBeforeCoreOperation(JoinPoint joinPoint) &#123; 不同类中引用 不同类在引用切点，只需要添加类的全限定符+方法名即可！ 12@Before(value = &quot;com.atguigu.spring.aop.aspect.LogAspect.declarPointCut()&quot;)public Object roundAdvice(ProceedingJoinPoint joinPoint) &#123; 切点统一管理 建议：将切点表达式统一存储到一个类中进行集中管理和维护！ 123456789101112@Componentpublic class AtguiguPointCut &#123; @Pointcut(value = &quot;execution(public int *..Calculator.sub(int,int))&quot;) public void atguiguGlobalPointCut()&#123;&#125; @Pointcut(value = &quot;execution(public int *..Calculator.add(int,int))&quot;) public void atguiguSecondPointCut()&#123;&#125; @Pointcut(value = &quot;execution(* *..*Service.*(..))&quot;) public void transactionPointCut()&#123;&#125;&#125; 5.5.6 环绕通知环绕通知对应整个 try…catch…finally 结构，包括前面四种通知的所有功能。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546// 使用@Around注解标明环绕通知方法@Around(value = &quot;com.atguigu.aop.aspect.AtguiguPointCut.transactionPointCut()&quot;)public Object manageTransaction( // 通过在通知方法形参位置声明ProceedingJoinPoint类型的形参， // Spring会将这个类型的对象传给我们 ProceedingJoinPoint joinPoint) &#123; // 通过ProceedingJoinPoint对象获取外界调用目标方法时传入的实参数组 Object[] args = joinPoint.getArgs(); // 通过ProceedingJoinPoint对象获取目标方法的签名对象 Signature signature = joinPoint.getSignature(); // 通过签名对象获取目标方法的方法名 String methodName = signature.getName(); // 声明变量用来存储目标方法的返回值 Object targetMethodReturnValue = null; try &#123; // 在目标方法执行前：开启事务（模拟） log.debug(&quot;[AOP 环绕通知] 开启事务，方法名：&quot; + methodName + &quot;，参数列表：&quot; + Arrays.asList(args)); // 过ProceedingJoinPoint对象调用目标方法 // 目标方法的返回值一定要返回给外界调用者 targetMethodReturnValue = joinPoint.proceed(args); // 在目标方法成功返回后：提交事务（模拟） log.debug(&quot;[AOP 环绕通知] 提交事务，方法名：&quot; + methodName + &quot;，方法返回值：&quot; + targetMethodReturnValue); &#125;catch (Throwable e)&#123; // 在目标方法抛异常后：回滚事务（模拟） log.debug(&quot;[AOP 环绕通知] 回滚事务，方法名：&quot; + methodName + &quot;，异常：&quot; + e.getClass().getName()); &#125;finally &#123; // 在目标方法最终结束后：释放数据库连接 log.debug(&quot;[AOP 环绕通知] 释放数据库连接，方法名：&quot; + methodName); &#125; return targetMethodReturnValue;&#125; 5.5.7 切面优先级设置相同目标方法上同时存在多个切面时，切面的优先级控制切面的内外嵌套顺序。 优先级高的切面：外面 优先级低的切面：里面 使用 @Order 注解可以控制切面的优先级： @Order(较小的数)：优先级高 @Order(较大的数)：优先级低 实际意义 实际开发时，如果有多个切面嵌套的情况，要慎重考虑。例如：如果事务切面优先级高，那么在缓存中命中数据的情况下，事务切面的操作都浪费了。 此时应该将缓存切面的优先级提高，在事务操作之前先检查缓存中是否存在目标数据。 5.5.8 CGLib动态代理生效在目标类没有实现任何接口的情况下，Spring会自动使用cglib技术实现代理。为了证明这一点，我们做下面的测试： 1234567@Servicepublic class EmployeeService &#123; public void getEmpList() &#123; System.out.print(&quot;方法内部 com.atguigu.aop.imp.EmployeeService.getEmpList&quot;); &#125;&#125; 测试： 1234567@Autowiredprivate EmployeeService employeeService;@Testpublic void testNoInterfaceProxy() &#123; employeeService.getEmpList();&#125; 没有接口： 有接口： 使用总结： a. 如果目标类有接口,选择使用jdk动态代理 b. 如果目标类没有接口,选择cglib动态代理 c. 如果有接口,接口接值 d. 如果没有接口,类进行接值 5.5.9 注解实现小结 5.6 Spring AOP基于XML方式实现(了解) 准备工作 加入依赖 和基于注解的 AOP 时一样。 准备代码 把测试基于注解功能时的Java类复制到新module中，去除所有注解。 配置Spring配置文件 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;!-- 配置目标类的bean --&gt;&lt;bean id=&quot;calculatorPure&quot; class=&quot;com.atguigu.aop.imp.CalculatorPureImpl&quot;/&gt; &lt;!-- 配置切面类的bean --&gt;&lt;bean id=&quot;logAspect&quot; class=&quot;com.atguigu.aop.aspect.LogAspect&quot;/&gt; &lt;!-- 配置AOP --&gt;&lt;aop:config&gt; &lt;!-- 配置切入点表达式 --&gt; &lt;aop:pointcut id=&quot;logPointCut&quot; expression=&quot;execution(* *..*.*(..))&quot;/&gt; &lt;!-- aop:aspect标签：配置切面 --&gt; &lt;!-- ref属性：关联切面类的bean --&gt; &lt;aop:aspect ref=&quot;logAspect&quot;&gt; &lt;!-- aop:before标签：配置前置通知 --&gt; &lt;!-- method属性：指定前置通知的方法名 --&gt; &lt;!-- pointcut-ref属性：引用切入点表达式 --&gt; &lt;aop:before method=&quot;printLogBeforeCore&quot; pointcut-ref=&quot;logPointCut&quot;/&gt; &lt;!-- aop:after-returning标签：配置返回通知 --&gt; &lt;!-- returning属性：指定通知方法中用来接收目标方法返回值的参数名 --&gt; &lt;aop:after-returning method=&quot;printLogAfterCoreSuccess&quot; pointcut-ref=&quot;logPointCut&quot; returning=&quot;targetMethodReturnValue&quot;/&gt; &lt;!-- aop:after-throwing标签：配置异常通知 --&gt; &lt;!-- throwing属性：指定通知方法中用来接收目标方法抛出异常的异常对象的参数名 --&gt; &lt;aop:after-throwing method=&quot;printLogAfterCoreException&quot; pointcut-ref=&quot;logPointCut&quot; throwing=&quot;targetMethodException&quot;/&gt; &lt;!-- aop:after标签：配置后置通知 --&gt; &lt;aop:after method=&quot;printLogCoreFinallyEnd&quot; pointcut-ref=&quot;logPointCut&quot;/&gt; &lt;!-- aop:around标签：配置环绕通知 --&gt; &lt;!--&lt;aop:around method=&quot;……&quot; pointcut-ref=&quot;logPointCut&quot;/&gt;--&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt; 测试 123456789101112@SpringJUnitConfig(locations = &quot;classpath:spring-aop.xml&quot;)public class AopTest &#123; @Autowired private Calculator calculator; @Test public void testCalculator()&#123; System.out.println(calculator); calculator.add(1,1); &#125;&#125; 5.7 Spring AOP对获取Bean的影响理解5.7.1 根据类型装配 bean 情景一 bean 对应的类没有实现任何接口 根据 bean 本身的类型获取 bean 测试：IOC容器中同类型的 bean 只有一个 正常获取到 IOC 容器中的那个 bean 对象 测试：IOC 容器中同类型的 bean 有多个 会抛出 NoUniqueBeanDefinitionException 异常，表示 IOC 容器中这个类型的 bean 有多个 情景二 bean 对应的类实现了接口，这个接口也只有这一个实现类 测试：根据接口类型获取 bean 测试：根据类获取 bean 结论：上面两种情况其实都能够正常获取到 bean，而且是同一个对象 情景三 声明一个接口 接口有多个实现类 接口所有实现类都放入 IOC 容器 测试：根据接口类型获取 bean 会抛出 NoUniqueBeanDefinitionException 异常，表示 IOC 容器中这个类型的 bean 有多个 测试：根据类获取bean 正常 情景四 声明一个接口 接口有一个实现类 创建一个切面类，对上面接口的实现类应用通知 测试：根据接口类型获取bean 正常 测试：根据类获取bean 无法获取原因分析： 应用了切面后，真正放在IOC容器中的是代理类的对象 目标类并没有被放到IOC容器中，所以根据目标类的类型从IOC容器中是找不到的 情景五 声明一个类 创建一个切面类，对上面的类应用通知 测试：根据类获取 bean，能获取到debug查看实际类型： 5.7.2 使用总结对实现了接口的类应用切面 对没实现接口的类应用切面new 如果使用AOP技术，目标类有接口，必须使用接口类型接收IoC容器中代理组件！ 六、Spring 声明式事务6.1 声明式事务概念6.1.1 编程式事务编程式事务是指手动编写程序来管理事务，即通过编写代码的方式直接控制事务的提交和回滚。在 Java 中，通常使用事务管理器(如 Spring 中的 PlatformTransactionManager)来实现编程式事务。 编程式事务的主要优点是灵活性高，可以按照自己的需求来控制事务的粒度、模式等等。但是，编写大量的事务控制代码容易出现问题，对代码的可读性和可维护性有一定影响。 123456789101112131415161718192021Connection conn = ...; try &#123; // 开启事务：关闭事务的自动提交 conn.setAutoCommit(false); // 核心操作 // 业务代码 // 提交事务 conn.commit(); &#125;catch(Exception e)&#123; // 回滚事务 conn.rollBack(); &#125;finally&#123; // 释放数据库连接 conn.close(); &#125; 编程式的实现方式存在缺陷： 细节没有被屏蔽：具体操作过程中，所有细节都需要程序员自己来完成，比较繁琐。 代码复用性不高：如果没有有效抽取出来，每次实现功能都需要自己编写代码，代码就没有得到复用。 6.1.2 声明式事务声明式事务是指使用注解或 XML 配置的方式来控制事务的提交和回滚。 开发者只需要添加配置即可， 具体事务的实现由第三方框架实现，避免我们直接进行事务操作！ 使用声明式事务可以将事务的控制和业务逻辑分离开来，提高代码的可读性和可维护性。 区别： 编程式事务需要手动编写代码来管理事务 而声明式事务可以通过配置文件或注解来控制事务。 6.1.3 Spring事务管理器 Spring声明式事务对应依赖 spring-tx: 包含声明式事务实现的基本规范（事务管理器规范接口和事务增强等等） spring-jdbc: 包含DataSource方式事务管理器实现类DataSourceTransactionManager spring-orm: 包含其他持久层框架的事务管理器实现类例如：Hibernate&#x2F;Jpa等 Spring声明式事务对应事务管理器接口 我们现在要使用的事务管理器是org.springframework.jdbc.datasource.DataSourceTransactionManager，将来整合 JDBC方式、JdbcTemplate方式、Mybatis方式的事务实现！ DataSourceTransactionManager类中的主要方法： doBegin()：开启事务 doSuspend()：挂起事务 doResume()：恢复挂起的事务 doCommit()：提交事务 doRollback()：回滚事务 6.2 基于注解的声明式事务6.2.1 准备工作 准备项目 123456789101112131415&lt;dependencies&gt; &lt;!--spring context依赖--&gt; &lt;!--当你引入Spring Context依赖之后，表示将Spring的基础依赖引入了--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;6.0.6&lt;/version&gt; &lt;/dependency&gt; &lt;!--junit5测试--&gt; &lt;dependency&gt; &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt; &lt;artifactId&gt;junit-jupiter-api&lt;/artifactId&gt; &lt;version&gt;5.3.1&lt;/version&gt; &lt;/dependency&gt; org.springframework spring-test 6.0.6 test jakarta.annotation jakarta.annotation-api 2.1.1 mysql mysql-connector-java 8.0.25 com.alibaba druid 1.2.8 org.springframework spring-jdbc 6.0.6 org.springframework spring-tx 6.0.6 org.springframework spring-aop 6.0.6 org.springframework spring-aspects 6.0.6 123456782. 外部配置文件 jdbc.properties ```.properties atguigu.url=jdbc:mysql://localhost:3306/studb atguigu.driver=com.mysql.cj.jdbc.Driver atguigu.username=root atguigu.password=root spring配置文件 12345678910111213@Configuration@ComponentScan(&quot;com.atguigu&quot;)@PropertySource(&quot;classpath:jdbc.properties&quot;)public class JavaConfig &#123; @Value(&quot;$&#123;atguigu.driver&#125;&quot;) private String driver; @Value(&quot;$&#123;atguigu.url&#125;&quot;) private String url; @Value(&quot;$&#123;atguigu.username&#125;&quot;) private String username; @Value(&quot;$&#123;atguigu.password&#125;&quot;) private String password; //druid连接池 @Bean public DataSource dataSource()&#123; DruidDataSource dataSource = new DruidDataSource(); dataSource.setDriverClassName(driver); dataSource.setUrl(url); dataSource.setUsername(username); dataSource.setPassword(password); return dataSource; &#125; @Bean //jdbcTemplate public JdbcTemplate jdbcTemplate(DataSource dataSource)&#123; JdbcTemplate jdbcTemplate = new JdbcTemplate(); jdbcTemplate.setDataSource(dataSource); return jdbcTemplate; &#125; } 1234567891011121314151617181920214. 准备dao/service层 dao ```java @Repository public class StudentDao &#123; @Autowired private JdbcTemplate jdbcTemplate; public void updateNameById(String name,Integer id)&#123; String sql = &quot;update students set name = ? where id = ? ;&quot;; int rows = jdbcTemplate.update(sql, name, id); &#125; public void updateAgeById(Integer age,Integer id)&#123; String sql = &quot;update students set age = ? where id = ? ;&quot;; jdbcTemplate.update(sql,age,id); &#125; &#125; service 12345678910111213@Servicepublic class StudentService &#123; @Autowired private StudentDao studentDao; public void changeInfo()&#123; studentDao.updateAgeById(100,1); System.out.println(&quot;-----------&quot;); studentDao.updateNameById(&quot;test1&quot;,1); &#125;&#125; 测试环境搭建 1234567891011121314151617/** * projectName: com.atguigu.test * * description: */@SpringJUnitConfig(JavaConfig.class)public class TxTest &#123; @Autowired private StudentService studentService; @Test public void testTx()&#123; studentService.changeInfo(); &#125;&#125; 6.2.2 基本事务控制 配置事务管理器 数据库相关的配置 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758/** * projectName: com.atguigu.config * * description: 数据库和连接池配置类 */@Configuration@ComponenScan(&quot;com.atguigu&quot;)@PropertySource(value = &quot;classpath:jdbc.properties&quot;)@EnableTransactionManagementpublic class DataSourceConfig &#123; /** * 实例化dataSource加入到ioc容器 * @param url * @param driver * @param username * @param password * @return */ @Bean public DataSource dataSource(@Value(&quot;$&#123;atguigu.url&#125;&quot;)String url, @Value(&quot;$&#123;atguigu.driver&#125;&quot;)String driver, @Value(&quot;$&#123;atguigu.username&#125;&quot;)String username, @Value(&quot;$&#123;atguigu.password&#125;&quot;)String password)&#123; DruidDataSource dataSource = new DruidDataSource(); dataSource.setDriverClassName(driver); dataSource.setUrl(url); dataSource.setUsername(username); dataSource.setPassword(password); return dataSource; &#125; /** * 实例化JdbcTemplate对象,需要使用ioc中的DataSource * @param dataSource * @return */ @Bean public JdbcTemplate jdbcTemplate(DataSource dataSource)&#123; JdbcTemplate jdbcTemplate = new JdbcTemplate(); jdbcTemplate.setDataSource(dataSource); return jdbcTemplate; &#125; /** * 装配事务管理实现对象 * @param dataSource * @return */ @Bean public TransactionManager transactionManager(DataSource dataSource)&#123; return new DataSourceTransactionManager(dataSource); &#125;&#125; 使用声明事务注解@Transactional 12345678910111213141516171819/** * projectName: com.atguigu.service * */@Servicepublic class StudentService &#123; @Autowired private StudentDao studentDao; @Transactional public void changeInfo()&#123; studentDao.updateAgeById(100,1); System.out.println(&quot;-----------&quot;); int i = 1/0; studentDao.updateNameById(&quot;test1&quot;,1); &#125;&#125; 测试事务效果 123456789101112131415161718/** * projectName: com.atguigu.test * * description: *///@SpringJUnitConfig(locations = &quot;classpath:application.xml&quot;)@SpringJUnitConfig(classes = DataSourceConfig.class)public class TxTest &#123; @Autowired private StudentService studentService; @Test public void testTx()&#123; studentService.changeInfo(); &#125;&#125; 6.2.3 事务属性：只读 只读介绍 对一个查询操作来说，如果我们把它设置成只读，就能够明确告诉数据库，这个操作不涉及写操作。这样数据库就能够针对查询操作来进行优化。 设置方式 12// readOnly = true把当前事务设置为只读 默认是false!@Transactional(readOnly = true) 针对DML动作设置只读模式 会抛出下面异常： Caused by: java.sql.SQLException: Connection is read-only. Queries leading to data modification are not allowed @Transactional注解放在类上 生效原则 如果一个类中每一个方法上都使用了 @Transactional 注解，那么就可以将 @Transactional 注解提取到类上。反过来说：@Transactional 注解在类级别标记，会影响到类中的每一个方法。同时，类级别标记的 @Transactional 注解中设置的事务属性也会延续影响到方法执行时的事务属性。除非在方法上又设置了 @Transactional 注解。 对一个方法来说，离它最近的 @Transactional 注解中的事务属性设置生效。 用法举例 在类级别@Transactional注解中设置只读，这样类中所有的查询方法都不需要设置@Transactional注解了。因为对查询操作来说，其他属性通常不需要设置，所以使用公共设置即可。 然后在这个基础上，对增删改方法设置@Transactional注解 readOnly 属性为 false。 1234567891011121314151617@Service@Transactional(readOnly = true)public class EmpService &#123; // 为了便于核对数据库操作结果，不要修改同一条记录 @Transactional(readOnly = false) public void updateTwice(……) &#123; …… &#125; // readOnly = true把当前事务设置为只读 // @Transactional(readOnly = true) public String getEmpName(Integer empId) &#123; …… &#125; &#125; 6.2.4 事务属性：超时时间 需求 事务在执行过程中，有可能因为遇到某些问题，导致程序卡住，从而长时间占用数据库资源。而长时间占用资源，大概率是因为程序运行出现了问题（可能是Java程序或MySQL数据库或网络连接等等）。 此时这个很可能出问题的程序应该被回滚，撤销它已做的操作，事务结束，把资源让出来，让其他正常程序可以执行。 概括来说就是一句话：超时回滚，释放资源。 设置超时时间 12345678910111213141516171819202122@Servicepublic class StudentService &#123; @Autowired private StudentDao studentDao; /** * timeout设置事务超时时间,单位秒! 默认: -1 永不超时,不限制事务时间! */ @Transactional(readOnly = false,timeout = 3) public void changeInfo()&#123; studentDao.updateAgeById(100,1); //休眠4秒,等待方法超时! try &#123; Thread.sleep(4000); &#125; catch (InterruptedException e) &#123; throw new RuntimeException(e); &#125; studentDao.updateNameById(&quot;test1&quot;,1); &#125;&#125; 测试超时效果 执行抛出事务超时异常 12345678org.springframework.transaction.TransactionTimedOutException: Transaction timed out: deadline was Wed May 24 09:10:43 IRKT 2023 at org.springframework.transaction.support.ResourceHolderSupport.checkTransactionTimeout(ResourceHolderSupport.java:155) at org.springframework.transaction.support.ResourceHolderSupport.getTimeToLiveInMillis(ResourceHolderSupport.java:144) at org.springframework.transaction.support.ResourceHolderSupport.getTimeToLiveInSeconds(ResourceHolderSupport.java:128) at org.springframework.jdbc.datasource.DataSourceUtils.applyTimeout(DataSourceUtils.java:341) at org.springframework.jdbc.core.JdbcTemplate.applyStatementSettings(JdbcTemplate.java:1467) 6.2.5 事务属性：事务异常 默认情况 默认只针对运行时异常回滚，编译时异常不回滚。情景模拟代码如下： 12345678910111213141516171819@Servicepublic class StudentService &#123; @Autowired private StudentDao studentDao; /** * timeout设置事务超时时间,单位秒! 默认: -1 永不超时,不限制事务时间! * rollbackFor = 指定哪些异常才会回滚,默认是 RuntimeException and Error 异常方可回滚! * noRollbackFor = 指定哪些异常不会回滚, 默认没有指定,如果指定,应该在rollbackFor的范围内! */ @Transactional(readOnly = false,timeout = 3) public void changeInfo() throws FileNotFoundException &#123; studentDao.updateAgeById(100,1); //主动抛出一个检查异常,测试! 发现不会回滚,因为不在rollbackFor的默认范围内! new FileInputStream(&quot;xxxx&quot;); studentDao.updateNameById(&quot;test1&quot;,1); &#125;&#125; 设置回滚异常 rollbackFor属性：指定哪些异常类才会回滚,默认是 RuntimeException and Error 异常方可回滚! 123456789101112/** * timeout设置事务超时时间,单位秒! 默认: -1 永不超时,不限制事务时间! * rollbackFor = 指定哪些异常才会回滚,默认是 RuntimeException and Error 异常方可回滚! * noRollbackFor = 指定哪些异常不会回滚, 默认没有指定,如果指定,应该在rollbackFor的范围内! */@Transactional(readOnly = false,timeout = 3,rollbackFor = Exception.class)public void changeInfo() throws FileNotFoundException &#123; studentDao.updateAgeById(100,1); //主动抛出一个检查异常,测试! 发现不会回滚,因为不在rollbackFor的默认范围内! new FileInputStream(&quot;xxxx&quot;); studentDao.updateNameById(&quot;test1&quot;,1);&#125; 设置不回滚的异常 在默认设置和已有设置的基础上，再指定一个异常类型，碰到它不回滚。 noRollbackFor属性：指定哪些异常不会回滚, 默认没有指定,如果指定,应该在rollbackFor的范围内! 1234567891011121314151617181920@Servicepublic class StudentService &#123; @Autowired private StudentDao studentDao; /** * timeout设置事务超时时间,单位秒! 默认: -1 永不超时,不限制事务时间! * rollbackFor = 指定哪些异常才会回滚,默认是 RuntimeException and Error 异常方可回滚! * noRollbackFor = 指定哪些异常不会回滚, 默认没有指定,如果指定,应该在rollbackFor的范围内! */ @Transactional(readOnly = false,timeout = 3,rollbackFor = Exception.class,noRollbackFor = FileNotFoundException.class) public void changeInfo() throws FileNotFoundException &#123; studentDao.updateAgeById(100,1); //主动抛出一个检查异常,测试! 发现不会回滚,因为不在rollbackFor的默认范围内! new FileInputStream(&quot;xxxx&quot;); studentDao.updateNameById(&quot;test1&quot;,1); &#125;&#125; 6.2.6 事务属性：事务隔离级别 事务隔离级别 数据库事务的隔离级别是指在多个事务并发执行时，数据库系统为了保证数据一致性所遵循的规定。常见的隔离级别包括： 读未提交（Read Uncommitted）：事务可以读取未被提交的数据，容易产生脏读、不可重复读和幻读等问题。实现简单但不太安全，一般不用。 读已提交（Read Committed）：事务只能读取已经提交的数据，可以避免脏读问题，但可能引发不可重复读和幻读。 可重复读（Repeatable Read）：在一个事务中，相同的查询将返回相同的结果集，不管其他事务对数据做了什么修改。可以避免脏读和不可重复读，但仍有幻读的问题。 串行化（Serializable）：最高的隔离级别，完全禁止了并发，只允许一个事务执行完毕之后才能执行另一个事务。可以避免以上所有问题，但效率较低，不适用于高并发场景。不同的隔离级别适用于不同的场景，需要根据实际业务需求进行选择和调整。 事务隔离级别设置 123456789101112131415161718192021222324252627282930313233343536373839package com.atguigu.service;import com.atguigu.dao.StudentDao;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import org.springframework.transaction.annotation.Isolation;import org.springframework.transaction.annotation.Transactional;import java.io.FileInputStream;import java.io.FileNotFoundException;/** * projectName: com.atguigu.service */@Servicepublic class StudentService &#123; @Autowired private StudentDao studentDao; /** * timeout设置事务超时时间,单位秒! 默认: -1 永不超时,不限制事务时间! * rollbackFor = 指定哪些异常才会回滚,默认是 RuntimeException and Error 异常方可回滚! * noRollbackFor = 指定哪些异常不会回滚, 默认没有指定,如果指定,应该在rollbackFor的范围内! * isolation = 设置事务的隔离级别,mysql默认是repeatable read! */ @Transactional(readOnly = false, timeout = 3, rollbackFor = Exception.class, noRollbackFor = FileNotFoundException.class, isolation = Isolation.REPEATABLE_READ) public void changeInfo() throws FileNotFoundException &#123; studentDao.updateAgeById(100,1); //主动抛出一个检查异常,测试! 发现不会回滚,因为不在rollbackFor的默认范围内! new FileInputStream(&quot;xxxx&quot;); studentDao.updateNameById(&quot;test1&quot;,1); &#125;&#125; 6.2.7 事务属性：事务传播行为 事务传播行为要研究的问题 举例代码： 12345678910111213@Transactionalpublic void MethodA()&#123; // ... MethodB(); // ...&#125;//在被调用的子方法中设置传播行为，代表如何处理调用的事务！ 是加入，还是新事务等！@Transactional(propagation = Propagation.REQUIRES_NEW)public void MethodB()&#123; // ...&#125; propagation属性 @Transactional 注解通过 propagation 属性设置事务的传播行为。它的默认值是： 12Propagation propagation() default Propagation.REQUIRED; propagation 属性的可选值由 org.springframework.transaction.annotation.Propagation 枚举类提供： 名称 含义 REQUIRED &#xA;默认值 如果父方法有事务，就加入，如果没有就新建自己独立！ REQUIRES_NEW 不管父方法是否有事务，我都新建事务，都是独立的！ 测试 声明两个业务方法12345678910111213141516171819202122232425262728293031323334353637383940@Servicepublic class StudentService &#123; @Autowired private StudentDao studentDao; /** * timeout设置事务超时时间,单位秒! 默认: -1 永不超时,不限制事务时间! * rollbackFor = 指定哪些异常才会回滚,默认是 RuntimeException and Error 异常方可回滚! * noRollbackFor = 指定哪些异常不会回滚, 默认没有指定,如果指定,应该在rollbackFor的范围内! * isolation = 设置事务的隔离级别,mysql默认是repeatable read! */ @Transactional(readOnly = false, timeout = 3, rollbackFor = Exception.class, noRollbackFor = FileNotFoundException.class, isolation = Isolation.REPEATABLE_READ) public void changeInfo() throws FileNotFoundException &#123; studentDao.updateAgeById(100,1); //主动抛出一个检查异常,测试! 发现不会回滚,因为不在rollbackFor的默认范围内! new FileInputStream(&quot;xxxx&quot;); studentDao.updateNameById(&quot;test1&quot;,1); &#125; /** * 声明两个独立修改数据库的事务业务方法 */ @Transactional(propagation = Propagation.REQUIRED) public void changeAge()&#123; studentDao.updateAgeById(99,1); &#125; @Transactional(propagation = Propagation.REQUIRED) public void changeName()&#123; studentDao.updateNameById(&quot;test2&quot;,1); int i = 1/0; &#125;&#125; 声明一个整合业务方法12345678910111213@Servicepublic class TopService &#123; @Autowired private StudentService studentService; @Transactional public void topService()&#123; studentService.changeAge(); studentService.changeName(); &#125;&#125; 添加传播行为测试123456789101112131415@SpringJUnitConfig(classes = AppConfig.class)public class TxTest &#123; @Autowired private StudentService studentService; @Autowired private TopService topService; @Test public void testTx() throws FileNotFoundException &#123; topService.topService(); &#125;&#125; 注意： 在同一个类中，对于@Transactional注解的方法调用，事务传播行为不会生效。这是因为Spring框架中使用代理模式实现了事务机制，在同一个类中的方法调用并不经过代理，而是通过对象的方法调用，因此@Transactional注解的设置不会被代理捕获，也就不会产生任何事务传播行为的效果。 其他传播行为值（了解） Propagation.REQUIRED：如果当前存在事务，则加入当前事务，否则创建一个新事务。 Propagation.REQUIRES_NEW：创建一个新事务，并在新事务中执行。如果当前存在事务，则挂起当前事务，即使新事务抛出异常，也不会影响当前事务。 Propagation.NESTED：如果当前存在事务，则在该事务中嵌套一个新事务，如果没有事务，则与Propagation.REQUIRED一样。 Propagation.SUPPORTS：如果当前存在事务，则加入该事务，否则以非事务方式执行。 Propagation.NOT_SUPPORTED：以非事务方式执行，如果当前存在事务，挂起该事务。 Propagation.MANDATORY：必须在一个已有的事务中执行，否则抛出异常。 Propagation.NEVER：必须在没有事务的情况下执行，否则抛出异常。 七、Spring核心掌握总结 核心点 掌握目标 spring框架理解 spring家族和spring framework框架 spring核心功能 ioc&#x2F;di , aop , tx spring ioc &#x2F; di 组件管理、ioc容器、ioc&#x2F;di , 三种配置方式 spring aop aop和aop框架和代理技术、基于注解的aop配置 spring tx 声明式和编程式事务、动态事务管理器、事务注解、属性","categories":[{"name":"SSM框架","slug":"SSM框架","permalink":"http://example.com/categories/SSM%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"ssm","slug":"ssm","permalink":"http://example.com/tags/ssm/"}]},{"title":"一、高效构建Java应用：Maven入门和进阶","slug":"SSM/一、高效构建Java应用：Maven入门和进阶/一、高效构建Java应用：Maven入门和进阶","date":"2022-09-27T00:55:54.000Z","updated":"2023-09-28T00:29:57.856Z","comments":true,"path":"2022/09/27/SSM/一、高效构建Java应用：Maven入门和进阶/一、高效构建Java应用：Maven入门和进阶/","link":"","permalink":"http://example.com/2022/09/27/SSM/%E4%B8%80%E3%80%81%E9%AB%98%E6%95%88%E6%9E%84%E5%BB%BAJava%E5%BA%94%E7%94%A8%EF%BC%9AMaven%E5%85%A5%E9%97%A8%E5%92%8C%E8%BF%9B%E9%98%B6/%E4%B8%80%E3%80%81%E9%AB%98%E6%95%88%E6%9E%84%E5%BB%BAJava%E5%BA%94%E7%94%A8%EF%BC%9AMaven%E5%85%A5%E9%97%A8%E5%92%8C%E8%BF%9B%E9%98%B6/","excerpt":"","text":"一、高效构建Java应用：Maven入门和进阶1.1 Maven介绍https://maven.apache.org/what-is-maven.html Maven 是一款为 Java 项目构建管理、依赖管理的工具（软件），使用 Maven 可以自动化构建、测试、打包和发布项目，大大提高了开发效率和质量。 总结：Maven就是一个软件，掌握软件安装、配置、以及基本功能 （项目构建、依赖管理） 使用就是本课程的主要目标！ 1.2 Maven主要作用理解 场景概念 场景1： 例如我们项目需要第三方库（依赖），如Druid连接池、MySQL数据库驱动和Jackson等。那么我们可以将需要的依赖项的信息编写到Maven工程的配置文件，Maven软件就会自动下载并复制这些依赖项到项目中，也会自动下载依赖需要的依赖！确保依赖版本正确无冲突和依赖完整！ 场景2： 项目开发完成后，想要将项目打成.war文件，并部署到服务器中运行，使用Maven软件，我们可以通过一行构建命令（mvn package）快速项目构建和打包！节省大量时间！ 依赖管理： Maven 可以管理项目的依赖，包括自动下载所需依赖库、自动下载依赖需要的依赖并且保证版本没有冲突、依赖版本管理等。通过 Maven，我们可以方便地维护项目所依赖的外部库，而我们仅仅需要编写配置即可。 构建管理： 项目构建是指将源代码、配置文件、资源文件等转化为能够运行或部署的应用程序或库的过程！ Maven 可以管理项目的编译、测试、打包、部署等构建过程。通过实现标准的构建生命周期，Maven 可以确保每一个构建过程都遵循同样的规则和最佳实践。同时，Maven 的插件机制也使得开发者可以对构建过程进行扩展和定制。主动触发构建，只需要简单的命令操作即可。 1.3 Maven安装和配置https://maven.apache.org/docs/history.html 选用版本： apache-maven-3.6.3-bin.zip 发布时间 maven版本 jdk最低版本 **2019 - 11 - **25 3.6. 3 Java 7 安装 安装条件： maven需要本机安装java环境、必需包含java_home环境变量！ 软件安装： 右键解压即可（绿色免安装） 软件结构： 环境变量 环境变量： 配置maven_home 和 path 命令测试 123mvn -v # 输出版本信息即可，如果错误，请仔细检查环境变量即可！# 友好提示，如果此处错误，绝大部分原因都是java_home变量的事，请仔细检查！！ 配置文件 我们需要需改maven&#x2F;conf&#x2F;settings.xml配置文件，来修改maven的一些默认配置。我们主要休要修改的有三个配置：1.依赖本地缓存位置（本地仓库位置）2.maven下载镜像3.maven选用编译项目的jdk版本！ 配置本地仓库地址12345678&lt;!-- localRepository | The path to the local repository maven will use to store artifacts. | | Default: $&#123;user.home&#125;/.m2/repository&lt;localRepository&gt;/path/to/local/repo&lt;/localRepository&gt;--&gt;&lt;!-- conf/settings.xml 55行 --&gt;&lt;localRepository&gt;D:\\repository&lt;/localRepository&gt; 配置国内阿里镜像1234567&lt;!--在mirrors节点(标签)下添加中央仓库镜像 160行附近--&gt;&lt;mirror&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt;&lt;/mirror&gt; 配置jdk17版本项目构建12345678910111213&lt;!--在profiles节点(标签)下添加jdk编译版本 268行附近--&gt;&lt;profile&gt; &lt;id&gt;jdk-17&lt;/id&gt; &lt;activation&gt; &lt;activeByDefault&gt;true&lt;/activeByDefault&gt; &lt;jdk&gt;17&lt;/jdk&gt; &lt;/activation&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;17&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;17&lt;/maven.compiler.target&gt; &lt;maven.compiler.compilerVersion&gt;17&lt;/maven.compiler.compilerVersion&gt; &lt;/properties&gt;&lt;/profile&gt; idea配置本地maven 我们需要将配置好的maven软件，配置到idea开发工具中即可！ 注意：idea工具默认自带maven配置软件，但是因为没有修改配置，建议替换成本地配置好的maven！ 打开idea配置文件，构建工具配置 依次点击 file / settings / build / build tool / maven 选中本地maven软件 测试是否配置成功 注意：如果本地仓库地址不变化，只有一个原因，就是maven&#x2F;conf&#x2F;settings.xml配置文件编写错误！仔细检查即可！ 二、基于IDEA的Maven工程创建2.1梳理Maven工程GAVP属性 Maven工程相对之前的工程，多出一组gavp属性，gav需要我们在创建项目的时指定，p有默认值，后期通过配置文件修改。既然要填写的属性，我们先行了解下这组属性的含义! Maven 中的 GAVP 是指 GroupId、ArtifactId、Version、Packaging 等四个属性的缩写，其中前三个是必要的，而 Packaging 属性为可选项。这四个属性主要为每个项目在maven仓库总做一个标识，类似人的《姓-名》。有了具体标识，方便maven软件对项目进行管理和互相引用！ GAV遵循一下规则： 1） GroupID 格式：com.{公司&#x2F;BU }.业务线.[子业务线]，最多 4 级。 说明：{公司&#x2F;BU} 例如：alibaba&#x2F;taobao&#x2F;tmall&#x2F;aliexpress 等 BU 一级；子业务线可选。 正例：com.taobao.tddl 或 com.alibaba.sourcing.multilang com.atguigu.java 2） ArtifactID 格式：产品线名-模块名。语义不重复不遗漏，先到仓库中心去查证一下。 正例：tc-client &#x2F; uic-api &#x2F; tair-tool &#x2F; bookstore 3） Version版本号格式推荐：主版本号.次版本号.修订号 1.0.0 1） 主版本号：当做了不兼容的 API 修改，或者增加了能改变产品方向的新功能。 2） 次版本号：当做了向下兼容的功能性新增（新增类、接口等）。 3） 修订号：修复 bug，没有修改方法签名的功能加强，保持 API 兼容性。 例如： 初始→1.0.0 修改bug → 1.0.1 功能调整 → 1.1.1等 Packaging定义规则： 指示将项目打包为什么类型的文件，idea根据packaging值，识别maven项目类型！ packaging 属性为 jar（默认值），代表普通的Java工程，打包以后是.jar结尾的文件。 packaging 属性为 war，代表Java的web工程，打包以后.war结尾的文件。 packaging 属性为 pom，代表不会打包，用来做继承的父工程。 2.2 Idea构建Maven JavaSE工程注意：此处省略了version，直接给了一个默认值&lt;version&gt;1.0-SNAPSHOT&lt;&#x2F;version&gt; 自己后期可以在项目中随意修改！ 2.3 Idea构建Maven JavaEE工程 手动创建 创建一个javasemaven工程 手动添加web项目结构文件 注意：结构和命名固定 修改pom.xml文件打包方式 修改位置：项目下&#x2F;pom.xml 12345&lt;groupId&gt;com.atguigu&lt;/groupId&gt;&lt;artifactId&gt;maven_parent&lt;/artifactId&gt;&lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;&lt;!-- 新增一列打包方式packaging --&gt;&lt;packaging&gt;war&lt;/packaging&gt; 刷新和校验 项目的webapp文件夹出现小蓝点，代表成功！！ 插件方式创建 安装插件JBLJavaToWeb file &#x2F; settings &#x2F; plugins &#x2F; marketplace 创建一个javasemaven工程 右键、使用插件快速补全web项目 2.4 Maven工程项目结构说明Maven 是一个强大的构建工具，它提供一种标准化的项目结构，可以帮助开发者更容易地管理项目的依赖、构建、测试和发布等任务。以下是 Maven Web 程序的文件结构及每个文件的作用： 123456789101112131415161718192021222324|-- pom.xml # Maven 项目管理文件 |-- src |-- main # 项目主要代码 | |-- java # Java 源代码目录 | | `-- com/example/myapp # 开发者代码主目录 | | |-- controller # 存放 Controller 层代码的目录 | | |-- service # 存放 Service 层代码的目录 | | |-- dao # 存放 DAO 层代码的目录 | | `-- model # 存放数据模型的目录 | |-- resources # 资源目录，存放配置文件、静态资源等 | | |-- log4j.properties # 日志配置文件 | | |-- spring-mybatis.xml # Spring Mybatis 配置文件 | | `-- static # 存放静态资源的目录 | | |-- css # 存放 CSS 文件的目录 | | |-- js # 存放 JavaScript 文件的目录 | | `-- images # 存放图片资源的目录 | `-- webapp # 存放 WEB 相关配置和资源 | |-- WEB-INF # 存放 WEB 应用配置文件 | | |-- web.xml # Web 应用的部署描述文件 | | `-- classes # 存放编译后的 class 文件 | `-- index.html # Web 应用入口页面 `-- test # 项目测试代码 |-- java # 单元测试目录 `-- resources # 测试资源目录 pom.xml：Maven 项目管理文件，用于描述项目的依赖和构建配置等信息。 src&#x2F;main&#x2F;java：存放项目的 Java 源代码。 src&#x2F;main&#x2F;resources：存放项目的资源文件，如配置文件、静态资源等。 src&#x2F;main&#x2F;webapp&#x2F;WEB-INF：存放 Web 应用的配置文件。 src&#x2F;main&#x2F;webapp&#x2F;index.html：Web 应用的入口页面。 src&#x2F;test&#x2F;java：存放项目的测试代码。 src&#x2F;test&#x2F;resources：存放测试相关的资源文件，如测试配置文件等。 三、Maven核心功能依赖和构建管理3.1 依赖管理和配置Maven 依赖管理是 Maven 软件中最重要的功能之一。Maven 的依赖管理能够帮助开发人员自动解决软件包依赖问题，使得开发人员能够轻松地将其他开发人员开发的模块或第三方框架集成到自己的应用程序或模块中，避免出现版本冲突和依赖缺失等问题。 我们通过定义 POM 文件，Maven 能够自动解析项目的依赖关系，并通过 Maven 仓库自动下载和管理依赖，从而避免了手动下载和管理依赖的繁琐工作和可能引发的版本冲突问题。 重点: 编写pom.xml文件! maven项目信息属性配置和读取： 12345678910111213141516&lt;!-- 模型版本 --&gt;&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;&lt;!-- 公司或者组织的唯一标志，并且配置时生成的路径也是由此生成， 如com.companyname.project-group，maven会将该项目打成的jar包放本地路径：/com/companyname/project-group --&gt;&lt;groupId&gt;com.companyname.project-group&lt;/groupId&gt;&lt;!-- 项目的唯一ID，一个groupId下面可能多个项目，就是靠artifactId来区分的 --&gt;&lt;artifactId&gt;project&lt;/artifactId&gt;&lt;!-- 版本号 --&gt;&lt;version&gt;1.0.0&lt;/version&gt;&lt;!--打包方式 默认：jar jar指的是普通的java项目打包方式！ 项目打成jar包！ war指的是web项目打包方式！项目打成war包！ pom不会讲项目打包！这个项目作为父工程，被其他工程聚合或者继承！后面会讲解两个概念--&gt;&lt;packaging&gt;jar/pom/war&lt;/packaging&gt; 依赖管理和添加： 123456789101112131415161718192021222324&lt;!-- 通过编写依赖jar包的gav必要属性，引入第三方依赖！ scope属性是可选的，可以指定依赖生效范围！ 依赖信息查询方式： 1. maven仓库信息官网 https://mvnrepository.com/ 2. mavensearch插件搜索 --&gt;&lt;dependencies&gt; &lt;!-- 引入具体的依赖包 --&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt; &lt;!-- 生效范围 - compile ：main目录 test目录 打包打包 [默认] - provided：main目录 test目录 Servlet - runtime： 打包运行 MySQL - test: test目录 junit --&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 依赖版本提取和维护: 1234567891011121314151617&lt;!--声明版本--&gt;&lt;properties&gt; &lt;!--命名随便,内部制定版本号即可！--&gt; &lt;junit.version&gt;4.11&lt;/junit.version&gt; &lt;!-- 也可以通过 maven规定的固定的key，配置maven的参数！如下配置编码格式！--&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt;&lt;/properties&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;!--引用properties声明版本 --&gt; &lt;version&gt;$&#123;junit.version&#125;&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 3.2依赖传递和冲突依赖传递指的是当一个模块或库 A 依赖于另一个模块或库 B，而 B 又依赖于模块或库 C，那么 A 会间接依赖于 C。这种依赖传递结构可以形成一个依赖树。当我们引入一个库或框架时，构建工具（如 Maven、Gradle）会自动解析和加载其所有的直接和间接依赖，确保这些依赖都可用。 依赖传递的作用是： 减少重复依赖：当多个项目依赖同一个库时，Maven 可以自动下载并且只下载一次该库。这样可以减少项目的构建时间和磁盘空间。 自动管理依赖: Maven 可以自动管理依赖项，使用依赖传递，简化了依赖项的管理，使项目构建更加可靠和一致。 确保依赖版本正确性：通过依赖传递的依赖，之间都不会存在版本兼容性问题，确实依赖的版本正确性！ 依赖传递演示： 项目中，需要导入jackson相关的依赖，通过之前导入经验，jackson需要导入三个依赖，分别为： 通过查看网站介绍的依赖传递特性：data-bind中，依赖其他两个依赖 最佳导入：直接可以导入data-bind，自动依赖传递需要的依赖 123456&lt;!-- https://mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-databind --&gt;&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.15.0&lt;/version&gt;&lt;/dependency&gt; 依赖冲突演示： 当直接引用或者间接引用出现了相同的jar包! 这时呢，一个项目就会出现相同的重复jar包，这就算作冲突！依赖冲突避免出现重复依赖，并且终止依赖传递！ maven自动解决依赖冲突问题能力，会按照自己的原则，进行重复依赖选择。同时也提供了手动解决的冲突的方式，不过不推荐！ 解决依赖冲突（如何选择重复依赖）方式： 自动选择原则 短路优先原则（第一原则） A—&gt;B—&gt;C—&gt;D—&gt;E—&gt;X(version 0.0.1) A—&gt;F—&gt;X(version 0.0.2) 则A依赖于X(version 0.0.2)。 依赖路径长度相同情况下，则“先声明优先”（第二原则） A—&gt;E—&gt;X(version 0.0.1) A—&gt;F—&gt;X(version 0.0.2) 在&lt;depencies&gt;&lt;&#x2F;depencies&gt;中，先声明的，路径相同，会优先选择！ 小思考: 123456789前提： A 1.1 -&gt; B 1.1 -&gt; C 1.1 F 2.2 -&gt; B 2.2 pom声明： F 2.2 A 1.1 B 2.2 3.3 依赖导入失败场景和解决方案在使用 Maven 构建项目时，可能会发生依赖项下载错误的情况，主要原因有以下几种： 下载依赖时出现网络故障或仓库服务器宕机等原因，导致无法连接至 Maven 仓库，从而无法下载依赖。 依赖项的版本号或配置文件中的版本号错误，或者依赖项没有正确定义，导致 Maven 下载的依赖项与实际需要的不一致，从而引发错误。 本地 Maven 仓库或缓存被污染或损坏，导致 Maven 无法正确地使用现有的依赖项，并且也无法重新下载！ 解决方案： 检查网络连接和 Maven 仓库服务器状态。 确保依赖项的版本号与项目对应的版本号匹配，并检查 POM 文件中的依赖项是否正确。 清除本地 Maven 仓库缓存（lastUpdated 文件），因为只要存在lastupdated缓存文件，刷新也不会重新下载。本地仓库中，根据依赖的gav属性依次向下查找文件夹，最终删除内部的文件，刷新重新下载即可！ 例如： pom.xml依赖 12345&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.2.8&lt;/version&gt;&lt;/dependency&gt; 文件： 脚本使用： 清理maven错误缓存.bat 123使用记事本打开set REPOSITORY_PATH=D:\\repository 改成你本地仓库地址即可！点击运行脚本，即可自动清理本地错误缓存文件！！ 3.4 扩展构建管理和插件配置构建概念: 项目构建是指将源代码、依赖库和资源文件等转换成可执行或可部署的应用程序的过程，在这个过程中包括编译源代码、链接依赖库、打包和部署等多个步骤。 主动触发场景： 重新编译 : 编译不充分, 部分文件没有被编译! 打包 : 独立部署到外部服务器软件,打包部署 部署本地或者私服仓库 : maven工程加入到本地或者私服仓库,供其他工程使用 命令方式构建: 语法: mvn 构建命令 构建命令…. 命令 描述 mvn clean 清理编译或打包后的项目结构,删除target文件夹 mvn compile 编译项目，生成target文件 mvn test 执行测试源码 (测试) mvn site 生成一个项目依赖信息的展示页面 mvn package 打包项目，生成war &#x2F; jar 文件 mvn install 打包后上传到maven本地仓库(本地部署) mvn deploy 只打包，上传到maven私服仓库(私服部署) 可视化方式构建: 构建命令周期: 构建生命周期可以理解成是一组固定构建命令的有序集合，触发周期后的命令，会自动触发周期前的命令！也是一种简化构建的思路! 清理周期：主要是对项目编译生成文件进行清理 包含命令：clean 默认周期：定义了真正构件时所需要执行的所有步骤，它是生命周期中最核心的部分 包含命令：compile - test - package - install &#x2F; deploy 报告周期 包含命令：site 打包: mvn clean package 本地仓库: mvn clean install 最佳使用方案: 123打包: mvn clean package重新编译: mvn clean compile本地部署: mvn clean install 周期，命令和插件: 周期→包含若干命令→包含若干插件! 使用周期命令构建，简化构建过程！ 最终进行构建的是插件！ 插件配置: 12345678910&lt;build&gt; &lt;!-- jdk17 和 war包版本插件不匹配 --&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt; &lt;version&gt;3.2.2&lt;/version&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 四、Maven继承和聚合特性4.1 Maven工程继承关系 继承概念 Maven 继承是指在 Maven 的项目中，让一个项目从另一个项目中继承配置信息的机制。继承可以让我们在多个项目中共享同一配置信息，简化项目的管理和维护工作。 继承作用 作用：在父工程中统一管理项目中的依赖信息,进行统一版本管理! 它的背景是： 对一个比较大型的项目进行了模块拆分。 一个 project 下面，创建了很多个 module。 每一个 module 都需要配置自己的依赖信息。它背后的需求是： 多个模块要使用同一个框架，它们应该是同一个版本，所以整个项目中使用的框架版本需要统一管理。 使用框架时所需要的 jar 包组合（或者说依赖信息组合）需要经过长期摸索和反复调试，最终确定一个可用组合。这个耗费很大精力总结出来的方案不应该在新的项目中重新摸索。通过在父工程中为整个项目维护依赖信息的组合既保证了整个项目使用规范、准确的 jar 包；又能够将以往的经验沉淀下来，节约时间和精力。 继承语法 父工程123456&lt;groupId&gt;com.atguigu.maven&lt;/groupId&gt;&lt;artifactId&gt;pro03-maven-parent&lt;/artifactId&gt;&lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;&lt;!-- 当前工程作为父工程，它要去管理子工程，所以打包方式必须是 pom --&gt;&lt;packaging&gt;pom&lt;/packaging&gt; 子工程12345678910111213&lt;!-- 使用parent标签指定当前工程的父工程 --&gt;&lt;parent&gt; &lt;!-- 父工程的坐标 --&gt; &lt;groupId&gt;com.atguigu.maven&lt;/groupId&gt; &lt;artifactId&gt;pro03-maven-parent&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;&lt;/parent&gt;&lt;!-- 子工程的坐标 --&gt;&lt;!-- 如果子工程坐标中的groupId和version与父工程一致，那么可以省略 --&gt;&lt;!-- &lt;groupId&gt;com.atguigu.maven&lt;/groupId&gt; --&gt;&lt;artifactId&gt;pro04-maven-module&lt;/artifactId&gt;&lt;!-- &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; --&gt; 父工程依赖统一管理 父工程声明版本12345678910111213141516171819202122232425262728293031&lt;!-- 使用dependencyManagement标签配置对依赖的管理 --&gt;&lt;!-- 被管理的依赖并没有真正被引入到工程 --&gt;&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;4.0.0.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;version&gt;4.0.0.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;4.0.0.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-expression&lt;/artifactId&gt; &lt;version&gt;4.0.0.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;version&gt;4.0.0.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt; 子工程引用版本12345678910111213141516171819202122232425&lt;!-- 子工程引用父工程中的依赖信息时，可以把版本号去掉。 --&gt;&lt;!-- 把版本号去掉就表示子工程中这个依赖的版本由父工程决定。 --&gt;&lt;!-- 具体来说是由父工程的dependencyManagement来决定。 --&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-expression&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 4.2 Maven工程聚合关系 聚合概念 Maven 聚合是指将多个项目组织到一个父级项目中，通过触发父工程的构建,统一按顺序触发子工程构建的过程!! 聚合作用 统一管理子项目构建：通过聚合，可以将多个子项目组织在一起，方便管理和维护。 优化构建顺序：通过聚合，可以对多个项目进行顺序控制，避免出现构建依赖混乱导致构建失败的情况。 聚合语法 父项目中包含的子项目列表。 12345678910&lt;project&gt; &lt;groupId&gt;com.example&lt;/groupId&gt; &lt;artifactId&gt;parent-project&lt;/artifactId&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;version&gt;1.0.0&lt;/version&gt; &lt;modules&gt; &lt;module&gt;child-project1&lt;/module&gt; &lt;module&gt;child-project2&lt;/module&gt; &lt;/modules&gt;&lt;/project&gt; 聚合演示 通过触发父工程构建命令、引发所有子模块构建！产生反应堆！ 五、Maven实战案例：搭建微服务Maven工程架构5.1 项目需求和结构分析 需求案例：搭建一个电商平台项目，该平台包括用户服务、订单服务、通用工具模块等。 项目架构： 用户服务：负责处理用户相关的逻辑，例如用户信息的管理、用户注册、登录等。 订单服务：负责处理订单相关的逻辑，例如订单的创建、订单支付、退货、订单查看等。 通用模块：负责存储其他服务需要通用工具类，其他服务依赖此模块。 服务依赖： 用户服务 (1.0.1) spring-context 6.0.6&#x20; spring-core 6.0.6 spring-beans 6.0.6 jackson-databind &#x2F; jackson-core &#x2F; jackson-annotations 2.15.0&#x20; 订单服务 (1.0.1) shiro-core 1.10.1&#x20; spring-context 6.0.6&#x20; spring-core 6.0.6 spring-beans 6.0.6 通用模块 (1.0.1) commons-io 2.11.0 5.2项目搭建和统一构建 父模块搭建 (micro-shop) 创建父工程 pom.xml配置 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.atguigu&lt;/groupId&gt; &lt;artifactId&gt;micro-shop&lt;/artifactId&gt; &lt;version&gt;1.0.1&lt;/version&gt; &lt;!-- 父工程不打包，所以选择pom值--&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;properties&gt; &lt;spring.version&gt;6.0.6&lt;/spring.version&gt; &lt;jackson.version&gt;2.15.0&lt;/jackson.version&gt; &lt;shiro.version&gt;1.10.1&lt;/shiro.version&gt; &lt;commons.version&gt;2.11.0&lt;/commons.version&gt; &lt;maven.compiler.source&gt;17&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;17&lt;/maven.compiler.target&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;/properties&gt; &lt;!-- 依赖管理 --&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;!-- spring-context会依赖传递core/beans --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- jackson-databind会依赖传递core/annotations --&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;$&#123;jackson.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- shiro-core --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-core&lt;/artifactId&gt; &lt;version&gt;$&#123;shiro.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- commons-io --&gt; &lt;dependency&gt; &lt;groupId&gt;commons-io&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;version&gt;$&#123;commons.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;dependencies&gt; &lt;!-- 父工程添加依赖，会自动传递给所有子工程，不推荐！ --&gt; &lt;/dependencies&gt; &lt;!-- 统一更新子工程打包插件--&gt; &lt;build&gt; &lt;!-- jdk17 和 war包版本插件不匹配 --&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt; &lt;version&gt;3.2.2&lt;/version&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 通用模块 (common-service) 创建模块 pom.xml配置 1234567891011121314151617181920212223242526272829&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;com.atguigu&lt;/groupId&gt; &lt;artifactId&gt;micro-shop&lt;/artifactId&gt; &lt;version&gt;1.0.1&lt;/version&gt; &lt;/parent&gt; &lt;artifactId&gt;common-service&lt;/artifactId&gt; &lt;!-- 打包方式默认就是jar！ --&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;17&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;17&lt;/maven.compiler.target&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!-- 声明commons-io，继承父工程版本 --&gt; &lt;dependency&gt; &lt;groupId&gt;commons-io&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 用户模块 (user-service) 创建模块 pom.xml配置 123456789101112131415161718192021222324252627282930313233&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;com.atguigu&lt;/groupId&gt; &lt;artifactId&gt;micro-shop&lt;/artifactId&gt; &lt;version&gt;1.0.1&lt;/version&gt; &lt;/parent&gt; &lt;artifactId&gt;user-service&lt;/artifactId&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;17&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;17&lt;/maven.compiler.target&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!-- 添加spring-context 自动传递 core / beans --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- 添加jackson-databind 自动传递 core / annotations --&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 订单模块 (order-service) 创建模块 pom.xml 1234567891011121314151617181920212223242526272829303132333435&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;com.atguigu&lt;/groupId&gt; &lt;artifactId&gt;micro-shop&lt;/artifactId&gt; &lt;version&gt;1.0.1&lt;/version&gt; &lt;/parent&gt; &lt;artifactId&gt;order-service&lt;/artifactId&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;17&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;17&lt;/maven.compiler.target&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!-- 继承父工程依赖版本 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- 继承父工程依赖版本 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-core&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 六、Maven核心掌握总结 核心点 掌握目标 安装 maven安装、环境变量、maven配置文件修改 工程创建 gavp属性理解、JavaSE&#x2F;EE工程创建、项目结构 依赖管理 依赖添加、依赖传递、版本提取、导入依赖错误解决 构建管理 构建过程、构建场景、构建周期等 继承和聚合 理解继承和聚合作用、继承语法和实践、聚合语法和实践","categories":[{"name":"SSM框架","slug":"SSM框架","permalink":"http://example.com/categories/SSM%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"ssm","slug":"ssm","permalink":"http://example.com/tags/ssm/"}]},{"title":"Spring6","slug":"Spring6/spring6","date":"2022-05-29T23:55:54.000Z","updated":"2023-09-28T00:38:48.115Z","comments":true,"path":"2022/05/30/Spring6/spring6/","link":"","permalink":"http://example.com/2022/05/30/Spring6/spring6/","excerpt":"","text":"Spring6 1、概述1.1、Spring是什么？Spring 是一款主流的 Java EE 轻量级开源框架 ，Spring 由“Spring 之父”Rod Johnson 提出并创立，其目的是用于简化 Java 企业级应用的开发难度和开发周期。Spring的用途不仅限于服务器端的开发。从简单性、可测试性和松耦合的角度而言，任何Java应用都可以从Spring中受益。Spring 框架除了自己提供功能外，还提供整合其他技术和框架的能力。 Spring 自诞生以来备受青睐，一直被广大开发人员作为 Java 企业级应用程序开发的首选。时至今日，Spring 俨然成为了 Java EE 代名词，成为了构建 Java EE 应用的事实标准。 自 2004 年 4 月，Spring 1.0 版本正式发布以来，Spring 已经步入到了第 6 个大版本，也就是 Spring 6。本课程采用Spring当前最新发布的正式版本6.0.2。 1.2、Spring 的狭义和广义在不同的语境中，Spring 所代表的含义是不同的。下面我们就分别从“广义”和“狭义”两个角度，对 Spring 进行介绍。 广义的 Spring：Spring 技术栈 广义上的 Spring 泛指以 Spring Framework 为核心的 Spring 技术栈。 经过十多年的发展，Spring 已经不再是一个单纯的应用框架，而是逐渐发展成为一个由多个不同子项目（模块）组成的成熟技术，例如 Spring Framework、Spring MVC、SpringBoot、Spring Cloud、Spring Data、Spring Security 等，其中 Spring Framework 是其他子项目的基础。 这些子项目涵盖了从企业级应用开发到云计算等各方面的内容，能够帮助开发人员解决软件发展过程中不断产生的各种实际问题，给开发人员带来了更好的开发体验。 狭义的 Spring：Spring Framework 狭义的 Spring 特指 Spring Framework，通常我们将它称为 Spring 框架。 Spring 框架是一个分层的、面向切面的 Java 应用程序的一站式轻量级解决方案，它是 Spring 技术栈的核心和基础，是为了解决企业级应用开发的复杂性而创建的。 Spring 有两个最核心模块： IoC 和 AOP。 IoC：Inverse of Control 的简写，译为“控制反转”，指把创建对象过程交给 Spring 进行管理。 AOP：Aspect Oriented Programming 的简写，译为“面向切面编程”。AOP 用来封装多个类的公共行为，将那些与业务无关，却为业务模块所共同调用的逻辑封装起来，减少系统的重复代码，降低模块间的耦合度。另外，AOP 还解决一些系统层面上的问题，比如日志、事务、权限等。 1.3、Spring Framework特点 非侵入式：使用 Spring Framework 开发应用程序时，Spring 对应用程序本身的结构影响非常小。对领域模型可以做到零污染；对功能性组件也只需要使用几个简单的注解进行标记，完全不会破坏原有结构，反而能将组件结构进一步简化。这就使得基于 Spring Framework 开发应用程序时结构清晰、简洁优雅。 控制反转：IoC——Inversion of Control，翻转资源获取方向。把自己创建资源、向环境索取资源变成环境将资源准备好，我们享受资源注入。 面向切面编程：AOP——Aspect Oriented Programming，在不修改源代码的基础上增强代码功能。 容器：Spring IoC 是一个容器，因为它包含并且管理组件对象的生命周期。组件享受到了容器化的管理，替程序员屏蔽了组件创建过程中的大量细节，极大的降低了使用门槛，大幅度提高了开发效率。 组件化：Spring 实现了使用简单的组件配置组合成一个复杂的应用。在 Spring 中可以使用 XML 和 Java 注解组合这些对象。这使得我们可以基于一个个功能明确、边界清晰的组件有条不紊的搭建超大型复杂应用系统。 一站式：在 IoC 和 AOP 的基础上可以整合各种企业应用的开源框架和优秀的第三方类库。而且 Spring 旗下的项目已经覆盖了广泛领域，很多方面的功能性需求可以在 Spring Framework 的基础上全部使用 Spring 来实现。 1.4、Spring模块组成官网地址：https://spring.io/ 上图中包含了 Spring 框架的所有模块，这些模块可以满足一切企业级应用开发的需求，在开发过程中可以根据需求有选择性地使用所需要的模块。下面分别对这些模块的作用进行简单介绍。 ①Spring Core（核心容器） spring core提供了IOC,DI,Bean配置装载创建的核心实现。核心概念： Beans、BeanFactory、BeanDefinitions、ApplicationContext。 spring-core ：IOC和DI的基本实现 spring-beans：BeanFactory和Bean的装配管理(BeanFactory) spring-context：Spring context上下文，即IOC容器(AppliactionContext) spring-expression：spring表达式语言 ②Spring AOP spring-aop：面向切面编程的应用模块，整合ASM，CGLib，JDK Proxy spring-aspects：集成AspectJ，AOP应用框架 spring-instrument：动态Class Loading模块 ③Spring Data Access spring-jdbc：spring对JDBC的封装，用于简化jdbc操作 spring-orm：java对象与数据库数据的映射框架 spring-oxm：对象与xml文件的映射框架 spring-jms： Spring对Java Message Service(java消息服务)的封装，用于服务之间相互通信 spring-tx：spring jdbc事务管理 ④Spring Web spring-web：最基础的web支持，建立于spring-context之上，通过servlet或listener来初始化IOC容器 spring-webmvc：实现web mvc spring-websocket：与前端的全双工通信协议 spring-webflux：Spring 5.0提供的，用于取代传统java servlet，非阻塞式Reactive Web框架，异步，非阻塞，事件驱动的服务 ⑤Spring Message Spring-messaging：spring 4.0提供的，为Spring集成一些基础的报文传送服务 ⑥Spring test spring-test：集成测试支持，主要是对junit的封装 1.5、Spring6特点1.5.1、版本要求（1）Spring6要求JDK最低版本是JDK17 1.5.2、本课程软件版本（1）IDEA开发工具：2022.1.2 （2）JDK：Java17（Spring6要求JDK最低版本是Java17） （3）Spring：6.0.2 2、入门2.1、环境要求 JDK：Java17+（Spring6要求JDK最低版本是Java17） Maven：3.6+ Spring：6.0.2 2.2、构建模块（1）构建父模块spring6 在idea中，依次单击 File -&gt; New -&gt; Project -&gt; New Project 点击“Create” 删除src目录 （2）构建子模块spring6-first 点击 Create 完成 2.3、程序开发2.3.1、引入依赖https://spring.io/projects/spring-framework#learn 添加依赖： 12345678910111213141516&lt;dependencies&gt; &lt;!--spring context依赖--&gt; &lt;!--当你引入Spring Context依赖之后，表示将Spring的基础依赖引入了--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;6.0.2&lt;/version&gt; &lt;/dependency&gt; &lt;!--junit5测试--&gt; &lt;dependency&gt; &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt; &lt;artifactId&gt;junit-jupiter-api&lt;/artifactId&gt; &lt;version&gt;5.3.1&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 查看依赖： 2.3.2、创建java类12345678package com.atguigu.spring6.bean;public class HelloWorld &#123; public void sayHello()&#123; System.out.println(&quot;helloworld&quot;); &#125;&#125; 2.3.3、创建配置文件在resources目录创建一个 Spring 配置文件 beans.xml（配置文件名称可随意命名，如：springs.xm） 123456789101112131415&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;!-- 配置HelloWorld所对应的bean，即将HelloWorld的对象交给Spring的IOC容器管理 通过bean标签配置IOC容器所管理的bean 属性： id：设置bean的唯一标识 class：设置bean所对应类型的全类名 --&gt; &lt;bean id=&quot;helloWorld&quot; class=&quot;com.atguigu.spring6.bean.HelloWorld&quot;&gt;&lt;/bean&gt; &lt;/beans&gt; 2.3.4、创建测试类测试123456789101112131415package com.atguigu.spring6.bean;import org.junit.jupiter.api.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class HelloWorldTest &#123; @Test public void testHelloWorld()&#123; ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;); HelloWorld helloworld = (HelloWorld) ac.getBean(&quot;helloWorld&quot;); helloworld.sayHello(); &#125;&#125; 2.3.5、运行测试程序 2.4、程序分析1. 底层是怎么创建对象的，是通过反射机制调用无参数构造方法吗？ 修改HelloWorld类： 123456789101112package com.atguigu.spring6.bean;public class HelloWorld &#123; public HelloWorld() &#123; System.out.println(&quot;无参数构造方法执行&quot;); &#125; public void sayHello()&#123; System.out.println(&quot;helloworld&quot;); &#125;&#125; 执行结果： 测试得知：创建对象时确实调用了无参数构造方法。 2. Spring是如何创建对象的呢？原理是什么？ 12345// dom4j解析beans.xml文件，从中获取class属性值，类的全类名 // 通过反射机制调用无参数构造方法创建对象 Class clazz = Class.forName(&quot;com.atguigu.spring6.bean.HelloWorld&quot;); //Object obj = clazz.newInstance(); Object object = clazz.getDeclaredConstructor().newInstance(); 3. 把创建好的对象存储到一个什么样的数据结构当中了呢？ bean对象最终存储在spring容器中，在spring源码底层就是一个map集合，存储bean的map在DefaultListableBeanFactory类中： 1private final Map&lt;String, BeanDefinition&gt; beanDefinitionMap = new ConcurrentHashMap&lt;&gt;(256); Spring容器加载到Bean类时 , 会把这个类的描述信息, 以包名加类名的方式存到beanDefinitionMap 中,Map&lt;String,BeanDefinition&gt; , 其中 String是Key , 默认是类名首字母小写 , BeanDefinition , 存的是类的定义(描述信息) , 我们通常叫BeanDefinition接口为 : bean的定义对象。 2.5、启用Log4j2日志框架2.5.1、Log4j2日志概述在项目开发中，日志十分的重要，不管是记录运行情况还是定位线上问题，都离不开对日志的分析。日志记录了系统行为的时间、地点、状态等相关信息，能够帮助我们了解并监控系统状态，在发生错误或者接近某种危险状态时能够及时提醒我们处理，同时在系统产生问题时，能够帮助我们快速的定位、诊断并解决问题。 Apache Log4j2是一个开源的日志记录组件，使用非常的广泛。在工程中以易用方便代替了 System.out 等打印语句，它是JAVA下最流行的日志输入工具。 Log4j2主要由几个重要的组件构成： （1）日志信息的优先级，日志信息的优先级从高到低有TRACE &lt; DEBUG &lt; INFO &lt; WARN &lt; ERROR &lt; FATAL TRACE：追踪，是最低的日志级别，相当于追踪程序的执行 DEBUG：调试，一般在开发中，都将其设置为最低的日志级别 INFO：信息，输出重要的信息，使用较多 WARN：警告，输出警告的信息 ERROR：错误，输出错误信息 FATAL：严重错误 这些级别分别用来指定这条日志信息的重要程度；级别高的会自动屏蔽级别低的日志，也就是说，设置了WARN的日志，则INFO、DEBUG的日志级别的日志不会显示 （2）日志信息的输出目的地，日志信息的输出目的地指定了日志将打印到控制台还是文件中； （3）日志信息的输出格式，而输出格式则控制了日志信息的显示内容。 2.5.2、引入Log4j2依赖1234567891011&lt;!--log4j2的依赖--&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j-core&lt;/artifactId&gt; &lt;version&gt;2.19.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j-slf4j2-impl&lt;/artifactId&gt; &lt;version&gt;2.19.0&lt;/version&gt;&lt;/dependency&gt; 2.5.3、加入日志配置文件在类的根路径下提供log4j2.xml配置文件（文件名固定为：log4j2.xml，文件必须放到类根路径下。） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;configuration&gt; &lt;loggers&gt; &lt;!-- level指定日志级别，从低到高的优先级： TRACE &lt; DEBUG &lt; INFO &lt; WARN &lt; ERROR &lt; FATAL trace：追踪，是最低的日志级别，相当于追踪程序的执行 debug：调试，一般在开发中，都将其设置为最低的日志级别 info：信息，输出重要的信息，使用较多 warn：警告，输出警告的信息 error：错误，输出错误信息 fatal：严重错误 --&gt; &lt;root level=&quot;DEBUG&quot;&gt; &lt;appender-ref ref=&quot;spring6log&quot;/&gt; &lt;appender-ref ref=&quot;RollingFile&quot;/&gt; &lt;appender-ref ref=&quot;log&quot;/&gt; &lt;/root&gt; &lt;/loggers&gt; &lt;appenders&gt; &lt;!--输出日志信息到控制台--&gt; &lt;console name=&quot;spring6log&quot; target=&quot;SYSTEM_OUT&quot;&gt; &lt;!--控制日志输出的格式--&gt; &lt;PatternLayout pattern=&quot;%d&#123;yyyy-MM-dd HH:mm:ss SSS&#125; [%t] %-3level %logger&#123;1024&#125; - %msg%n&quot;/&gt; &lt;/console&gt; &lt;!--文件会打印出所有信息，这个log每次运行程序会自动清空，由append属性决定，适合临时测试用--&gt; &lt;File name=&quot;log&quot; fileName=&quot;d:/spring6_log/test.log&quot; append=&quot;false&quot;&gt; &lt;PatternLayout pattern=&quot;%d&#123;HH:mm:ss.SSS&#125; %-5level %class&#123;36&#125; %L %M - %msg%xEx%n&quot;/&gt; &lt;/File&gt; &lt;!-- 这个会打印出所有的信息， 每次大小超过size， 则这size大小的日志会自动存入按年份-月份建立的文件夹下面并进行压缩， 作为存档--&gt; &lt;RollingFile name=&quot;RollingFile&quot; fileName=&quot;d:/spring6_log/app.log&quot; filePattern=&quot;log/$$&#123;date:yyyy-MM&#125;/app-%d&#123;MM-dd-yyyy&#125;-%i.log.gz&quot;&gt; &lt;PatternLayout pattern=&quot;%d&#123;yyyy-MM-dd &#x27;at&#x27; HH:mm:ss z&#125; %-5level %class&#123;36&#125; %L %M - %msg%xEx%n&quot;/&gt; &lt;SizeBasedTriggeringPolicy size=&quot;50MB&quot;/&gt; &lt;!-- DefaultRolloverStrategy属性如不设置， 则默认为最多同一文件夹下7个文件，这里设置了20 --&gt; &lt;DefaultRolloverStrategy max=&quot;20&quot;/&gt; &lt;/RollingFile&gt; &lt;/appenders&gt;&lt;/configuration&gt; 2.5.4、测试运行原测试程序 运行原测试程序，多了spring打印日志 2.5.5、使用日志123456789101112public class HelloWorldTest &#123; private Logger logger = LoggerFactory.getLogger(HelloWorldTest.class); @Test public void testHelloWorld()&#123; ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;); HelloWorld helloworld = (HelloWorld) ac.getBean(&quot;helloWorld&quot;); helloworld.sayHello(); logger.info(&quot;执行成功&quot;); &#125;&#125; 控制台： 3、容器：IoCIoC 是 Inversion of Control 的简写，译为“控制反转”，它不是一门技术，而是一种设计思想，是一个重要的面向对象编程法则，能够指导我们如何设计出松耦合、更优良的程序。 Spring 通过 IoC 容器来管理所有 Java 对象的实例化和初始化，控制对象与对象之间的依赖关系。我们将由 IoC 容器管理的 Java 对象称为 Spring Bean，它与使用关键字 new 创建的 Java 对象没有任何区别。 IoC 容器是 Spring 框架中最重要的核心组件之一，它贯穿了 Spring 从诞生到成长的整个过程。 3.1、IoC容器3.1.1、控制反转（IoC） 控制反转是一种思想。 控制反转是为了降低程序耦合度，提高程序扩展力。 控制反转，反转的是什么？ 将对象的创建权利交出去，交给第三方容器负责。 将对象和对象之间关系的维护权交出去，交给第三方容器负责。 控制反转这种思想如何实现呢？ DI（Dependency Injection）：依赖注入 3.1.2、依赖注入DI（Dependency Injection）：依赖注入，依赖注入实现了控制反转的思想。 依赖注入： 指Spring创建对象的过程中，将对象依赖属性通过配置进行注入 依赖注入常见的实现方式包括两种： 第一种：set注入 第二种：构造注入 所以结论是：IOC 就是一种控制反转的思想， 而 DI 是对IoC的一种具体实现。 Bean管理说的是：Bean对象的创建，以及Bean对象中属性的赋值（或者叫做Bean对象之间关系的维护）。 3.1.3、IoC容器在Spring的实现Spring 的 IoC 容器就是 IoC思想的一个落地的产品实现。IoC容器中管理的组件也叫做 bean。在创建 bean 之前，首先需要创建IoC 容器。Spring 提供了IoC 容器的两种实现方式： ①BeanFactory 这是 IoC 容器的基本实现，是 Spring 内部使用的接口。面向 Spring 本身，不提供给开发人员使用。 ②ApplicationContext BeanFactory 的子接口，提供了更多高级特性。面向 Spring 的使用者，几乎所有场合都使用 ApplicationContext 而不是底层的 BeanFactory。 ③ApplicationContext的主要实现类 类型名 简介 ClassPathXmlApplicationContext 通过读取类路径下的 XML 格式的配置文件创建 IOC 容器对象 FileSystemXmlApplicationContext 通过文件系统路径读取 XML 格式的配置文件创建 IOC 容器对象 ConfigurableApplicationContext ApplicationContext 的子接口，包含一些扩展方法 refresh() 和 close() ，让 ApplicationContext 具有启动、关闭和刷新上下文的能力。 WebApplicationContext 专门为 Web 应用准备，基于 Web 环境创建 IOC 容器对象，并将对象引入存入 ServletContext 域中。 3.2、基于XML管理Bean3.2.1、搭建子模块spring6-ioc-xml①搭建模块 搭建方式如：spring-first ②引入配置文件 引入spring-first模块配置文件：beans.xml、log4j2.xml ③添加依赖 12345678910111213141516171819202122232425262728&lt;dependencies&gt; &lt;!--spring context依赖--&gt; &lt;!--当你引入Spring Context依赖之后，表示将Spring的基础依赖引入了--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;6.0.3&lt;/version&gt; &lt;/dependency&gt; &lt;!--junit5测试--&gt; &lt;dependency&gt; &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt; &lt;artifactId&gt;junit-jupiter-api&lt;/artifactId&gt; &lt;version&gt;5.3.1&lt;/version&gt; &lt;/dependency&gt; &lt;!--log4j2的依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j-core&lt;/artifactId&gt; &lt;version&gt;2.19.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j-slf4j2-impl&lt;/artifactId&gt; &lt;version&gt;2.19.0&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; ④引入java类 引入spring-first模块java及test目录下实体类 12345678910111213package com.atguigu.spring6.bean;public class HelloWorld &#123; public HelloWorld() &#123; System.out.println(&quot;无参数构造方法执行&quot;); &#125; public void sayHello()&#123; System.out.println(&quot;helloworld&quot;); &#125;&#125; 1234567891011121314151617package com.atguigu.spring6.bean;import org.junit.jupiter.api.Test;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class HelloWorldTest &#123; private Logger logger = LoggerFactory.getLogger(HelloWorldTest.class); @Test public void testHelloWorld()&#123; &#125;&#125; 3.2.2、实验一：获取bean①方式一：根据id获取由于 id 属性指定了 bean 的唯一标识，所以根据 bean 标签的 id 属性可以精确获取到一个组件对象。上个实验中我们使用的就是这种方式。 ②方式二：根据类型获取123456@Testpublic void testHelloWorld1()&#123; ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;); HelloWorld bean = ac.getBean(HelloWorld.class); bean.sayHello();&#125; ③方式三：根据id和类型123456@Testpublic void testHelloWorld2()&#123; ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;); HelloWorld bean = ac.getBean(&quot;helloworld&quot;, HelloWorld.class); bean.sayHello();&#125; ④注意的地方当根据类型获取bean时，要求IOC容器中指定类型的bean有且只能有一个 当IOC容器中一共配置了两个： 12&lt;bean id=&quot;helloworldOne&quot; class=&quot;com.atguigu.spring6.bean.HelloWorld&quot;&gt;&lt;/bean&gt;&lt;bean id=&quot;helloworldTwo&quot; class=&quot;com.atguigu.spring6.bean.HelloWorld&quot;&gt;&lt;/bean&gt; 根据类型获取时会抛出异常： org.springframework.beans.factory.NoUniqueBeanDefinitionException: No qualifying bean of type ‘com.atguigu.spring6.bean.HelloWorld’ available: expected single matching bean but found 2: helloworldOne,helloworldTwo ⑤扩展知识如果组件类实现了接口，根据接口类型可以获取 bean 吗？ 可以，前提是bean唯一 如果一个接口有多个实现类，这些实现类都配置了 bean，根据接口类型可以获取 bean 吗？ 不行，因为bean不唯一 结论 根据类型来获取bean时，在满足bean唯一性的前提下，其实只是看：『对象 instanceof 指定的类型』的返回结果，只要返回的是true就可以认定为和类型匹配，能够获取到。 java中，instanceof运算符用于判断前面的对象是否是后面的类，或其子类、实现类的实例。如果是返回true，否则返回false。也就是说：用instanceof关键字做判断时， instanceof 操作符的左右操作必须有继承或实现关系 3.2.3、实验二：依赖注入之setter注入①创建学生类Student 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758package com.atguigu.spring6.bean;public class Student &#123; private Integer id; private String name; private Integer age; private String sex; public Student() &#123; &#125; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Integer getAge() &#123; return age; &#125; public void setAge(Integer age) &#123; this.age = age; &#125; public String getSex() &#123; return sex; &#125; public void setSex(String sex) &#123; this.sex = sex; &#125; @Override public String toString() &#123; return &quot;Student&#123;&quot; + &quot;id=&quot; + id + &quot;, name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, age=&quot; + age + &quot;, sex=&#x27;&quot; + sex + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125;&#125; ②配置bean时为属性赋值 spring-di.xml 123456789&lt;bean id=&quot;studentOne&quot; class=&quot;com.atguigu.spring6.bean.Student&quot;&gt; &lt;!-- property标签：通过组件类的setXxx()方法给组件对象设置属性 --&gt; &lt;!-- name属性：指定属性名（这个属性名是getXxx()、setXxx()方法定义的，和成员变量无关） --&gt; &lt;!-- value属性：指定属性值 --&gt; &lt;property name=&quot;id&quot; value=&quot;1001&quot;&gt;&lt;/property&gt; &lt;property name=&quot;name&quot; value=&quot;张三&quot;&gt;&lt;/property&gt; &lt;property name=&quot;age&quot; value=&quot;23&quot;&gt;&lt;/property&gt; &lt;property name=&quot;sex&quot; value=&quot;男&quot;&gt;&lt;/property&gt;&lt;/bean&gt; ③测试 123456@Testpublic void testDIBySet()&#123; ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;spring-di.xml&quot;); Student studentOne = ac.getBean(&quot;studentOne&quot;, Student.class); System.out.println(studentOne);&#125; 3.2.4、实验三：依赖注入之构造器注入①在Student类中添加有参构造 123456public Student(Integer id, String name, Integer age, String sex) &#123; this.id = id; this.name = name; this.age = age; this.sex = sex;&#125; ②配置bean spring-di.xml 123456&lt;bean id=&quot;studentTwo&quot; class=&quot;com.atguigu.spring6.bean.Student&quot;&gt; &lt;constructor-arg value=&quot;1002&quot;&gt;&lt;/constructor-arg&gt; &lt;constructor-arg value=&quot;李四&quot;&gt;&lt;/constructor-arg&gt; &lt;constructor-arg value=&quot;33&quot;&gt;&lt;/constructor-arg&gt; &lt;constructor-arg value=&quot;女&quot;&gt;&lt;/constructor-arg&gt;&lt;/bean&gt; 注意： constructor-arg标签还有两个属性可以进一步描述构造器参数： index属性：指定参数所在位置的索引（从0开始） name属性：指定参数名 ③测试 123456@Testpublic void testDIByConstructor()&#123; ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;spring-di.xml&quot;); Student studentOne = ac.getBean(&quot;studentTwo&quot;, Student.class); System.out.println(studentOne);&#125; 3.2.5、实验四：特殊值处理①字面量赋值 什么是字面量？ int a &#x3D; 10; 声明一个变量a，初始化为10，此时a就不代表字母a了，而是作为一个变量的名字。当我们引用a的时候，我们实际上拿到的值是10。 而如果a是带引号的：’a’，那么它现在不是一个变量，它就是代表a这个字母本身，这就是字面量。所以字面量没有引申含义，就是我们看到的这个数据本身。 12&lt;!-- 使用value属性给bean的属性赋值时，Spring会把value属性的值看做字面量 --&gt;&lt;property name=&quot;name&quot; value=&quot;张三&quot;/&gt; ②null值123&lt;property name=&quot;name&quot;&gt; &lt;null /&gt;&lt;/property&gt; 注意： 1&lt;property name=&quot;name&quot; value=&quot;null&quot;&gt;&lt;/property&gt; 以上写法，为name所赋的值是字符串null ③xml实体123&lt;!-- 小于号在XML文档中用来定义标签的开始，不能随便使用 --&gt;&lt;!-- 解决方案一：使用XML实体来代替 --&gt;&lt;property name=&quot;expression&quot; value=&quot;a &amp;lt; b&quot;/&gt; ④CDATA节1234567&lt;property name=&quot;expression&quot;&gt; &lt;!-- 解决方案二：使用CDATA节 --&gt; &lt;!-- CDATA中的C代表Character，是文本、字符的含义，CDATA就表示纯文本数据 --&gt; &lt;!-- XML解析器看到CDATA节就知道这里是纯文本，就不会当作XML标签或属性来解析 --&gt; &lt;!-- 所以CDATA节中写什么符号都随意 --&gt; &lt;value&gt;&lt;![CDATA[a &lt; b]]&gt;&lt;/value&gt;&lt;/property&gt; 3.2.6、实验五：为对象类型属性赋值①创建班级类Clazz 12345678910111213141516171819202122232425262728293031323334353637383940package com.atguigu.spring6.bean public class Clazz &#123; private Integer clazzId; private String clazzName; public Integer getClazzId() &#123; return clazzId; &#125; public void setClazzId(Integer clazzId) &#123; this.clazzId = clazzId; &#125; public String getClazzName() &#123; return clazzName; &#125; public void setClazzName(String clazzName) &#123; this.clazzName = clazzName; &#125; @Override public String toString() &#123; return &quot;Clazz&#123;&quot; + &quot;clazzId=&quot; + clazzId + &quot;, clazzName=&#x27;&quot; + clazzName + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125; public Clazz() &#123; &#125; public Clazz(Integer clazzId, String clazzName) &#123; this.clazzId = clazzId; this.clazzName = clazzName; &#125;&#125; ②修改Student类 在Student类中添加以下代码： 123456789private Clazz clazz;public Clazz getClazz() &#123; return clazz;&#125;public void setClazz(Clazz clazz) &#123; this.clazz = clazz;&#125; 方式一：引用外部bean配置Clazz类型的bean： 1234&lt;bean id=&quot;clazzOne&quot; class=&quot;com.atguigu.spring6.bean.Clazz&quot;&gt; &lt;property name=&quot;clazzId&quot; value=&quot;1111&quot;&gt;&lt;/property&gt; &lt;property name=&quot;clazzName&quot; value=&quot;财源滚滚班&quot;&gt;&lt;/property&gt;&lt;/bean&gt; 为Student中的clazz属性赋值： 12345678&lt;bean id=&quot;studentFour&quot; class=&quot;com.atguigu.spring6.bean.Student&quot;&gt; &lt;property name=&quot;id&quot; value=&quot;1004&quot;&gt;&lt;/property&gt; &lt;property name=&quot;name&quot; value=&quot;赵六&quot;&gt;&lt;/property&gt; &lt;property name=&quot;age&quot; value=&quot;26&quot;&gt;&lt;/property&gt; &lt;property name=&quot;sex&quot; value=&quot;女&quot;&gt;&lt;/property&gt; &lt;!-- ref属性：引用IOC容器中某个bean的id，将所对应的bean为属性赋值 --&gt; &lt;property name=&quot;clazz&quot; ref=&quot;clazzOne&quot;&gt;&lt;/property&gt;&lt;/bean&gt; 错误演示： 1234567&lt;bean id=&quot;studentFour&quot; class=&quot;com.atguigu.spring6.bean.Student&quot;&gt; &lt;property name=&quot;id&quot; value=&quot;1004&quot;&gt;&lt;/property&gt; &lt;property name=&quot;name&quot; value=&quot;赵六&quot;&gt;&lt;/property&gt; &lt;property name=&quot;age&quot; value=&quot;26&quot;&gt;&lt;/property&gt; &lt;property name=&quot;sex&quot; value=&quot;女&quot;&gt;&lt;/property&gt; &lt;property name=&quot;clazz&quot; value=&quot;clazzOne&quot;&gt;&lt;/property&gt;&lt;/bean&gt; 如果错把ref属性写成了value属性，会抛出异常： Caused by: java.lang.IllegalStateException: Cannot convert value of type ‘java.lang.String’ to required type ‘com.atguigu.spring6.bean.Clazz’ for property ‘clazz’: no matching editors or conversion strategy found 意思是不能把String类型转换成我们要的Clazz类型，说明我们使用value属性时，Spring只把这个属性看做一个普通的字符串，不会认为这是一个bean的id，更不会根据它去找到bean来赋值 方式二：内部bean1234567891011121314&lt;bean id=&quot;studentFour&quot; class=&quot;com.atguigu.spring6.bean.Student&quot;&gt; &lt;property name=&quot;id&quot; value=&quot;1004&quot;&gt;&lt;/property&gt; &lt;property name=&quot;name&quot; value=&quot;赵六&quot;&gt;&lt;/property&gt; &lt;property name=&quot;age&quot; value=&quot;26&quot;&gt;&lt;/property&gt; &lt;property name=&quot;sex&quot; value=&quot;女&quot;&gt;&lt;/property&gt; &lt;property name=&quot;clazz&quot;&gt; &lt;!-- 在一个bean中再声明一个bean就是内部bean --&gt; &lt;!-- 内部bean只能用于给属性赋值，不能在外部通过IOC容器获取，因此可以省略id属性 --&gt; &lt;bean id=&quot;clazzInner&quot; class=&quot;com.atguigu.spring6.bean.Clazz&quot;&gt; &lt;property name=&quot;clazzId&quot; value=&quot;2222&quot;&gt;&lt;/property&gt; &lt;property name=&quot;clazzName&quot; value=&quot;远大前程班&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;/property&gt;&lt;/bean&gt; 方式三：级联属性赋值123456789&lt;bean id=&quot;studentFour&quot; class=&quot;com.atguigu.spring6.bean.Student&quot;&gt; &lt;property name=&quot;id&quot; value=&quot;1004&quot;&gt;&lt;/property&gt; &lt;property name=&quot;name&quot; value=&quot;赵六&quot;&gt;&lt;/property&gt; &lt;property name=&quot;age&quot; value=&quot;26&quot;&gt;&lt;/property&gt; &lt;property name=&quot;sex&quot; value=&quot;女&quot;&gt;&lt;/property&gt; &lt;property name=&quot;clazz&quot; ref=&quot;clazzOne&quot;&gt;&lt;/property&gt; &lt;property name=&quot;clazz.clazzId&quot; value=&quot;3333&quot;&gt;&lt;/property&gt; &lt;property name=&quot;clazz.clazzName&quot; value=&quot;最强王者班&quot;&gt;&lt;/property&gt;&lt;/bean&gt; 3.2.7、实验六：为数组类型属性赋值①修改Student类 在Student类中添加以下代码： 123456789private String[] hobbies;public String[] getHobbies() &#123; return hobbies;&#125;public void setHobbies(String[] hobbies) &#123; this.hobbies = hobbies;&#125; ②配置bean 123456789101112131415&lt;bean id=&quot;studentFour&quot; class=&quot;com.atguigu.spring.bean6.Student&quot;&gt; &lt;property name=&quot;id&quot; value=&quot;1004&quot;&gt;&lt;/property&gt; &lt;property name=&quot;name&quot; value=&quot;赵六&quot;&gt;&lt;/property&gt; &lt;property name=&quot;age&quot; value=&quot;26&quot;&gt;&lt;/property&gt; &lt;property name=&quot;sex&quot; value=&quot;女&quot;&gt;&lt;/property&gt; &lt;!-- ref属性：引用IOC容器中某个bean的id，将所对应的bean为属性赋值 --&gt; &lt;property name=&quot;clazz&quot; ref=&quot;clazzOne&quot;&gt;&lt;/property&gt; &lt;property name=&quot;hobbies&quot;&gt; &lt;array&gt; &lt;value&gt;抽烟&lt;/value&gt; &lt;value&gt;喝酒&lt;/value&gt; &lt;value&gt;烫头&lt;/value&gt; &lt;/array&gt; &lt;/property&gt;&lt;/bean&gt; 3.2.8、实验七：为集合类型属性赋值①为List集合类型属性赋值在Clazz类中添加以下代码： 123456789private List&lt;Student&gt; students;public List&lt;Student&gt; getStudents() &#123; return students;&#125;public void setStudents(List&lt;Student&gt; students) &#123; this.students = students;&#125; 配置bean： 1234567891011&lt;bean id=&quot;clazzTwo&quot; class=&quot;com.atguigu.spring6.bean.Clazz&quot;&gt; &lt;property name=&quot;clazzId&quot; value=&quot;4444&quot;&gt;&lt;/property&gt; &lt;property name=&quot;clazzName&quot; value=&quot;Javaee0222&quot;&gt;&lt;/property&gt; &lt;property name=&quot;students&quot;&gt; &lt;list&gt; &lt;ref bean=&quot;studentOne&quot;&gt;&lt;/ref&gt; &lt;ref bean=&quot;studentTwo&quot;&gt;&lt;/ref&gt; &lt;ref bean=&quot;studentThree&quot;&gt;&lt;/ref&gt; &lt;/list&gt; &lt;/property&gt;&lt;/bean&gt; 若为Set集合类型属性赋值，只需要将其中的list标签改为set标签即可 ②为Map集合类型属性赋值创建教师类Teacher： 12345678910111213141516171819202122232425262728293031323334353637383940package com.atguigu.spring6.bean;public class Teacher &#123; private Integer teacherId; private String teacherName; public Integer getTeacherId() &#123; return teacherId; &#125; public void setTeacherId(Integer teacherId) &#123; this.teacherId = teacherId; &#125; public String getTeacherName() &#123; return teacherName; &#125; public void setTeacherName(String teacherName) &#123; this.teacherName = teacherName; &#125; public Teacher(Integer teacherId, String teacherName) &#123; this.teacherId = teacherId; this.teacherName = teacherName; &#125; public Teacher() &#123; &#125; @Override public String toString() &#123; return &quot;Teacher&#123;&quot; + &quot;teacherId=&quot; + teacherId + &quot;, teacherName=&#x27;&quot; + teacherName + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125;&#125; 在Student类中添加以下代码： 123456789private Map&lt;String, Teacher&gt; teacherMap;public Map&lt;String, Teacher&gt; getTeacherMap() &#123; return teacherMap;&#125;public void setTeacherMap(Map&lt;String, Teacher&gt; teacherMap) &#123; this.teacherMap = teacherMap;&#125; 配置bean： 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;bean id=&quot;teacherOne&quot; class=&quot;com.atguigu.spring6.bean.Teacher&quot;&gt; &lt;property name=&quot;teacherId&quot; value=&quot;10010&quot;&gt;&lt;/property&gt; &lt;property name=&quot;teacherName&quot; value=&quot;大宝&quot;&gt;&lt;/property&gt;&lt;/bean&gt;&lt;bean id=&quot;teacherTwo&quot; class=&quot;com.atguigu.spring6.bean.Teacher&quot;&gt; &lt;property name=&quot;teacherId&quot; value=&quot;10086&quot;&gt;&lt;/property&gt; &lt;property name=&quot;teacherName&quot; value=&quot;二宝&quot;&gt;&lt;/property&gt;&lt;/bean&gt;&lt;bean id=&quot;studentFour&quot; class=&quot;com.atguigu.spring6.bean.Student&quot;&gt; &lt;property name=&quot;id&quot; value=&quot;1004&quot;&gt;&lt;/property&gt; &lt;property name=&quot;name&quot; value=&quot;赵六&quot;&gt;&lt;/property&gt; &lt;property name=&quot;age&quot; value=&quot;26&quot;&gt;&lt;/property&gt; &lt;property name=&quot;sex&quot; value=&quot;女&quot;&gt;&lt;/property&gt; &lt;!-- ref属性：引用IOC容器中某个bean的id，将所对应的bean为属性赋值 --&gt; &lt;property name=&quot;clazz&quot; ref=&quot;clazzOne&quot;&gt;&lt;/property&gt; &lt;property name=&quot;hobbies&quot;&gt; &lt;array&gt; &lt;value&gt;抽烟&lt;/value&gt; &lt;value&gt;喝酒&lt;/value&gt; &lt;value&gt;烫头&lt;/value&gt; &lt;/array&gt; &lt;/property&gt; &lt;property name=&quot;teacherMap&quot;&gt; &lt;map&gt; &lt;entry&gt; &lt;key&gt; &lt;value&gt;10010&lt;/value&gt; &lt;/key&gt; &lt;ref bean=&quot;teacherOne&quot;&gt;&lt;/ref&gt; &lt;/entry&gt; &lt;entry&gt; &lt;key&gt; &lt;value&gt;10086&lt;/value&gt; &lt;/key&gt; &lt;ref bean=&quot;teacherTwo&quot;&gt;&lt;/ref&gt; &lt;/entry&gt; &lt;/map&gt; &lt;/property&gt;&lt;/bean&gt; ③引用集合类型的bean123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!--list集合类型的bean--&gt;&lt;util:list id=&quot;students&quot;&gt; &lt;ref bean=&quot;studentOne&quot;&gt;&lt;/ref&gt; &lt;ref bean=&quot;studentTwo&quot;&gt;&lt;/ref&gt; &lt;ref bean=&quot;studentThree&quot;&gt;&lt;/ref&gt;&lt;/util:list&gt;&lt;!--map集合类型的bean--&gt;&lt;util:map id=&quot;teacherMap&quot;&gt; &lt;entry&gt; &lt;key&gt; &lt;value&gt;10010&lt;/value&gt; &lt;/key&gt; &lt;ref bean=&quot;teacherOne&quot;&gt;&lt;/ref&gt; &lt;/entry&gt; &lt;entry&gt; &lt;key&gt; &lt;value&gt;10086&lt;/value&gt; &lt;/key&gt; &lt;ref bean=&quot;teacherTwo&quot;&gt;&lt;/ref&gt; &lt;/entry&gt;&lt;/util:map&gt;&lt;bean id=&quot;clazzTwo&quot; class=&quot;com.atguigu.spring6.bean.Clazz&quot;&gt; &lt;property name=&quot;clazzId&quot; value=&quot;4444&quot;&gt;&lt;/property&gt; &lt;property name=&quot;clazzName&quot; value=&quot;Javaee0222&quot;&gt;&lt;/property&gt; &lt;property name=&quot;students&quot; ref=&quot;students&quot;&gt;&lt;/property&gt;&lt;/bean&gt;&lt;bean id=&quot;studentFour&quot; class=&quot;com.atguigu.spring6.bean.Student&quot;&gt; &lt;property name=&quot;id&quot; value=&quot;1004&quot;&gt;&lt;/property&gt; &lt;property name=&quot;name&quot; value=&quot;赵六&quot;&gt;&lt;/property&gt; &lt;property name=&quot;age&quot; value=&quot;26&quot;&gt;&lt;/property&gt; &lt;property name=&quot;sex&quot; value=&quot;女&quot;&gt;&lt;/property&gt; &lt;!-- ref属性：引用IOC容器中某个bean的id，将所对应的bean为属性赋值 --&gt; &lt;property name=&quot;clazz&quot; ref=&quot;clazzOne&quot;&gt;&lt;/property&gt; &lt;property name=&quot;hobbies&quot;&gt; &lt;array&gt; &lt;value&gt;抽烟&lt;/value&gt; &lt;value&gt;喝酒&lt;/value&gt; &lt;value&gt;烫头&lt;/value&gt; &lt;/array&gt; &lt;/property&gt; &lt;property name=&quot;teacherMap&quot; ref=&quot;teacherMap&quot;&gt;&lt;/property&gt;&lt;/bean&gt; 使用util:list、util:map标签必须引入相应的命名空间 12345678&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:util=&quot;http://www.springframework.org/schema/util&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util.xsd http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; 3.2.9、实验八：p命名空间引入p命名空间 123456789&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:util=&quot;http://www.springframework.org/schema/util&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util.xsd http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; 引入p命名空间后，可以通过以下方式为bean的各个属性赋值 12&lt;bean id=&quot;studentSix&quot; class=&quot;com.atguigu.spring6.bean.Student&quot; p:id=&quot;1006&quot; p:name=&quot;小明&quot; p:clazz-ref=&quot;clazzOne&quot; p:teacherMap-ref=&quot;teacherMap&quot;&gt;&lt;/bean&gt; 3.2.10、实验九：引入外部属性文件①加入依赖 12345678910111213 &lt;!-- MySQL驱动 --&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.30&lt;/version&gt;&lt;/dependency&gt;&lt;!-- 数据源 --&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.2.15&lt;/version&gt;&lt;/dependency&gt; ②创建外部属性文件 1234jdbc.user=rootjdbc.password=atguigujdbc.url=jdbc:mysql://localhost:3306/ssm?serverTimezone=UTCjdbc.driver=com.mysql.cj.jdbc.Driver ③引入属性文件 引入context 名称空间 12345678910&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;&lt;/beans&gt; 12&lt;!-- 引入外部属性文件 --&gt;&lt;context:property-placeholder location=&quot;classpath:jdbc.properties&quot;/&gt; 注意：在使用 context:property-placeholder 元素加载外包配置文件功能前，首先需要在 XML 配置的一级标签 中添加 context 相关的约束。 ④配置bean 123456&lt;bean id=&quot;druidDataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot;/&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;$&#123;jdbc.driver&#125;&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.user&#125;&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;/&gt;&lt;/bean&gt; ⑤测试 1234567@Testpublic void testDataSource() throws SQLException &#123; ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;spring-datasource.xml&quot;); DataSource dataSource = ac.getBean(DataSource.class); Connection connection = dataSource.getConnection(); System.out.println(connection);&#125; 3.2.11、实验十：bean的作用域①概念 在Spring中可以通过配置bean标签的scope属性来指定bean的作用域范围，各取值含义参加下表： 取值 含义 创建对象的时机 singleton（默认） 在IOC容器中，这个bean的对象始终为单实例 IOC容器初始化时 prototype 这个bean在IOC容器中有多个实例 获取bean时 如果是在WebApplicationContext环境下还会有另外几个作用域（但不常用）： 取值 含义 request 在一个请求范围内有效 session 在一个会话范围内有效 ②创建类User 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263package com.atguigu.spring6.bean;public class User &#123; private Integer id; private String username; private String password; private Integer age; public User() &#123; &#125; public User(Integer id, String username, String password, Integer age) &#123; this.id = id; this.username = username; this.password = password; this.age = age; &#125; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; public Integer getAge() &#123; return age; &#125; public void setAge(Integer age) &#123; this.age = age; &#125; @Override public String toString() &#123; return &quot;User&#123;&quot; + &quot;id=&quot; + id + &quot;, username=&#x27;&quot; + username + &#x27;\\&#x27;&#x27; + &quot;, password=&#x27;&quot; + password + &#x27;\\&#x27;&#x27; + &quot;, age=&quot; + age + &#x27;&#125;&#x27;; &#125;&#125; ③配置bean 123&lt;!-- scope属性：取值singleton（默认值），bean在IOC容器中只有一个实例，IOC容器初始化时创建对象 --&gt;&lt;!-- scope属性：取值prototype，bean在IOC容器中可以有多个实例，getBean()时创建对象 --&gt;&lt;bean class=&quot;com.atguigu.spring6.bean.User&quot; scope=&quot;prototype&quot;&gt;&lt;/bean&gt; ④测试 1234567@Testpublic void testBeanScope()&#123; ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;spring-scope.xml&quot;); User user1 = ac.getBean(User.class); User user2 = ac.getBean(User.class); System.out.println(user1==user2);&#125; 3.2.12、实验十一：bean生命周期①具体的生命周期过程 bean对象创建（调用无参构造器） 给bean对象设置属性 bean的后置处理器（初始化之前） bean对象初始化（需在配置bean时指定初始化方法） bean的后置处理器（初始化之后） bean对象就绪可以使用 bean对象销毁（需在配置bean时指定销毁方法） IOC容器关闭 ②修改类User 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172public class User &#123; private Integer id; private String username; private String password; private Integer age; public User() &#123; System.out.println(&quot;生命周期：1、创建对象&quot;); &#125; public User(Integer id, String username, String password, Integer age) &#123; this.id = id; this.username = username; this.password = password; this.age = age; &#125; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; System.out.println(&quot;生命周期：2、依赖注入&quot;); this.id = id; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; public Integer getAge() &#123; return age; &#125; public void setAge(Integer age) &#123; this.age = age; &#125; public void initMethod()&#123; System.out.println(&quot;生命周期：3、初始化&quot;); &#125; public void destroyMethod()&#123; System.out.println(&quot;生命周期：5、销毁&quot;); &#125; @Override public String toString() &#123; return &quot;User&#123;&quot; + &quot;id=&quot; + id + &quot;, username=&#x27;&quot; + username + &#x27;\\&#x27;&#x27; + &quot;, password=&#x27;&quot; + password + &#x27;\\&#x27;&#x27; + &quot;, age=&quot; + age + &#x27;&#125;&#x27;; &#125;&#125; 注意其中的initMethod()和destroyMethod()，可以通过配置bean指定为初始化和销毁的方法 ③配置bean 12345678&lt;!-- 使用init-method属性指定初始化方法 --&gt;&lt;!-- 使用destroy-method属性指定销毁方法 --&gt;&lt;bean class=&quot;com.atguigu.spring6.bean.User&quot; scope=&quot;prototype&quot; init-method=&quot;initMethod&quot; destroy-method=&quot;destroyMethod&quot;&gt; &lt;property name=&quot;id&quot; value=&quot;1001&quot;&gt;&lt;/property&gt; &lt;property name=&quot;username&quot; value=&quot;admin&quot;&gt;&lt;/property&gt; &lt;property name=&quot;password&quot; value=&quot;123456&quot;&gt;&lt;/property&gt; &lt;property name=&quot;age&quot; value=&quot;23&quot;&gt;&lt;/property&gt;&lt;/bean&gt; ④测试 1234567@Testpublic void testLife()&#123; ClassPathXmlApplicationContext ac = new ClassPathXmlApplicationContext(&quot;spring-lifecycle.xml&quot;); User bean = ac.getBean(User.class); System.out.println(&quot;生命周期：4、通过IOC容器获取bean并使用&quot;); ac.close();&#125; ⑤bean的后置处理器 bean的后置处理器会在生命周期的初始化前后添加额外的操作，需要实现BeanPostProcessor接口，且配置到IOC容器中，需要注意的是，bean后置处理器不是单独针对某一个bean生效，而是针对IOC容器中所有bean都会执行 创建bean的后置处理器： 12345678910111213141516171819package com.atguigu.spring6.process; import org.springframework.beans.BeansException;import org.springframework.beans.factory.config.BeanPostProcessor;public class MyBeanProcessor implements BeanPostProcessor &#123; @Override public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException &#123; System.out.println(&quot;☆☆☆&quot; + beanName + &quot; = &quot; + bean); return bean; &#125; @Override public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException &#123; System.out.println(&quot;★★★&quot; + beanName + &quot; = &quot; + bean); return bean; &#125;&#125; 在IOC容器中配置后置处理器： 12&lt;!-- bean的后置处理器要放入IOC容器才能生效 --&gt;&lt;bean id=&quot;myBeanProcessor&quot; class=&quot;com.atguigu.spring6.process.MyBeanProcessor&quot;/&gt; 3.2.13、实验十二：FactoryBean①简介 FactoryBean是Spring提供的一种整合第三方框架的常用机制。和普通的bean不同，配置一个FactoryBean类型的bean，在获取bean的时候得到的并不是class属性中配置的这个类的对象，而是getObject()方法的返回值。通过这种机制，Spring可以帮我们把复杂组件创建的详细过程和繁琐细节都屏蔽起来，只把最简洁的使用界面展示给我们。 将来我们整合Mybatis时，Spring就是通过FactoryBean机制来帮我们创建SqlSessionFactory对象的。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146/* * Copyright 2002-2020 the original author or authors. * * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * https://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.springframework.beans.factory;import org.springframework.lang.Nullable;/** * Interface to be implemented by objects used within a &#123;@link BeanFactory&#125; which * are themselves factories for individual objects. If a bean implements this * interface, it is used as a factory for an object to expose, not directly as a * bean instance that will be exposed itself. * * &lt;p&gt;&lt;b&gt;NB: A bean that implements this interface cannot be used as a normal bean.&lt;/b&gt; * A FactoryBean is defined in a bean style, but the object exposed for bean * references (&#123;@link #getObject()&#125;) is always the object that it creates. * * &lt;p&gt;FactoryBeans can support singletons and prototypes, and can either create * objects lazily on demand or eagerly on startup. The &#123;@link SmartFactoryBean&#125; * interface allows for exposing more fine-grained behavioral metadata. * * &lt;p&gt;This interface is heavily used within the framework itself, for example for * the AOP &#123;@link org.springframework.aop.framework.ProxyFactoryBean&#125; or the * &#123;@link org.springframework.jndi.JndiObjectFactoryBean&#125;. It can be used for * custom components as well; however, this is only common for infrastructure code. * * &lt;p&gt;&lt;b&gt;&#123;@code FactoryBean&#125; is a programmatic contract. Implementations are not * supposed to rely on annotation-driven injection or other reflective facilities.&lt;/b&gt; * &#123;@link #getObjectType()&#125; &#123;@link #getObject()&#125; invocations may arrive early in the * bootstrap process, even ahead of any post-processor setup. If you need access to * other beans, implement &#123;@link BeanFactoryAware&#125; and obtain them programmatically. * * &lt;p&gt;&lt;b&gt;The container is only responsible for managing the lifecycle of the FactoryBean * instance, not the lifecycle of the objects created by the FactoryBean.&lt;/b&gt; Therefore, * a destroy method on an exposed bean object (such as &#123;@link java.io.Closeable#close()&#125; * will &lt;i&gt;not&lt;/i&gt; be called automatically. Instead, a FactoryBean should implement * &#123;@link DisposableBean&#125; and delegate any such close call to the underlying object. * * &lt;p&gt;Finally, FactoryBean objects participate in the containing BeanFactory&#x27;s * synchronization of bean creation. There is usually no need for internal * synchronization other than for purposes of lazy initialization within the * FactoryBean itself (or the like). * * @author Rod Johnson * @author Juergen Hoeller * @since 08.03.2003 * @param &lt;T&gt; the bean type * @see org.springframework.beans.factory.BeanFactory * @see org.springframework.aop.framework.ProxyFactoryBean * @see org.springframework.jndi.JndiObjectFactoryBean */public interface FactoryBean&lt;T&gt; &#123; /** * The name of an attribute that can be * &#123;@link org.springframework.core.AttributeAccessor#setAttribute set&#125; on a * &#123;@link org.springframework.beans.factory.config.BeanDefinition&#125; so that * factory beans can signal their object type when it can&#x27;t be deduced from * the factory bean class. * @since 5.2 */ String OBJECT_TYPE_ATTRIBUTE = &quot;factoryBeanObjectType&quot;; /** * Return an instance (possibly shared or independent) of the object * managed by this factory. * &lt;p&gt;As with a &#123;@link BeanFactory&#125;, this allows support for both the * Singleton and Prototype design pattern. * &lt;p&gt;If this FactoryBean is not fully initialized yet at the time of * the call (for example because it is involved in a circular reference), * throw a corresponding &#123;@link FactoryBeanNotInitializedException&#125;. * &lt;p&gt;As of Spring 2.0, FactoryBeans are allowed to return &#123;@code null&#125; * objects. The factory will consider this as normal value to be used; it * will not throw a FactoryBeanNotInitializedException in this case anymore. * FactoryBean implementations are encouraged to throw * FactoryBeanNotInitializedException themselves now, as appropriate. * @return an instance of the bean (can be &#123;@code null&#125;) * @throws Exception in case of creation errors * @see FactoryBeanNotInitializedException */ @Nullable T getObject() throws Exception; /** * Return the type of object that this FactoryBean creates, * or &#123;@code null&#125; if not known in advance. * &lt;p&gt;This allows one to check for specific types of beans without * instantiating objects, for example on autowiring. * &lt;p&gt;In the case of implementations that are creating a singleton object, * this method should try to avoid singleton creation as far as possible; * it should rather estimate the type in advance. * For prototypes, returning a meaningful type here is advisable too. * &lt;p&gt;This method can be called &lt;i&gt;before&lt;/i&gt; this FactoryBean has * been fully initialized. It must not rely on state created during * initialization; of course, it can still use such state if available. * &lt;p&gt;&lt;b&gt;NOTE:&lt;/b&gt; Autowiring will simply ignore FactoryBeans that return * &#123;@code null&#125; here. Therefore it is highly recommended to implement * this method properly, using the current state of the FactoryBean. * @return the type of object that this FactoryBean creates, * or &#123;@code null&#125; if not known at the time of the call * @see ListableBeanFactory#getBeansOfType */ @Nullable Class&lt;?&gt; getObjectType(); /** * Is the object managed by this factory a singleton? That is, * will &#123;@link #getObject()&#125; always return the same object * (a reference that can be cached)? * &lt;p&gt;&lt;b&gt;NOTE:&lt;/b&gt; If a FactoryBean indicates to hold a singleton object, * the object returned from &#123;@code getObject()&#125; might get cached * by the owning BeanFactory. Hence, do not return &#123;@code true&#125; * unless the FactoryBean always exposes the same reference. * &lt;p&gt;The singleton status of the FactoryBean itself will generally * be provided by the owning BeanFactory; usually, it has to be * defined as singleton there. * &lt;p&gt;&lt;b&gt;NOTE:&lt;/b&gt; This method returning &#123;@code false&#125; does not * necessarily indicate that returned objects are independent instances. * An implementation of the extended &#123;@link SmartFactoryBean&#125; interface * may explicitly indicate independent instances through its * &#123;@link SmartFactoryBean#isPrototype()&#125; method. Plain &#123;@link FactoryBean&#125; * implementations which do not implement this extended interface are * simply assumed to always return independent instances if the * &#123;@code isSingleton()&#125; implementation returns &#123;@code false&#125;. * &lt;p&gt;The default implementation returns &#123;@code true&#125;, since a * &#123;@code FactoryBean&#125; typically manages a singleton instance. * @return whether the exposed object is a singleton * @see #getObject() * @see SmartFactoryBean#isPrototype() */ default boolean isSingleton() &#123; return true; &#125;&#125; ②创建类UserFactoryBean 123456789101112package com.atguigu.spring6.bean;public class UserFactoryBean implements FactoryBean&lt;User&gt; &#123; @Override public User getObject() throws Exception &#123; return new User(); &#125; @Override public Class&lt;?&gt; getObjectType() &#123; return User.class; &#125;&#125; ③配置bean 1&lt;bean id=&quot;user&quot; class=&quot;com.atguigu.spring6.bean.UserFactoryBean&quot;&gt;&lt;/bean&gt; ④测试 1234567@Testpublic void testUserFactoryBean()&#123; //获取IOC容器 ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;spring-factorybean.xml&quot;); User user = (User) ac.getBean(&quot;user&quot;); System.out.println(user);&#125; 3.2.14、实验十三：基于xml自动装配 自动装配： 根据指定的策略，在IOC容器中匹配某一个bean，自动为指定的bean中所依赖的类类型或接口类型属性赋值 ①场景模拟 创建类UserController 1234567891011121314package com.atguigu.spring6.autowire.controllerpublic class UserController &#123; private UserService userService; public void setUserService(UserService userService) &#123; this.userService = userService; &#125; public void saveUser()&#123; userService.saveUser(); &#125;&#125; 创建接口UserService 123456package com.atguigu.spring6.autowire.servicepublic interface UserService &#123; void saveUser();&#125; 创建类UserServiceImpl实现接口UserService 123456789101112131415package com.atguigu.spring6.autowire.service.implpublic class UserServiceImpl implements UserService &#123; private UserDao userDao; public void setUserDao(UserDao userDao) &#123; this.userDao = userDao; &#125; @Override public void saveUser() &#123; userDao.saveUser(); &#125;&#125; 创建接口UserDao 123456package com.atguigu.spring6.autowire.daopublic interface UserDao &#123; void saveUser();&#125; 创建类UserDaoImpl实现接口UserDao 123456789package com.atguigu.spring6.autowire.dao.implpublic class UserDaoImpl implements UserDao &#123; @Override public void saveUser() &#123; System.out.println(&quot;保存成功&quot;); &#125;&#125; ②配置bean 使用bean标签的autowire属性设置自动装配效果 自动装配方式：byType byType：根据类型匹配IOC容器中的某个兼容类型的bean，为属性自动赋值 若在IOC中，没有任何一个兼容类型的bean能够为属性赋值，则该属性不装配，即值为默认值null 若在IOC中，有多个兼容类型的bean能够为属性赋值，则抛出异常NoUniqueBeanDefinitionException 12345&lt;bean id=&quot;userController&quot; class=&quot;com.atguigu.spring6.autowire.controller.UserController&quot; autowire=&quot;byType&quot;&gt;&lt;/bean&gt;&lt;bean id=&quot;userService&quot; class=&quot;com.atguigu.spring6.autowire.service.impl.UserServiceImpl&quot; autowire=&quot;byType&quot;&gt;&lt;/bean&gt;&lt;bean id=&quot;userDao&quot; class=&quot;com.atguigu.spring6.autowire.dao.impl.UserDaoImpl&quot;&gt;&lt;/bean&gt; 自动装配方式：byName byName：将自动装配的属性的属性名，作为bean的id在IOC容器中匹配相对应的bean进行赋值 1234567&lt;bean id=&quot;userController&quot; class=&quot;com.atguigu.spring6.autowire.controller.UserController&quot; autowire=&quot;byName&quot;&gt;&lt;/bean&gt;&lt;bean id=&quot;userService&quot; class=&quot;com.atguigu.spring6.autowire.service.impl.UserServiceImpl&quot; autowire=&quot;byName&quot;&gt;&lt;/bean&gt;&lt;bean id=&quot;userServiceImpl&quot; class=&quot;com.atguigu.spring6.autowire.service.impl.UserServiceImpl&quot; autowire=&quot;byName&quot;&gt;&lt;/bean&gt;&lt;bean id=&quot;userDao&quot; class=&quot;com.atguigu.spring6.autowire.dao.impl.UserDaoImpl&quot;&gt;&lt;/bean&gt;&lt;bean id=&quot;userDaoImpl&quot; class=&quot;com.atguigu.spring6.autowire.dao.impl.UserDaoImpl&quot;&gt;&lt;/bean&gt; ③测试 123456@Testpublic void testAutoWireByXML()&#123; ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;autowire-xml.xml&quot;); UserController userController = ac.getBean(UserController.class); userController.saveUser();&#125; 3.3、基于注解管理Bean（☆）从 Java 5 开始，Java 增加了对注解（Annotation）的支持，它是代码中的一种特殊标记，可以在编译、类加载和运行时被读取，执行相应的处理。开发人员可以通过注解在不改变原有代码和逻辑的情况下，在源代码中嵌入补充信息。 Spring 从 2.5 版本开始提供了对注解技术的全面支持，我们可以使用注解来实现自动装配，简化 Spring 的 XML 配置。 Spring 通过注解实现自动装配的步骤如下： 引入依赖 开启组件扫描 使用注解定义 Bean 依赖注入 3.3.1、搭建子模块spring6-ioc-annotation①搭建模块 搭建方式如：spring6-ioc-xml ②引入配置文件 引入spring-ioc-xml模块日志log4j2.xml ③添加依赖 123456789101112131415161718192021222324252627&lt;dependencies&gt; &lt;!--spring context依赖--&gt; &lt;!--当你引入Spring Context依赖之后，表示将Spring的基础依赖引入了--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;6.0.3&lt;/version&gt; &lt;/dependency&gt; &lt;!--junit5测试--&gt; &lt;dependency&gt; &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt; &lt;artifactId&gt;junit-jupiter-api&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--log4j2的依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j-core&lt;/artifactId&gt; &lt;version&gt;2.19.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j-slf4j2-impl&lt;/artifactId&gt; &lt;version&gt;2.19.0&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 3.3.2、开启组件扫描Spring 默认不使用注解装配 Bean，因此我们需要在 Spring 的 XML 配置中，通过 context:component-scan 元素开启 Spring Beans的自动扫描功能。开启此功能后，Spring 会自动从扫描指定的包（base-package 属性设置）及其子包下的所有类，如果类上使用了 @Component 注解，就将该类装配到容器中。 1234567891011&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;!--开启组件扫描功能--&gt; &lt;context:component-scan base-package=&quot;com.atguigu.spring6&quot;&gt;&lt;/context:component-scan&gt;&lt;/beans&gt; 注意：在使用 context:component-scan 元素开启自动扫描功能前，首先需要在 XML 配置的一级标签 中添加 context 相关的约束。 情况一：最基本的扫描方式 12&lt;context:component-scan base-package=&quot;com.atguigu.spring6&quot;&gt;&lt;/context:component-scan&gt; 情况二：指定要排除的组件 12345678910&lt;context:component-scan base-package=&quot;com.atguigu.spring6&quot;&gt; &lt;!-- context:exclude-filter标签：指定排除规则 --&gt; &lt;!-- type：设置排除或包含的依据 type=&quot;annotation&quot;，根据注解排除，expression中设置要排除的注解的全类名 type=&quot;assignable&quot;，根据类型排除，expression中设置要排除的类型的全类名 --&gt; &lt;context:exclude-filter type=&quot;annotation&quot; expression=&quot;org.springframework.stereotype.Controller&quot;/&gt; &lt;!--&lt;context:exclude-filter type=&quot;assignable&quot; expression=&quot;com.atguigu.spring6.controller.UserController&quot;/&gt;--&gt;&lt;/context:component-scan&gt; 情况三：仅扫描指定组件 123456789101112&lt;context:component-scan base-package=&quot;com.atguigu&quot; use-default-filters=&quot;false&quot;&gt; &lt;!-- context:include-filter标签：指定在原有扫描规则的基础上追加的规则 --&gt; &lt;!-- use-default-filters属性：取值false表示关闭默认扫描规则 --&gt; &lt;!-- 此时必须设置use-default-filters=&quot;false&quot;，因为默认规则即扫描指定包下所有类 --&gt; &lt;!-- type：设置排除或包含的依据 type=&quot;annotation&quot;，根据注解排除，expression中设置要排除的注解的全类名 type=&quot;assignable&quot;，根据类型排除，expression中设置要排除的类型的全类名 --&gt; &lt;context:include-filter type=&quot;annotation&quot; expression=&quot;org.springframework.stereotype.Controller&quot;/&gt; &lt;!--&lt;context:include-filter type=&quot;assignable&quot; expression=&quot;com.atguigu.spring6.controller.UserController&quot;/&gt;--&gt;&lt;/context:component-scan&gt; 3.3.3、使用注解定义 BeanSpring 提供了以下多个注解，这些注解可以直接标注在 Java 类上，将它们定义成 Spring Bean。 注解 说明 @Component 该注解用于描述 Spring 中的 Bean，它是一个泛化的概念，仅仅表示容器中的一个组件（Bean），并且可以作用在应用的任何层次，例如 Service 层、Dao 层等。 使用时只需将该注解标注在相应类上即可。 @Repository 该注解用于将数据访问层（Dao 层）的类标识为 Spring 中的 Bean，其功能与 @Component 相同。 @Service 该注解通常作用在业务层（Service 层），用于将业务层的类标识为 Spring 中的 Bean，其功能与 @Component 相同。 @Controller 该注解通常作用在控制层（如SpringMVC 的 Controller），用于将控制层的类标识为 Spring 中的 Bean，其功能与 @Component 相同。 3.3.4、实验一：@Autowired注入单独使用@Autowired注解，默认根据类型装配。【默认是byType】 查看源码： 1234567891011121314package org.springframework.beans.factory.annotation;import java.lang.annotation.Documented;import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;@Target(&#123;ElementType.CONSTRUCTOR, ElementType.METHOD, ElementType.PARAMETER, ElementType.FIELD, ElementType.ANNOTATION_TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Documentedpublic @interface Autowired &#123; boolean required() default true;&#125; 源码中有两处需要注意： 第一处：该注解可以标注在哪里？ 构造方法上 方法上 形参上 属性上 注解上 第二处：该注解有一个required属性，默认值是true，表示在注入的时候要求被注入的Bean必须是存在的，如果不存在则报错。如果required属性设置为false，表示注入的Bean存在或者不存在都没关系，存在的话就注入，不存在的话，也不报错。 ①场景一：属性注入创建UserDao接口 123456package com.atguigu.spring6.dao;public interface UserDao &#123; public void print();&#125; 创建UserDaoImpl实现 12345678910111213package com.atguigu.spring6.dao.impl;import com.atguigu.spring6.dao.UserDao;import org.springframework.stereotype.Repository;@Repositorypublic class UserDaoImpl implements UserDao &#123; @Override public void print() &#123; System.out.println(&quot;Dao层执行结束&quot;); &#125;&#125; 创建UserService接口 123456package com.atguigu.spring6.service;public interface UserService &#123; public void out();&#125; 创建UserServiceImpl实现类 12345678910111213141516171819package com.atguigu.spring6.service.impl;import com.atguigu.spring6.dao.UserDao;import com.atguigu.spring6.service.UserService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;@Servicepublic class UserServiceImpl implements UserService &#123; @Autowired private UserDao userDao; @Override public void out() &#123; userDao.print(); System.out.println(&quot;Service层执行结束&quot;); &#125;&#125; 创建UserController类 123456789101112131415161718package com.atguigu.spring6.controller;import com.atguigu.spring6.service.UserService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;@Controllerpublic class UserController &#123; @Autowired private UserService userService; public void out() &#123; userService.out(); System.out.println(&quot;Controller层执行结束。&quot;); &#125;&#125; 测试一 1234567891011121314151617181920212223package com.atguigu.spring6.bean;import com.atguigu.spring6.controller.UserController;import org.junit.jupiter.api.Test;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class UserTest &#123; private Logger logger = LoggerFactory.getLogger(UserTest.class); @Test public void testAnnotation()&#123; ApplicationContext context = new ClassPathXmlApplicationContext(&quot;Beans.xml&quot;); UserController userController = context.getBean(&quot;userController&quot;, UserController.class); userController.out(); logger.info(&quot;执行成功&quot;); &#125;&#125; 测试结果： 以上构造方法和setter方法都没有提供，经过测试，仍然可以注入成功。 ②场景二：set注入修改UserServiceImpl类 1234567891011121314151617181920212223package com.atguigu.spring6.service.impl;import com.atguigu.spring6.dao.UserDao;import com.atguigu.spring6.service.UserService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;@Servicepublic class UserServiceImpl implements UserService &#123; private UserDao userDao; @Autowired public void setUserDao(UserDao userDao) &#123; this.userDao = userDao; &#125; @Override public void out() &#123; userDao.print(); System.out.println(&quot;Service层执行结束&quot;); &#125;&#125; 修改UserController类 12345678910111213141516171819202122package com.atguigu.spring6.controller;import com.atguigu.spring6.service.UserService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;@Controllerpublic class UserController &#123; private UserService userService; @Autowired public void setUserService(UserService userService) &#123; this.userService = userService; &#125; public void out() &#123; userService.out(); System.out.println(&quot;Controller层执行结束。&quot;); &#125;&#125; 测试：成功调用 ③场景三：构造方法注入修改UserServiceImpl类 1234567891011121314151617181920212223package com.atguigu.spring6.service.impl;import com.atguigu.spring6.dao.UserDao;import com.atguigu.spring6.service.UserService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;@Servicepublic class UserServiceImpl implements UserService &#123; private UserDao userDao; @Autowired public UserServiceImpl(UserDao userDao) &#123; this.userDao = userDao; &#125; @Override public void out() &#123; userDao.print(); System.out.println(&quot;Service层执行结束&quot;); &#125;&#125; 修改UserController类 12345678910111213141516171819202122package com.atguigu.spring6.controller;import com.atguigu.spring6.service.UserService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;@Controllerpublic class UserController &#123; private UserService userService; @Autowired public UserController(UserService userService) &#123; this.userService = userService; &#125; public void out() &#123; userService.out(); System.out.println(&quot;Controller层执行结束。&quot;); &#125;&#125; 测试：成功调用 ④场景四：形参上注入修改UserServiceImpl类 12345678910111213141516171819202122package com.atguigu.spring6.service.impl;import com.atguigu.spring6.dao.UserDao;import com.atguigu.spring6.service.UserService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;@Servicepublic class UserServiceImpl implements UserService &#123; private UserDao userDao; public UserServiceImpl(@Autowired UserDao userDao) &#123; this.userDao = userDao; &#125; @Override public void out() &#123; userDao.print(); System.out.println(&quot;Service层执行结束&quot;); &#125;&#125; 修改UserController类 123456789101112131415161718192021package com.atguigu.spring6.controller;import com.atguigu.spring6.service.UserService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;@Controllerpublic class UserController &#123; private UserService userService; public UserController(@Autowired UserService userService) &#123; this.userService = userService; &#125; public void out() &#123; userService.out(); System.out.println(&quot;Controller层执行结束。&quot;); &#125;&#125; 测试：成功调用 ⑤场景五：只有一个构造函数，无注解修改UserServiceImpl类 123456789101112131415161718192021222324package com.atguigu.spring6.service.impl;import com.atguigu.spring6.dao.UserDao;import com.atguigu.spring6.service.UserService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.beans.factory.annotation.Qualifier;import org.springframework.stereotype.Service;@Servicepublic class UserServiceImpl implements UserService &#123; @Autowired private UserDao userDao; public UserServiceImpl(UserDao userDao) &#123; this.userDao = userDao; &#125; @Override public void out() &#123; userDao.print(); System.out.println(&quot;Service层执行结束&quot;); &#125;&#125; 测试通过 当有参数的构造方法只有一个时，@Autowired注解可以省略。 说明：有多个构造方法时呢？大家可以测试（再添加一个无参构造函数），测试报错 ⑥场景六：@Autowired注解和@Qualifier注解联合添加dao层实现 12345678910111213package com.atguigu.spring6.dao.impl;import com.atguigu.spring6.dao.UserDao;import org.springframework.stereotype.Repository;@Repositorypublic class UserDaoRedisImpl implements UserDao &#123; @Override public void print() &#123; System.out.println(&quot;Redis Dao层执行结束&quot;); &#125;&#125; 测试：测试异常 错误信息中说：不能装配，UserDao这个Bean的数量等于2 怎么解决这个问题呢？当然要byName，根据名称进行装配了。 修改UserServiceImpl类 1234567891011121314151617181920package com.atguigu.spring6.service.impl;import com.atguigu.spring6.dao.UserDao;import com.atguigu.spring6.service.UserService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;@Servicepublic class UserServiceImpl implements UserService &#123; @Autowired @Qualifier(&quot;userDaoImpl&quot;) // 指定bean的名字 private UserDao userDao; @Override public void out() &#123; userDao.print(); System.out.println(&quot;Service层执行结束&quot;); &#125;&#125; 总结 @Autowired注解可以出现在：属性上、构造方法上、构造方法的参数上、setter方法上。 当带参数的构造方法只有一个，@Autowired注解可以省略。（） @Autowired注解默认根据类型注入。如果要根据名称注入的话，需要配合@Qualifier注解一起使用。 3.3.5、实验二：@Resource注入@Resource注解也可以完成属性注入。那它和@Autowired注解有什么区别？ @Resource注解是JDK扩展包中的，也就是说属于JDK的一部分。所以该注解是标准注解，更加具有通用性。(JSR-250标准中制定的注解类型。JSR是Java规范提案。) @Autowired注解是Spring框架自己的。 @Resource注解默认根据名称装配byName，未指定name时，使用属性名作为name。通过name找不到的话会自动启动通过类型byType装配。 @Autowired注解默认根据类型装配byType，如果想根据名称装配，需要配合@Qualifier注解一起用。 @Resource注解用在属性上、setter方法上。 @Autowired注解用在属性上、setter方法上、构造方法上、构造方法参数上。 @Resource注解属于JDK扩展包，所以不在JDK当中，需要额外引入以下依赖：【如果是JDK8的话不需要额外引入依赖。高于JDK11或低于JDK8需要引入以下依赖。】 12345&lt;dependency&gt; &lt;groupId&gt;jakarta.annotation&lt;/groupId&gt; &lt;artifactId&gt;jakarta.annotation-api&lt;/artifactId&gt; &lt;version&gt;2.1.1&lt;/version&gt;&lt;/dependency&gt; 源码： 12345678910111213141516171819202122232425262728293031323334package jakarta.annotation;import java.lang.annotation.ElementType;import java.lang.annotation.Repeatable;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;@Target(&#123;ElementType.TYPE, ElementType.FIELD, ElementType.METHOD&#125;)@Retention(RetentionPolicy.RUNTIME)@Repeatable(Resources.class)public @interface Resource &#123; String name() default &quot;&quot;; String lookup() default &quot;&quot;; Class&lt;?&gt; type() default Object.class; Resource.AuthenticationType authenticationType() default Resource.AuthenticationType.CONTAINER; boolean shareable() default true; String mappedName() default &quot;&quot;; String description() default &quot;&quot;; public static enum AuthenticationType &#123; CONTAINER, APPLICATION; private AuthenticationType() &#123; &#125; &#125;&#125; ①场景一：根据name注入修改UserDaoImpl类 12345678910111213package com.atguigu.spring6.dao.impl;import com.atguigu.spring6.dao.UserDao;import org.springframework.stereotype.Repository;@Repository(&quot;myUserDao&quot;)public class UserDaoImpl implements UserDao &#123; @Override public void print() &#123; System.out.println(&quot;Dao层执行结束&quot;); &#125;&#125; 修改UserServiceImpl类 123456789101112131415161718192021package com.atguigu.spring6.service.impl;import com.atguigu.spring6.dao.UserDao;import com.atguigu.spring6.service.UserService;import jakarta.annotation.Resource;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.beans.factory.annotation.Qualifier;import org.springframework.stereotype.Service;@Servicepublic class UserServiceImpl implements UserService &#123; @Resource(name = &quot;myUserDao&quot;) private UserDao myUserDao; @Override public void out() &#123; myUserDao.print(); System.out.println(&quot;Service层执行结束&quot;); &#125;&#125; 测试通过 ②场景二：name未知注入修改UserDaoImpl类 12345678910111213package com.atguigu.spring6.dao.impl;import com.atguigu.spring6.dao.UserDao;import org.springframework.stereotype.Repository;@Repository(&quot;myUserDao&quot;)public class UserDaoImpl implements UserDao &#123; @Override public void print() &#123; System.out.println(&quot;Dao层执行结束&quot;); &#125;&#125; 修改UserServiceImpl类 123456789101112131415161718192021package com.atguigu.spring6.service.impl;import com.atguigu.spring6.dao.UserDao;import com.atguigu.spring6.service.UserService;import jakarta.annotation.Resource;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.beans.factory.annotation.Qualifier;import org.springframework.stereotype.Service;@Servicepublic class UserServiceImpl implements UserService &#123; @Resource private UserDao myUserDao; @Override public void out() &#123; myUserDao.print(); System.out.println(&quot;Service层执行结束&quot;); &#125;&#125; 测试通过 当@Resource注解使用时没有指定name的时候，还是根据name进行查找，这个name是属性名。 ③场景三 其他情况修改UserServiceImpl类，userDao1属性名不存在 123456789101112131415161718192021package com.atguigu.spring6.service.impl;import com.atguigu.spring6.dao.UserDao;import com.atguigu.spring6.service.UserService;import jakarta.annotation.Resource;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.beans.factory.annotation.Qualifier;import org.springframework.stereotype.Service;@Servicepublic class UserServiceImpl implements UserService &#123; @Resource private UserDao userDao1; @Override public void out() &#123; userDao1.print(); System.out.println(&quot;Service层执行结束&quot;); &#125;&#125; 测试异常 根据异常信息得知：显然当通过name找不到的时候，自然会启动byType进行注入，以上的错误是因为UserDao接口下有两个实现类导致的。所以根据类型注入就会报错。 @Resource的set注入可以自行测试 总结： @Resource注解：默认byName注入，没有指定name时把属性名当做name，根据name找不到时，才会byType注入。byType注入时，某种类型的Bean只能有一个 3.3.6、Spring全注解开发全注解开发就是不再使用spring配置文件了，写一个配置类来代替配置文件。 12345678910package com.atguigu.spring6.config;import org.springframework.context.annotation.ComponentScan;import org.springframework.context.annotation.Configuration;@Configuration//@ComponentScan(&#123;&quot;com.atguigu.spring6.controller&quot;, &quot;com.atguigu.spring6.service&quot;,&quot;com.atguigu.spring6.dao&quot;&#125;)@ComponentScan(&quot;com.atguigu.spring6&quot;)public class Spring6Config &#123;&#125; 测试类 1234567@Testpublic void testAllAnnotation()&#123; ApplicationContext context = new AnnotationConfigApplicationContext(Spring6Config.class); UserController userController = context.getBean(&quot;userController&quot;, UserController.class); userController.out(); logger.info(&quot;执行成功&quot;);&#125; 4、原理-手写IoC我们都知道，Spring框架的IOC是基于Java反射机制实现的，下面我们先回顾一下java反射。 4.1、回顾Java反射Java反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性；这种动态获取信息以及动态调用对象方法的功能称为Java语言的反射机制。简单来说，反射机制指的是程序在运行时能够获取自身的信息。 要想解剖一个类，必须先要获取到该类的Class对象。而剖析一个类或用反射解决具体的问题就是使用相关API（1）java.lang.Class（2）java.lang.reflect，所以，Class对象是反射的根源。 自定义类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package com.atguigu.reflect;public class Car &#123; //属性 private String name; private int age; private String color; //无参数构造 public Car() &#123; &#125; //有参数构造 public Car(String name, int age, String color) &#123; this.name = name; this.age = age; this.color = color; &#125; //普通方法 private void run() &#123; System.out.println(&quot;私有方法-run.....&quot;); &#125; //get和set方法 public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public String getColor() &#123; return color; &#125; public void setColor(String color) &#123; this.color = color; &#125; @Override public String toString() &#123; return &quot;Car&#123;&quot; + &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, age=&quot; + age + &quot;, color=&#x27;&quot; + color + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125;&#125; 编写测试类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899package com.atguigu.reflect;import org.junit.jupiter.api.Test;import java.lang.reflect.Constructor;import java.lang.reflect.Field;import java.lang.reflect.Method;public class TestCar &#123; //1、获取Class对象多种方式 @Test public void test01() throws Exception &#123; //1 类名.class Class clazz1 = Car.class; //2 对象.getClass() Class clazz2 = new Car().getClass(); //3 Class.forName(&quot;全路径&quot;) Class clazz3 = Class.forName(&quot;com.atguigu.reflect.Car&quot;); //实例化 Car car = (Car)clazz3.getConstructor().newInstance(); System.out.println(car); &#125; //2、获取构造方法 @Test public void test02() throws Exception &#123; Class clazz = Car.class; //获取所有构造 // getConstructors()获取所有public的构造方法// Constructor[] constructors = clazz.getConstructors(); // getDeclaredConstructors()获取所有的构造方法public private Constructor[] constructors = clazz.getDeclaredConstructors(); for (Constructor c:constructors) &#123; System.out.println(&quot;方法名称：&quot;+c.getName()+&quot; 参数个数：&quot;+c.getParameterCount()); &#125; //指定有参数构造创建对象 //1 构造public// Constructor c1 = clazz.getConstructor(String.class, int.class, String.class);// Car car1 = (Car)c1.newInstance(&quot;夏利&quot;, 10, &quot;红色&quot;);// System.out.println(car1); //2 构造private Constructor c2 = clazz.getDeclaredConstructor(String.class, int.class, String.class); c2.setAccessible(true); Car car2 = (Car)c2.newInstance(&quot;捷达&quot;, 15, &quot;白色&quot;); System.out.println(car2); &#125; //3、获取属性 @Test public void test03() throws Exception &#123; Class clazz = Car.class; Car car = (Car)clazz.getDeclaredConstructor().newInstance(); //获取所有public属性 //Field[] fields = clazz.getFields(); //获取所有属性（包含私有属性） Field[] fields = clazz.getDeclaredFields(); for (Field field:fields) &#123; if(field.getName().equals(&quot;name&quot;)) &#123; //设置允许访问 field.setAccessible(true); field.set(car,&quot;五菱宏光&quot;); System.out.println(car); &#125; System.out.println(field.getName()); &#125; &#125; //4、获取方法 @Test public void test04() throws Exception &#123; Car car = new Car(&quot;奔驰&quot;,10,&quot;黑色&quot;); Class clazz = car.getClass(); //1 public方法 Method[] methods = clazz.getMethods(); for (Method m1:methods) &#123; //System.out.println(m1.getName()); //执行方法 toString if(m1.getName().equals(&quot;toString&quot;)) &#123; String invoke = (String)m1.invoke(car); //System.out.println(&quot;toString执行了：&quot;+invoke); &#125; &#125; //2 private方法 Method[] methodsAll = clazz.getDeclaredMethods(); for (Method m:methodsAll) &#123; //执行方法 run if(m.getName().equals(&quot;run&quot;)) &#123; m.setAccessible(true); m.invoke(car); &#125; &#125; &#125;&#125; 4.2、实现Spring的IoC我们知道，IoC（控制反转）和DI（依赖注入）是Spring里面核心的东西，那么，我们如何自己手写出这样的代码呢？下面我们就一步一步写出Spring框架最核心的部分。 ①搭建子模块 搭建模块：guigu-spring，搭建方式如其他spring子模块 ②准备测试需要的bean 添加依赖 12345678&lt;dependencies&gt; &lt;!--junit5测试--&gt; &lt;dependency&gt; &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt; &lt;artifactId&gt;junit-jupiter-api&lt;/artifactId&gt; &lt;version&gt;5.3.1&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 创建UserDao接口 123456package com.atguigu.spring6.test.dao;public interface UserDao &#123; public void print();&#125; 创建UserDaoImpl实现 123456789101112package com.atguigu.spring6.test.dao.impl;import com.atguigu.spring.dao.UserDao;public class UserDaoImpl implements UserDao &#123; @Override public void print() &#123; System.out.println(&quot;Dao层执行结束&quot;); &#125;&#125; 创建UserService接口 123456package com.atguigu.spring6.test.service;public interface UserService &#123; public void out();&#125; 创建UserServiceImpl实现类 1234567891011121314151617package com.atguigu.spring.test.service.impl;import com.atguigu.spring.core.annotation.Bean;import com.atguigu.spring.service.UserService;@Beanpublic class UserServiceImpl implements UserService &#123;// private UserDao userDao; @Override public void out() &#123; //userDao.print(); System.out.println(&quot;Service层执行结束&quot;); &#125;&#125; ③定义注解 我们通过注解的形式加载bean与实现依赖注入 bean注解 1234567891011package com.atguigu.spring.core.annotation;import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)public @interface Bean &#123;&#125; 依赖注入注解 1234567891011package com.atguigu.spring.core.annotation;import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;@Target(&#123;ElementType.FIELD&#125;)@Retention(RetentionPolicy.RUNTIME)public @interface Di &#123;&#125; 说明：上面两个注解可以随意取名 ④定义bean容器接口 123456package com.atguigu.spring.core;public interface ApplicationContext &#123; Object getBean(Class clazz);&#125; ⑤编写注解bean容器接口实现 AnnotationApplicationContext基于注解扫描bean 12345678910111213141516171819202122package com.atguigu.spring.core;import java.util.HashMap;public class AnnotationApplicationContext implements ApplicationContext &#123; //存储bean的容器 private HashMap&lt;Class, Object&gt; beanFactory = new HashMap&lt;&gt;(); @Override public Object getBean(Class clazz) &#123; return beanFactory.get(clazz); &#125; /** * 根据包扫描加载bean * @param basePackage */ public AnnotationApplicationContext(String basePackage) &#123; &#125;&#125; ⑥编写扫描bean逻辑 我们通过构造方法传入包的base路径，扫描被@Bean注解的java对象，完整代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485package com.atguigu.spring.core;import com.atguigu.spring.core.annotation.Bean;import java.io.File;import java.util.HashMap;public class AnnotationApplicationContext implements ApplicationContext &#123; //存储bean的容器 private HashMap&lt;Class, Object&gt; beanFactory = new HashMap&lt;&gt;(); private static String rootPath; @Override public Object getBean(Class clazz) &#123; return beanFactory.get(clazz); &#125; /** * 根据包扫描加载bean * @param basePackage */ public AnnotationApplicationContext(String basePackage) &#123; try &#123; String packageDirName = basePackage.replaceAll(&quot;\\\\.&quot;, &quot;\\\\\\\\&quot;); Enumeration&lt;URL&gt; dirs =Thread.currentThread().getContextClassLoader().getResources(packageDirName); while (dirs.hasMoreElements()) &#123; URL url = dirs.nextElement(); String filePath = URLDecoder.decode(url.getFile(),&quot;utf-8&quot;); rootPath = filePath.substring(0, filePath.length()-packageDirName.length()); loadBean(new File(filePath)); &#125; &#125; catch (Exception e) &#123; throw new RuntimeException(e); &#125; &#125; private void loadBean(File fileParent) &#123; if (fileParent.isDirectory()) &#123; File[] childrenFiles = fileParent.listFiles(); if(childrenFiles == null || childrenFiles.length == 0)&#123; return; &#125; for (File child : childrenFiles) &#123; if (child.isDirectory()) &#123; //如果是个文件夹就继续调用该方法,使用了递归 loadBean(child); &#125; else &#123; //通过文件路径转变成全类名,第一步把绝对路径部分去掉 String pathWithClass = child.getAbsolutePath().substring(rootPath.length() - 1); //选中class文件 if (pathWithClass.contains(&quot;.class&quot;)) &#123; // com.xinzhi.dao.UserDao //去掉.class后缀，并且把 \\ 替换成 . String fullName = pathWithClass.replaceAll(&quot;\\\\\\\\&quot;, &quot;.&quot;).replace(&quot;.class&quot;, &quot;&quot;); try &#123; Class&lt;?&gt; aClass = Class.forName(fullName); //把非接口的类实例化放在map中 if(!aClass.isInterface())&#123; Bean annotation = aClass.getAnnotation(Bean.class); if(annotation != null)&#123; Object instance = aClass.newInstance(); //判断一下有没有接口 if(aClass.getInterfaces().length &gt; 0) &#123; //如果有接口把接口的class当成key，实例对象当成value System.out.println(&quot;正在加载【&quot;+ aClass.getInterfaces()[0] +&quot;】,实例对象是：&quot; + instance.getClass().getName()); beanFactory.put(aClass.getInterfaces()[0], instance); &#125;else&#123; //如果有接口把自己的class当成key，实例对象当成value System.out.println(&quot;正在加载【&quot;+ aClass.getName() +&quot;】,实例对象是：&quot; + instance.getClass().getName()); beanFactory.put(aClass, instance); &#125; &#125; &#125; &#125; catch (ClassNotFoundException | IllegalAccessException | InstantiationException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; &#125; &#125;&#125; ⑦java类标识Bean注解 12@Beanpublic class UserServiceImpl implements UserService 12@Beanpublic class UserDaoImpl implements UserDao ⑧测试Bean加载 1234567891011121314151617package com.atguigu.spring;import com.atguigu.spring.core.AnnotationApplicationContext;import com.atguigu.spring.core.ApplicationContext;import com.atguigu.spring.test.service.UserService;import org.junit.jupiter.api.Test;public class SpringIocTest &#123; @Test public void testIoc() &#123; ApplicationContext applicationContext = new AnnotationApplicationContext(&quot;com.atguigu.spring.test&quot;); UserService userService = (UserService)applicationContext.getBean(UserService.class); userService.out(); System.out.println(&quot;run success&quot;); &#125;&#125; 控制台打印测试 ⑨依赖注入 只要userDao.print();调用成功，说明就注入成功 12345678910111213141516171819package com.atguigu.spring.test.service.impl;import com.atguigu.spring.core.annotation.Bean;import com.atguigu.spring.core.annotation.Di;import com.atguigu.spring.dao.UserDao;import com.atguigu.spring.service.UserService;@Beanpublic class UserServiceImpl implements UserService &#123; @Di private UserDao userDao; @Override public void out() &#123; userDao.print(); System.out.println(&quot;Service层执行结束&quot;); &#125;&#125; 执行第八步：报错了，说明当前userDao是个空对象 ⑩依赖注入实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112package com.atguigu.spring.core;import com.atguigu.spring.core.annotation.Bean;import com.atguigu.spring.core.annotation.Di;import java.io.File;import java.lang.reflect.Field;import java.util.HashMap;import java.util.Map;public class AnnotationApplicationContext implements ApplicationContext &#123; //存储bean的容器 private HashMap&lt;Class, Object&gt; beanFactory = new HashMap&lt;&gt;(); private static String rootPath; @Override public Object getBean(Class clazz) &#123; return beanFactory.get(clazz); &#125; /** * 根据包扫描加载bean * @param basePackage */ public AnnotationApplicationContext(String basePackage) &#123; try &#123; String packageDirName = basePackage.replaceAll(&quot;\\\\.&quot;, &quot;\\\\\\\\&quot;); Enumeration&lt;URL&gt; dirs =Thread.currentThread().getContextClassLoader().getResources(packageDirName); while (dirs.hasMoreElements()) &#123; URL url = dirs.nextElement(); String filePath = URLDecoder.decode(url.getFile(),&quot;utf-8&quot;); rootPath = filePath.substring(0, filePath.length()-packageDirName.length()); loadBean(new File(filePath)); &#125; &#125; catch (Exception e) &#123; throw new RuntimeException(e); &#125; //依赖注入 loadDi(); &#125; private void loadBean(File fileParent) &#123; if (fileParent.isDirectory()) &#123; File[] childrenFiles = fileParent.listFiles(); if(childrenFiles == null || childrenFiles.length == 0)&#123; return; &#125; for (File child : childrenFiles) &#123; if (child.isDirectory()) &#123; //如果是个文件夹就继续调用该方法,使用了递归 loadBean(child); &#125; else &#123; //通过文件路径转变成全类名,第一步把绝对路径部分去掉 String pathWithClass = child.getAbsolutePath().substring(rootPath.length() - 1); //选中class文件 if (pathWithClass.contains(&quot;.class&quot;)) &#123; // com.xinzhi.dao.UserDao //去掉.class后缀，并且把 \\ 替换成 . String fullName = pathWithClass.replaceAll(&quot;\\\\\\\\&quot;, &quot;.&quot;).replace(&quot;.class&quot;, &quot;&quot;); try &#123; Class&lt;?&gt; aClass = Class.forName(fullName); //把非接口的类实例化放在map中 if(!aClass.isInterface())&#123; Bean annotation = aClass.getAnnotation(Bean.class); if(annotation != null)&#123; Object instance = aClass.newInstance(); //判断一下有没有接口 if(aClass.getInterfaces().length &gt; 0) &#123; //如果有接口把接口的class当成key，实例对象当成value System.out.println(&quot;正在加载【&quot;+ aClass.getInterfaces()[0] +&quot;】,实例对象是：&quot; + instance.getClass().getName()); beanFactory.put(aClass.getInterfaces()[0], instance); &#125;else&#123; //如果有接口把自己的class当成key，实例对象当成value System.out.println(&quot;正在加载【&quot;+ aClass.getName() +&quot;】,实例对象是：&quot; + instance.getClass().getName()); beanFactory.put(aClass, instance); &#125; &#125; &#125; &#125; catch (ClassNotFoundException | IllegalAccessException | InstantiationException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; &#125; &#125; private void loadDi() &#123; for(Map.Entry&lt;Class,Object&gt; entry : beanFactory.entrySet())&#123; //就是咱们放在容器的对象 Object obj = entry.getValue(); Class&lt;?&gt; aClass = obj.getClass(); Field[] declaredFields = aClass.getDeclaredFields(); for (Field field : declaredFields)&#123; Di annotation = field.getAnnotation(Di.class); if( annotation != null )&#123; field.setAccessible(true); try &#123; System.out.println(&quot;正在给【&quot;+obj.getClass().getName()+&quot;】属性【&quot; + field.getName() + &quot;】注入值【&quot;+ beanFactory.get(field.getType()).getClass().getName() +&quot;】&quot;); field.set(obj,beanFactory.get(field.getType())); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; &#125;&#125; 执行第八步：执行成功，依赖注入成功 5、面向切面：AOP5.1、场景模拟搭建子模块：spring6-aop 5.1.1、声明接口声明计算器接口Calculator，包含加减乘除的抽象方法 1234567891011public interface Calculator &#123; int add(int i, int j); int sub(int i, int j); int mul(int i, int j); int div(int i, int j); &#125; 5.1.2、创建实现类 123456789101112131415161718192021222324252627282930313233343536373839404142public class CalculatorImpl implements Calculator &#123; @Override public int add(int i, int j) &#123; int result = i + j; System.out.println(&quot;方法内部 result = &quot; + result); return result; &#125; @Override public int sub(int i, int j) &#123; int result = i - j; System.out.println(&quot;方法内部 result = &quot; + result); return result; &#125; @Override public int mul(int i, int j) &#123; int result = i * j; System.out.println(&quot;方法内部 result = &quot; + result); return result; &#125; @Override public int div(int i, int j) &#123; int result = i / j; System.out.println(&quot;方法内部 result = &quot; + result); return result; &#125;&#125; 5.1.3、创建带日志功能的实现类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public class CalculatorLogImpl implements Calculator &#123; @Override public int add(int i, int j) &#123; System.out.println(&quot;[日志] add 方法开始了，参数是：&quot; + i + &quot;,&quot; + j); int result = i + j; System.out.println(&quot;方法内部 result = &quot; + result); System.out.println(&quot;[日志] add 方法结束了，结果是：&quot; + result); return result; &#125; @Override public int sub(int i, int j) &#123; System.out.println(&quot;[日志] sub 方法开始了，参数是：&quot; + i + &quot;,&quot; + j); int result = i - j; System.out.println(&quot;方法内部 result = &quot; + result); System.out.println(&quot;[日志] sub 方法结束了，结果是：&quot; + result); return result; &#125; @Override public int mul(int i, int j) &#123; System.out.println(&quot;[日志] mul 方法开始了，参数是：&quot; + i + &quot;,&quot; + j); int result = i * j; System.out.println(&quot;方法内部 result = &quot; + result); System.out.println(&quot;[日志] mul 方法结束了，结果是：&quot; + result); return result; &#125; @Override public int div(int i, int j) &#123; System.out.println(&quot;[日志] div 方法开始了，参数是：&quot; + i + &quot;,&quot; + j); int result = i / j; System.out.println(&quot;方法内部 result = &quot; + result); System.out.println(&quot;[日志] div 方法结束了，结果是：&quot; + result); return result; &#125;&#125; 5.1.4、提出问题①现有代码缺陷 针对带日志功能的实现类，我们发现有如下缺陷： 对核心业务功能有干扰，导致程序员在开发核心业务功能时分散了精力 附加功能分散在各个业务功能方法中，不利于统一维护 ②解决思路 解决这两个问题，核心就是：解耦。我们需要把附加功能从业务功能代码中抽取出来。 ③困难 解决问题的困难：要抽取的代码在方法内部，靠以前把子类中的重复代码抽取到父类的方式没法解决。所以需要引入新的技术。 5.2、代理模式5.2.1、概念①介绍 二十三种设计模式中的一种，属于结构型模式。它的作用就是通过提供一个代理类，让我们在调用目标方法的时候，不再是直接对目标方法进行调用，而是通过代理类间接调用。让不属于目标方法核心逻辑的代码从目标方法中剥离出来——解耦。调用目标方法时先调用代理对象的方法，减少对目标方法的调用和打扰，同时让附加功能能够集中在一起也有利于统一维护。 使用代理后： ②生活中的代理 广告商找大明星拍广告需要经过经纪人 合作伙伴找大老板谈合作要约见面时间需要经过秘书 房产中介是买卖双方的代理 ③相关术语 代理：将非核心逻辑剥离出来以后，封装这些非核心逻辑的类、对象、方法。 目标：被代理“套用”了非核心逻辑代码的类、对象、方法。 5.2.2、静态代理创建静态代理类： 1234567891011121314151617181920212223public class CalculatorStaticProxy implements Calculator &#123; // 将被代理的目标对象声明为成员变量 private Calculator target; public CalculatorStaticProxy(Calculator target) &#123; this.target = target; &#125; @Override public int add(int i, int j) &#123; // 附加功能由代理类中的代理方法来实现 System.out.println(&quot;[日志] add 方法开始了，参数是：&quot; + i + &quot;,&quot; + j); // 通过目标对象来实现核心业务逻辑 int addResult = target.add(i, j); System.out.println(&quot;[日志] add 方法结束了，结果是：&quot; + addResult); return addResult; &#125;&#125; 静态代理确实实现了解耦，但是由于代码都写死了，完全不具备任何的灵活性。就拿日志功能来说，将来其他地方也需要附加日志，那还得再声明更多个静态代理类，那就产生了大量重复的代码，日志功能还是分散的，没有统一管理。 提出进一步的需求：将日志功能集中到一个代理类中，将来有任何日志需求，都通过这一个代理类来实现。这就需要使用动态代理技术了。 5.2.3、动态代理 生产代理对象的工厂类： 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class ProxyFactory &#123; private Object target; public ProxyFactory(Object target) &#123; this.target = target; &#125; public Object getProxy()&#123; /** * newProxyInstance()：创建一个代理实例 * 其中有三个参数： * 1、classLoader：加载动态生成的代理类的类加载器 * 2、interfaces：目标对象实现的所有接口的class对象所组成的数组 * 3、invocationHandler：设置代理对象实现目标对象方法的过程，即代理类中如何重写接口中的抽象方法 */ ClassLoader classLoader = target.getClass().getClassLoader(); Class&lt;?&gt;[] interfaces = target.getClass().getInterfaces(); InvocationHandler invocationHandler = new InvocationHandler() &#123; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; /** * proxy：代理对象 * method：代理对象需要实现的方法，即其中需要重写的方法 * args：method所对应方法的参数 */ Object result = null; try &#123; System.out.println(&quot;[动态代理][日志] &quot;+method.getName()+&quot;，参数：&quot;+ Arrays.toString(args)); result = method.invoke(target, args); System.out.println(&quot;[动态代理][日志] &quot;+method.getName()+&quot;，结果：&quot;+ result); &#125; catch (Exception e) &#123; e.printStackTrace(); System.out.println(&quot;[动态代理][日志] &quot;+method.getName()+&quot;，异常：&quot;+e.getMessage()); &#125; finally &#123; System.out.println(&quot;[动态代理][日志] &quot;+method.getName()+&quot;，方法执行完毕&quot;); &#125; return result; &#125; &#125;; return Proxy.newProxyInstance(classLoader, interfaces, invocationHandler); &#125;&#125; 5.2.4、测试1234567@Testpublic void testDynamicProxy()&#123; ProxyFactory factory = new ProxyFactory(new CalculatorLogImpl()); Calculator proxy = (Calculator) factory.getProxy(); proxy.div(1,0); //proxy.div(1,1);&#125; 5.3、AOP概念及相关术语5.3.1、概述AOP（Aspect Oriented Programming）是一种设计思想，是软件设计领域中的面向切面编程，它是面向对象编程的一种补充和完善，它以通过预编译方式和运行期动态代理方式实现，在不修改源代码的情况下，给程序动态统一添加额外功能的一种技术。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。 5.3.2、相关术语①横切关注点分散在每个各个模块中解决同一样的问题，如用户验证、日志管理、事务处理、数据缓存都属于横切关注点。 从每个方法中抽取出来的同一类非核心业务。在同一个项目中，我们可以使用多个横切关注点对相关方法进行多个不同方面的增强。 这个概念不是语法层面的，而是根据附加功能的逻辑上的需要：有十个附加功能，就有十个横切关注点。 ②通知（增强）增强，通俗说，就是你想要增强的功能，比如 安全，事务，日志等。 每一个横切关注点上要做的事情都需要写一个方法来实现，这样的方法就叫通知方法。 前置通知：在被代理的目标方法前执行 返回通知：在被代理的目标方法成功结束后执行（寿终正寝） 异常通知：在被代理的目标方法异常结束后执行（死于非命） 后置通知：在被代理的目标方法最终结束后执行（盖棺定论） 环绕通知：使用try…catch…finally结构围绕整个被代理的目标方法，包括上面四种通知对应的所有位置 ③切面封装通知方法的类。 ④目标被代理的目标对象。 ⑤代理向目标对象应用通知之后创建的代理对象。 ⑥连接点这也是一个纯逻辑概念，不是语法定义的。 把方法排成一排，每一个横切位置看成x轴方向，把方法从上到下执行的顺序看成y轴，x轴和y轴的交叉点就是连接点。通俗说，就是spring允许你使用通知的地方 ⑦切入点定位连接点的方式。 每个类的方法中都包含多个连接点，所以连接点是类中客观存在的事物（从逻辑上来说）。 如果把连接点看作数据库中的记录，那么切入点就是查询记录的 SQL 语句。 Spring 的 AOP 技术可以通过切入点定位到特定的连接点。通俗说，要实际去增强的方法 切点通过 org.springframework.aop.Pointcut 接口进行描述，它使用类和方法作为连接点的查询条件。 5.3.3、作用 简化代码：把方法中固定位置的重复的代码抽取出来，让被抽取的方法更专注于自己的核心功能，提高内聚性。 代码增强：把特定的功能封装到切面类中，看哪里有需要，就往上套，被套用了切面逻辑的方法就被切面给增强了。 5.4、基于注解的AOP5.4.1、技术说明 动态代理分为JDK动态代理和cglib动态代理 当目标类有接口的情况使用JDK动态代理和cglib动态代理，没有接口时只能使用cglib动态代理 JDK动态代理动态生成的代理类会在com.sun.proxy包下，类名为$proxy1，和目标类实现相同的接口 cglib动态代理动态生成的代理类会和目标在在相同的包下，会继承目标类 动态代理（InvocationHandler）：JDK原生的实现方式，需要被代理的目标类必须实现接口。因为这个技术要求代理对象和目标对象实现同样的接口（兄弟两个拜把子模式）。 cglib：通过继承被代理的目标类（认干爹模式）实现代理，所以不需要目标类实现接口。 AspectJ：是AOP思想的一种实现。本质上是静态代理，将代理逻辑“织入”被代理的目标类编译得到的字节码文件，所以最终效果是动态的。weaver就是织入器。Spring只是借用了AspectJ中的注解。 5.4.2、准备工作①添加依赖 在IOC所需依赖基础上再加入下面依赖即可： 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;dependencies&gt; &lt;!--spring context依赖--&gt; &lt;!--当你引入Spring Context依赖之后，表示将Spring的基础依赖引入了--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;6.0.2&lt;/version&gt; &lt;/dependency&gt; &lt;!--spring aop依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;version&gt;6.0.2&lt;/version&gt; &lt;/dependency&gt; &lt;!--spring aspects依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt; &lt;version&gt;6.0.2&lt;/version&gt; &lt;/dependency&gt; &lt;!--junit5测试--&gt; &lt;dependency&gt; &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt; &lt;artifactId&gt;junit-jupiter-api&lt;/artifactId&gt; &lt;version&gt;5.3.1&lt;/version&gt; &lt;/dependency&gt; &lt;!--log4j2的依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j-core&lt;/artifactId&gt; &lt;version&gt;2.19.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j-slf4j2-impl&lt;/artifactId&gt; &lt;version&gt;2.19.0&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; ②准备被代理的目标资源 接口： 1234567891011public interface Calculator &#123; int add(int i, int j); int sub(int i, int j); int mul(int i, int j); int div(int i, int j); &#125; 实现类： 12345678910111213141516171819202122232425262728293031323334353637383940414243@Componentpublic class CalculatorImpl implements Calculator &#123; @Override public int add(int i, int j) &#123; int result = i + j; System.out.println(&quot;方法内部 result = &quot; + result); return result; &#125; @Override public int sub(int i, int j) &#123; int result = i - j; System.out.println(&quot;方法内部 result = &quot; + result); return result; &#125; @Override public int mul(int i, int j) &#123; int result = i * j; System.out.println(&quot;方法内部 result = &quot; + result); return result; &#125; @Override public int div(int i, int j) &#123; int result = i / j; System.out.println(&quot;方法内部 result = &quot; + result); return result; &#125;&#125; 5.4.3、创建切面类并配置123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// @Aspect表示这个类是一个切面类@Aspect// @Component注解保证这个切面类能够放入IOC容器@Componentpublic class LogAspect &#123; @Before(&quot;execution(public int com.atguigu.aop.annotation.CalculatorImpl.*(..))&quot;) public void beforeMethod(JoinPoint joinPoint)&#123; String methodName = joinPoint.getSignature().getName(); String args = Arrays.toString(joinPoint.getArgs()); System.out.println(&quot;Logger--&gt;前置通知，方法名：&quot;+methodName+&quot;，参数：&quot;+args); &#125; @After(&quot;execution(* com.atguigu.aop.annotation.CalculatorImpl.*(..))&quot;) public void afterMethod(JoinPoint joinPoint)&#123; String methodName = joinPoint.getSignature().getName(); System.out.println(&quot;Logger--&gt;后置通知，方法名：&quot;+methodName); &#125; @AfterReturning(value = &quot;execution(* com.atguigu.aop.annotation.CalculatorImpl.*(..))&quot;, returning = &quot;result&quot;) public void afterReturningMethod(JoinPoint joinPoint, Object result)&#123; String methodName = joinPoint.getSignature().getName(); System.out.println(&quot;Logger--&gt;返回通知，方法名：&quot;+methodName+&quot;，结果：&quot;+result); &#125; @AfterThrowing(value = &quot;execution(* com.atguigu.aop.annotation.CalculatorImpl.*(..))&quot;, throwing = &quot;ex&quot;) public void afterThrowingMethod(JoinPoint joinPoint, Throwable ex)&#123; String methodName = joinPoint.getSignature().getName(); System.out.println(&quot;Logger--&gt;异常通知，方法名：&quot;+methodName+&quot;，异常：&quot;+ex); &#125; @Around(&quot;execution(* com.atguigu.aop.annotation.CalculatorImpl.*(..))&quot;) public Object aroundMethod(ProceedingJoinPoint joinPoint)&#123; String methodName = joinPoint.getSignature().getName(); String args = Arrays.toString(joinPoint.getArgs()); Object result = null; try &#123; System.out.println(&quot;环绕通知--&gt;目标对象方法执行之前&quot;); //目标对象（连接点）方法的执行 result = joinPoint.proceed(); System.out.println(&quot;环绕通知--&gt;目标对象方法返回值之后&quot;); &#125; catch (Throwable throwable) &#123; throwable.printStackTrace(); System.out.println(&quot;环绕通知--&gt;目标对象方法出现异常时&quot;); &#125; finally &#123; System.out.println(&quot;环绕通知--&gt;目标对象方法执行完毕&quot;); &#125; return result; &#125; &#125; 在Spring的配置文件中配置： 123456789101112131415161718192021&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt; &lt;!-- 基于注解的AOP的实现： 1、将目标对象和切面交给IOC容器管理（注解+扫描） 2、开启AspectJ的自动代理，为目标对象自动生成代理 3、将切面类通过注解@Aspect标识 --&gt; &lt;context:component-scan base-package=&quot;com.atguigu.aop.annotation&quot;&gt;&lt;/context:component-scan&gt; &lt;aop:aspectj-autoproxy /&gt;&lt;/beans&gt; 执行测试： 12345678910111213public class CalculatorTest &#123; private Logger logger = LoggerFactory.getLogger(CalculatorTest.class); @Test public void testAdd()&#123; ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;); Calculator calculator = ac.getBean( Calculator.class); int add = calculator.add(1, 1); logger.info(&quot;执行成功:&quot;+add); &#125;&#125; 执行结果： 5.4.4、各种通知 前置通知：使用@Before注解标识，在被代理的目标方法前执行 返回通知：使用@AfterReturning注解标识，在被代理的目标方法成功结束后执行（寿终正寝） 异常通知：使用@AfterThrowing注解标识，在被代理的目标方法异常结束后执行（死于非命） 后置通知：使用@After注解标识，在被代理的目标方法最终结束后执行（盖棺定论） 环绕通知：使用@Around注解标识，使用try…catch…finally结构围绕整个被代理的目标方法，包括上面四种通知对应的所有位置 各种通知的执行顺序： Spring版本5.3.x以前： 前置通知 目标操作 后置通知 返回通知或异常通知 Spring版本5.3.x以后： 前置通知 目标操作 返回通知或异常通知 后置通知 5.4.5、切入点表达式语法①作用 ②语法细节 用*号代替“权限修饰符”和“返回值”部分表示“权限修饰符”和“返回值”不限 在包名的部分，一个“*”号只能代表包的层次结构中的一层，表示这一层是任意的。 例如：*.Hello匹配com.Hello，不匹配com.atguigu.Hello 在包名的部分，使用“*..”表示包名任意、包的层次深度任意 在类名的部分，类名部分整体用*号代替，表示类名任意 在类名的部分，可以使用*号代替类名的一部分 例如：*Service匹配所有名称以Service结尾的类或接口 在方法名部分，可以使用*号表示方法名任意 在方法名部分，可以使用*号代替方法名的一部分 例如：*Operation匹配所有方法名以Operation结尾的方法 在方法参数列表部分，使用(..)表示参数列表任意 在方法参数列表部分，使用(int,..)表示参数列表以一个int类型的参数开头 在方法参数列表部分，基本数据类型和对应的包装类型是不一样的 切入点表达式中使用 int 和实际方法中 Integer 是不匹配的 在方法返回值部分，如果想要明确指定一个返回值类型，那么必须同时写明权限修饰符 例如：execution(public int ..Service.(.., int)) 正确 例如：execution( int *..Service.(.., int)) 错误 5.4.6、重用切入点表达式①声明 12@Pointcut(&quot;execution(* com.atguigu.aop.annotation.*.*(..))&quot;)public void pointCut()&#123;&#125; ②在同一个切面中使用 123456@Before(&quot;pointCut()&quot;)public void beforeMethod(JoinPoint joinPoint)&#123; String methodName = joinPoint.getSignature().getName(); String args = Arrays.toString(joinPoint.getArgs()); System.out.println(&quot;Logger--&gt;前置通知，方法名：&quot;+methodName+&quot;，参数：&quot;+args);&#125; ③在不同切面中使用 123456@Before(&quot;com.atguigu.aop.CommonPointCut.pointCut()&quot;)public void beforeMethod(JoinPoint joinPoint)&#123; String methodName = joinPoint.getSignature().getName(); String args = Arrays.toString(joinPoint.getArgs()); System.out.println(&quot;Logger--&gt;前置通知，方法名：&quot;+methodName+&quot;，参数：&quot;+args);&#125; 5.4.7、获取通知的相关信息①获取连接点信息 获取连接点信息可以在通知方法的参数位置设置JoinPoint类型的形参 12345678@Before(&quot;execution(public int com.atguigu.aop.annotation.CalculatorImpl.*(..))&quot;)public void beforeMethod(JoinPoint joinPoint)&#123; //获取连接点的签名信息 String methodName = joinPoint.getSignature().getName(); //获取目标方法到的实参信息 String args = Arrays.toString(joinPoint.getArgs()); System.out.println(&quot;Logger--&gt;前置通知，方法名：&quot;+methodName+&quot;，参数：&quot;+args);&#125; ②获取目标方法的返回值 @AfterReturning中的属性returning，用来将通知方法的某个形参，接收目标方法的返回值 12345@AfterReturning(value = &quot;execution(* com.atguigu.aop.annotation.CalculatorImpl.*(..))&quot;, returning = &quot;result&quot;)public void afterReturningMethod(JoinPoint joinPoint, Object result)&#123; String methodName = joinPoint.getSignature().getName(); System.out.println(&quot;Logger--&gt;返回通知，方法名：&quot;+methodName+&quot;，结果：&quot;+result);&#125; ③获取目标方法的异常 @AfterThrowing中的属性throwing，用来将通知方法的某个形参，接收目标方法的异常 12345@AfterThrowing(value = &quot;execution(* com.atguigu.aop.annotation.CalculatorImpl.*(..))&quot;, throwing = &quot;ex&quot;)public void afterThrowingMethod(JoinPoint joinPoint, Throwable ex)&#123; String methodName = joinPoint.getSignature().getName(); System.out.println(&quot;Logger--&gt;异常通知，方法名：&quot;+methodName+&quot;，异常：&quot;+ex);&#125; 5.4.8、环绕通知123456789101112131415161718@Around(&quot;execution(* com.atguigu.aop.annotation.CalculatorImpl.*(..))&quot;)public Object aroundMethod(ProceedingJoinPoint joinPoint)&#123; String methodName = joinPoint.getSignature().getName(); String args = Arrays.toString(joinPoint.getArgs()); Object result = null; try &#123; System.out.println(&quot;环绕通知--&gt;目标对象方法执行之前&quot;); //目标方法的执行，目标方法的返回值一定要返回给外界调用者 result = joinPoint.proceed(); System.out.println(&quot;环绕通知--&gt;目标对象方法返回值之后&quot;); &#125; catch (Throwable throwable) &#123; throwable.printStackTrace(); System.out.println(&quot;环绕通知--&gt;目标对象方法出现异常时&quot;); &#125; finally &#123; System.out.println(&quot;环绕通知--&gt;目标对象方法执行完毕&quot;); &#125; return result;&#125; 5.4.9、切面的优先级相同目标方法上同时存在多个切面时，切面的优先级控制切面的内外嵌套顺序。 优先级高的切面：外面 优先级低的切面：里面 使用@Order注解可以控制切面的优先级： @Order(较小的数)：优先级高 @Order(较大的数)：优先级低 5.5、基于XML的AOP5.5.1、准备工作参考基于注解的AOP环境 5.5.2、实现1234567891011121314&lt;context:component-scan base-package=&quot;com.atguigu.aop.xml&quot;&gt;&lt;/context:component-scan&gt;&lt;aop:config&gt; &lt;!--配置切面类--&gt; &lt;aop:aspect ref=&quot;loggerAspect&quot;&gt; &lt;aop:pointcut id=&quot;pointCut&quot; expression=&quot;execution(* com.atguigu.aop.xml.CalculatorImpl.*(..))&quot;/&gt; &lt;aop:before method=&quot;beforeMethod&quot; pointcut-ref=&quot;pointCut&quot;&gt;&lt;/aop:before&gt; &lt;aop:after method=&quot;afterMethod&quot; pointcut-ref=&quot;pointCut&quot;&gt;&lt;/aop:after&gt; &lt;aop:after-returning method=&quot;afterReturningMethod&quot; returning=&quot;result&quot; pointcut-ref=&quot;pointCut&quot;&gt;&lt;/aop:after-returning&gt; &lt;aop:after-throwing method=&quot;afterThrowingMethod&quot; throwing=&quot;ex&quot; pointcut-ref=&quot;pointCut&quot;&gt;&lt;/aop:after-throwing&gt; &lt;aop:around method=&quot;aroundMethod&quot; pointcut-ref=&quot;pointCut&quot;&gt;&lt;/aop:around&gt; &lt;/aop:aspect&gt;&lt;/aop:config&gt; 6、单元测试：JUnit在之前的测试方法中，几乎都能看到以下的两行代码： 12ApplicationContext context = new ClassPathXmlApplicationContext(&quot;xxx.xml&quot;);Xxxx xxx = context.getBean(Xxxx.class); 这两行代码的作用是创建Spring容器，最终获取到对象，但是每次测试都需要重复编写。针对上述问题，我们需要的是程序能自动帮我们创建容器。我们都知道JUnit无法知晓我们是否使用了 Spring 框架，更不用说帮我们创建 Spring 容器了。Spring提供了一个运行器，可以读取配置文件（或注解）来创建容器。我们只需要告诉它配置文件位置就可以了。这样一来，我们通过Spring整合JUnit可以使程序创建spring容器了 6.1、整合JUnit56.1.1、搭建子模块搭建spring-junit模块 6.1.2、引入依赖1234567891011121314151617181920212223242526272829303132333435&lt;dependencies&gt; &lt;!--spring context依赖--&gt; &lt;!--当你引入Spring Context依赖之后，表示将Spring的基础依赖引入了--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;6.0.2&lt;/version&gt; &lt;/dependency&gt; &lt;!--spring对junit的支持相关依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;6.0.2&lt;/version&gt; &lt;/dependency&gt; &lt;!--junit5测试--&gt; &lt;dependency&gt; &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt; &lt;artifactId&gt;junit-jupiter-api&lt;/artifactId&gt; &lt;version&gt;5.9.0&lt;/version&gt; &lt;/dependency&gt; &lt;!--log4j2的依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j-core&lt;/artifactId&gt; &lt;version&gt;2.19.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j-slf4j2-impl&lt;/artifactId&gt; &lt;version&gt;2.19.0&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 6.1.3、添加配置文件beans.xml 12345678&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;context:component-scan base-package=&quot;com.atguigu.spring6.bean&quot;/&gt;&lt;/beans&gt; copy日志文件：log4j2.xml 6.1.4、添加java类1234567891011package com.atguigu.spring6.bean;import org.springframework.stereotype.Component;@Componentpublic class User &#123; public User() &#123; System.out.println(&quot;run user&quot;); &#125;&#125; 6.1.5、测试123456789101112131415161718192021222324import com.atguigu.spring6.bean.User;import org.junit.jupiter.api.Test;import org.junit.jupiter.api.extension.ExtendWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit.jupiter.SpringExtension;import org.springframework.test.context.junit.jupiter.SpringJUnitConfig;//两种方式均可//方式一//@ExtendWith(SpringExtension.class)//@ContextConfiguration(&quot;classpath:beans.xml&quot;)//方式二@SpringJUnitConfig(locations = &quot;classpath:beans.xml&quot;)public class SpringJUnit5Test &#123; @Autowired private User user; @Test public void testUser()&#123; System.out.println(user); &#125;&#125; 6.2、整合JUnit4JUnit4在公司也会经常用到，在此也学习一下 6.2.1、添加依赖123456&lt;!-- junit测试 --&gt;&lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt;&lt;/dependency&gt; 6.2.2、测试12345678910111213141516171819import com.atguigu.spring6.bean.User;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(&quot;classpath:beans.xml&quot;)public class SpringJUnit4Test &#123; @Autowired private User user; @Test public void testUser()&#123; System.out.println(user); &#125;&#125; 7、事务7.1、JdbcTemplate7.1.1、简介 Spring 框架对 JDBC 进行封装，使用 JdbcTemplate 方便实现对数据库操作 7.1.2、准备工作①搭建子模块 搭建子模块：spring-jdbc-tx ②加入依赖 1234567891011121314151617181920&lt;dependencies&gt; &lt;!--spring jdbc Spring 持久化层支持jar包--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;6.0.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- MySQL驱动 --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.30&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 数据源 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.2.15&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; ③创建jdbc.properties 1234jdbc.user=rootjdbc.password=rootjdbc.url=jdbc:mysql://localhost:3306/spring?characterEncoding=utf8&amp;useSSL=falsejdbc.driver=com.mysql.cj.jdbc.Driver ④配置Spring的配置文件 beans.xml 123456789101112131415161718192021222324252627&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;!-- 导入外部属性文件 --&gt; &lt;context:property-placeholder location=&quot;classpath:jdbc.properties&quot; /&gt; &lt;!-- 配置数据源 --&gt; &lt;bean id=&quot;druidDataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot;/&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;$&#123;jdbc.driver&#125;&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.user&#125;&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;/&gt; &lt;/bean&gt; &lt;!-- 配置 JdbcTemplate --&gt; &lt;bean id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt; &lt;!-- 装配数据源 --&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;druidDataSource&quot;/&gt; &lt;/bean&gt;&lt;/beans&gt; ⑤准备数据库与测试表 1234567891011CREATE DATABASE `spring`;use `spring`;CREATE TABLE `t_emp` ( `id` int(11) NOT NULL AUTO_INCREMENT, `name` varchar(20) DEFAULT NULL COMMENT &#x27;姓名&#x27;, `age` int(11) DEFAULT NULL COMMENT &#x27;年龄&#x27;, `sex` varchar(2) DEFAULT NULL COMMENT &#x27;性别&#x27;, PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4; 7.1.3、实现CURD①装配 JdbcTemplate创建测试类，整合JUnit，注入JdbcTemplate 12345678910111213package com.atguigu.spring6;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.jdbc.core.JdbcTemplate;import org.springframework.test.context.junit.jupiter.SpringJUnitConfig;@SpringJUnitConfig(locations = &quot;classpath:beans.xml&quot;)public class JDBCTemplateTest &#123; @Autowired private JdbcTemplate jdbcTemplate; &#125; ②测试增删改功能123456789101112131415@Test//测试增删改功能public void testUpdate()&#123; //添加功能 String sql = &quot;insert into t_emp values(null,?,?,?)&quot;; int result = jdbcTemplate.update(sql, &quot;张三&quot;, 23, &quot;男&quot;); //修改功能 //String sql = &quot;update t_emp set name=? where id=?&quot;; //int result = jdbcTemplate.update(sql, &quot;张三atguigu&quot;, 1); //删除功能 //String sql = &quot;delete from t_emp where id=?&quot;; //int result = jdbcTemplate.update(sql, 1);&#125; ③查询数据返回对象1234567891011121314151617181920public class Emp &#123; private Integer id; private String name; private Integer age; private String sex; //生成get和set方法 //...... @Override public String toString() &#123; return &quot;Emp&#123;&quot; + &quot;id=&quot; + id + &quot;, name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, age=&quot; + age + &quot;, sex=&#x27;&quot; + sex + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125;&#125; 12345678910111213141516171819202122//查询：返回对象@Testpublic void testSelectObject() &#123; //写法一// String sql = &quot;select * from t_emp where id=?&quot;;// Emp empResult = jdbcTemplate.queryForObject(sql,// (rs, rowNum) -&gt; &#123;// Emp emp = new Emp();// emp.setId(rs.getInt(&quot;id&quot;));// emp.setName(rs.getString(&quot;name&quot;));// emp.setAge(rs.getInt(&quot;age&quot;));// emp.setSex(rs.getString(&quot;sex&quot;));// return emp;// &#125;, 1);// System.out.println(empResult); //写法二 String sql = &quot;select * from t_emp where id=?&quot;; Emp emp = jdbcTemplate.queryForObject(sql, new BeanPropertyRowMapper&lt;&gt;(Emp.class),1); System.out.println(emp);&#125; ④查询数据返回list集合1234567@Test//查询多条数据为一个list集合public void testSelectList()&#123; String sql = &quot;select * from t_emp&quot;; List&lt;Emp&gt; list = jdbcTemplate.query(sql, new BeanPropertyRowMapper&lt;&gt;(Emp.class)); System.out.println(list);&#125; ⑤查询返回单个的值1234567@Test//查询单行单列的值public void selectCount()&#123; String sql = &quot;select count(id) from t_emp&quot;; Integer count = jdbcTemplate.queryForObject(sql, Integer.class); System.out.println(count);&#125; 7.2、声明式事务概念7.2.1、事务基本概念①什么是事务数据库事务( transaction)是访问并可能操作各种数据项的一个数据库操作序列，这些操作要么全部执行,要么全部不执行，是一个不可分割的工作单位。事务由事务开始与事务结束之间执行的全部数据库操作组成。 ②事务的特性A：原子性(Atomicity) 一个事务(transaction)中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。 C：一致性(Consistency) 事务的一致性指的是在一个事务执行之前和执行之后数据库都必须处于一致性状态。 如果事务成功地完成，那么系统中所有变化将正确地应用，系统处于有效状态。 如果在事务中出现错误，那么系统中的所有变化将自动地回滚，系统返回到原始状态。 I：隔离性(Isolation) 指的是在并发环境中，当不同的事务同时操纵相同的数据时，每个事务都有各自的完整数据空间。由并发事务所做的修改必须与任何其他并发事务所做的修改隔离。事务查看数据更新时，数据所处的状态要么是另一事务修改它之前的状态，要么是另一事务修改它之后的状态，事务不会查看到中间状态的数据。 D：持久性(Durability) 指的是只要事务成功结束，它对数据库所做的更新就必须保存下来。即使发生系统崩溃，重新启动数据库系统后，数据库还能恢复到事务成功结束时的状态。 7.2.2、编程式事务事务功能的相关操作全部通过自己编写代码来实现： 1234567891011121314151617181920212223Connection conn = ...; try &#123; // 开启事务：关闭事务的自动提交 conn.setAutoCommit(false); // 核心操作 // 提交事务 conn.commit(); &#125;catch(Exception e)&#123; // 回滚事务 conn.rollBack(); &#125;finally&#123; // 释放数据库连接 conn.close(); &#125; 编程式的实现方式存在缺陷： 细节没有被屏蔽：具体操作过程中，所有细节都需要程序员自己来完成，比较繁琐。 代码复用性不高：如果没有有效抽取出来，每次实现功能都需要自己编写代码，代码就没有得到复用。 7.2.3、声明式事务既然事务控制的代码有规律可循，代码的结构基本是确定的，所以框架就可以将固定模式的代码抽取出来，进行相关的封装。 封装起来后，我们只需要在配置文件中进行简单的配置即可完成操作。 好处1：提高开发效率 好处2：消除了冗余的代码 好处3：框架会综合考虑相关领域中在实际开发环境下有可能遇到的各种问题，进行了健壮性、性能等各个方面的优化 所以，我们可以总结下面两个概念： 编程式：自己写代码实现功能 声明式：通过配置让框架实现功能 7.3、基于注解的声明式事务7.3.1、准备工作①添加配置 在beans.xml添加配置 12&lt;!--扫描组件--&gt;&lt;context:component-scan base-package=&quot;com.atguigu.spring6&quot;&gt;&lt;/context:component-scan&gt; ②创建表 123456789101112131415CREATE TABLE `t_book` ( `book_id` int(11) NOT NULL AUTO_INCREMENT COMMENT &#x27;主键&#x27;, `book_name` varchar(20) DEFAULT NULL COMMENT &#x27;图书名称&#x27;, `price` int(11) DEFAULT NULL COMMENT &#x27;价格&#x27;, `stock` int(10) unsigned DEFAULT NULL COMMENT &#x27;库存（无符号）&#x27;, PRIMARY KEY (`book_id`)) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8;insert into `t_book`(`book_id`,`book_name`,`price`,`stock`) values (1,&#x27;斗破苍穹&#x27;,80,100),(2,&#x27;斗罗大陆&#x27;,50,100);CREATE TABLE `t_user` ( `user_id` int(11) NOT NULL AUTO_INCREMENT COMMENT &#x27;主键&#x27;, `username` varchar(20) DEFAULT NULL COMMENT &#x27;用户名&#x27;, `balance` int(10) unsigned DEFAULT NULL COMMENT &#x27;余额（无符号）&#x27;, PRIMARY KEY (`user_id`)) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8;insert into `t_user`(`user_id`,`username`,`balance`) values (1,&#x27;admin&#x27;,50); ③创建组件 创建BookController： 123456789101112package com.atguigu.spring6.controller;@Controllerpublic class BookController &#123; @Autowired private BookService bookService; public void buyBook(Integer bookId, Integer userId)&#123; bookService.buyBook(bookId, userId); &#125;&#125; 创建接口BookService： 1234package com.atguigu.spring6.service;public interface BookService &#123; void buyBook(Integer bookId, Integer userId);&#125; 创建实现类BookServiceImpl： 1234567891011121314151617package com.atguigu.spring6.service.impl;@Servicepublic class BookServiceImpl implements BookService &#123; @Autowired private BookDao bookDao; @Override public void buyBook(Integer bookId, Integer userId) &#123; //查询图书的价格 Integer price = bookDao.getPriceByBookId(bookId); //更新图书的库存 bookDao.updateStock(bookId); //更新用户的余额 bookDao.updateBalance(userId, price); &#125;&#125; 创建接口BookDao： 12345678package com.atguigu.spring6.dao;public interface BookDao &#123; Integer getPriceByBookId(Integer bookId); void updateStock(Integer bookId); void updateBalance(Integer userId, Integer price);&#125; 创建实现类BookDaoImpl： 12345678910111213141516171819202122232425package com.atguigu.spring6.dao.impl;@Repositorypublic class BookDaoImpl implements BookDao &#123; @Autowired private JdbcTemplate jdbcTemplate; @Override public Integer getPriceByBookId(Integer bookId) &#123; String sql = &quot;select price from t_book where book_id = ?&quot;; return jdbcTemplate.queryForObject(sql, Integer.class, bookId); &#125; @Override public void updateStock(Integer bookId) &#123; String sql = &quot;update t_book set stock = stock - 1 where book_id = ?&quot;; jdbcTemplate.update(sql, bookId); &#125; @Override public void updateBalance(Integer userId, Integer price) &#123; String sql = &quot;update t_user set balance = balance - ? where user_id = ?&quot;; jdbcTemplate.update(sql, price, userId); &#125;&#125; 7.3.2、测试无事务情况①创建测试类 1234567891011121314151617import org.junit.jupiter.api.Test;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.jdbc.core.JdbcTemplate;import org.springframework.test.context.junit.jupiter.SpringJUnitConfig;@SpringJUnitConfig(locations = &quot;classpath:beans.xml&quot;)public class TxByAnnotationTest &#123; @Autowired private BookController bookController; @Test public void testBuyBook()&#123; bookController.buyBook(1, 1); &#125;&#125; ②模拟场景 用户购买图书，先查询图书的价格，再更新图书的库存和用户的余额 假设用户id为1的用户，购买id为1的图书 用户余额为50，而图书价格为80 购买图书之后，用户的余额为-30，数据库中余额字段设置了无符号，因此无法将-30插入到余额字段 此时执行sql语句会抛出SQLException ③观察结果 因为没有添加事务，图书的库存更新了，但是用户的余额没有更新 显然这样的结果是错误的，购买图书是一个完整的功能，更新库存和更新余额要么都成功要么都失败 7.3.3、加入事务①添加事务配置在spring配置文件中引入tx命名空间 1234567891011&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd&quot;&gt; 在Spring的配置文件中添加配置： 12345678910&lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;druidDataSource&quot;&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!-- 开启事务的注解驱动 通过注解@Transactional所标识的方法或标识的类中所有的方法，都会被事务管理器管理事务--&gt;&lt;!-- transaction-manager属性的默认值是transactionManager，如果事务管理器bean的id正好就是这个默认值，则可以省略这个属性 --&gt;&lt;tx:annotation-driven transaction-manager=&quot;transactionManager&quot; /&gt; ②添加事务注解因为service层表示业务逻辑层，一个方法表示一个完成的功能，因此处理事务一般在service层处理 在BookServiceImpl的buybook()添加注解@Transactional ③观察结果由于使用了Spring的声明式事务，更新库存和更新余额都没有执行 7.3.4、@Transactional注解标识的位置@Transactional标识在方法上，则只会影响该方法 @Transactional标识的类上，则会影响类中所有的方法 7.3.5、事务属性：只读①介绍 对一个查询操作来说，如果我们把它设置成只读，就能够明确告诉数据库，这个操作不涉及写操作。这样数据库就能够针对查询操作来进行优化。 ②使用方式 12345678910@Transactional(readOnly = true)public void buyBook(Integer bookId, Integer userId) &#123; //查询图书的价格 Integer price = bookDao.getPriceByBookId(bookId); //更新图书的库存 bookDao.updateStock(bookId); //更新用户的余额 bookDao.updateBalance(userId, price); //System.out.println(1/0);&#125; ③注意 对增删改操作设置只读会抛出下面异常： Caused by: java.sql.SQLException: Connection is read-only. Queries leading to data modification are not allowed 7.3.6、事务属性：超时①介绍 事务在执行过程中，有可能因为遇到某些问题，导致程序卡住，从而长时间占用数据库资源。而长时间占用资源，大概率是因为程序运行出现了问题（可能是Java程序或MySQL数据库或网络连接等等）。此时这个很可能出问题的程序应该被回滚，撤销它已做的操作，事务结束，把资源让出来，让其他正常程序可以执行。 概括来说就是一句话：超时回滚，释放资源。 ②使用方式 12345678910111213141516//超时时间单位秒@Transactional(timeout = 3)public void buyBook(Integer bookId, Integer userId) &#123; try &#123; TimeUnit.SECONDS.sleep(5); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; //查询图书的价格 Integer price = bookDao.getPriceByBookId(bookId); //更新图书的库存 bookDao.updateStock(bookId); //更新用户的余额 bookDao.updateBalance(userId, price); //System.out.println(1/0);&#125; ③观察结果 执行过程中抛出异常： org.springframework.transaction.TransactionTimedOutException: Transaction timed out: deadline was Fri Jun 04 16:25:39 CST 2022 7.3.7、事务属性：回滚策略①介绍 声明式事务默认只针对运行时异常回滚，编译时异常不回滚。 可以通过@Transactional中相关属性设置回滚策略 rollbackFor属性：需要设置一个Class类型的对象 rollbackForClassName属性：需要设置一个字符串类型的全类名 noRollbackFor属性：需要设置一个Class类型的对象 rollbackFor属性：需要设置一个字符串类型的全类名 ②使用方式 1234567891011@Transactional(noRollbackFor = ArithmeticException.class)//@Transactional(noRollbackForClassName = &quot;java.lang.ArithmeticException&quot;)public void buyBook(Integer bookId, Integer userId) &#123; //查询图书的价格 Integer price = bookDao.getPriceByBookId(bookId); //更新图书的库存 bookDao.updateStock(bookId); //更新用户的余额 bookDao.updateBalance(userId, price); System.out.println(1/0);&#125; ③观察结果 虽然购买图书功能中出现了数学运算异常（ArithmeticException），但是我们设置的回滚策略是，当出现ArithmeticException不发生回滚，因此购买图书的操作正常执行 7.3.8、事务属性：隔离级别①介绍 数据库系统必须具有隔离并发运行各个事务的能力，使它们不会相互影响，避免各种并发问题。一个事务与其他事务隔离的程度称为隔离级别。SQL标准中规定了多种事务隔离级别，不同隔离级别对应不同的干扰程度，隔离级别越高，数据一致性就越好，但并发性越弱。 隔离级别一共有四种： 读未提交：READ UNCOMMITTED 允许Transaction01读取Transaction02未提交的修改。 读已提交：READ COMMITTED、 要求Transaction01只能读取Transaction02已提交的修改。 可重复读：REPEATABLE READ 确保Transaction01可以多次从一个字段中读取到相同的值，即Transaction01执行期间禁止其它事务对这个字段进行更新。 串行化：SERIALIZABLE 确保Transaction01可以多次从一个表中读取到相同的行，在Transaction01执行期间，禁止其它事务对这个表进行添加、更新、删除操作。可以避免任何并发问题，但性能十分低下。 各个隔离级别解决并发问题的能力见下表： 隔离级别 脏读 不可重复读 幻读 READ UNCOMMITTED 有 有 有 READ COMMITTED 无 有 有 REPEATABLE READ 无 无 有 SERIALIZABLE 无 无 无 各种数据库产品对事务隔离级别的支持程度： 隔离级别 Oracle MySQL READ UNCOMMITTED × √ READ COMMITTED √(默认) √ REPEATABLE READ × √(默认) SERIALIZABLE √ √ ②使用方式 12345@Transactional(isolation = Isolation.DEFAULT)//使用数据库默认的隔离级别@Transactional(isolation = Isolation.READ_UNCOMMITTED)//读未提交@Transactional(isolation = Isolation.READ_COMMITTED)//读已提交@Transactional(isolation = Isolation.REPEATABLE_READ)//可重复读@Transactional(isolation = Isolation.SERIALIZABLE)//串行化 7.3.9、事务属性：传播行为①介绍 什么是事务的传播行为？ 在service类中有a()方法和b()方法，a()方法上有事务，b()方法上也有事务，当a()方法执行过程中调用了b()方法，事务是如何传递的？合并到一个事务里？还是开启一个新的事务？这就是事务传播行为。 一共有七种传播行为： REQUIRED：支持当前事务，如果不存在就新建一个(默认)【没有就新建，有就加入】 SUPPORTS：支持当前事务，如果当前没有事务，就以非事务方式执行【有就加入，没有就不管了】 MANDATORY：必须运行在一个事务中，如果当前没有事务正在发生，将抛出一个异常【有就加入，没有就抛异常】 REQUIRES_NEW：开启一个新的事务，如果一个事务已经存在，则将这个存在的事务挂起【不管有没有，直接开启一个新事务，开启的新事务和之前的事务不存在嵌套关系，之前事务被挂起】 NOT_SUPPORTED：以非事务方式运行，如果有事务存在，挂起当前事务【不支持事务，存在就挂起】 NEVER：以非事务方式运行，如果有事务存在，抛出异常【不支持事务，存在就抛异常】 NESTED：如果当前正有一个事务在进行中，则该方法应当运行在一个嵌套式事务中。被嵌套的事务可以独立于外层事务进行提交或回滚。如果外层事务不存在，行为就像REQUIRED一样。【有事务的话，就在这个事务里再嵌套一个完全独立的事务，嵌套的事务可以独立的提交和回滚。没有事务就和REQUIRED一样。】 ②测试 创建接口CheckoutService： 12345package com.atguigu.spring6.service;public interface CheckoutService &#123; void checkout(Integer[] bookIds, Integer userId);&#125; 创建实现类CheckoutServiceImpl： 1234567891011121314151617package com.atguigu.spring6.service.impl;@Servicepublic class CheckoutServiceImpl implements CheckoutService &#123; @Autowired private BookService bookService; @Override @Transactional //一次购买多本图书 public void checkout(Integer[] bookIds, Integer userId) &#123; for (Integer bookId : bookIds) &#123; bookService.buyBook(bookId, userId); &#125; &#125;&#125; 在BookController中添加方法： 123456@Autowiredprivate CheckoutService checkoutService;public void checkout(Integer[] bookIds, Integer userId)&#123; checkoutService.checkout(bookIds, userId);&#125; 在数据库中将用户的余额修改为100元 ③观察结果 可以通过@Transactional中的propagation属性设置事务传播行为 修改BookServiceImpl中buyBook()上，注解@Transactional的propagation属性 @Transactional(propagation &#x3D; Propagation.REQUIRED)，默认情况，表示如果当前线程上有已经开启的事务可用，那么就在这个事务中运行。经过观察，购买图书的方法buyBook()在checkout()中被调用，checkout()上有事务注解，因此在此事务中执行。所购买的两本图书的价格为80和50，而用户的余额为100，因此在购买第二本图书时余额不足失败，导致整个checkout()回滚，即只要有一本书买不了，就都买不了 @Transactional(propagation &#x3D; Propagation.REQUIRES_NEW)，表示不管当前线程上是否有已经开启的事务，都要开启新事务。同样的场景，每次购买图书都是在buyBook()的事务中执行，因此第一本图书购买成功，事务结束，第二本图书购买失败，只在第二次的buyBook()中回滚，购买第一本图书不受影响，即能买几本就买几本。 7.3.10、全注解配置事务①添加配置类 12345678910111213141516171819202122232425262728293031323334353637383940package com.atguigu.spring6.config;import com.alibaba.druid.pool.DruidDataSource;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.ComponentScan;import org.springframework.context.annotation.Configuration;import org.springframework.jdbc.core.JdbcTemplate;import org.springframework.jdbc.datasource.DataSourceTransactionManager;import org.springframework.transaction.annotation.EnableTransactionManagement;import javax.sql.DataSource;@Configuration@ComponentScan(&quot;com.atguigu.spring6&quot;)@EnableTransactionManagementpublic class SpringConfig &#123; @Bean public DataSource getDataSource()&#123; DruidDataSource dataSource = new DruidDataSource(); dataSource.setDriverClassName(&quot;com.mysql.cj.jdbc.Driver&quot;); dataSource.setUrl(&quot;jdbc:mysql://localhost:3306/spring?characterEncoding=utf8&amp;useSSL=false&quot;); dataSource.setUsername(&quot;root&quot;); dataSource.setPassword(&quot;root&quot;); return dataSource; &#125; @Bean(name = &quot;jdbcTemplate&quot;) public JdbcTemplate getJdbcTemplate(DataSource dataSource)&#123; JdbcTemplate jdbcTemplate = new JdbcTemplate(); jdbcTemplate.setDataSource(dataSource); return jdbcTemplate; &#125; @Bean public DataSourceTransactionManager getDataSourceTransactionManager(DataSource dataSource)&#123; DataSourceTransactionManager dataSourceTransactionManager = new DataSourceTransactionManager(); dataSourceTransactionManager.setDataSource(dataSource); return dataSourceTransactionManager; &#125;&#125; ②测试 1234567891011121314151617import com.atguigu.spring6.config.SpringConfig;import com.atguigu.spring6.controller.BookController;import org.junit.jupiter.api.Test;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.context.ApplicationContext;import org.springframework.context.annotation.AnnotationConfigApplicationContext;import org.springframework.test.context.junit.jupiter.SpringJUnitConfig;public class TxByAllAnnotationTest &#123; @Test public void testTxAllAnnotation()&#123; ApplicationContext applicationContext = new AnnotationConfigApplicationContext(SpringConfig.class); BookController accountService = applicationContext.getBean(&quot;bookController&quot;, BookController.class); accountService.buyBook(1, 1); &#125;&#125; 7.4、基于XML的声明式事务7.3.1、场景模拟参考基于注解的声明式事务 7.3.2、修改Spring配置文件将Spring配置文件中去掉tx:annotation-driven 标签，并添加配置： 1234567891011121314151617181920212223242526&lt;aop:config&gt; &lt;!-- 配置事务通知和切入点表达式 --&gt; &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut=&quot;execution(* com.atguigu.spring.tx.xml.service.impl.*.*(..))&quot;&gt;&lt;/aop:advisor&gt;&lt;/aop:config&gt;&lt;!-- tx:advice标签：配置事务通知 --&gt;&lt;!-- id属性：给事务通知标签设置唯一标识，便于引用 --&gt;&lt;!-- transaction-manager属性：关联事务管理器 --&gt;&lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;transactionManager&quot;&gt; &lt;tx:attributes&gt; &lt;!-- tx:method标签：配置具体的事务方法 --&gt; &lt;!-- name属性：指定方法名，可以使用星号代表多个字符 --&gt; &lt;tx:method name=&quot;get*&quot; read-only=&quot;true&quot;/&gt; &lt;tx:method name=&quot;query*&quot; read-only=&quot;true&quot;/&gt; &lt;tx:method name=&quot;find*&quot; read-only=&quot;true&quot;/&gt; &lt;!-- read-only属性：设置只读属性 --&gt; &lt;!-- rollback-for属性：设置回滚的异常 --&gt; &lt;!-- no-rollback-for属性：设置不回滚的异常 --&gt; &lt;!-- isolation属性：设置事务的隔离级别 --&gt; &lt;!-- timeout属性：设置事务的超时属性 --&gt; &lt;!-- propagation属性：设置事务的传播行为 --&gt; &lt;tx:method name=&quot;save*&quot; read-only=&quot;false&quot; rollback-for=&quot;java.lang.Exception&quot; propagation=&quot;REQUIRES_NEW&quot;/&gt; &lt;tx:method name=&quot;update*&quot; read-only=&quot;false&quot; rollback-for=&quot;java.lang.Exception&quot; propagation=&quot;REQUIRES_NEW&quot;/&gt; &lt;tx:method name=&quot;delete*&quot; read-only=&quot;false&quot; rollback-for=&quot;java.lang.Exception&quot; propagation=&quot;REQUIRES_NEW&quot;/&gt; &lt;/tx:attributes&gt;&lt;/tx:advice&gt; 注意：基于xml实现的声明式事务，必须引入aspectJ的依赖 12345 &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt; &lt;version&gt;6.0.2&lt;/version&gt;&lt;/dependency&gt; 8、资源操作：Resources8.1、Spring Resources概述 Java的标准java.net.URL类和各种URL前缀的标准处理程序无法满足所有对low-level资源的访问，比如：没有标准化的 URL 实现可用于访问需要从类路径或相对于 ServletContext 获取的资源。并且缺少某些Spring所需要的功能，例如检测某资源是否存在等。而Spring的Resource声明了访问low-level资源的能力。 8.2、Resource接口Spring 的 Resource 接口位于 org.springframework.core.io 中。 旨在成为一个更强大的接口，用于抽象对低级资源的访问。以下显示了Resource接口定义的方法 12345678910111213141516171819202122232425262728public interface Resource extends InputStreamSource &#123; boolean exists(); boolean isReadable(); boolean isOpen(); boolean isFile(); URL getURL() throws IOException; URI getURI() throws IOException; File getFile() throws IOException; ReadableByteChannel readableChannel() throws IOException; long contentLength() throws IOException; long lastModified() throws IOException; Resource createRelative(String relativePath) throws IOException; String getFilename(); String getDescription();&#125; Resource接口继承了InputStreamSource接口，提供了很多InputStreamSource所没有的方法。InputStreamSource接口，只有一个方法： 12345public interface InputStreamSource &#123; InputStream getInputStream() throws IOException;&#125; 其中一些重要的方法： getInputStream(): 找到并打开资源，返回一个InputStream以从资源中读取。预计每次调用都会返回一个新的InputStream()，调用者有责任关闭每个流exists(): 返回一个布尔值，表明某个资源是否以物理形式存在isOpen: 返回一个布尔值，指示此资源是否具有开放流的句柄。如果为true，InputStream就不能够多次读取，只能够读取一次并且及时关闭以避免内存泄漏。对于所有常规资源实现，返回false，但是InputStreamResource除外。getDescription(): 返回资源的描述，用来输出错误的日志。这通常是完全限定的文件名或资源的实际URL。 其他方法： isReadable(): 表明资源的目录读取是否通过getInputStream()进行读取。isFile(): 表明这个资源是否代表了一个文件系统的文件。getURL(): 返回一个URL句柄，如果资源不能够被解析为URL，将抛出IOExceptiongetURI(): 返回一个资源的URI句柄getFile(): 返回某个文件，如果资源不能够被解析称为绝对路径，将会抛出FileNotFoundExceptionlastModified(): 资源最后一次修改的时间戳createRelative(): 创建此资源的相关资源getFilename(): 资源的文件名是什么 例如：最后一部分的文件名 myfile.txt 8.3、Resource的实现类Resource 接口是 Spring 资源访问策略的抽象，它本身并不提供任何资源访问实现，具体的资源访问由该接口的实现类完成——每个实现类代表一种资源访问策略。Resource一般包括这些实现类：UrlResource、ClassPathResource、FileSystemResource、ServletContextResource、InputStreamResource、ByteArrayResource 8.3.1、UrlResource访问网络资源Resource的一个实现类，用来访问网络资源，它支持URL的绝对路径。 http:——该前缀用于访问基于HTTP协议的网络资源。 ftp:——该前缀用于访问基于FTP协议的网络资源 file: ——该前缀用于从文件系统中读取资源 实验：访问基于HTTP协议的网络资源 创建一个maven子模块spring6-resources，配置Spring依赖（参考前面） 12345678910111213141516171819202122232425262728package com.atguigu.spring6.resources;import org.springframework.core.io.UrlResource;public class UrlResourceDemo &#123; public static void loadAndReadUrlResource(String path)&#123; // 创建一个 Resource 对象 UrlResource url = null; try &#123; url = new UrlResource(path); // 获取资源名 System.out.println(url.getFilename()); System.out.println(url.getURI()); // 获取资源描述 System.out.println(url.getDescription()); //获取资源内容 System.out.println(url.getInputStream().read()); &#125; catch (Exception e) &#123; throw new RuntimeException(e); &#125; &#125; public static void main(String[] args) &#123; //访问网络资源 loadAndReadUrlResource(&quot;http://www.baidu.com&quot;); &#125;&#125; 实验二：在项目根路径下创建文件，从文件系统中读取资源 方法不变，修改调用传递路径 1234567public static void main(String[] args) &#123; //1 访问网络资源 //loadAndReadUrlResource(&quot;http://www.atguigu.com&quot;); //2 访问文件系统资源 loadAndReadUrlResource(&quot;file:atguigu.txt&quot;);&#125; 8.3.2、ClassPathResource 访问类路径下资源ClassPathResource 用来访问类加载路径下的资源，相对于其他的 Resource 实现类，其主要优势是方便访问类加载路径里的资源，尤其对于 Web 应用，ClassPathResource 可自动搜索位于 classes 下的资源文件，无须使用绝对路径访问。 实验：在类路径下创建文件atguigu.txt，使用ClassPathResource 访问 1234567891011121314151617181920212223242526package com.atguigu.spring6.resources;import org.springframework.core.io.ClassPathResource;import java.io.InputStream;public class ClassPathResourceDemo &#123; public static void loadAndReadUrlResource(String path) throws Exception&#123; // 创建一个 Resource 对象 ClassPathResource resource = new ClassPathResource(path); // 获取文件名 System.out.println(&quot;resource.getFileName = &quot; + resource.getFilename()); // 获取文件描述 System.out.println(&quot;resource.getDescription = &quot;+ resource.getDescription()); //获取文件内容 InputStream in = resource.getInputStream(); byte[] b = new byte[1024]; while(in.read(b)!=-1) &#123; System.out.println(new String(b)); &#125; &#125; public static void main(String[] args) throws Exception &#123; loadAndReadUrlResource(&quot;atguigu.txt&quot;); &#125;&#125; ClassPathResource实例可使用ClassPathResource构造器显式地创建，但更多的时候它都是隐式地创建的。当执行Spring的某个方法时，该方法接受一个代表资源路径的字符串参数，当Spring识别该字符串参数中包含classpath:前缀后，系统会自动创建ClassPathResource对象。 8.3.3、FileSystemResource 访问文件系统资源Spring 提供的 FileSystemResource 类用于访问文件系统资源，使用 FileSystemResource 来访问文件系统资源并没有太大的优势，因为 Java 提供的 File 类也可用于访问文件系统资源。 实验：使用FileSystemResource 访问文件系统资源 1234567891011121314151617181920212223242526272829package com.atguigu.spring6.resources;import org.springframework.core.io.FileSystemResource;import java.io.InputStream;public class FileSystemResourceDemo &#123; public static void loadAndReadUrlResource(String path) throws Exception&#123; //相对路径 FileSystemResource resource = new FileSystemResource(&quot;atguigu.txt&quot;); //绝对路径 //FileSystemResource resource = new FileSystemResource(&quot;C:\\\\atguigu.txt&quot;); // 获取文件名 System.out.println(&quot;resource.getFileName = &quot; + resource.getFilename()); // 获取文件描述 System.out.println(&quot;resource.getDescription = &quot;+ resource.getDescription()); //获取文件内容 InputStream in = resource.getInputStream(); byte[] b = new byte[1024]; while(in.read(b)!=-1) &#123; System.out.println(new String(b)); &#125; &#125; public static void main(String[] args) throws Exception &#123; loadAndReadUrlResource(&quot;atguigu.txt&quot;); &#125;&#125; FileSystemResource实例可使用FileSystemResource构造器显示地创建，但更多的时候它都是隐式创建。执行Spring的某个方法时，该方法接受一个代表资源路径的字符串参数，当Spring识别该字符串参数中包含file:前缀后，系统将会自动创建FileSystemResource对象。 8.3.4、ServletContextResource这是ServletContext资源的Resource实现，它解释相关Web应用程序根目录中的相对路径。它始终支持流(stream)访问和URL访问，但只有在扩展Web应用程序存档且资源实际位于文件系统上时才允许java.io.File访问。无论它是在文件系统上扩展还是直接从JAR或其他地方（如数据库）访问，实际上都依赖于Servlet容器。 8.3.5、InputStreamResourceInputStreamResource 是给定的输入流(InputStream)的Resource实现。它的使用场景在没有特定的资源实现的时候使用(感觉和@Component 的适用场景很相似)。与其他Resource实现相比，这是已打开资源的描述符。 因此，它的isOpen()方法返回true。如果需要将资源描述符保留在某处或者需要多次读取流，请不要使用它。 8.3.6、ByteArrayResource字节数组的Resource实现类。通过给定的数组创建了一个ByteArrayInputStream。它对于从任何给定的字节数组加载内容非常有用，而无需求助于单次使用的InputStreamResource。 8.4、Resource类图上述Resource实现类与Resource顶级接口之间的关系可以用下面的UML关系模型来表示 8.5、ResourceLoader 接口8.5.1、ResourceLoader 概述Spring 提供如下两个标志性接口： （1）ResourceLoader ： 该接口实现类的实例可以获得一个Resource实例。 （2） ResourceLoaderAware ： 该接口实现类的实例将获得一个ResourceLoader的引用。 在ResourceLoader接口里有如下方法： （1）Resource getResource（String location） ： 该接口仅有这个方法，用于返回一个Resource实例。ApplicationContext实现类都实现ResourceLoader接口，因此ApplicationContext可直接获取Resource实例。 8.5.2、使用演示实验一：ClassPathXmlApplicationContext获取Resource实例 1234567891011121314151617package com.atguigu.spring6.resouceloader;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;import org.springframework.core.io.Resource;public class Demo1 &#123; public static void main(String[] args) &#123; ApplicationContext ctx = new ClassPathXmlApplicationContext();// 通过ApplicationContext访问资源// ApplicationContext实例获取Resource实例时，// 默认采用与ApplicationContext相同的资源访问策略 Resource res = ctx.getResource(&quot;atguigu.txt&quot;); System.out.println(res.getFilename()); &#125;&#125; 实验二：FileSystemApplicationContext获取Resource实例 1234567891011121314package com.atguigu.spring6.resouceloader;import org.springframework.context.ApplicationContext;import org.springframework.context.support.FileSystemXmlApplicationContext;import org.springframework.core.io.Resource;public class Demo2 &#123; public static void main(String[] args) &#123; ApplicationContext ctx = new FileSystemXmlApplicationContext(); Resource res = ctx.getResource(&quot;atguigu.txt&quot;); System.out.println(res.getFilename()); &#125;&#125; 8.5.3、ResourceLoader 总结Spring将采用和ApplicationContext相同的策略来访问资源。也就是说，如果ApplicationContext是FileSystemXmlApplicationContext，res就是FileSystemResource实例；如果ApplicationContext是ClassPathXmlApplicationContext，res就是ClassPathResource实例 当Spring应用需要进行资源访问时，实际上并不需要直接使用Resource实现类，而是调用ResourceLoader实例的getResource()方法来获得资源，ReosurceLoader将会负责选择Reosurce实现类，也就是确定具体的资源访问策略，从而将应用程序和具体的资源访问策略分离开来 另外，使用ApplicationContext访问资源时，可通过不同前缀指定强制使用指定的ClassPathResource、FileSystemResource等实现类 123Resource res = ctx.getResource(&quot;calsspath:bean.xml&quot;);Resrouce res = ctx.getResource(&quot;file:bean.xml&quot;);Resource res = ctx.getResource(&quot;http://localhost:8080/beans.xml&quot;); 8.6、ResourceLoaderAware 接口ResourceLoaderAware接口实现类的实例将获得一个ResourceLoader的引用，ResourceLoaderAware接口也提供了一个setResourceLoader()方法，该方法将由Spring容器负责调用，Spring容器会将一个ResourceLoader对象作为该方法的参数传入。 如果把实现ResourceLoaderAware接口的Bean类部署在Spring容器中，Spring容器会将自身当成ResourceLoader作为setResourceLoader()方法的参数传入。由于ApplicationContext的实现类都实现了ResourceLoader接口，Spring容器自身完全可作为ResorceLoader使用。 实验：演示ResourceLoaderAware使用 第一步 创建类，实现ResourceLoaderAware接口 12345678910111213141516171819202122package com.atguigu.spring6.resouceloader;import org.springframework.context.ResourceLoaderAware;import org.springframework.core.io.ResourceLoader;public class TestBean implements ResourceLoaderAware &#123; private ResourceLoader resourceLoader; //实现ResourceLoaderAware接口必须实现的方法 //如果把该Bean部署在Spring容器中，该方法将会有Spring容器负责调用。 //SPring容器调用该方法时，Spring会将自身作为参数传给该方法。 public void setResourceLoader(ResourceLoader resourceLoader) &#123; this.resourceLoader = resourceLoader; &#125; //返回ResourceLoader对象的应用 public ResourceLoader getResourceLoader()&#123; return this.resourceLoader; &#125;&#125; 第二步 创建bean.xml文件，配置TestBean 1234567&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id=&quot;testBean&quot; class=&quot;com.atguigu.spring6.resouceloader.TestBean&quot;&gt;&lt;/bean&gt;&lt;/beans&gt; 第三步 测试 12345678910111213141516171819202122package com.atguigu.spring6.resouceloader;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;import org.springframework.core.io.Resource;import org.springframework.core.io.ResourceLoader;public class Demo3 &#123; public static void main(String[] args) &#123; //Spring容器会将一个ResourceLoader对象作为该方法的参数传入 ApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;bean.xml&quot;); TestBean testBean = ctx.getBean(&quot;testBean&quot;,TestBean.class); //获取ResourceLoader对象 ResourceLoader resourceLoader = testBean.getResourceLoader(); System.out.println(&quot;Spring容器将自身注入到ResourceLoaderAware Bean 中 ？ ：&quot; + (resourceLoader == ctx)); //加载其他资源 Resource resource = resourceLoader.getResource(&quot;atguigu.txt&quot;); System.out.println(resource.getFilename()); System.out.println(resource.getDescription()); &#125;&#125; 8.7、使用Resource 作为属性前面介绍了 Spring 提供的资源访问策略，但这些依赖访问策略要么需要使用 Resource 实现类，要么需要使用 ApplicationContext 来获取资源。实际上，当应用程序中的 Bean 实例需要访问资源时，Spring 有更好的解决方法：直接利用依赖注入。从这个意义上来看，Spring 框架不仅充分利用了策略模式来简化资源访问，而且还将策略模式和 IoC 进行充分地结合，最大程度地简化了 Spring 资源访问。 归纳起来，如果 Bean 实例需要访问资源，有如下两种解决方案： 代码中获取 Resource 实例。 使用依赖注入。 对于第一种方式，当程序获取 Resource 实例时，总需要提供 Resource 所在的位置，不管通过 FileSystemResource 创建实例，还是通过 ClassPathResource 创建实例，或者通过 ApplicationContext 的 getResource() 方法获取实例，都需要提供资源位置。这意味着：资源所在的物理位置将被耦合到代码中，如果资源位置发生改变，则必须改写程序。因此，通常建议采用第二种方法，让 Spring 为 Bean 实例依赖注入资源。 实验：让Spring为Bean实例依赖注入资源 第一步 创建依赖注入类，定义属性和方法 1234567891011121314151617181920package com.atguigu.spring6.resouceloader;import org.springframework.core.io.Resource;public class ResourceBean &#123; private Resource res; public void setRes(Resource res) &#123; this.res = res; &#125; public Resource getRes() &#123; return res; &#125; public void parse()&#123; System.out.println(res.getFilename()); System.out.println(res.getDescription()); &#125;&#125; 第二步 创建spring配置文件，配置依赖注入 1234567891011&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id=&quot;resourceBean&quot; class=&quot;com.atguigu.spring6.resouceloader.ResourceBean&quot; &gt; &lt;!-- 可以使用file:、http:、ftp:等前缀强制Spring采用对应的资源访问策略 --&gt; &lt;!-- 如果不采用任何前缀，则Spring将采用与该ApplicationContext相同的资源访问策略来访问资源 --&gt; &lt;property name=&quot;res&quot; value=&quot;classpath:atguigu.txt&quot;/&gt; &lt;/bean&gt;&lt;/beans&gt; 第三步 测试 1234567891011121314package com.atguigu.spring6.resouceloader;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class Demo4 &#123; public static void main(String[] args) &#123; ApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;bean.xml&quot;); ResourceBean resourceBean = ctx.getBean(&quot;resourceBean&quot;,ResourceBean.class); resourceBean.parse(); &#125;&#125; 8.8、应用程序上下文和资源路径8.8.1、概述不管以怎样的方式创建ApplicationContext实例，都需要为ApplicationContext指定配置文件，Spring允许使用一份或多分XML配置文件。当程序创建ApplicationContext实例时，通常也是以Resource的方式来访问配置文件的，所以ApplicationContext完全支持ClassPathResource、FileSystemResource、ServletContextResource等资源访问方式。 ApplicationContext确定资源访问策略通常有两种方法： （1）使用ApplicationContext实现类指定访问策略。 （2）使用前缀指定访问策略。 8.8.2、ApplicationContext实现类指定访问策略创建ApplicationContext对象时，通常可以使用如下实现类： （1） ClassPathXMLApplicationContext : 对应使用ClassPathResource进行资源访问。 （2）FileSystemXmlApplicationContext ： 对应使用FileSystemResource进行资源访问。 （3）XmlWebApplicationContext ： 对应使用ServletContextResource进行资源访问。 当使用ApplicationContext的不同实现类时，就意味着Spring使用响应的资源访问策略。 效果前面已经演示 8.8.3、使用前缀指定访问策略实验一：classpath前缀使用 12345678910111213141516171819202122package com.atguigu.spring6.context;import org.springframework.context.ApplicationContext;import org.springframework.context.support.FileSystemXmlApplicationContext;import org.springframework.core.io.Resource;public class Demo1 &#123; public static void main(String[] args) &#123; /* * 通过搜索文件系统路径下的xml文件创建ApplicationContext， * 但通过指定classpath:前缀强制搜索类加载路径 * classpath:bean.xml * */ ApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;classpath:bean.xml&quot;); System.out.println(ctx); Resource resource = ctx.getResource(&quot;atguigu.txt&quot;); System.out.println(resource.getFilename()); System.out.println(resource.getDescription()); &#125;&#125; 实验二：classpath通配符使用 classpath * :前缀提供了加载多个XML配置文件的能力，当使用classpath*:前缀来指定XML配置文件时，系统将搜索类加载路径，找到所有与文件名匹配的文件，分别加载文件中的配置定义，最后合并成一个ApplicationContext。 12ApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;classpath*:bean.xml&quot;);System.out.println(ctx); 当使用classpath * :前缀时，Spring将会搜索类加载路径下所有满足该规则的配置文件。 如果不是采用classpath * :前缀，而是改为使用classpath:前缀，Spring则只加载第一个符合条件的XML文件 注意 ： classpath * : 前缀仅对ApplicationContext有效。实际情况是，创建ApplicationContext时，分别访问多个配置文件(通过ClassLoader的getResource方法实现)。因此，classpath * :前缀不可用于Resource。 使用三：通配符其他使用 一次性加载多个配置文件的方式：指定配置文件时使用通配符 1ApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;classpath:bean*.xml&quot;); Spring允许将classpath*:前缀和通配符结合使用： 1ApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;classpath*:bean*.xml&quot;); 9、国际化：i18n 9.1、i18n概述国际化也称作i18n，其来源是英文单词 internationalization的首末字符i和n，18为中间的字符数。由于软件发行可能面向多个国家，对于不同国家的用户，软件显示不同语言的过程就是国际化。通常来讲，软件中的国际化是通过配置文件来实现的，假设要支撑两种语言，那么就需要两个版本的配置文件。 9.2、Java国际化（1）Java自身是支持国际化的，java.util.Locale用于指定当前用户所属的语言环境等信息，java.util.ResourceBundle用于查找绑定对应的资源文件。Locale包含了language信息和country信息，Locale创建默认locale对象时使用的静态方法： 12345678/** * This method must be called only for creating the Locale.* * constants due to making shortcuts. */private static Locale createConstant(String lang, String country) &#123; BaseLocale base = BaseLocale.createInstance(lang, country); return getInstance(base, null);&#125; （2）配置文件命名规则： basename_language_country.properties 必须遵循以上的命名规则，java才会识别。其中，basename是必须的，语言和国家是可选的。这里存在一个优先级概念，如果同时提供了messages.properties和messages_zh_CN.propertes两个配置文件，如果提供的locale符合en_CN，那么优先查找messages_en_CN.propertes配置文件，如果没查找到，再查找messages.properties配置文件。最后，提示下，所有的配置文件必须放在classpath中，一般放在resources目录下 （3）实验：演示Java国际化 第一步 创建子模块spring6-i18n，引入spring依赖 第二步 在resource目录下创建两个配置文件：messages_zh_CN.propertes和messages_en_GB.propertes 第三步 测试 12345678910111213141516package com.atguigu.spring6.javai18n;import java.nio.charset.StandardCharsets;import java.util.Locale;import java.util.ResourceBundle;public class Demo1 &#123; public static void main(String[] args) &#123; System.out.println(ResourceBundle.getBundle(&quot;messages&quot;, new Locale(&quot;en&quot;,&quot;GB&quot;)).getString(&quot;test&quot;)); System.out.println(ResourceBundle.getBundle(&quot;messages&quot;, new Locale(&quot;zh&quot;,&quot;CN&quot;)).getString(&quot;test&quot;)); &#125;&#125; 9.3、Spring6国际化9.3.1、MessageSource接口spring中国际化是通过MessageSource这个接口来支持的 常见实现类 ResourceBundleMessageSource 这个是基于Java的ResourceBundle基础类实现，允许仅通过资源名加载国际化资源 ReloadableResourceBundleMessageSource 这个功能和第一个类的功能类似，多了定时刷新功能，允许在不重启系统的情况下，更新资源的信息 StaticMessageSource 它允许通过编程的方式提供国际化信息，一会我们可以通过这个来实现db中存储国际化信息的功能。 9.3.2、使用Spring6国际化第一步 创建资源文件 国际化文件命名格式：基本名称 _ 语言 _ 国家.properties {0},{1}这样内容，就是动态参数 （1）创建atguigu_en_US.properties 1www.atguigu.com=welcome &#123;0&#125;,时间:&#123;1&#125; （2）创建atguigu_zh_CN.properties 1www.atguigu.com=欢迎 &#123;0&#125;,时间:&#123;1&#125; 第二步 创建spring配置文件，配置MessageSource 1234567891011121314151617&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id=&quot;messageSource&quot; class=&quot;org.springframework.context.support.ResourceBundleMessageSource&quot;&gt; &lt;property name=&quot;basenames&quot;&gt; &lt;list&gt; &lt;value&gt;atguigu&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;property name=&quot;defaultEncoding&quot;&gt; &lt;value&gt;utf-8&lt;/value&gt; &lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 第三步 创建测试类 1234567891011121314151617181920212223package com.atguigu.spring6.javai18n;import org.springframework.context.ApplicationContext;import org.springframework.context.annotation.AnnotationConfigApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;import java.util.Date;import java.util.Locale;public class Demo2 &#123; public static void main(String[] args) &#123; ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;); //传递动态参数，使用数组形式对应&#123;0&#125; &#123;1&#125;顺序 Object[] objs = new Object[]&#123;&quot;atguigu&quot;,new Date().toString()&#125;; //www.atguigu.com为资源文件的key值, //objs为资源文件value值所需要的参数,Local.CHINA为国际化为语言 String str=context.getMessage(&quot;www.atguigu.com&quot;, objs, Locale.CHINA); System.out.println(str); &#125;&#125; 10、数据校验：Validation 10.1、Spring Validation概述 在开发中，我们经常遇到参数校验的需求，比如用户注册的时候，要校验用户名不能为空、用户名长度不超过20个字符、手机号是合法的手机号格式等等。如果使用普通方式，我们会把校验的代码和真正的业务处理逻辑耦合在一起，而且如果未来要新增一种校验逻辑也需要在修改多个地方。而spring validation允许通过注解的方式来定义对象校验规则，把校验和业务逻辑分离开，让代码编写更加方便。Spring Validation其实就是对Hibernate Validator进一步的封装，方便在Spring中使用。 在Spring中有多种校验的方式 第一种是通过实现org.springframework.validation.Validator接口，然后在代码中调用这个类 第二种是按照Bean Validation方式来进行校验，即通过注解的方式。 第三种是基于方法实现校验 除此之外，还可以实现自定义校验 10.2、实验一：通过Validator接口实现第一步 创建子模块 spring6-validator 第二步 引入相关依赖 12345678910111213&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.hibernate.validator&lt;/groupId&gt; &lt;artifactId&gt;hibernate-validator&lt;/artifactId&gt; &lt;version&gt;7.0.5.Final&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.glassfish&lt;/groupId&gt; &lt;artifactId&gt;jakarta.el&lt;/artifactId&gt; &lt;version&gt;4.0.1&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 第三步 创建实体类，定义属性和方法 12345678910111213141516171819package com.atguigu.spring6.validation.method1;public class Person &#123; private String name; private int age; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125;&#125; 第四步 创建类实现Validator接口，实现接口方法指定校验规则 123456789101112131415161718192021222324package com.atguigu.spring6.validation.method1;import org.springframework.validation.Errors;import org.springframework.validation.ValidationUtils;import org.springframework.validation.Validator;public class PersonValidator implements Validator &#123; @Override public boolean supports(Class&lt;?&gt; clazz) &#123; return Person.class.equals(clazz); &#125; @Override public void validate(Object object, Errors errors) &#123; ValidationUtils.rejectIfEmpty(errors, &quot;name&quot;, &quot;name.empty&quot;); Person p = (Person) object; if (p.getAge() &lt; 0) &#123; errors.rejectValue(&quot;age&quot;, &quot;error value &lt; 0&quot;); &#125; else if (p.getAge() &gt; 110) &#123; errors.rejectValue(&quot;age&quot;, &quot;error value too old&quot;); &#125; &#125;&#125; 上面定义的类，其实就是实现接口中对应的方法， supports方法用来表示此校验用在哪个类型上， validate是设置校验逻辑的地点，其中ValidationUtils，是Spring封装的校验工具类，帮助快速实现校验。 第五步 使用上述Validator进行测试 123456789101112131415161718192021222324252627package com.atguigu.spring6.validation.method1;import org.springframework.validation.BindingResult;import org.springframework.validation.DataBinder;public class TestMethod1 &#123; public static void main(String[] args) &#123; //创建person对象 Person person = new Person(); person.setName(&quot;lucy&quot;); person.setAge(-1); // 创建Person对应的DataBinder DataBinder binder = new DataBinder(person); // 设置校验 binder.setValidator(new PersonValidator()); // 由于Person对象中的属性为空，所以校验不通过 binder.validate(); //输出结果 BindingResult results = binder.getBindingResult(); System.out.println(results.getAllErrors()); &#125;&#125; 10.3、实验二：Bean Validation注解实现使用Bean Validation校验方式，就是如何将Bean Validation需要使用的javax.validation.ValidatorFactory 和javax.validation.Validator注入到容器中。spring默认有一个实现类LocalValidatorFactoryBean，它实现了上面Bean Validation中的接口，并且也实现了org.springframework.validation.Validator接口。 第一步 创建配置类，配置LocalValidatorFactoryBean 123456789@Configuration@ComponentScan(&quot;com.atguigu.spring6.validation.method2&quot;)public class ValidationConfig &#123; @Bean public LocalValidatorFactoryBean validator() &#123; return new LocalValidatorFactoryBean(); &#125;&#125; 第二步 创建实体类，使用注解定义校验规则 12345678910111213141516171819202122232425262728package com.atguigu.spring6.validation.method2;import jakarta.validation.constraints.Max;import jakarta.validation.constraints.Min;import jakarta.validation.constraints.NotNull;public class User &#123; @NotNull private String name; @Min(0) @Max(120) private int age; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125;&#125; 常用注解说明@NotNull 限制必须不为null@NotEmpty 只作用于字符串类型，字符串不为空，并且长度不为0@NotBlank 只作用于字符串类型，字符串不为空，并且trim()后不为空串@DecimalMax(value) 限制必须为一个不大于指定值的数字@DecimalMin(value) 限制必须为一个不小于指定值的数字@Max(value) 限制必须为一个不大于指定值的数字@Min(value) 限制必须为一个不小于指定值的数字@Pattern(value) 限制必须符合指定的正则表达式@Size(max,min) 限制字符长度必须在min到max之间@Email 验证注解的元素值是Email，也可以通过正则表达式和flag指定自定义的email格式 第三步 使用两种不同的校验器实现 （1）使用jakarta.validation.Validator校验 1234567891011121314151617181920package com.atguigu.spring6.validation.method2;import jakarta.validation.ConstraintViolation;import jakarta.validation.Validator;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import java.util.Set;@Servicepublic class MyService1 &#123; @Autowired private Validator validator; public boolean validator(User user)&#123; Set&lt;ConstraintViolation&lt;User&gt;&gt; sets = validator.validate(user); return sets.isEmpty(); &#125;&#125; （2）使用org.springframework.validation.Validator校验 12345678910111213141516171819package com.atguigu.spring6.validation.method2;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import org.springframework.validation.BindException;import org.springframework.validation.Validator;@Servicepublic class MyService2 &#123; @Autowired private Validator validator; public boolean validaPersonByValidator(User user) &#123; BindException bindException = new BindException(user, user.getName()); validator.validate(user, bindException); return bindException.hasErrors(); &#125;&#125; 第四步 测试 123456789101112131415161718192021222324252627282930package com.atguigu.spring6.validation.method2;import org.junit.jupiter.api.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.annotation.AnnotationConfigApplicationContext;public class TestMethod2 &#123; @Test public void testMyService1() &#123; ApplicationContext context = new AnnotationConfigApplicationContext(ValidationConfig.class); MyService1 myService = context.getBean(MyService1.class); User user = new User(); user.setAge(-1); boolean validator = myService.validator(user); System.out.println(validator); &#125; @Test public void testMyService2() &#123; ApplicationContext context = new AnnotationConfigApplicationContext(ValidationConfig.class); MyService2 myService = context.getBean(MyService2.class); User user = new User(); user.setName(&quot;lucy&quot;); user.setAge(130); user.setAge(-1); boolean validator = myService.validaPersonByValidator(user); System.out.println(validator); &#125;&#125; 10.4、实验三：基于方法实现校验第一步 创建配置类，配置MethodValidationPostProcessor 1234567891011121314151617package com.atguigu.spring6.validation.method3;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.ComponentScan;import org.springframework.context.annotation.Configuration;import org.springframework.validation.beanvalidation.LocalValidatorFactoryBean;import org.springframework.validation.beanvalidation.MethodValidationPostProcessor;@Configuration@ComponentScan(&quot;com.atguigu.spring6.validation.method3&quot;)public class ValidationConfig &#123; @Bean public MethodValidationPostProcessor validationPostProcessor() &#123; return new MethodValidationPostProcessor(); &#125;&#125; 第二步 创建实体类，使用注解设置校验规则 123456789101112131415161718192021222324252627282930313233343536package com.atguigu.spring6.validation.method3;import jakarta.validation.constraints.*;public class User &#123; @NotNull private String name; @Min(0) @Max(120) private int age; @Pattern(regexp = &quot;^1(3|4|5|7|8)\\\\d&#123;9&#125;$&quot;,message = &quot;手机号码格式错误&quot;) @NotBlank(message = &quot;手机号码不能为空&quot;) private String phone; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public String getPhone() &#123; return phone; &#125; public void setPhone(String phone) &#123; this.phone = phone; &#125;&#125; 第三步 定义Service类，通过注解操作对象 12345678910111213141516package com.atguigu.spring6.validation.method3;import jakarta.validation.Valid;import jakarta.validation.constraints.NotNull;import org.springframework.stereotype.Service;import org.springframework.validation.annotation.Validated;@Service@Validatedpublic class MyService &#123; public String testParams(@NotNull @Valid User user) &#123; return user.toString(); &#125;&#125; 第四步 测试 1234567891011121314151617package com.atguigu.spring6.validation.method3;import org.junit.jupiter.api.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.annotation.AnnotationConfigApplicationContext;public class TestMethod3 &#123; @Test public void testMyService1() &#123; ApplicationContext context = new AnnotationConfigApplicationContext(ValidationConfig.class); MyService myService = context.getBean(MyService.class); User user = new User(); user.setAge(-1); myService.testParams(user); &#125;&#125; 10.5、实验四：实现自定义校验第一步 自定义校验注解 12345678910111213141516171819202122232425262728package com.atguigu.spring6.validation.method4;import jakarta.validation.Constraint;import jakarta.validation.Payload;import java.lang.annotation.*;@Target(&#123;ElementType.METHOD, ElementType.FIELD, ElementType.ANNOTATION_TYPE, ElementType.CONSTRUCTOR, ElementType.PARAMETER&#125;)@Retention(RetentionPolicy.RUNTIME)@Documented@Constraint(validatedBy = &#123;CannotBlankValidator.class&#125;)public @interface CannotBlank &#123; //默认错误消息 String message() default &quot;不能包含空格&quot;; //分组 Class&lt;?&gt;[] groups() default &#123;&#125;; //负载 Class&lt;? extends Payload&gt;[] payload() default &#123;&#125;; //指定多个时使用 @Target(&#123;ElementType.METHOD, ElementType.FIELD, ElementType.ANNOTATION_TYPE, ElementType.CONSTRUCTOR, ElementType.PARAMETER, ElementType.TYPE_USE&#125;) @Retention(RetentionPolicy.RUNTIME) @Documented @interface List &#123; CannotBlank[] value(); &#125;&#125; 第二步 编写真正的校验类 123456789101112131415161718192021222324252627package com.atguigu.spring6.validation.method4;import jakarta.validation.ConstraintValidator;import jakarta.validation.ConstraintValidatorContext;public class CannotBlankValidator implements ConstraintValidator&lt;CannotBlank, String&gt; &#123; @Override public void initialize(CannotBlank constraintAnnotation) &#123; &#125; @Override public boolean isValid(String value, ConstraintValidatorContext context) &#123; //null时不进行校验 if (value != null &amp;&amp; value.contains(&quot; &quot;)) &#123; //获取默认提示信息 String defaultConstraintMessageTemplate = context.getDefaultConstraintMessageTemplate(); System.out.println(&quot;default message :&quot; + defaultConstraintMessageTemplate); //禁用默认提示信息 context.disableDefaultConstraintViolation(); //设置提示语 context.buildConstraintViolationWithTemplate(&quot;can not contains blank&quot;).addConstraintViolation(); return false; &#125; return true; &#125;&#125; 11、提前编译：AOT 11.1、AOT概述11.1.1、JIT与AOT的区别JIT和AOT 这个名词是指两种不同的编译方式，这两种编译方式的主要区别在于是否在“运行时”进行编译 （1）JIT， Just-in-time,动态(即时)编译，边运行边编译； 在程序运行时，根据算法计算出热点代码，然后进行 JIT 实时编译，这种方式吞吐量高，有运行时性能加成，可以跑得更快，并可以做到动态生成代码等，但是相对启动速度较慢，并需要一定时间和调用频率才能触发 JIT 的分层机制。JIT 缺点就是编译需要占用运行时资源，会导致进程卡顿。 （2）AOT，Ahead Of Time，指运行前编译，预先编译。 AOT 编译能直接将源代码转化为机器码，内存占用低，启动速度快，可以无需 runtime 运行，直接将 runtime 静态链接至最终的程序中，但是无运行时性能加成，不能根据程序运行情况做进一步的优化，AOT 缺点就是在程序运行前编译会使程序安装的时间增加。 简单来讲：JIT即时编译指的是在程序的运行过程中，将字节码转换为可在硬件上直接运行的机器码，并部署至托管环境中的过程。而 AOT 编译指的则是，在程序运行之前，便将字节码转换为机器码的过程。 1.java -&gt; .class -&gt; (使用jaotc编译工具) -&gt; .so（程序函数库,即编译好的可以供其他程序使用的代码和数据） （3）AOT的优点 简单来讲，Java 虚拟机加载已经预编译成二进制库，可以直接执行。不必等待及时编译器的预热，减少 Java 应用给人带来“第一次运行慢” 的不良体验。 在程序运行前编译，可以避免在运行时的编译性能消耗和内存消耗可以在程序运行初期就达到最高性能，程序启动速度快运行产物只有机器码，打包体积小 AOT的缺点 由于是静态提前编译，不能根据硬件情况或程序运行情况择优选择机器指令序列，理论峰值性能不如JIT没有动态能力，同一份产物不能跨平台运行 第一种即时编译 (JIT) 是默认模式，Java Hotspot 虚拟机使用它在运行时将字节码转换为机器码。后者提前编译 (AOT)由新颖的 GraalVM 编译器支持，并允许在构建时将字节码直接静态编译为机器码。 现在正处于云原生，降本增效的时代，Java 相比于 Go、Rust 等其他编程语言非常大的弊端就是启动编译和启动进程非常慢，这对于根据实时计算资源，弹性扩缩容的云原生技术相冲突，Spring6 借助 AOT 技术在运行时内存占用低，启动速度快，逐渐的来满足 Java 在云原生时代的需求，对于大规模使用 Java 应用的商业公司可以考虑尽早调研使用 JDK17，通过云原生技术为公司实现降本增效。 11.1.2、GraalvmSpring6 支持的 AOT 技术，这个 GraalVM 就是底层的支持，Spring 也对 GraalVM 本机映像提供了一流的支持。GraalVM 是一种高性能 JDK，旨在加速用 Java 和其他 JVM 语言编写的应用程序的执行，同时还为 JavaScript、Python 和许多其他流行语言提供运行时。 GraalVM 提供两种运行 Java 应用程序的方法：在 HotSpot JVM 上使用 Graal 即时 (JIT) 编译器或作为提前 (AOT) 编译的本机可执行文件。 GraalVM 的多语言能力使得在单个应用程序中混合多种编程语言成为可能，同时消除了外语调用成本。GraalVM 向 HotSpot Java 虚拟机添加了一个用 Java 编写的高级即时 (JIT) 优化编译器。 GraalVM 具有以下特性： （1）一种高级优化编译器，它生成更快、更精简的代码，需要更少的计算资源 （2）AOT 本机图像编译提前将 Java 应用程序编译为本机二进制文件，立即启动，无需预热即可实现最高性能 （3）Polyglot 编程在单个应用程序中利用流行语言的最佳功能和库，无需额外开销 （4）高级工具在 Java 和多种语言中调试、监视、分析和优化资源消耗 总的来说对云原生的要求不算高短期内可以继续使用 2.7.X 的版本和 JDK8，不过 Spring 官方已经对 Spring6 进行了正式版发布。 11.1.3、Native Image目前业界除了这种在JVM中进行AOT的方案，还有另外一种实现Java AOT的思路，那就是直接摒弃JVM，和C&#x2F;C++一样通过编译器直接将代码编译成机器代码，然后运行。这无疑是一种直接颠覆Java语言设计的思路，那就是GraalVM Native Image。它通过C语言实现了一个超微缩的运行时组件 —— Substrate VM，基本实现了JVM的各种特性，但足够轻量、可以被轻松内嵌，这就让Java语言和工程摆脱JVM的限制，能够真正意义上实现和C&#x2F;C++一样的AOT编译。这一方案在经过长时间的优化和积累后，已经拥有非常不错的效果，基本上成为Oracle官方首推的Java AOT解决方案。Native Image 是一项创新技术，可将 Java 代码编译成独立的本机可执行文件或本机共享库。在构建本机可执行文件期间处理的 Java 字节码包括所有应用程序类、依赖项、第三方依赖库和任何所需的 JDK 类。生成的自包含本机可执行文件特定于不需要 JVM 的每个单独的操作系统和机器体系结构。 11.2、演示Native Image构建过程11.2.1、GraalVM安装（1）下载GraalVM进入官网下载：https://www.graalvm.org/downloads/ （2）配置环境变量添加GRAALVM_HOME 把JAVA_HOME修改为graalvm的位置 把Path修改位graalvm的bin位置 使用命令查看是否安装成功 （3）安装native-image插件使用命令 gu install native-image下载安装 11.2.2、安装C++的编译环境（1）下载Visual Studio安装软件https://visualstudio.microsoft.com/zh-hans/downloads/ （2）安装Visual Studio （3）添加Visual Studio环境变量配置INCLUDE、LIB和Path （4）打开工具，在工具中操作 11.2.3、编写代码，构建Native Image（1）编写Java代码123456public class Hello &#123; public static void main(String[] args) &#123; System.out.println(&quot;hello world&quot;); &#125;&#125; （2）复制文件到目录，执行编译 （3）Native Image 进行构建 （4）查看构建的文件 （5）执行构建的文件 可以看到这个Hello最终打包产出的二进制文件大小为11M，这是包含了SVM和JDK各种库后的大小，虽然相比C&#x2F;C++的二进制文件来说体积偏大，但是对比完整JVM来说，可以说是已经是非常小了。 相比于使用JVM运行，Native Image的速度要快上不少，cpu占用也更低一些，从官方提供的各类实验数据也可以看出Native Image对于启动速度和内存占用带来的提升是非常显著的：","categories":[{"name":"Spring6","slug":"Spring6","permalink":"http://example.com/categories/Spring6/"}],"tags":[{"name":"框架","slug":"框架","permalink":"http://example.com/tags/%E6%A1%86%E6%9E%B6/"}]},{"title":"page","slug":"page","date":"2021-09-27T23:55:54.000Z","updated":"2023-09-28T00:28:56.682Z","comments":true,"path":"2021/09/28/page/","link":"","permalink":"http://example.com/2021/09/28/page/","excerpt":"","text":"","categories":[],"tags":[]}],"categories":[{"name":"程序猿","slug":"程序猿","permalink":"http://example.com/categories/%E7%A8%8B%E5%BA%8F%E7%8C%BF/"},{"name":"SSM框架","slug":"SSM框架","permalink":"http://example.com/categories/SSM%E6%A1%86%E6%9E%B6/"},{"name":"Spring6","slug":"Spring6","permalink":"http://example.com/categories/Spring6/"}],"tags":[{"name":"经验","slug":"经验","permalink":"http://example.com/tags/%E7%BB%8F%E9%AA%8C/"},{"name":"ssm","slug":"ssm","permalink":"http://example.com/tags/ssm/"},{"name":"框架","slug":"框架","permalink":"http://example.com/tags/%E6%A1%86%E6%9E%B6/"}]}