{"meta":{"title":"tianfeng","subtitle":"","description":"","author":"Tian Feng","url":"http://example.com","root":"/"},"pages":[{"title":"书单","date":"2023-09-27T14:03:34.980Z","updated":"2022-03-21T07:18:46.000Z","comments":false,"path":"books/index.html","permalink":"http://example.com/books/index.html","excerpt":"","text":""},{"title":"关于","date":"2023-09-28T08:45:21.646Z","updated":"2023-09-28T08:45:21.646Z","comments":false,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"个人详细介绍 1234567891011121314151617181920212223242526272829303132&#123; name: &#x27;tianfeng&#x27; age: 25, gender: &#x27;男&#x27;, profession: &#x27;计算机技术&#x27;, experience: &#x27;5年&#x27;, address: &#x27;陕西省西安市&#x27;, education: &#x27;硕士&#x27;, github: &#x27;https://github.com/cofess&#x27;, blog: &#x27;https://fengtien.github.io/&#x27;, email: &#x27;723544546@qq.com&#x27;, description: &#x27;致力于网站建设与前后端用户体验设计&#x27;, skills: [ [&#x27;Html&#x27;, &#x27;Javascript&#x27;, &#x27;jQuery&#x27;, &#x27;CSS&#x27;, &#x27;ES6&#x27;, &#x27;Node&#x27;], [&#x27;Webpack&#x27;, &#x27;Gulp&#x27;], [&#x27;Less&#x27;,&#x27;Sass&#x27;], [&#x27;Git&#x27;, &#x27;SVN&#x27;], [&#x27;Vue&#x27;], [&#x27;Bootstrap&#x27;, &#x27;SUI Mobile&#x27;, &#x27;light7&#x27;], [&#x27;WordPress&#x27;, &#x27;OpenCart&#x27;], [&#x27;平面设计&#x27;] ], devTools: [ [&#x27;Sublime Text&#x27;, &#x27;Visual Studio Code&#x27;, &#x27;Notepad++&#x27;], [&#x27;Chrome DevTools&#x27;, &#x27;Fiddler&#x27;], [&#x27;SourceTree&#x27;, &#x27;TortoiseSVN&#x27;], [&#x27;SwitchHosts&#x27;], [&#x27;Navicat&#x27;, &#x27;XAMPP&#x27;], ] &#125;"},{"title":"分类","date":"2023-09-27T13:39:49.782Z","updated":"2022-03-21T07:18:46.000Z","comments":false,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"404 Not Found：该页无法显示","date":"2023-09-27T13:09:00.666Z","updated":"2022-03-21T07:18:46.000Z","comments":false,"path":"/404.html","permalink":"http://example.com/404.html","excerpt":"","text":""},{"title":"友情链接","date":"2023-09-27T16:33:32.977Z","updated":"2022-03-21T07:18:46.000Z","comments":true,"path":"links/index.html","permalink":"http://example.com/links/index.html","excerpt":"","text":""},{"title":"标签","date":"2023-09-27T13:09:00.666Z","updated":"2022-03-21T07:18:46.000Z","comments":false,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2023-09-28T00:46:50.774Z","updated":"2022-03-21T07:18:46.000Z","comments":false,"path":"repository/index.html","permalink":"http://example.com/repository/index.html","excerpt":"","text":""}],"posts":[{"title":"","slug":"Java/尚硅谷_第02章_变量与运算符/images/Untitled 1","date":"2023-10-07T11:18:35.024Z","updated":"2023-08-01T13:41:07.013Z","comments":true,"path":"2023/10/07/Java/尚硅谷_第02章_变量与运算符/images/Untitled 1/","link":"","permalink":"http://example.com/2023/10/07/Java/%E5%B0%9A%E7%A1%85%E8%B0%B7_%E7%AC%AC02%E7%AB%A0_%E5%8F%98%E9%87%8F%E4%B8%8E%E8%BF%90%E7%AE%97%E7%AC%A6/images/Untitled%201/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"","slug":"Java/尚硅谷_第02章_变量与运算符/images/Untitled","date":"2023-10-07T11:18:35.024Z","updated":"2023-08-01T13:41:06.007Z","comments":true,"path":"2023/10/07/Java/尚硅谷_第02章_变量与运算符/images/Untitled/","link":"","permalink":"http://example.com/2023/10/07/Java/%E5%B0%9A%E7%A1%85%E8%B0%B7_%E7%AC%AC02%E7%AB%A0_%E5%8F%98%E9%87%8F%E4%B8%8E%E8%BF%90%E7%AE%97%E7%AC%A6/images/Untitled/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"","slug":"Java/尚硅谷_第18章_JDK8-17新特性/尚硅谷_宋红康_第18章_JDK8-17新特性（下）","date":"2023-10-07T11:18:34.274Z","updated":"2022-12-27T10:21:04.988Z","comments":true,"path":"2023/10/07/Java/尚硅谷_第18章_JDK8-17新特性/尚硅谷_宋红康_第18章_JDK8-17新特性（下）/","link":"","permalink":"http://example.com/2023/10/07/Java/%E5%B0%9A%E7%A1%85%E8%B0%B7_%E7%AC%AC18%E7%AB%A0_JDK8-17%E6%96%B0%E7%89%B9%E6%80%A7/%E5%B0%9A%E7%A1%85%E8%B0%B7_%E5%AE%8B%E7%BA%A2%E5%BA%B7_%E7%AC%AC18%E7%AB%A0_JDK8-17%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%88%E4%B8%8B%EF%BC%89/","excerpt":"","text":"第18章_JDK8-17新特性（下）讲师：尚硅谷-宋红康（江湖人称：康师傅） 官网：http://www.atguigu.com 6. 新语法结构新的语法结构，为我们勾勒出了 Java 语法进化的一个趋势，将开发者从复杂、繁琐的低层次抽象中逐渐解放出来，以更高层次、更优雅的抽象，既降低代码量，又避免意外编程错误的出现，进而提高代码质量和开发效率。 6.1 Java的REPL工具： jShell命令JDK9的新特性 Java 终于拥有了像Python 和 Scala 之类语言的REPL工具（交互式编程环境，read - evaluate - print - loop）：jShell。以交互式的方式对语句和表达式进行求值。即写即得、快速运行。 利用jShell在没有创建类的情况下，在命令行里直接声明变量，计算表达式，执行语句。无需跟人解释”public static void main(String[] args)”这句”废话”。 使用举例 调出jShell 获取帮助 基本使用 导入指定的包 默认已经导入如下的所有包：（包含java.lang包） 只需按下 Tab 键，就能自动补全代码 列出当前 session 里所有有效的代码片段 查看当前 session 下所有创建过的变量 查看当前 session 下所有创建过的方法 Tips：我们还可以重新定义相同方法名和参数列表的方法，即对现有方法的修改（或覆盖）。 使用外部代码编辑器来编写 Java 代码 从外部文件加载源代码【HelloWorld.java】 12345678/** * Created by songhongkang */public void printHello() &#123; System.out.println(&quot;马上2023年了，尚硅谷祝所有的谷粉元旦快乐！&quot;);&#125;printHello(); 使用&#x2F;open命令调用 退出jShell 6.2 异常处理之try-catch资源关闭在JDK7 之前，我们这样处理资源的关闭： 1234567891011121314151617181920212223242526272829@Testpublic void test01() &#123; FileWriter fw = null; BufferedWriter bw = null; try &#123; fw = new FileWriter(&quot;d:/1.txt&quot;); bw = new BufferedWriter(fw); bw.write(&quot;hello&quot;); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; if (bw != null) &#123; bw.close(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; try &#123; if (fw != null) &#123; fw.close(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; JDK7的新特性 在try的后面可以增加一个()，在括号中可以声明流对象并初始化。try中的代码执行完毕，会自动把流对象释放，就不用写finally了。 格式： 1234567try(资源对象的声明和初始化)&#123; 业务逻辑代码,可能会产生异常&#125;catch(异常类型1 e)&#123; 处理异常代码&#125;catch(异常类型2 e)&#123; 处理异常代码&#125; 说明： 1、在try()中声明的资源，无论是否发生异常，无论是否处理异常，都会自动关闭资源对象，不用手动关闭了。 2、这些资源实现类必须实现AutoCloseable或Closeable接口，实现其中的close()方法。Closeable是AutoCloseable的子接口。Java7几乎把所有的“资源类”（包括文件IO的各种类、JDBC编程的Connection、Statement等接口…）都进行了改写，改写后资源类都实现了AutoCloseable或Closeable接口，并实现了close()方法。 3、写到try()中的资源类的变量默认是final声明的，不能修改。 举例： 12345678910111213141516171819202122232425262728293031323334353637//举例1@Testpublic void test02() &#123; try ( FileWriter fw = new FileWriter(&quot;d:/1.txt&quot;); BufferedWriter bw = new BufferedWriter(fw); ) &#123; bw.write(&quot;hello&quot;); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;&#125;//举例2@Testpublic void test03() &#123; //从d:/1.txt(utf-8)文件中，读取内容，写到项目根目录下1.txt(gbk)文件中 try ( FileInputStream fis = new FileInputStream(&quot;d:/1.txt&quot;); InputStreamReader isr = new InputStreamReader(fis, &quot;utf-8&quot;); BufferedReader br = new BufferedReader(isr); FileOutputStream fos = new FileOutputStream(&quot;1.txt&quot;); OutputStreamWriter osw = new OutputStreamWriter(fos, &quot;gbk&quot;); BufferedWriter bw = new BufferedWriter(osw); ) &#123; String str; while ((str = br.readLine()) != null) &#123; bw.write(str); bw.newLine(); &#125; &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;&#125; JDK9的新特性 try的前面可以定义流对象，try后面的()中可以直接引用流对象的名称。在try代码执行完毕后，流对象也可以释放掉，也不用写finally了。 格式： 1234567A a = new A();B b = new B();try(a;b)&#123; 可能产生的异常代码&#125;catch(异常类名 变量名)&#123; 异常处理的逻辑&#125; 举例： 123456789101112@Testpublic void test04() &#123; InputStreamReader reader = new InputStreamReader(System.in); OutputStreamWriter writer = new OutputStreamWriter(System.out); try (reader; writer) &#123; //reader是final的，不可再被赋值 // reader = null; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;&#125; 6.3 局部变量类型推断JDK 10的新特性 局部变量的显示类型声明，常常被认为是不必须的，给一个好听的名字反而可以很清楚的表达出下面应该怎样继续。本新特性允许开发人员省略通常不必要的局部变量类型声明，以增强Java语言的体验性、可读性。 使用举例 12345678910111213141516171819//1.局部变量的实例化var list = new ArrayList&lt;String&gt;();var set = new LinkedHashSet&lt;Integer&gt;();//2.增强for循环中的索引for (var v : list) &#123; System.out.println(v);&#125;//3.传统for循环中for (var i = 0; i &lt; 100; i++) &#123; System.out.println(i);&#125;//4. 返回值类型含复杂泛型结构var iterator = set.iterator();//Iterator&lt;Map.Entry&lt;Integer, Student&gt;&gt; iterator = set.iterator(); 不适用场景 声明一个成员变量 声明一个数组变量，并为数组静态初始化（省略new的情况下） 方法的返回值类型 方法的参数类型 没有初始化的方法内的局部变量声明 作为catch块中异常类型 Lambda表达式中函数式接口的类型 方法引用中函数式接口的类型 代码举例： 声明一个成员变量，并初始化值为null 声明一个数组变量，并为数组静态初始化（省略new的情况下） 没有初始化的方法内的局部变量声明 方法的返回值类型 方法的参数类型 构造器的参数类型 作为catch块中异常类型 Lambda表达式中函数式接口的类型 方法引用中函数式接口的类型 注意： var不是一个关键字，而是一个类型名，将它作为变量的类型。不能使用var作为类名。 这不是JavaScript。var并不会改变 Java是一门静态类型语言的事实。编译器负责推断出类型，并把结果写入字节码文件，就好像是开发人员自己敲入类型一样。 6.4 instanceof的模式匹配JDK14中预览特性： instanceof 模式匹配通过提供更为简便的语法，来提高生产力。有了该功能，可以减少Java程序中显式强制转换的数量，实现更精确、简洁的类型安全的代码。 Java 14之前旧写法： 123456if(obj instanceof String)&#123; String str = (String)obj; //需要强转 .. str.contains(..)..&#125;else&#123; ...&#125; Java 14新特性写法： 12345if(obj instanceof String str)&#123; .. str.contains(..)..&#125;else&#123; ...&#125; 举例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465/** * instanceof的模式匹配（预览） * * @author shkstart * @create 上午 11:32 */public class Feature01 &#123; @Test public void test1()&#123; Object obj = new String(&quot;hello,Java14&quot;); obj = null;//在使用null 匹配instanceof 时，返回都是false. if(obj instanceof String)&#123; String str = (String) obj; System.out.println(str.contains(&quot;Java&quot;)); &#125;else&#123; System.out.println(&quot;非String类型&quot;); &#125; //举例1： if(obj instanceof String str)&#123; //新特性：省去了强制类型转换的过程 System.out.println(str.contains(&quot;Java&quot;)); &#125;else&#123; System.out.println(&quot;非String类型&quot;); &#125; &#125;&#125;// 举例2class InstanceOf&#123; String str = &quot;abc&quot;; public void test(Object obj)&#123; if(obj instanceof String str)&#123;//此时的str的作用域仅限于if结构内。 System.out.println(str.toUpperCase()); &#125;else&#123; System.out.println(str.toLowerCase()); &#125; &#125;&#125;//举例3：class Monitor&#123; private String model; private double price;// public boolean equals(Object o)&#123;// if(o instanceof Monitor other)&#123;// if(model.equals(other.model) &amp;&amp; price == other.price)&#123;// return true;// &#125;// &#125;// return false;// &#125; public boolean equals(Object o)&#123; return o instanceof Monitor other &amp;&amp; model.equals(other.model) &amp;&amp; price == other.price; &#125;&#125; JDK15中第二次预览： 没有任何更改。 JDK16中转正特性： 在Java16中转正。 6.5 switch表达式传统switch声明语句的弊端： 匹配是自上而下的，如果忘记写break，后面的case语句不论匹配与否都会执行； —&gt;case穿透 所有的case语句共用一个块范围，在不同的case语句定义的变量名不能重复； 不能在一个case里写多个执行结果一致的条件； 整个switch不能作为表达式返回值； 1234567891011121314151617//常见错误实现switch(month)&#123; case 3|4|5://3|4|5 用了位运算符，11 | 100 | 101结果是 111是7 System.out.println(&quot;春季&quot;); break; case 6|7|8://6|7|8用了位运算符，110 | 111 | 1000结果是1111是15 System.out.println(&quot;夏季&quot;); break; case 9|10|11://9|10|11用了位运算符，1001 | 1010 | 1011结果是1011是11 System.out.println(&quot;秋季&quot;); break; case 12|1|2://12|1|2 用了位运算符，1100 | 1 | 10 结果是1111，是15 System.out.println(&quot;冬季&quot;); break; default: System.out.println(&quot;输入有误&quot;);&#125; JDK12中预览特性： Java 12将会对switch声明语句进行扩展，使用case L -&gt;来替代以前的break;，省去了 break 语句，避免了因少写 break 而出错。 同时将多个 case 合并到一行，显得简洁、清晰，也更加优雅的表达逻辑分支。 为了保持兼容性，case 条件语句中依然可以使用字符 : ，但是同一个 switch 结构里不能混用 -&gt; 和 : ，否则编译错误。 举例： Java 12之前 12345678910111213141516171819202122232425262728293031/** * @author shkstart * @create 下午 4:47 */public class SwitchTest &#123; public static void main(String[] args) &#123; int numberOfLetters; Fruit fruit = Fruit.APPLE; switch (fruit) &#123; case PEAR: numberOfLetters = 4; break; case APPLE: case GRAPE: case MANGO: numberOfLetters = 5; break; case ORANGE: case PAPAYA: numberOfLetters = 6; break; default: throw new IllegalStateException(&quot;No Such Fruit:&quot; + fruit); &#125; System.out.println(numberOfLetters); &#125;&#125;enum Fruit &#123; PEAR, APPLE, GRAPE, MANGO, ORANGE, PAPAYA;&#125; switch 语句如果漏写了一个 break，那么逻辑往往就跑偏了，这种方式既繁琐，又容易出错。 Java 12中： 123456789101112131415/** * @author shkstart * @create 下午 10:38 */public class SwitchTest1 &#123; public static void main(String[] args) &#123; Fruit fruit = Fruit.GRAPE; switch(fruit)&#123; case PEAR -&gt; System.out.println(4); case APPLE,MANGO,GRAPE -&gt; System.out.println(5); case ORANGE,PAPAYA -&gt; System.out.println(6); default -&gt; throw new IllegalStateException(&quot;No Such Fruit:&quot; + fruit); &#125;; &#125;&#125; 更进一步： 12345678910111213141516/** * @author shkstart * @create 2019 下午 10:44 */public class SwitchTest2 &#123; public static void main(String[] args) &#123; Fruit fruit = Fruit.GRAPE; int numberOfLetters = switch(fruit)&#123; case PEAR -&gt; 4; case APPLE,MANGO,GRAPE -&gt; 5; case ORANGE,PAPAYA -&gt; 6; default -&gt; throw new IllegalStateException(&quot;No Such Fruit:&quot; + fruit); &#125;; System.out.println(numberOfLetters); &#125;&#125; JDK13中二次预览特性： JDK13中引入了yield语句，用于返回值。这意味着，switch表达式(返回值)应该使用yield，switch语句(不返回值)应该使用break。 yield和return的区别在于：return会直接跳出当前循环或者方法，而yield只会跳出当前switch块。 在以前： 1234567891011121314151617@Testpublic void testSwitch1()&#123; String x = &quot;3&quot;; int i; switch (x) &#123; case &quot;1&quot;: i=1; break; case &quot;2&quot;: i=2; break; default: i = x.length(); break; &#125; System.out.println(i);&#125; 在JDK13中： 123456789101112@Testpublic void testSwitch2()&#123; String x = &quot;3&quot;; int i = switch (x) &#123; case &quot;1&quot; -&gt; 1; case &quot;2&quot; -&gt; 2; default -&gt; &#123; yield 3; &#125; &#125;; System.out.println(i);&#125; 或者 12345678910111213@Testpublic void testSwitch3() &#123; String x = &quot;3&quot;; int i = switch (x) &#123; case &quot;1&quot;: yield 1; case &quot;2&quot;: yield 2; default: yield 3; &#125;; System.out.println(i);&#125; JDK14中转正特性： 这是JDK 12和JDK 13中的预览特性，现在是正式特性了。 JDK17的预览特性：switch的模式匹配 旧写法： 12345678910111213static String formatter(Object o) &#123; String formatted = &quot;unknown&quot;; if (o instanceof Integer i) &#123; formatted = String.format(&quot;int %d&quot;, i); &#125; else if (o instanceof Long l) &#123; formatted = String.format(&quot;long %d&quot;, l); &#125; else if (o instanceof Double d) &#123; formatted = String.format(&quot;double %f&quot;, d); &#125; else if (o instanceof String s) &#123; formatted = String.format(&quot;String %s&quot;, s); &#125; return formatted;&#125; 模式匹配新写法： 123456789static String formatterPatternSwitch(Object o) &#123; return switch (o) &#123; case Integer i -&gt; String.format(&quot;int %d&quot;, i); case Long l -&gt; String.format(&quot;long %d&quot;, l); case Double d -&gt; String.format(&quot;double %f&quot;, d); case String s -&gt; String.format(&quot;String %s&quot;, s); default -&gt; o.toString(); &#125;;&#125; 直接在 switch 上支持 Object 类型，这就等于同时支持多种类型，使用模式匹配得到具体类型，大大简化了语法量，这个功能很实用。 6.6 文本块现实问题： 在Java中，通常需要使用String类型表达HTML，XML，SQL或JSON等格式的字符串，在进行字符串赋值时需要进行转义和连接操作，然后才能编译该代码，这种表达方式难以阅读并且难以维护。 JDK13的新特性 使用”””作为文本块的开始符和结束符，在其中就可以放置多行的字符串，不需要进行任何转义。因此，文本块将提高Java程序的可读性和可写性。 基本使用： 12345&quot;&quot;&quot;line1line2line3&quot;&quot;&quot; 相当于： 1&quot;line1\\nline2\\nline3\\n&quot; 或者一个连接的字符串： 123&quot;line1\\n&quot; +&quot;line2\\n&quot; +&quot;line3\\n&quot; 如果字符串末尾不需要行终止符，则结束分隔符可以放在最后一行内容上。例如： 1234&quot;&quot;&quot;line1line2line3&quot;&quot;&quot; 相当于 1&quot;line1\\nline2\\nline3&quot; 文本块可以表示空字符串，但不建议这样做，因为它需要两行源代码： 12String empty = &quot;&quot;&quot;&quot;&quot;&quot;; 举例1：普通文本 原有写法： 12345678910 String text1 = &quot;The Sound of silence\\n&quot; + &quot;Hello darkness, my old friend\\n&quot; + &quot;I&#x27;ve come to talk with you again\\n&quot; + &quot;Because a vision softly creeping\\n&quot; + &quot;Left its seeds while I was sleeping\\n&quot; + &quot;And the vision that was planted in my brain\\n&quot; + &quot;Still remains\\n&quot; + &quot;Within the sound of silence&quot;;System.out.println(text1); 使用新特性： 1234567891011String text2 = &quot;&quot;&quot; The Sound of silence Hello darkness, my old friend I&#x27;ve come to talk with you again Because a vision softly creeping Left its seeds while I was sleeping And the vision that was planted in my brain Still remains Within the sound of silence &quot;&quot;&quot;;System.out.println(text2); 举例2：HTML语句 12345&lt;html&gt; &lt;body&gt; &lt;p&gt;Hello, 尚硅谷&lt;/p&gt; &lt;/body&gt;&lt;/html&gt; 将其复制到Java的字符串中，会展示成以下内容： 12345&quot;&lt;html&gt;\\n&quot; +&quot; &lt;body&gt;\\n&quot; +&quot; &lt;p&gt;Hello, 尚硅谷&lt;/p&gt;\\n&quot; +&quot; &lt;/body&gt;\\n&quot; +&quot;&lt;/html&gt;\\n&quot;; 即被自动进行了转义，这样的字符串看起来不是很直观，在JDK 13中： 1234567&quot;&quot;&quot;&lt;html&gt; &lt;body&gt; &lt;p&gt;Hello, world&lt;/p&gt; &lt;/body&gt;&lt;/html&gt;&quot;&quot;&quot;; 举例3：SQL语句 1234select employee_id,last_name,salary,department_idfrom employeeswhere department_id in (40,50,60)order by department_id asc 原有方式： 1234String sql = &quot;SELECT id,NAME,email\\n&quot; + &quot;FROM customers\\n&quot; + &quot;WHERE id &gt; 4\\n&quot; + &quot;ORDER BY email DESC&quot;; 使用新特性： 123456String sql1 = &quot;&quot;&quot; SELECT id,NAME,email FROM customers WHERE id &gt; 4 ORDER BY email DESC &quot;&quot;&quot;; 举例4：JSON字符串 原有方式： 123456String myJson = &quot;&#123;\\n&quot; + &quot; \\&quot;name\\&quot;:\\&quot;Song Hongkang\\&quot;,\\n&quot; + &quot; \\&quot;address\\&quot;:\\&quot;www.atguigu.com\\&quot;,\\n&quot; + &quot; \\&quot;email\\&quot;:\\&quot;shkstart@126.com\\&quot;\\n&quot; + &quot;&#125;&quot;;System.out.println(myJson); 使用新特性： 1234567String myJson1 = &quot;&quot;&quot; &#123; &quot;name&quot;:&quot;Song Hongkang&quot;, &quot;address&quot;:&quot;www.atguigu.com&quot;, &quot;email&quot;:&quot;shkstart@126.com&quot; &#125;&quot;&quot;&quot;;System.out.println(myJson1); JDK14中二次预览特性 JDK14的版本主要增加了两个escape sequences，分别是 \\ &lt;line-terminator&gt;与\\s escape sequence。 举例： 123456789101112131415161718192021222324252627/** * @author shkstart * @create 下午 7:13 */public class Feature05 &#123; //jdk14新特性 @Test public void test5()&#123; String sql1 = &quot;&quot;&quot; SELECT id,NAME,email FROM customers WHERE id &gt; 4 ORDER BY email DESC &quot;&quot;&quot;; System.out.println(sql1); // \\:取消换行操作 // \\s:表示一个空格 String sql2 = &quot;&quot;&quot; SELECT id,NAME,email \\ FROM customers\\s\\ WHERE id &gt; 4 \\ ORDER BY email DESC &quot;&quot;&quot;; System.out.println(sql2); &#125;&#125; JDK15中功能转正 6.7 Record背景 早在2019年2月份，Java 语言架构师 Brian Goetz，曾写文抱怨“Java太啰嗦”或有太多的“繁文缛节”。他提到：开发人员想要创建纯数据载体类（plain data carriers）通常都必须编写大量低价值、重复的、容易出错的代码。如：构造函数、getter&#x2F;setter、equals()、hashCode()以及toString()等。 以至于很多人选择使用IDE的功能来自动生成这些代码。还有一些开发会选择使用一些第三方类库，如Lombok等来生成这些方法。 JDK14中预览特性：神说要用record，于是就有了。实现一个简单的数据载体类，为了避免编写：构造函数，访问器，equals()，hashCode () ，toString ()等，Java 14推出record。 record 是一种全新的类型，它本质上是一个 final 类，同时所有的属性都是 final 修饰，它会自动编译出 public get 、hashcode 、equals、toString、构造器等结构，减少了代码编写量。 具体来说：当你用record 声明一个类时，该类将自动拥有以下功能： 获取成员变量的简单方法，比如例题中的 name() 和 partner() 。注意区别于我们平常getter()的写法。 一个 equals 方法的实现，执行比较时会比较该类的所有成员属性。 重写 hashCode() 方法。 一个可以打印该类所有成员属性的 toString() 方法。 只有一个构造方法。 此外： 还可以在record声明的类中定义静态字段、静态方法、构造器或实例方法。 不能在record声明的类中定义实例字段；类不能声明为abstract；不能声明显式的父类等。 举例1（旧写法）： 1234567891011121314151617181920212223242526272829303132333435class Point &#123; private final int x; private final int y; Point(int x, int y) &#123; this.x = x; this.y = y; &#125; int x() &#123; return x; &#125; int y() &#123; return y; &#125; public boolean equals(Object o) &#123; if (!(o instanceof Point)) return false; Point other = (Point) o; return other.x == x &amp;&amp; other.y == y; &#125; public int hashCode() &#123; return Objects.hash(x, y); &#125; @Override public String toString() &#123; return &quot;Point&#123;&quot; + &quot;x=&quot; + x + &quot;, y=&quot; + y + &#x27;&#125;&#x27;; &#125;&#125; 举例1（新写法）： 1record Point(int x, int y) &#123; &#125; 举例1： 12public record Dog(String name, Integer age) &#123;&#125; 1234567891011public class Java14Record &#123; public static void main(String[] args) &#123; Dog dog1 = new Dog(&quot;牧羊犬&quot;, 1); Dog dog2 = new Dog(&quot;田园犬&quot;, 2); Dog dog3 = new Dog(&quot;哈士奇&quot;, 3); System.out.println(dog1); System.out.println(dog2); System.out.println(dog3); &#125;&#125; 举例2： 12345678910111213141516171819202122232425262728293031323334353637383940414243/** * Record类型的演示 * * @author shkstart * @create 下午 6:13 */public class Feature07 &#123; @Test public void test1()&#123; //测试构造器 Person p1 = new Person(&quot;罗密欧&quot;,new Person(&quot;zhuliye&quot;,null)); //测试toString() System.out.println(p1); //测试equals(): Person p2 = new Person(&quot;罗密欧&quot;,new Person(&quot;zhuliye&quot;,null)); System.out.println(p1.equals(p2)); //测试hashCode()和equals() HashSet&lt;Person&gt; set = new HashSet&lt;&gt;(); set.add(p1); set.add(p2); for (Person person : set) &#123; System.out.println(person); &#125; //测试name()和partner():类似于getName()和getPartner() System.out.println(p1.name()); System.out.println(p1.partner()); &#125; @Test public void test2()&#123; Person p1 = new Person(&quot;zhuyingtai&quot;); System.out.println(p1.getNameInUpperCase()); Person.nation = &quot;CHN&quot;; System.out.println(Person.showNation()); &#125;&#125; 12345678910111213141516171819202122232425262728293031323334/** * @author shkstart * @create 下午 6:20 */public record Person(String name,Person partner) &#123; //还可以声明静态的属性、静态的方法、构造器、实例方法 public static String nation; public static String showNation()&#123; return nation; &#125; public Person(String name)&#123; this(name,null); &#125; public String getNameInUpperCase()&#123; return name.toUpperCase(); &#125; //不可以声明非静态的属性// private int id;//报错&#125;//不可以将record定义的类声明为abstract的//abstract record Order()&#123;////&#125;//不可以给record定义的类声明显式的父类（非Record类）//record Order() extends Thread&#123;////&#125; JDK15中第二次预览特性 JDK16中转正特性 最终到JDK16中转正。 记录不适合哪些场景 record的设计目标是提供一种将数据建模为数据的好方法。它也不是 JavaBeans 的直接替代品，因为record的方法不符合 JavaBeans 的 get 标准。另外 JavaBeans 通常是可变的，而记录是不可变的。尽管它们的用途有点像，但记录并不会以某种方式取代 JavaBean。 6.8 密封类背景： 在 Java 中如果想让一个类不能被继承和修改，这时我们应该使用 final 关键字对类进行修饰。不过这种要么可以继承，要么不能继承的机制不够灵活，有些时候我们可能想让某个类可以被某些类型继承，但是又不能随意继承，是做不到的。Java 15 尝试解决这个问题，引入了 sealed 类，被 sealed 修饰的类可以指定子类。这样这个类就只能被指定的类继承。 JDK15的预览特性： 通过密封的类和接口来限制超类的使用，密封的类和接口限制其它可能继承或实现它们的其它类或接口。 具体使用： 使用修饰符sealed，可以将一个类声明为密封类。密封的类使用保留关键字permits列出可以直接扩展（即extends）它的类。 sealed 修饰的类的机制具有传递性，它的子类必须使用指定的关键字进行修饰，且只能是 final、sealed、non-sealed 三者之一。 举例： 123456789101112package com.atguigu.java;public abstract sealed class Shape permits Circle, Rectangle, Square &#123;...&#125;public final class Circle extends Shape &#123;...&#125; //final表示Circle不能再被继承了public sealed class Rectangle extends Shape permits TransparentRectangle, FilledRectangle &#123;...&#125;public final class TransparentRectangle extends Rectangle &#123;...&#125;public final class FilledRectangle extends Rectangle &#123;...&#125;public non-sealed class Square extends Shape &#123;...&#125; //non-sealed表示可以允许任何类继承 JDK16二次预览特性 JDK17中转正特性 7. API的变化7.1 Optional类JDK8的新特性 到目前为止，臭名昭著的空指针异常是导致Java应用程序失败的最常见原因。以前，为了解决空指针异常，Google在著名的Guava项目引入了Optional类，通过检查空值的方式避免空指针异常。受到Google的启发，Optional类已经成为Java 8类库的一部分。 Optional&lt;T&gt; 类(java.util.Optional) 是一个容器类，它可以保存类型T的值，代表这个值存在。或者仅仅保存null，表示这个值不存在。如果值存在，则isPresent()方法会返回true，调用get()方法会返回该对象。 Optional提供很多有用的方法，这样我们就不用显式进行空值检测。 创建Optional类对象的方法： static Optional empty() ：用来创建一个空的Optional实例 static Optional of(T value) ：用来创建一个Optional实例，value必须非空 static &lt;T&gt; Optional&lt;T&gt; ofNullable(T value) ：用来创建一个Optional实例，value可能是空，也可能非空 判断Optional容器中是否包含对象： boolean isPresent() : 判断Optional容器中的值是否存在 void ifPresent(Consumer&lt;? super T&gt; consumer) ：判断Optional容器中的值是否存在，如果存在，就对它进行Consumer指定的操作，如果不存在就不做 获取Optional容器的对象： T get(): 如果调用对象包含值，返回该值。否则抛异常。T get()与of(T value)配合使用 T orElse(T other) ：orElse(T other) 与ofNullable(T value)配合使用，如果Optional容器中非空，就返回所包装值，如果为空，就用orElse(T other)other指定的默认值（备胎）代替 T orElseGet(Supplier&lt;? extends T&gt; other) ：如果Optional容器中非空，就返回所包装值，如果为空，就用Supplier接口的Lambda表达式提供的值代替 T orElseThrow(Supplier&lt;? extends X&gt; exceptionSupplier) ：如果Optional容器中非空，就返回所包装值，如果为空，就抛出你指定的异常类型代替原来的NoSuchElementException 举例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970package com.atguigu.optional;import java.util.Optional;import org.junit.Test;public class TestOptional &#123; @Test public void test1()&#123; String str = &quot;hello&quot;; Optional&lt;String&gt; opt = Optional.of(str); System.out.println(opt); &#125; @Test public void test2()&#123; Optional&lt;String&gt; opt = Optional.empty(); System.out.println(opt); &#125; @Test public void test3()&#123; String str = null; Optional&lt;String&gt; opt = Optional.ofNullable(str); System.out.println(opt); &#125; @Test public void test4()&#123; String str = &quot;hello&quot;; Optional&lt;String&gt; opt = Optional.of(str); String string = opt.get(); System.out.println(string); &#125; @Test public void test5()&#123; String str = null; Optional&lt;String&gt; opt = Optional.ofNullable(str);// System.out.println(opt.get());//java.util.NoSuchElementException: No value present &#125; @Test public void test6()&#123; String str = &quot;hello&quot;; Optional&lt;String&gt; opt = Optional.ofNullable(str); String string = opt.orElse(&quot;atguigu&quot;); System.out.println(string); &#125; @Test public void test7()&#123; String str = null; Optional&lt;String&gt; opt = Optional.ofNullable(str); String string = opt.orElseGet(String::new); System.out.println(string); &#125; @Test public void test8()&#123; String str = null; Optional&lt;String&gt; opt = Optional.ofNullable(str); String string = opt.orElseThrow(()-&gt;new RuntimeException(&quot;值不存在&quot;)); System.out.println(string); &#125; @Test public void test9()&#123; String str = &quot;Hello1&quot;; Optional&lt;String&gt; opt = Optional.ofNullable(str); //判断是否是纯字母单词，如果是，转为大写，否则保持不变 String result = opt.filter(s-&gt;s.matches(&quot;[a-zA-Z]+&quot;)) .map(s -&gt; s.toUpperCase()).orElse(str); System.out.println(result); &#125;&#125; 这是JDK9-11的新特性 新增方法 描述 新增的版本 boolean isEmpty() 判断value是否为空 JDK 11 ifPresentOrElse(Consumer&lt;? super T&gt; action, Runnable emptyAction) value非空，执行参数1功能；如果value为空，执行参数2功能 JDK 9 Optional or(Supplier&lt;? extends Optional&lt;? extends T&gt;&gt; supplier) value非空，返回对应的Optional；value为空，返回形参封装的Optional JDK 9 Stream stream() value非空，返回仅包含此value的Stream；否则，返回一个空的Stream JDK 9 T orElseThrow() value非空，返回value；否则抛异常NoSuchElementException JDK 10 7.2 String存储结构和API变更这是JDK9的新特性。 产生背景： MotivationThe current implementation of the String class stores characters in a char array, using two bytes (sixteen bits) for each character. Data gathered from many different applications indicates that strings are a major component of heap usage and, moreover, that most String objects contain only Latin-1 characters. Such characters require only one byte of storage, hence half of the space in the internal char arrays of such String objects is going unused. 使用说明： DescriptionWe propose to change the internal representation of the String class from a UTF-16 char array to a byte array plus an encoding-flag field. The new String class will store characters encoded either as ISO-8859-1&#x2F;Latin-1 (one byte per character), or as UTF-16 (two bytes per character), based upon the contents of the string. The encoding flag will indicate which encoding is used. 结论：String 再也不用 char[] 来存储啦，改成了 byte[] 加上编码标记，节约了一些空间。 123456public final class String implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123; @Stable private final byte[] value; ...&#125; 拓展：StringBuffer 与 StringBuilder 那StringBuffer 和 StringBuilder 是否仍无动于衷呢？ String-related classes such as AbstractStringBuilder, StringBuilder, and StringBuffer will be updated to use the same representation, as will the HotSpot VM’s intrinsic string operations. JDK11新特性：新增了一系列字符串处理方法 描述 举例 判断字符串是否为空白 “ “.isBlank(); &#x2F;&#x2F; true 去除首尾空白 “ Javastack “.strip(); &#x2F;&#x2F; “Javastack” 去除尾部空格 “ Javastack “.stripTrailing(); &#x2F;&#x2F; “ Javastack” 去除首部空格 “ Javastack “.stripLeading(); &#x2F;&#x2F; “Javastack “ 复制字符串 “Java”.repeat(3);&#x2F;&#x2F; “JavaJavaJava” 行数统计 “A\\nB\\nC”.lines().count(); &#x2F;&#x2F; 3 JDK12新特性：String 实现了 Constable 接口 String源码： 1public final class String implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence,Constable, ConstantDesc &#123; java.lang.constant.Constable接口定义了抽象方法： 123public interface Constable &#123; Optional&lt;? extends ConstantDesc&gt; describeConstable();&#125; Java 12 String 的实现源码： 1234567891011/** * Returns an &#123;@link Optional&#125; containing the nominal descriptor for this * instance, which is the instance itself. * * @return an &#123;@link Optional&#125; describing the &#123;@linkplain String&#125; instance * @since 12 */@Overridepublic Optional&lt;String&gt; describeConstable() &#123; return Optional.of(this);&#125; 很简单，其实就是调用 Optional.of 方法返回一个 Optional 类型。 举例： 12345private static void testDescribeConstable() &#123; String name = &quot;尚硅谷Java高级工程师&quot;; Optional&lt;String&gt; optional = name.describeConstable(); System.out.println(optional.get());&#125; 结果输出： 1尚硅谷Java高级工程师 JDK12新特性：String新增方法 String的transform(Function) 12var result = &quot;foo&quot;.transform(input -&gt; input + &quot; bar&quot;);System.out.println(result); //foo bar 或者 12var result = &quot;foo&quot;.transform(input -&gt; input + &quot; bar&quot;).transform(String::toUpperCase)System.out.println(result); //FOO BAR 对应的源码： 123456789/*** This method allows the application of a function to &#123;@code this&#125;* string. The function should expect a single String argument* and produce an &#123;@code R&#125; result.* @since 12*/public &lt;R&gt; R transform(Function&lt;? super String, ? extends R&gt; f) &#123; return f.apply(this);&#125; 在某种情况下，该方法应该被称为map()。 举例： 12345678910private static void testTransform() &#123; System.out.println(&quot;======test java 12 transform======&quot;); List&lt;String&gt; list1 = List.of(&quot;Java&quot;, &quot; Python&quot;, &quot; C++ &quot;); List&lt;String&gt; list2 = new ArrayList&lt;&gt;(); list1.forEach(element -&gt; list2.add(element.transform(String::strip) .transform(String::toUpperCase) .transform((e) -&gt; &quot;Hi,&quot; + e)) ); list2.forEach(System.out::println);&#125; 结果输出： 1234======test java 12 transform======Hi,JAVAHi,PYTHONHi,C++ 如果使用Java 8的Stream特性，可以如下实现： 12345678private static void testTransform1() &#123; System.out.println(&quot;======test before java 12 ======&quot;); List&lt;String&gt; list1 = List.of(&quot;Java &quot;, &quot; Python&quot;, &quot; C++ &quot;); Stream&lt;String&gt; stringStream = list1.stream().map(element -&gt; element.strip()).map(String::toUpperCase).map(element -&gt; &quot;Hello,&quot; + element); List&lt;String&gt; list2 = stringStream.collect(Collectors.toList()); list2.forEach(System.out::println); &#125; 7.3 JDK17：标记删除Applet APIApplet API 提供了一种将 Java AWT&#x2F;Swing 控件嵌入到浏览器网页中的方法。不过，目前 Applet 已经被淘汰。大部分人可能压根就没有用过 Applet。 Applet API 实际上是无用的，因为所有 Web 浏览器供应商都已删除或透露计划放弃对 Java 浏览器插件的支持。Java 9 的时候，Applet API 已经被标记为过时，Java 17 的时候终于标记为删除了。 具体如下： 123456java.applet.Appletjava.applet.AppletStubjava.applet.AppletContextjava.applet.AudioClipjavax.swing.JAppletjava.beans.AppletInitializer 8. 其它结构变化8.1 JDK9：UnderScore(下划线)使用的限制在java 8 中，标识符可以独立使用“_”来命名： 12String _ = &quot;hello&quot;;System.out.println(_); 但是，在java 9 中规定“_”不再可以单独命名标识符了，如果使用，会报错： 8.2 JDK11：更简化的编译运行程序看下面的代码。 12345// 编译javac JavaStack.java// 运行java JavaStack 我们的认知里，要运行一个 Java 源代码必须先编译，再运行。而在 Java 11 版本中，通过一个 java 命令就直接搞定了，如下所示： 1java JavaStack.java 注意点： 执行源文件中的第一个类，第一个类必须包含主方法。 8.3 GC方面新特性GC是Java主要优势之一。 然而，当GC停顿太长，就会开始影响应用的响应时间。随着现代系统中内存不断增长，用户和程序员希望JVM能够以高效的方式充分利用这些内存， 并且无需长时间的GC暂停时间。 8.3.1 G1 GCJDK9以后默认的垃圾回收器是G1GC。 JDK10 : 为G1提供并行的Full GC G1最大的亮点就是可以尽量的避免full gc。但毕竟是“尽量”，在有些情况下，G1就要进行full gc了，比如如果它无法足够快的回收内存的时候，它就会强制停止所有的应用线程然后清理。 在Java10之前，一个单线程版的标记-清除-压缩算法被用于full gc。为了尽量减少full gc带来的影响，在Java10中，就把之前的那个单线程版的标记-清除-压缩的full gc算法改成了支持多个线程同时full gc。这样也算是减少了full gc所带来的停顿，从而提高性能。 你可以通过-XX:ParallelGCThreads参数来指定用于并行GC的线程数。 JDK12：可中断的 G1 Mixed GC JDK12：增强G1，自动返回未用堆内存给操作系统 8.3.2 Shenandoah GCJDK12：Shenandoah GC：低停顿时间的GC Shenandoah 垃圾回收器是 Red Hat 在 2014 年宣布进行的一项垃圾收集器研究项目 Pauseless GC 的实现，旨在针对 JVM 上的内存收回实现低停顿的需求。 据 Red Hat 研发 Shenandoah 团队对外宣称，Shenandoah 垃圾回收器的暂停时间与堆大小无关，这意味着无论将堆设置为 200 MB 还是 200 GB，都将拥有一致的系统暂停时间，不过实际使用性能将取决于实际工作堆的大小和工作负载。 Shenandoah GC 主要目标是 99.9% 的暂停小于 10ms，暂停与堆大小无关等。 这是一个实验性功能，不包含在默认（Oracle）的OpenJDK版本中。 Shenandoah开发团队在实际应用中的测试数据： JDK15：Shenandoah垃圾回收算法转正 Shenandoah垃圾回收算法终于从实验特性转变为产品特性，这是一个从 JDK 12 引入的回收算法，该算法通过与正在运行的 Java 线程同时进行疏散工作来减少 GC 暂停时间。Shenandoah 的暂停时间与堆大小无关，无论堆栈是 200 MB 还是 200 GB，都具有相同的一致暂停时间。 Shenandoah在JDK12被作为experimental引入，在JDK15变为Production；之前需要通过-XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC来启用，现在只需要-XX:+UseShenandoahGC即可启用 8.3.3 革命性的 ZGCJDK11：引入革命性的 ZGC ZGC，这应该是JDK11最为瞩目的特性，没有之一。 ZGC是一个并发、基于region、压缩型的垃圾收集器。 ZGC的设计目标是：支持TB级内存容量，暂停时间低（&lt;10ms），对整个程序吞吐量的影响小于15%。 将来还可以扩展实现机制，以支持不少令人兴奋的功能，例如多层堆（即热对象置于DRAM和冷对象置于NVMe闪存），或压缩堆。 JDK13：ZGC:将未使用的堆内存归还给操作系统 JDK14：ZGC on macOS和windows JDK14之前，ZGC仅Linux才支持。现在mac或Windows上也能使用ZGC了，示例如下： 1-XX:+UnlockExperimentalVMOptions -XX:+UseZGC ZGC与Shenandoah目标高度相似，在尽可能对吞吐量影响不大的前提下，实现在任意堆内存大小下都可以把垃圾收集的停顿时间限制在十毫秒以内的低延迟。 JDK15：ZGC 功能转正 ZGC是Java 11引入的新的垃圾收集器，经过了多个实验阶段，自此终于成为正式特性。 但是这并不是替换默认的GC，默认的GC仍然还是G1；之前需要通过-XX:+UnlockExperimentalVMOptions、 -XX:+UseZGC来启用ZGC，现在只需要-XX:+UseZGC就可以。相信不久的将来它必将成为默认的垃圾回收器。 ZGC的性能已经相当亮眼，用“令人震惊、革命性”来形容，不为过。未来将成为服务端、大内存、低延迟应用的首选垃圾收集器。 怎么形容Shenandoah和ZGC的关系呢？异同点大概如下： 相同点：性能几乎可认为是相同的 不同点：ZGC是Oracle JDK的，根正苗红。而Shenandoah只存在于OpenJDK中，因此使用时需注意你的JDK版本 JDK16：ZGC 并发线程处理 在线程的堆栈处理过程中，总有一个制约因素就是safepoints。在safepoints这个点，Java的线程是要暂停执行的，从而限制了GC的效率。 回顾： 我们都知道，在之前，需要 GC 的时候，为了进行垃圾回收，需要所有的线程都暂停下来，这个暂停的时间我们称为 Stop The World。 而为了实现 STW 这个操作， JVM 需要为每个线程选择一个点停止运行，这个点就叫做安全点（Safepoints）。 而ZGC的并发线程堆栈处理可以保证Java线程可以在GC safepoints的同时可以并发执行。它有助于提高所开发的Java软件应用程序的性能和效率。 9. 小结与展望随着云计算和 AI 等技术浪潮，当前的计算模式和场景正在发生翻天覆地的变化，不仅对 Java 的发展速度提出了更高要求，也深刻影响着 Java 技术的发展方向。传统的大型企业或互联网应用，正在被云端、容器化应用、模块化的微服务甚至是函数(FaaS， Function-as-a-Service)所替代。 Java 需要在新的计算场景下，改进开发效率。比如，Java 代码虽然进行了一些类型推断等改进，更易用的集合 API 等，但仍然给开发者留下了过于刻板、形式主义的印象，这是一个长期的改进方向。 Java虽然标榜面向对象编程，却毫不顾忌的加入面向接口编程思想，又扯出匿名对象的概念，每增加一个新的东西，对Java的根本（面向对象思想）的一次冲击。 士，不可不弘毅，任重而道远。","categories":[],"tags":[]},{"title":"","slug":"Java/尚硅谷_第18章_JDK8-17新特性/尚硅谷_宋红康_第18章_JDK8-17新特性（上）","date":"2023-10-07T11:18:34.274Z","updated":"2022-12-22T14:25:35.901Z","comments":true,"path":"2023/10/07/Java/尚硅谷_第18章_JDK8-17新特性/尚硅谷_宋红康_第18章_JDK8-17新特性（上）/","link":"","permalink":"http://example.com/2023/10/07/Java/%E5%B0%9A%E7%A1%85%E8%B0%B7_%E7%AC%AC18%E7%AB%A0_JDK8-17%E6%96%B0%E7%89%B9%E6%80%A7/%E5%B0%9A%E7%A1%85%E8%B0%B7_%E5%AE%8B%E7%BA%A2%E5%BA%B7_%E7%AC%AC18%E7%AB%A0_JDK8-17%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%88%E4%B8%8A%EF%BC%89/","excerpt":"","text":"第18章_JDK8-17新特性（上）讲师：尚硅谷-宋红康（江湖人称：康师傅） 官网：http://www.atguigu.com 本章专题与脉络 1. Java版本迭代概述1.1 发布特点（小步快跑，快速迭代） 发行版本 发行时间 备注 Java 1.0 1996.01.23 Sun公司发布了Java的第一个开发工具包 Java 5.0 2004.09.30 ①版本号从1.4直接更新至5.0；②平台更名为JavaSE、JavaEE、JavaME Java 8.0 2014.03.18 此版本是继Java 5.0以来变化最大的版本。是长期支持版本（LTS） Java 9.0 2017.09.22 此版本开始，每半年更新一次 Java 10.0 2018.03.21 Java 11.0 2018.09.25 JDK安装包取消独立JRE安装包，是长期支持版本（LTS） Java 12.0 2019.03.19 … … Java17.0 2021.09 发布Java 17.0，版本号也称为21.9，是长期支持版本（LTS） … … Java19.0 2022.09 发布Java19.0，版本号也称为22.9。 从Java 9 这个版本开始，Java 的计划发布周期是 6个月。 这意味着Java的更新从传统的以特性驱动的发布周期，转变为以时间驱动的发布模式，并且承诺不会跳票。通过这样的方式，开发团队可以把一些关键特性尽早合并到 JDK 之中，以快速得到开发者反馈，在一定程度上避免出现像 Java 9 两次被迫延迟发布的窘况。 针对企业客户的需求，Oracle 将以三年为周期发布长期支持版本（long term support）。 Oracle 的官方观点认为：与 Java 7-&gt;8-&gt;9 相比，Java 9-&gt;10-&gt;11的升级和 8-&gt;8u20-&gt;8u40 更相似。 新模式下的 Java 版本发布都会包含许多变更，包括语言变更和 JVM 变更，这两者都会对 IDE、字节码库和框架产生重大影响。此外，不仅会新增其他 API，还会有 API被删除（这在 Java 8 之前没有发生过）。 目前看这种发布策略是非常成功的，解开了 Java&#x2F;JVM 演进的许多枷锁，至关重要的是，OpenJDK 的权力中心，正在转移到开发社区和开发者手中。在新的模式中，既可以利用 LTS 满足企业长期可靠支持的需求，也可以满足各种开发者对于新特性迭代的诉求。因为用 2-3 年的最小间隔粒度来试验一个特性，基本是不现实的。 1.2 名词解释名词解释：Oracle JDK和Open JDK这两个JDK最大不同就是许可证不一样。但是对于个人用户来讲，没区别。 Oracle JDK Open JDK 来源 Oracle团队维护 Oracle和Open Java社区 授权协议 Java 17及更高版本 Oracle Java SE 许可证Java16及更低版本甲骨文免费条款和条件 （NFTC） 许可协议 GPL v2许可证 关系 由Open JDK构建，增加了少许内容 是否收费 2021年9月起Java17及更高版本所有用户免费。 16及更低版本，个人用户、开发用户免费。 2017年9月起，所有版本免费 对语法的支持 一致 一致 名词解释：JEPJEP(JDK Enhancement Proposals)：jdk 改进提案，每当需要有新的设想时候，JEP可以提出非正式的规范(specification)，被正式认可的JEP正式写进JDK的发展路线图并分配版本号。 名词解释：LTSLTS（Long-term Support）即长期支持。Oracle官网提供了对Oracle JDK个别版本的长期支持，即使发发行了新版本，比如目前最新的JDK19，在结束日期前，LTS版本都会被长期支持。（出了bug，会被修复，非LTS则不会再有补丁发布）所以，一定要选一个LTS版本，不然出了漏洞没人修复了。 版本 开始日期 结束日期 延期结束日期 7（LTS） 2011年7月 2019年7月 2022年7月 8（LTS） 2014年3月 2022年3月 2030年12月 11（LTS） 2018年9月 2023年9月 2026年9月 17（LTS） 2021年9月 2026年9月 2029年9月 21（LTS） 2023年9月 2028年9月 2031年9月 如果要选择Oracle JDK，目前可选的LTS版本为8、11、17三个。 1.3 各版本支持时间路线图 1.4 各版本介绍 jdk 9Java 9 提供了超过150项新功能特性，包括备受期待的模块化系统、可交互的 REPL 工具：jshell，JDK 编译工具，Java 公共 API 和私有代码，以及安全增强、扩展提升、性能管理改善等。 特性太多，查看链接： https://openjdk.java.net/projects/jdk9/ jdk 10https://openjdk.java.net/projects/jdk/10/ 286: Local-Variable Type Inference 局部变量类型推断 296: Consolidate the JDK Forest into a Single Repository JDK库的合并 304: Garbage-Collector Interface 统一的垃圾回收接口 307: Parallel Full GC for G1 为G1提供并行的Full GC 310: Application Class-Data Sharing 应用程序类数据（AppCDS）共享 312: Thread-Local Handshakes ThreadLocal握手交互 313: Remove the Native-Header Generation Tool (javah) 移除JDK中附带的javah工具 314: Additional Unicode Language-Tag Extensions 使用附加的Unicode语言标记扩展 316: Heap Allocation on Alternative Memory Devices 能将堆内存占用分配给用户指定的备用内存设备 317: Experimental Java-Based JIT Compiler 使用Graal基于Java的编译器 319: Root Certificates 根证书 322: Time-Based Release Versioning 基于时间定于的发布版本 jdk 11https://openjdk.java.net/projects/jdk/11/ 181: Nest-Based Access Control 基于嵌套的访问控制309: Dynamic Class-File Constants 动态类文件常量315: Improve Aarch64 Intrinsics 改进 Aarch64 Intrinsics318: Epsilon: A No-Op Garbage Collector Epsilon — 一个No-Op（无操作）的垃圾收集器320: Remove the Java EE and CORBA Modules 删除 Java EE 和 CORBA 模块321: HTTP Client (Standard) HTTPClient API323: Local-Variable Syntax for Lambda Parameters 用于 Lambda 参数的局部变量语法324: Key Agreement with Curve25519 and Curve448 Curve25519 和 Curve448 算法的密钥协议327: Unicode 10328: Flight Recorder 飞行记录仪329: ChaCha20 and Poly1305 Cryptographic Algorithms ChaCha20 和 Poly1305 加密算法330: Launch Single-File Source-Code Programs 启动单一文件的源代码程序331: Low-Overhead Heap Profiling 低开销的 Heap Profiling332: Transport Layer Security (TLS) 1.3 支持 TLS 1.3333: ZGC: A Scalable Low-Latency Garbage Collector (Experimental) 可伸缩低延迟垃圾收集器335: Deprecate the Nashorn JavaScript Engine 弃用 Nashorn JavaScript 引擎336: Deprecate the Pack200 Tools and API 弃用 Pack200 工具和 API jdk 12https://openjdk.java.net/projects/jdk/12/ 189：Shenandoah: A Low-Pause-Time Garbage Collector (Experimental) 低暂停时间的GC230: Microbenchmark Suite 微基准测试套件325: Switch Expressions (Preview) switch表达式334: JVM Constants API JVM常量API340: One AArch64 Port, Not Two 只保留一个AArch64实现341: Default CDS Archives 默认类数据共享归档文件344: Abortable Mixed Collections for G1 可中止的G1 Mixed GC346: Promptly Return Unused Committed Memory from G1 G1及时返回未使用的已分配内存 jdk 13https://openjdk.java.net/projects/jdk/13/ 350: Dynamic CDS Archives 动态CDS档案351: ZGC: Uncommit Unused Memory ZGC:取消使用未使用的内存353: Reimplement the Legacy Socket API 重新实现旧版套接字API354: Switch Expressions (Preview) switch表达式（预览）355: Text Blocks (Preview) 文本块（预览） jdk 14https://openjdk.java.net/projects/jdk/14/ 305: Pattern Matching for instanceof (Preview) instanceof的模式匹配343: Packaging Tool (Incubator) 打包工具345: NUMA-Aware Memory Allocation for G1 G1的NUMA-Aware内存分配349: JFR Event Streaming JFR事件流352: Non-Volatile Mapped Byte Buffers 非易失性映射字节缓冲区358: Helpful NullPointerExceptions 实用的NullPointerExceptions359: Records (Preview)361: Switch Expressions (Standard) Switch表达式362: Deprecate the Solaris and SPARC Ports 弃用Solaris和SPARC端口363: Remove the Concurrent Mark Sweep (CMS) Garbage Collector 删除并发标记扫描（CMS）垃圾回收器364: ZGC on macOS365: ZGC on Windows366: Deprecate the ParallelScavenge + SerialOld GC Combination 弃用ParallelScavenge + SerialOld GC组合367: Remove the Pack200 Tools and API 删除Pack200工具和API368: Text Blocks (Second Preview) 文本块370: Foreign-Memory Access API (Incubator) 外部存储器访问API jdk 15https://openjdk.java.net/projects/jdk/15/ 339: Edwards-Curve Digital Signature Algorithm (EdDSA) EdDSA 数字签名算法360: Sealed Classes (Preview) 密封类（预览）371: Hidden Classes 隐藏类372: Remove the Nashorn JavaScript Engine 移除 Nashorn JavaScript 引擎373: Reimplement the Legacy DatagramSocket API 重新实现 Legacy DatagramSocket API374: Disable and Deprecate Biased Locking 禁用偏向锁定375: Pattern Matching for instanceof (Second Preview) instanceof 模式匹配（第二次预览）377: ZGC: A Scalable Low-Latency Garbage Collector ZGC：一个可扩展的低延迟垃圾收集器378: Text Blocks 文本块379: Shenandoah: A Low-Pause-Time Garbage Collector Shenandoah:低暂停时间垃圾收集器381: Remove the Solaris and SPARC Ports 移除 Solaris 和 SPARC 端口383: Foreign-Memory Access API (Second Incubator) 外部存储器访问 API（第二次孵化版）384: Records (Second Preview) Records（第二次预览）385: Deprecate RMI Activation for Removal 废弃 RMI 激活机制 jdk 16https://openjdk.java.net/projects/jdk/16/ 338: Vector API (Incubator) Vector API（孵化器）347: Enable C++14 Language Features JDK C++的源码中允许使用C++14的语言特性357: Migrate from Mercurial to Git OpenJDK源码的版本控制从Mercurial (hg) 迁移到git369: Migrate to GitHub OpenJDK源码的版本控制迁移到github上376: ZGC: Concurrent Thread-Stack Processing ZGC：并发线程处理380: Unix-Domain Socket Channels Unix域套接字通道386: Alpine Linux Port 将glibc的jdk移植到使用musl的alpine linux上387: Elastic Metaspace 弹性元空间388: Windows&#x2F;AArch64 Port 移植JDK到Windows&#x2F;AArch64389: Foreign Linker API (Incubator) 提供jdk.incubator.foreign来简化native code的调用390: Warnings for Value-Based Classes 提供基于值的类的警告392: Packaging Tool jpackage打包工具转正393: Foreign-Memory Access API (Third Incubator)394: Pattern Matching for instanceof Instanceof的模式匹配转正395: Records Records转正396: Strongly Encapsulate JDK Internals by Default 默认情况下，封装了JDK内部构件397: Sealed Classes (Second Preview) 密封类 jdk 17https://openjdk.java.net/projects/jdk/17/ 306: Restore Always-Strict Floating-Point Semantics 恢复始终严格的浮点语义 356: Enhanced Pseudo-Random Number Generators 增强型伪随机数生成器 382: New macOS Rendering Pipeline 新的macOS渲染管道 391: macOS&#x2F;AArch64 Port macOS&#x2F;AArch64端口 398: Deprecate the Applet API for Removal 弃用Applet API后续将进行删除 403: Strongly Encapsulate JDK Internals 强封装JDK的内部API 406: Pattern Matching for switch (Preview) switch模式匹配（预览） 407: Remove RMI Activation 删除RMI激活机制 409: Sealed Classes 密封类转正 410: Remove the Experimental AOT and JIT Compiler 删除实验性的AOT和JIT编译器 411: Deprecate the Security Manager for Removal 弃用即将删除的安全管理器 412: Foreign Function &amp; Memory API (Incubator) 外部函数和内存API（孵化特性） 414: Vector API (Second Incubator) Vector API（第二次孵化特性） 415: Context-Specific Deserialization Filters 上下文特定的反序列化过滤器 1.5 JDK各版本下载链接1https://www.oracle.com/java/technologies/downloads/archive/ 链接：https://pan.baidu.com/s/15QrBUOvfE9vjlTzN_EeVLg提取码：yyds 1.6 如何学习新特性对于新特性，我们应该从哪几个角度学习新特性呢？ 语法层面： 比如JDK5中的自动拆箱、自动装箱、enum、泛型 比如JDK8中的lambda表达式、接口中的默认方法、静态方法 比如JDK10中局部变量的类型推断 比如JDK12中的switch 比如JDK13中的文本块 API层面： 比如JDK8中的Stream、Optional、新的日期时间、HashMap的底层结构 比如JDK9中String的底层结构 新的 &#x2F; 过时的 API 底层优化 比如JDK8中永久代被元空间替代、新的JS执行引擎 比如新的垃圾回收器、GC参数、JVM的优化 2. Java8新特性：Lambda表达式2.1 关于Java8新特性简介Java 8 (又称为 JDK 8或JDK1.8) 是 Java 语言开发的一个主要版本。 Java 8 是oracle公司于2014年3月发布，可以看成是自Java 5 以来最具革命性的版本。Java 8为Java语言、编译器、类库、开发工具与JVM带来了大量新特性。 速度更快 代码更少(增加了新的语法：Lambda 表达式) 强大的 Stream API 便于并行 并行流就是把一个内容分成多个数据块，并用不同的线程分别处理每个数据块的流。相比较串行的流，并行的流可以很大程度上提高程序的执行效率。 Java 8 中将并行进行了优化，我们可以很容易的对数据进行并行操作。Stream API 可以声明性地通过 parallel() 与 sequential() 在并行流与顺序流之间进行切换。 最大化减少空指针异常：Optional Nashorn引擎，允许在JVM上运行JS应用 发音“nass-horn”，是德国二战时一个坦克的命名 javascript运行在jvm已经不是新鲜事了，Rhino早在jdk6的时候已经存在。现在替代Rhino，官方的解释是Rhino相比其他JavaScript引擎（比如google的V8）实在太慢了，改造Rhino还不如重写。所以Nashorn的性能也是其一个亮点。 Nashorn 项目在 JDK 9 中得到改进；在JDK11 中Deprecated，后续JDK15版本中remove。在JDK11中取以代之的是GraalVM。（GraalVM是一个运行时平台，它支持Java和其他基于Java字节码的语言，但也支持其他语言，如JavaScript，Ruby，Python或LLVM。性能是Nashorn的2倍以上。） 2.2 冗余的匿名内部类当需要启动一个线程去完成任务时，通常会通过java.lang.Runnable接口来定义任务内容，并使用java.lang.Thread类来启动该线程。代码如下： 123456789101112package com.atguigu.fp;public class UseFunctionalProgramming &#123; public static void main(String[] args) &#123; new Thread(new Runnable() &#123; @Override public void run() &#123; System.out.println(&quot;多线程任务执行！&quot;); &#125; &#125;).start(); // 启动线程 &#125;&#125; 本着“一切皆对象”的思想，这种做法是无可厚非的：首先创建一个Runnable接口的匿名内部类对象来指定任务内容，再将其交给一个线程来启动。 代码分析： 对于Runnable的匿名内部类用法，可以分析出几点内容： Thread类需要Runnable接口作为参数，其中的抽象run方法是用来指定线程任务内容的核心； 为了指定run的方法体，不得不需要Runnable接口的实现类； 为了省去定义一个RunnableImpl实现类的麻烦，不得不使用匿名内部类； 必须覆盖重写抽象run方法，所以方法名称、方法参数、方法返回值不得不再写一遍，且不能写错； 而实际上，似乎只有方法体才是关键所在。 2.3 好用的lambda表达式 2.4 Lambda 及其使用举例Lambda 是一个匿名函数，我们可以把 Lambda 表达式理解为是一段可以传递的代码（将代码像数据一样进行传递）。使用它可以写出更简洁、更灵活的代码。作为一种更紧凑的代码风格，使Java的语言表达能力得到了提升。 从匿名类到 Lambda 的转换举例1 从匿名类到 Lambda 的转换举例2 2.5 语法Lambda 表达式：在Java 8 语言中引入的一种新的语法元素和操作符。这个操作符为 “-&gt;” ， 该操作符被称为 Lambda 操作符或箭头操作符。它将 Lambda 分为两个部分： 左侧：指定了 Lambda 表达式需要的参数列表 右侧：指定了 Lambda 体，是抽象方法的实现逻辑，也即 Lambda 表达式要执行的功能。 语法格式一：无参，无返回值 123456789101112131415161718192021@Testpublic void test1()&#123; //未使用Lambda表达式 Runnable r1 = new Runnable() &#123; @Override public void run() &#123; System.out.println(&quot;我爱北京天安门&quot;); &#125; &#125;; r1.run(); System.out.println(&quot;***********************&quot;); //使用Lambda表达式 Runnable r2 = () -&gt; &#123; System.out.println(&quot;我爱北京故宫&quot;); &#125;; r2.run();&#125; 语法格式二：Lambda 需要一个参数，但是没有返回值。 1234567891011121314151617181920@Testpublic void test2()&#123; //未使用Lambda表达式 Consumer&lt;String&gt; con = new Consumer&lt;String&gt;() &#123; @Override public void accept(String s) &#123; System.out.println(s); &#125; &#125;; con.accept(&quot;谎言和誓言的区别是什么？&quot;); System.out.println(&quot;*******************&quot;); //使用Lambda表达式 Consumer&lt;String&gt; con1 = (String s) -&gt; &#123; System.out.println(s); &#125;; con1.accept(&quot;一个是听得人当真了，一个是说的人当真了&quot;);&#125; 语法格式三：数据类型可以省略，因为可由编译器推断得出，称为“类型推断” 12345678910111213141516@Testpublic void test3()&#123; //语法格式三使用前 Consumer&lt;String&gt; con1 = (String s) -&gt; &#123; System.out.println(s); &#125;; con1.accept(&quot;一个是听得人当真了，一个是说的人当真了&quot;); System.out.println(&quot;*******************&quot;); //语法格式三使用后 Consumer&lt;String&gt; con2 = (s) -&gt; &#123; System.out.println(s); &#125;; con2.accept(&quot;一个是听得人当真了，一个是说的人当真了&quot;);&#125; 语法格式四：Lambda 若只需要一个参数时，参数的小括号可以省略 1234567891011121314151617@Testpublic void test4()&#123; //语法格式四使用前 Consumer&lt;String&gt; con1 = (s) -&gt; &#123; System.out.println(s); &#125;; con1.accept(&quot;一个是听得人当真了，一个是说的人当真了&quot;); System.out.println(&quot;*******************&quot;); //语法格式四使用后 Consumer&lt;String&gt; con2 = s -&gt; &#123; System.out.println(s); &#125;; con2.accept(&quot;一个是听得人当真了，一个是说的人当真了&quot;);&#125; 语法格式五：Lambda 需要两个或以上的参数，多条执行语句，并且可以有返回值 12345678910111213141516171819202122232425@Testpublic void test5()&#123; //语法格式五使用前 Comparator&lt;Integer&gt; com1 = new Comparator&lt;Integer&gt;() &#123; @Override public int compare(Integer o1, Integer o2) &#123; System.out.println(o1); System.out.println(o2); return o1.compareTo(o2); &#125; &#125;; System.out.println(com1.compare(12,21)); System.out.println(&quot;*****************************&quot;); //语法格式五使用后 Comparator&lt;Integer&gt; com2 = (o1,o2) -&gt; &#123; System.out.println(o1); System.out.println(o2); return o1.compareTo(o2); &#125;; System.out.println(com2.compare(12,6));&#125; 语法格式六：当 Lambda 体只有一条语句时，return 与大括号若有，都可以省略 1234567891011121314151617181920212223242526272829303132@Testpublic void test6()&#123; //语法格式六使用前 Comparator&lt;Integer&gt; com1 = (o1,o2) -&gt; &#123; return o1.compareTo(o2); &#125;; System.out.println(com1.compare(12,6)); System.out.println(&quot;*****************************&quot;); //语法格式六使用后 Comparator&lt;Integer&gt; com2 = (o1,o2) -&gt; o1.compareTo(o2); System.out.println(com2.compare(12,21));&#125;@Testpublic void test7()&#123; //语法格式六使用前 Consumer&lt;String&gt; con1 = s -&gt; &#123; System.out.println(s); &#125;; con1.accept(&quot;一个是听得人当真了，一个是说的人当真了&quot;); System.out.println(&quot;*****************************&quot;); //语法格式六使用后 Consumer&lt;String&gt; con2 = s -&gt; System.out.println(s); con2.accept(&quot;一个是听得人当真了，一个是说的人当真了&quot;);&#125; 2.6 关于类型推断在语法格式三 Lambda 表达式中的参数类型都是由编译器推断得出的。Lambda 表达式中无需指定类型，程序依然可以编译，这是因为 javac 根据程序的上下文，在后台推断出了参数的类型。Lambda 表达式的类型依赖于上下文环境，是由编译器推断出来的。这就是所谓的“类型推断”。 举例： 12345678@Testpublic void test() &#123; //类型推断1 ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(); //类型推断2 int[] arr = &#123;1, 2, 3&#125;;&#125; 3. Java8新特性：函数式(Functional)接口3.1 什么是函数式接口 只包含一个抽象方法（Single Abstract Method，简称SAM）的接口，称为函数式接口。当然该接口可以包含其他非抽象方法。 你可以通过 Lambda 表达式来创建该接口的对象。（若 Lambda 表达式抛出一个受检异常(即：非运行时异常)，那么该异常需要在目标接口的抽象方法上进行声明）。 我们可以在一个接口上使用 @FunctionalInterface 注解，这样做可以检查它是否是一个函数式接口。同时 javadoc 也会包含一条声明，说明这个接口是一个函数式接口。 在java.util.function包下定义了Java 8 的丰富的函数式接口 3.2 如何理解函数式接口 Java从诞生日起就是一直倡导“一切皆对象”，在Java里面面向对象(OOP)编程是一切。但是随着python、scala等语言的兴起和新技术的挑战，Java不得不做出调整以便支持更加广泛的技术要求，即Java不但可以支持OOP还可以支持OOF（面向函数编程） Java8引入了Lambda表达式之后，Java也开始支持函数式编程。 Lambda表达式不是Java最早使用的。目前C++，C#，Python，Scala等均支持Lambda表达式。 面向对象的思想： 做一件事情，找一个能解决这个事情的对象，调用对象的方法，完成事情。 函数式编程思想： 只要能获取到结果，谁去做的，怎么做的都不重要，重视的是结果，不重视过程。 在函数式编程语言当中，函数被当做一等公民对待。在将函数作为一等公民的编程语言中，Lambda表达式的类型是函数。但是在Java8中，有所不同。在Java8中，Lambda表达式是对象，而不是函数，它们必须依附于一类特别的对象类型——函数式接口。 简单的说，在Java8中，Lambda表达式就是一个函数式接口的实例。这就是Lambda表达式和函数式接口的关系。也就是说，只要一个对象是函数式接口的实例，那么该对象就可以用Lambda表达式来表示。 3.3 举例举例1： 举例2： 作为参数传递 Lambda 表达式： 作为参数传递 Lambda 表达式：为了将 Lambda 表达式作为参数传递，接收Lambda 表达式的参数类型必须是与该 Lambda 表达式兼容的函数式接口的类型。 3.4 Java 内置函数式接口3.4.1 之前的函数式接口之前学过的接口，有些就是函数式接口，比如： java.lang.Runnable public void run() java.lang.Iterable public Iterator iterate() java.lang.Comparable public int compareTo(T t) java.util.Comparator public int compare(T t1, T t2) 3.4.2 四大核心函数式接口 函数式接口 称谓 参数类型 用途 Consumer&lt;T&gt; 消费型接口 T 对类型为T的对象应用操作，包含方法： void accept(T t) Supplier&lt;T&gt; 供给型接口 无 返回类型为T的对象，包含方法：T get() Function&lt;T, R&gt; 函数型接口 T 对类型为T的对象应用操作，并返回结果。结果是R类型的对象。包含方法：R apply(T t) Predicate&lt;T&gt; 判断型接口 T 确定类型为T的对象是否满足某约束，并返回 boolean 值。包含方法：boolean test(T t) 3.4.3 其它接口类型1：消费型接口 消费型接口的抽象方法特点：有形参，但是返回值类型是void 接口名 抽象方法 描述 BiConsumer&lt;T,U&gt; void accept(T t, U u) 接收两个对象用于完成功能 DoubleConsumer void accept(double value) 接收一个double值 IntConsumer void accept(int value) 接收一个int值 LongConsumer void accept(long value) 接收一个long值 ObjDoubleConsumer void accept(T t, double value) 接收一个对象和一个double值 ObjIntConsumer void accept(T t, int value) 接收一个对象和一个int值 ObjLongConsumer void accept(T t, long value) 接收一个对象和一个long值 类型2：供给型接口 这类接口的抽象方法特点：无参，但是有返回值 接口名 抽象方法 描述 BooleanSupplier boolean getAsBoolean() 返回一个boolean值 DoubleSupplier double getAsDouble() 返回一个double值 IntSupplier int getAsInt() 返回一个int值 LongSupplier long getAsLong() 返回一个long值 类型3：函数型接口 这类接口的抽象方法特点：既有参数又有返回值 接口名 抽象方法 描述 UnaryOperator T apply(T t) 接收一个T类型对象，返回一个T类型对象结果 DoubleFunction R apply(double value) 接收一个double值，返回一个R类型对象 IntFunction R apply(int value) 接收一个int值，返回一个R类型对象 LongFunction R apply(long value) 接收一个long值，返回一个R类型对象 ToDoubleFunction double applyAsDouble(T value) 接收一个T类型对象，返回一个double ToIntFunction int applyAsInt(T value) 接收一个T类型对象，返回一个int ToLongFunction long applyAsLong(T value) 接收一个T类型对象，返回一个long DoubleToIntFunction int applyAsInt(double value) 接收一个double值，返回一个int结果 DoubleToLongFunction long applyAsLong(double value) 接收一个double值，返回一个long结果 IntToDoubleFunction double applyAsDouble(int value) 接收一个int值，返回一个double结果 IntToLongFunction long applyAsLong(int value) 接收一个int值，返回一个long结果 LongToDoubleFunction double applyAsDouble(long value) 接收一个long值，返回一个double结果 LongToIntFunction int applyAsInt(long value) 接收一个long值，返回一个int结果 DoubleUnaryOperator double applyAsDouble(double operand) 接收一个double值，返回一个double IntUnaryOperator int applyAsInt(int operand) 接收一个int值，返回一个int结果 LongUnaryOperator long applyAsLong(long operand) 接收一个long值，返回一个long结果 BiFunction&lt;T,U,R&gt; R apply(T t, U u) 接收一个T类型和一个U类型对象，返回一个R类型对象结果 BinaryOperator T apply(T t, T u) 接收两个T类型对象，返回一个T类型对象结果 ToDoubleBiFunction&lt;T,U&gt; double applyAsDouble(T t, U u) 接收一个T类型和一个U类型对象，返回一个double ToIntBiFunction&lt;T,U&gt; int applyAsInt(T t, U u) 接收一个T类型和一个U类型对象，返回一个int ToLongBiFunction&lt;T,U&gt; long applyAsLong(T t, U u) 接收一个T类型和一个U类型对象，返回一个long DoubleBinaryOperator double applyAsDouble(double left, double right) 接收两个double值，返回一个double结果 IntBinaryOperator int applyAsInt(int left, int right) 接收两个int值，返回一个int结果 LongBinaryOperator long applyAsLong(long left, long right) 接收两个long值，返回一个long结果 类型4：判断型接口 这类接口的抽象方法特点：有参，但是返回值类型是boolean结果。 接口名 抽象方法 描述 BiPredicate&lt;T,U&gt; boolean test(T t, U u) 接收两个对象 DoublePredicate boolean test(double value) 接收一个double值 IntPredicate boolean test(int value) 接收一个int值 LongPredicate boolean test(long value) 接收一个long值 3.4.4 内置接口代码演示举例1： 123456789101112package com.atguigu.four;import java.util.Arrays;import java.util.List;public class TestConsumer &#123; public static void main(String[] args) &#123; List&lt;String&gt; list = Arrays.asList(&quot;java&quot;,&quot;c&quot;,&quot;python&quot;,&quot;c++&quot;,&quot;VB&quot;,&quot;C#&quot;); //遍历Collection集合，并将传递给action参数的操作代码应用在每一个元素上。 list.forEach(s -&gt; System.out.println(s)); &#125;&#125; 举例2： 12345678910package com.atguigu.four;import java.util.function.Supplier;public class TestSupplier &#123; public static void main(String[] args) &#123; Supplier&lt;String&gt; supplier = () -&gt; &quot;尚硅谷&quot;; System.out.println(supplier.get()); &#125;&#125; 举例3： 123456789101112131415161718192021222324package com.atguigu.four;import java.util.ArrayList;public class TestPredicate &#123; public static void main(String[] args) &#123; ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add(&quot;hello&quot;); list.add(&quot;java&quot;); list.add(&quot;atguigu&quot;); list.add(&quot;ok&quot;); list.add(&quot;yes&quot;); System.out.println(&quot;删除之前：&quot;); list.forEach(t-&gt; System.out.println(t)); //用于删除集合中满足filter指定的条件判断的。 //删除包含o字母的元素 list.removeIf(s -&gt; s.contains(&quot;o&quot;)); System.out.println(&quot;删除包含o字母的元素之后：&quot;); list.forEach(t-&gt; System.out.println(t)); &#125;&#125; 举例4： 123456789101112package com.atguigu.four;import java.util.function.Function;public class TestFunction &#123; public static void main(String[] args) &#123; //使用Lambda表达式实现Function&lt;T,R&gt;接口，可以实现将一个字符串首字母转为大写的功能。 Function&lt;String,String&gt; fun = s -&gt; s.substring(0,1).toUpperCase() + s.substring(1); System.out.println(fun.apply(&quot;hello&quot;)); &#125;&#125; 3.4.5 练习练习1：无参无返回值形式 假如有自定义函数式接口Call如下： 123public interface Call &#123; void shout();&#125; 在测试类中声明一个如下方法： 123public static void callSomething(Call call)&#123; call.shout();&#125; 在测试类的main方法中调用callSomething方法，并用Lambda表达式为形参call赋值，可以喊出任意你想说的话。 1234567891011121314public class TestLambda &#123; public static void main(String[] args) &#123; callSomething(()-&gt;System.out.println(&quot;回家吃饭&quot;)); callSomething(()-&gt;System.out.println(&quot;我爱你&quot;)); callSomething(()-&gt;System.out.println(&quot;滚蛋&quot;)); callSomething(()-&gt;System.out.println(&quot;回来&quot;)); &#125; public static void callSomething(Call call)&#123; call.shout(); &#125;&#125;interface Call &#123; void shout();&#125; 练习2：消费型接口 代码示例：Consumer接口 在JDK1.8中Collection集合接口的父接口Iterable接口中增加了一个默认方法： public default void forEach(Consumer&lt;? super T&gt; action) 遍历Collection集合的每个元素，执行“xxx消费型”操作。 在JDK1.8中Map集合接口中增加了一个默认方法： public default void forEach(BiConsumer&lt;? super K,? super V&gt; action)遍历Map集合的每对映射关系，执行“xxx消费型”操作。 案例： （1）创建一个Collection系列的集合，添加一些字符串，调用forEach方法遍历查看 （2）创建一个Map系列的集合，添加一些(key,value)键值对，调用forEach方法遍历查看 示例代码： 1234567891011121314@Testpublic void test1()&#123; List&lt;String&gt; list = Arrays.asList(&quot;hello&quot;,&quot;java&quot;,&quot;lambda&quot;,&quot;atguigu&quot;); list.forEach(s -&gt; System.out.println(s)); &#125;@Testpublic void test2()&#123; HashMap&lt;Integer,String&gt; map = new HashMap&lt;&gt;(); map.put(1, &quot;hello&quot;); map.put(2, &quot;java&quot;); map.put(3, &quot;lambda&quot;); map.put(4, &quot;atguigu&quot;); map.forEach((k,v) -&gt; System.out.println(k+&quot;-&gt;&quot;+v));&#125; 练习3：供给型接口 代码示例：Supplier接口 在JDK1.8中增加了StreamAPI，java.util.stream.Stream是一个数据流。这个类型有一个静态方法： public static &lt;T&gt; Stream&lt;T&gt; generate(Supplier&lt;T&gt; s)可以创建Stream的对象。而又包含一个forEach方法可以遍历流中的元素：public void forEach(Consumer&lt;? super T&gt; action)。 案例： 现在请调用Stream的generate方法，来产生一个流对象，并调用Math.random()方法来产生数据，为Supplier函数式接口的形参赋值。最后调用forEach方法遍历流中的数据查看结果。 1234@Testpublic void test2()&#123; Stream.generate(() -&gt; Math.random()).forEach(num -&gt; System.out.println(num));&#125; 练习4：功能型接口 代码示例：Function&lt;T,R&gt;接口 在JDK1.8时Map接口增加了很多方法，例如： public default void replaceAll(BiFunction&lt;? super K,? super V,? extends V&gt; function) 按照function指定的操作替换map中的value。 public default void forEach(BiConsumer&lt;? super K,? super V&gt; action)遍历Map集合的每对映射关系，执行“xxx消费型”操作。 案例： （1）声明一个Employee员工类型，包含编号、姓名、薪资。 （2）添加n个员工对象到一个HashMap&lt;Integer,Employee&gt;集合中，其中员工编号为key，员工对象为value。 （3）调用Map的forEach遍历集合 （4）调用Map的replaceAll方法，将其中薪资低于10000元的，薪资设置为10000。 （5）再次调用Map的forEach遍历集合查看结果 Employee类： 12345678910111213141516171819202122232425262728293031323334353637class Employee&#123; private int id; private String name; private double salary; public Employee(int id, String name, double salary) &#123; super(); this.id = id; this.name = name; this.salary = salary; &#125; public Employee() &#123; super(); &#125; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public double getSalary() &#123; return salary; &#125; public void setSalary(double salary) &#123; this.salary = salary; &#125; @Override public String toString() &#123; return &quot;Employee [id=&quot; + id + &quot;, name=&quot; + name + &quot;, salary=&quot; + salary + &quot;]&quot;; &#125; &#125; 测试类： 1234567891011121314151617181920212223242526272829import java.util.HashMap;public class TestLambda &#123; public static void main(String[] args) &#123; HashMap&lt;Integer,Employee&gt; map = new HashMap&lt;&gt;(); Employee e1 = new Employee(1, &quot;张三&quot;, 8000); Employee e2 = new Employee(2, &quot;李四&quot;, 9000); Employee e3 = new Employee(3, &quot;王五&quot;, 10000); Employee e4 = new Employee(4, &quot;赵六&quot;, 11000); Employee e5 = new Employee(5, &quot;钱七&quot;, 12000); map.put(e1.getId(), e1); map.put(e2.getId(), e2); map.put(e3.getId(), e3); map.put(e4.getId(), e4); map.put(e5.getId(), e5); map.forEach((k,v) -&gt; System.out.println(k+&quot;=&quot;+v)); System.out.println(); map.replaceAll((k,v)-&gt;&#123; if(v.getSalary()&lt;10000)&#123; v.setSalary(10000); &#125; return v; &#125;); map.forEach((k,v) -&gt; System.out.println(k+&quot;=&quot;+v)); &#125;&#125; 练习5：判断型接口 代码示例：Predicate接口 JDK1.8时，Collecton接口增加了一下方法，其中一个如下： public default boolean removeIf(Predicate&lt;? super E&gt; filter) 用于删除集合中满足filter指定的条件判断的。 public default void forEach(Consumer&lt;? super T&gt; action) 遍历Collection集合的每个元素，执行“xxx消费型”操作。 案例： （1）添加一些字符串到一个Collection集合中 （2）调用forEach遍历集合 （3）调用removeIf方法，删除其中字符串的长度&lt;5的 （4）再次调用forEach遍历集合 123456789101112131415161718import java.util.ArrayList;public class TestLambda &#123; public static void main(String[] args) &#123; ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add(&quot;hello&quot;); list.add(&quot;java&quot;); list.add(&quot;atguigu&quot;); list.add(&quot;ok&quot;); list.add(&quot;yes&quot;); list.forEach(str-&gt;System.out.println(str)); System.out.println(); list.removeIf(str-&gt;str.length()&lt;5); list.forEach(str-&gt;System.out.println(str)); &#125;&#125; 练习6：判断型接口 案例： （1）声明一个Employee员工类型，包含编号、姓名、性别，年龄，薪资。 （2）声明一个EmployeeSerice员工管理类，包含一个ArrayList集合的属性all，在EmployeeSerice的构造器中，创建一些员工对象，为all集合初始化。 （3）在EmployeeSerice员工管理类中，声明一个方法：ArrayList get(Predicate p)，即将满足p指定的条件的员工，添加到一个新的ArrayList 集合中返回。 （4）在测试类中创建EmployeeSerice员工管理类的对象，并调用get方法，分别获取： 所有员工对象 所有年龄超过35的员工 所有薪资高于15000的女员工 所有编号是偶数的员工 名字是“张三”的员工 年龄超过25，薪资低于10000的男员工 示例代码： Employee类： 123456789101112131415161718192021222324252627282930313233343536373839404142public class Employee&#123; private int id; private String name; private char gender; private int age; private double salary; public Employee(int id, String name, char gender, int age, double salary) &#123; super(); this.id = id; this.name = name; this.gender = gender; this.age = age; this.salary = salary; &#125; public Employee() &#123; super(); &#125; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public double getSalary() &#123; return salary; &#125; public void setSalary(double salary) &#123; this.salary = salary; &#125; @Override public String toString() &#123; return &quot;Employee [id=&quot; + id + &quot;, name=&quot; + name + &quot;, gender=&quot; + gender + &quot;, age=&quot; + age + &quot;, salary=&quot; + salary + &quot;]&quot;; &#125;&#125; 员工管理类： 123456789101112131415161718192021class EmployeeService&#123; private ArrayList&lt;Employee&gt; all; public EmployeeService()&#123; all = new ArrayList&lt;Employee&gt;(); all.add(new Employee(1, &quot;张三&quot;, &#x27;男&#x27;, 33, 8000)); all.add(new Employee(2, &quot;翠花&quot;, &#x27;女&#x27;, 23, 18000)); all.add(new Employee(3, &quot;无能&quot;, &#x27;男&#x27;, 46, 8000)); all.add(new Employee(4, &quot;李四&quot;, &#x27;女&#x27;, 23, 9000)); all.add(new Employee(5, &quot;老王&quot;, &#x27;男&#x27;, 23, 15000)); all.add(new Employee(6, &quot;大嘴&quot;, &#x27;男&#x27;, 23, 11000)); &#125; public ArrayList&lt;Employee&gt; get(Predicate&lt;Employee&gt; p)&#123; ArrayList&lt;Employee&gt; result = new ArrayList&lt;Employee&gt;(); for (Employee emp : result) &#123; if(p.test(emp))&#123; result.add(emp); &#125; &#125; return result; &#125;&#125; 测试类： 1234567891011121314151617public class TestLambda &#123; public static void main(String[] args) &#123; EmployeeService es = new EmployeeService(); es.get(e -&gt; true).forEach(e-&gt;System.out.println(e)); System.out.println(); es.get(e -&gt; e.getAge()&gt;35).forEach(e-&gt;System.out.println(e)); System.out.println(); es.get(e -&gt; e.getSalary()&gt;15000 &amp;&amp; e.getGender()==&#x27;女&#x27;).forEach(e-&gt;System.out.println(e)); System.out.println(); es.get(e -&gt; e.getId()%2==0).forEach(e-&gt;System.out.println(e)); System.out.println(); es.get(e -&gt; &quot;张三&quot;.equals(e.getName())).forEach(e-&gt;System.out.println(e)); System.out.println(); es.get(e -&gt; e.getAge()&gt;25 &amp;&amp; e.getSalary()&lt;10000 &amp;&amp; e.getGender()==&#x27;男&#x27;).forEach(e-&gt;System.out.println(e)); &#125;&#125; 4. Java8新特性：方法引用与构造器引用Lambda表达式是可以简化函数式接口的变量或形参赋值的语法。而方法引用和构造器引用是为了简化Lambda表达式的。 4.1 方法引用当要传递给Lambda体的操作，已经有实现的方法了，可以使用方法引用！ 方法引用可以看做是Lambda表达式深层次的表达。换句话说，方法引用就是Lambda表达式，也就是函数式接口的一个实例，通过方法的名字来指向一个方法，可以认为是Lambda表达式的一个语法糖。 语法糖（Syntactic sugar），也译为糖衣语法，是由英国计算机科学家彼得·约翰·兰达（Peter J. Landin）发明的一个术语，指计算机语言中添加的某种语法，这种语法对语言的功能并没有影响，但是更方便程序员使用。通常来说使用语法糖能够增加程序的可读性，从而减少程序代码出错的机会。 4.1.1 方法引用格式 格式：使用方法引用操作符 “::” 将类(或对象) 与 方法名分隔开来。 两个:中间不能有空格，而且必须英文状态下半角输入 如下三种主要使用情况： 情况1：对象 :: 实例方法名 情况2：类 :: 静态方法名 情况3：类 :: 实例方法名 4.1.2 方法引用使用前提要求1：Lambda体只有一句语句，并且是通过调用一个对象的&#x2F;类现有的方法来完成的 例如：System.out对象，调用println()方法来完成Lambda体 ​ Math类，调用random()静态方法来完成Lambda体 要求2： 针对情况1：函数式接口中的抽象方法a在被重写时使用了某一个对象的方法b。如果方法a的形参列表、返回值类型与方法b的形参列表、返回值类型都相同，则我们可以使用方法b实现对方法a的重写、替换。 针对情况2：函数式接口中的抽象方法a在被重写时使用了某一个类的静态方法b。如果方法a的形参列表、返回值类型与方法b的形参列表、返回值类型都相同，则我们可以使用方法b实现对方法a的重写、替换。 针对情况3：函数式接口中的抽象方法a在被重写时使用了某一个对象的方法b。如果方法a的返回值类型与方法b的返回值类型相同，同时方法a的形参列表中有n个参数，方法b的形参列表有n-1个参数，且方法a的第1个参数作为方法b的调用者，且方法a的后n-1参数与方法b的n-1参数匹配（类型相同或满足多态场景也可以） 例如：t-&gt;System.out.println(t) ​ () -&gt; Math.random() 都是无参 4.1.3 举例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110public class MethodRefTest &#123; // 情况一：对象 :: 实例方法 //Consumer中的void accept(T t) //PrintStream中的void println(T t) @Test public void test1() &#123; Consumer&lt;String&gt; con1 = str -&gt; System.out.println(str); con1.accept(&quot;北京&quot;); System.out.println(&quot;*******************&quot;); PrintStream ps = System.out; Consumer&lt;String&gt; con2 = ps::println; con2.accept(&quot;beijing&quot;); &#125; //Supplier中的T get() //Employee中的String getName() @Test public void test2() &#123; Employee emp = new Employee(1001,&quot;Tom&quot;,23,5600); Supplier&lt;String&gt; sup1 = () -&gt; emp.getName(); System.out.println(sup1.get()); System.out.println(&quot;*******************&quot;); Supplier&lt;String&gt; sup2 = emp::getName; System.out.println(sup2.get()); &#125; // 情况二：类 :: 静态方法 //Comparator中的int compare(T t1,T t2) //Integer中的int compare(T t1,T t2) @Test public void test3() &#123; Comparator&lt;Integer&gt; com1 = (t1,t2) -&gt; Integer.compare(t1,t2); System.out.println(com1.compare(12,21)); System.out.println(&quot;*******************&quot;); Comparator&lt;Integer&gt; com2 = Integer::compare; System.out.println(com2.compare(12,3)); &#125; //Function中的R apply(T t) //Math中的Long round(Double d) @Test public void test4() &#123; Function&lt;Double,Long&gt; func = new Function&lt;Double, Long&gt;() &#123; @Override public Long apply(Double d) &#123; return Math.round(d); &#125; &#125;; System.out.println(&quot;*******************&quot;); Function&lt;Double,Long&gt; func1 = d -&gt; Math.round(d); System.out.println(func1.apply(12.3)); System.out.println(&quot;*******************&quot;); Function&lt;Double,Long&gt; func2 = Math::round; System.out.println(func2.apply(12.6)); &#125; // 情况三：类 :: 实例方法 (有难度) // Comparator中的int comapre(T t1,T t2) // String中的int t1.compareTo(t2) @Test public void test5() &#123; Comparator&lt;String&gt; com1 = (s1,s2) -&gt; s1.compareTo(s2); System.out.println(com1.compare(&quot;abc&quot;,&quot;abd&quot;)); System.out.println(&quot;*******************&quot;); Comparator&lt;String&gt; com2 = String :: compareTo; System.out.println(com2.compare(&quot;abd&quot;,&quot;abm&quot;)); &#125; //BiPredicate中的boolean test(T t1, T t2); //String中的boolean t1.equals(t2) @Test public void test6() &#123; BiPredicate&lt;String,String&gt; pre1 = (s1,s2) -&gt; s1.equals(s2); System.out.println(pre1.test(&quot;abc&quot;,&quot;abc&quot;)); System.out.println(&quot;*******************&quot;); BiPredicate&lt;String,String&gt; pre2 = String :: equals; System.out.println(pre2.test(&quot;abc&quot;,&quot;abd&quot;)); &#125; // Function中的R apply(T t) // Employee中的String getName(); @Test public void test7() &#123; Employee employee = new Employee(1001, &quot;Jerry&quot;, 23, 6000); Function&lt;Employee,String&gt; func1 = e -&gt; e.getName(); System.out.println(func1.apply(employee)); System.out.println(&quot;*******************&quot;); Function&lt;Employee,String&gt; func2 = Employee::getName; System.out.println(func2.apply(employee)); &#125;&#125; 4.2 构造器引用当Lambda表达式是创建一个对象，并且满足Lambda表达式形参，正好是给创建这个对象的构造器的实参列表，就可以使用构造器引用。 格式：类名::new 举例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public class ConstructorRefTest &#123; //构造器引用 //Supplier中的T get() //Employee的空参构造器：Employee() @Test public void test1()&#123; Supplier&lt;Employee&gt; sup = new Supplier&lt;Employee&gt;() &#123; @Override public Employee get() &#123; return new Employee(); &#125; &#125;; System.out.println(&quot;*******************&quot;); Supplier&lt;Employee&gt; sup1 = () -&gt; new Employee(); System.out.println(sup1.get()); System.out.println(&quot;*******************&quot;); Supplier&lt;Employee&gt; sup2 = Employee :: new; System.out.println(sup2.get()); &#125; //Function中的R apply(T t) @Test public void test2()&#123; Function&lt;Integer,Employee&gt; func1 = id -&gt; new Employee(id); Employee employee = func1.apply(1001); System.out.println(employee); System.out.println(&quot;*******************&quot;); Function&lt;Integer,Employee&gt; func2 = Employee :: new; Employee employee1 = func2.apply(1002); System.out.println(employee1); &#125; //BiFunction中的R apply(T t,U u) @Test public void test3()&#123; BiFunction&lt;Integer,String,Employee&gt; func1 = (id,name) -&gt; new Employee(id,name); System.out.println(func1.apply(1001,&quot;Tom&quot;)); System.out.println(&quot;*******************&quot;); BiFunction&lt;Integer,String,Employee&gt; func2 = Employee :: new; System.out.println(func2.apply(1002,&quot;Tom&quot;)); &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273package com.atguigu.java2;/** * @author 尚硅谷-宋红康 邮箱：shkstart@126.com */public class Employee &#123; private int id; private String name; private int age; private double salary; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public double getSalary() &#123; return salary; &#125; public void setSalary(double salary) &#123; this.salary = salary; &#125; public Employee() &#123; System.out.println(&quot;Employee().....&quot;); &#125; public Employee(int id) &#123; this.id = id; System.out.println(&quot;Employee(int id).....&quot;); &#125; public Employee(int id, String name) &#123; this.id = id; this.name = name; &#125; public Employee(int id, String name, int age, double salary) &#123; this.id = id; this.name = name; this.age = age; this.salary = salary; &#125; @Override public String toString() &#123; return &quot;Employee&#123;&quot; + &quot;id=&quot; + id + &quot;, name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, age=&quot; + age + &quot;, salary=&quot; + salary + &#x27;&#125;&#x27;; &#125;&#125; 4.3 数组构造引用当Lambda表达式是创建一个数组对象，并且满足Lambda表达式形参，正好是给创建这个数组对象的长度，就可以数组构造引用。 格式：数组类型名::new 举例： 123456789101112131415//数组引用//Function中的R apply(T t)@Testpublic void test4()&#123; Function&lt;Integer,String[]&gt; func1 = length -&gt; new String[length]; String[] arr1 = func1.apply(5); System.out.println(Arrays.toString(arr1)); System.out.println(&quot;*******************&quot;); Function&lt;Integer,String[]&gt; func2 = String[] :: new; String[] arr2 = func2.apply(10); System.out.println(Arrays.toString(arr2));&#125; 5. Java8新特性：强大的Stream API5.1 说明 Java8中有两大最为重要的改变。第一个是 Lambda 表达式；另外一个则是 Stream API。 Stream API ( java.util.stream) 把真正的函数式编程风格引入到Java中。这是目前为止对Java类库最好的补充，因为Stream API可以极大提供Java程序员的生产力，让程序员写出高效率、干净、简洁的代码。 Stream 是 Java8 中处理集合的关键抽象概念，它可以指定你希望对集合进行的操作，可以执行非常复杂的查找、过滤和映射数据等操作。 使用Stream API 对集合数据进行操作，就类似于使用 SQL 执行的数据库查询。也可以使用 Stream API 来并行执行操作。简言之，Stream API 提供了一种高效且易于使用的处理数据的方式。 5.2 为什么要使用Stream API实际开发中，项目中多数数据源都来自于MySQL、Oracle等。但现在数据源可以更多了，有MongDB，Radis等，而这些NoSQL的数据就需要Java层面去处理。 5.3 什么是StreamStream 是数据渠道，用于操作数据源（集合、数组等）所生成的元素序列。 Stream 和 Collection 集合的区别：Collection 是一种静态的内存数据结构，讲的是数据，而 Stream 是有关计算的，讲的是计算。前者是主要面向内存，存储在内存中，后者主要是面向 CPU，通过 CPU 实现计算。 注意： ①Stream 自己不会存储元素。 ②Stream 不会改变源对象。相反，他们会返回一个持有结果的新Stream。 ③Stream 操作是延迟执行的。这意味着他们会等到需要结果的时候才执行。即一旦执行终止操作，就执行中间操作链，并产生结果。 ④ Stream一旦执行了终止操作，就不能再调用其它中间操作或终止操作了。 5.4 Stream的操作三个步骤1- 创建 Stream一个数据源（如：集合、数组），获取一个流 2- 中间操作每次处理都会返回一个持有结果的新Stream，即中间操作的方法返回值仍然是Stream类型的对象。因此中间操作可以是个操作链，可对数据源的数据进行n次处理，但是在终结操作前，并不会真正执行。 3- 终止操作(终端操作)终止操作的方法返回值类型就不再是Stream了，因此一旦执行终止操作，就结束整个Stream操作了。一旦执行终止操作，就执行中间操作链，最终产生结果并结束Stream。 5.4.1 创建Stream实例方式一：通过集合 Java8 中的 Collection 接口被扩展，提供了两个获取流的方法： default Stream stream() : 返回一个顺序流 default Stream parallelStream() : 返回一个并行流 1234567@Testpublic void test01()&#123; List&lt;Integer&gt; list = Arrays.asList(1,2,3,4,5); //JDK1.8中，Collection系列集合增加了方法 Stream&lt;Integer&gt; stream = list.stream();&#125; 方式二：通过数组 Java8 中的 Arrays 的静态方法 stream() 可以获取数组流： static Stream stream(T[] array): 返回一个流 public static IntStream stream(int[] array) public static LongStream stream(long[] array) public static DoubleStream stream(double[] array) 1234567891011@Testpublic void test02()&#123; String[] arr = &#123;&quot;hello&quot;,&quot;world&quot;&#125;; Stream&lt;String&gt; stream = Arrays.stream(arr); &#125;@Testpublic void test03()&#123; int[] arr = &#123;1,2,3,4,5&#125;; IntStream stream = Arrays.stream(arr);&#125; 方式三：通过Stream的of() 可以调用Stream类静态方法 of(), 通过显示值创建一个流。它可以接收任意数量的参数。 public static Stream of(T… values) : 返回一个流 12345@Testpublic void test04()&#123; Stream&lt;Integer&gt; stream = Stream.of(1,2,3,4,5); stream.forEach(System.out::println);&#125; 方式四：创建无限流(了解) 可以使用静态方法 Stream.iterate() 和 Stream.generate(), 创建无限流。 迭代public static Stream iterate(final T seed, final UnaryOperator f) 生成public static Stream generate(Supplier s) 123456789101112131415// 方式四：创建无限流@Testpublic void test05() &#123; // 迭代 // public static&lt;T&gt; Stream&lt;T&gt; iterate(final T seed, final // UnaryOperator&lt;T&gt; f) Stream&lt;Integer&gt; stream = Stream.iterate(0, x -&gt; x + 2); stream.limit(10).forEach(System.out::println); // 生成 // public static&lt;T&gt; Stream&lt;T&gt; generate(Supplier&lt;T&gt; s) Stream&lt;Double&gt; stream1 = Stream.generate(Math::random); stream1.limit(10).forEach(System.out::println);&#125; 5.4.2 一系列中间操作多个中间操作可以连接起来形成一个流水线，除非流水线上触发终止操作，否则中间操作不会执行任何的处理！而在终止操作时一次性全部处理，称为“惰性求值”。 1-筛选与切片 方 法 描 述 filter(Predicatep) 接收 Lambda ， 从流中排除某些元素 distinct() 筛选，通过流所生成元素的 hashCode() 和 equals() 去除重复元素 limit(long maxSize) 截断流，使其元素不超过给定数量 skip(long n) 跳过元素，返回一个扔掉了前 n 个元素的流。若流中元素不足 n 个，则返回一个空流。与 limit(n) 互补 2-映 射 方法 描述 map(Function f) 接收一个函数作为参数，该函数会被应用到每个元素上，并将其映射成一个新的元素。 mapToDouble(ToDoubleFunction f) 接收一个函数作为参数，该函数会被应用到每个元素上，产生一个新的 DoubleStream。 mapToInt(ToIntFunction f) 接收一个函数作为参数，该函数会被应用到每个元素上，产生一个新的 IntStream。 mapToLong(ToLongFunction f) 接收一个函数作为参数，该函数会被应用到每个元素上，产生一个新的 LongStream。 flatMap(Function f) 接收一个函数作为参数，将流中的每个值都换成另一个流，然后把所有流连接成一个流 3-排序 方法 描述 sorted() 产生一个新流，其中按自然顺序排序 sorted(Comparator com) 产生一个新流，其中按比较器顺序排序 代码举例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105package com.atguigu.stream;import org.junit.Test;import java.util.Arrays;import java.util.stream.Stream;public class StreamMiddleOperate &#123; @Test public void test01()&#123; //1、创建Stream Stream&lt;Integer&gt; stream = Stream.of(1,2,3,4,5,6); //2、加工处理 //过滤：filter(Predicate p) //把里面的偶数拿出来 /* * filter(Predicate p) * Predicate是函数式接口，抽象方法：boolean test(T t) */ stream = stream.filter(t -&gt; t%2==0); //3、终结操作：例如：遍历 stream.forEach(System.out::println); &#125; @Test public void test02()&#123; Stream.of(1,2,3,4,5,6) .filter(t -&gt; t%2==0) .forEach(System.out::println); &#125; @Test public void test03()&#123; Stream.of(1,2,3,4,5,6,2,2,3,3,4,4,5) .distinct() .forEach(System.out::println); &#125; @Test public void test04()&#123; Stream.of(1,2,3,4,5,6,2,2,3,3,4,4,5) .limit(3) .forEach(System.out::println); &#125; @Test public void test05()&#123; Stream.of(1,2,2,3,3,4,4,5,2,3,4,5,6,7) .distinct() //(1,2,3,4,5,6,7) .filter(t -&gt; t%2!=0) //(1,3,5,7) .limit(3) .forEach(System.out::println); &#125; @Test public void test06()&#123; Stream.of(1,2,3,4,5,6,2,2,3,3,4,4,5) .skip(5) .forEach(System.out::println); &#125; @Test public void test07()&#123; Stream.of(1,2,3,4,5,6,2,2,3,3,4,4,5) .skip(5) .distinct() .filter(t -&gt; t%3==0) .forEach(System.out::println); &#125; @Test public void test08()&#123; long count = Stream.of(1,2,3,4,5,6,2,2,3,3,4,4,5) .distinct() .peek(System.out::println) //Consumer接口的抽象方法 void accept(T t) .count(); System.out.println(&quot;count=&quot;+count); &#125; @Test public void test09()&#123; //希望能够找出前三个最大值，前三名最大的，不重复 Stream.of(11,2,39,4,54,6,2,22,3,3,4,54,54) .distinct() .sorted((t1,t2) -&gt; -Integer.compare(t1, t2))//Comparator接口 int compare(T t1, T t2) .limit(3) .forEach(System.out::println); &#125; @Test public void test10()&#123; Stream.of(1,2,3,4,5) .map(t -&gt; t+=1)//Function&lt;T,R&gt;接口抽象方法 R apply(T t) .forEach(System.out::println); &#125; @Test public void test11()&#123; String[] arr = &#123;&quot;hello&quot;,&quot;world&quot;,&quot;java&quot;&#125;; Arrays.stream(arr) .map(t-&gt;t.toUpperCase()) .forEach(System.out::println); &#125; @Test public void test12()&#123; String[] arr = &#123;&quot;hello&quot;,&quot;world&quot;,&quot;java&quot;&#125;; Arrays.stream(arr) .flatMap(t -&gt; Stream.of(t.split(&quot;|&quot;)))//Function&lt;T,R&gt;接口抽象方法 R apply(T t) 现在的R是一个Stream .forEach(System.out::println); &#125; &#125; 5.4.3 终止操作 终端操作会从流的流水线生成结果。其结果可以是任何不是流的值，例如：List、Integer，甚至是 void 。 流进行了终止操作后，不能再次使用。 1-匹配与查找 方法 描述 allMatch(Predicate p) 检查是否匹配所有元素 **anyMatch(Predicate p) ** 检查是否至少匹配一个元素 noneMatch(Predicate p) 检查是否没有匹配所有元素 findFirst() 返回第一个元素 findAny() 返回当前流中的任意元素 count() 返回流中元素总数 max(Comparator c) 返回流中最大值 min(Comparator c) 返回流中最小值 forEach(Consumer c) 内部迭代(使用 Collection 接口需要用户去做迭代，称为外部迭代。相反，Stream API 使用内部迭代——它帮你把迭代做了) 2-归约 方法 描述 reduce(T identity, BinaryOperator b) 可以将流中元素反复结合起来，得到一个值。返回 T reduce(BinaryOperator b) 可以将流中元素反复结合起来，得到一个值。返回 Optional 备注：map 和 reduce 的连接通常称为 map-reduce 模式，因 Google 用它来进行网络搜索而出名。 3-收集 方 法 描 述 collect(Collector c) 将流转换为其他形式。接收一个 Collector接口的实现，用于给Stream中元素做汇总的方法 Collector 接口中方法的实现决定了如何对流执行收集的操作(如收集到 List、Set、Map)。 另外， Collectors 实用类提供了很多静态方法，可以方便地创建常见收集器实例，具体方法与实例如下表： 方法 返回类型 作用 toList Collector&lt;T, ?, List&gt; 把流中元素收集到List 1List&lt;Employee&gt; emps= list.stream().collect(Collectors.toList()); 方法 返回类型 作用 toSet Collector&lt;T, ?, Set&gt; 把流中元素收集到Set 1Set&lt;Employee&gt; emps= list.stream().collect(Collectors.toSet()); 方法 返回类型 作用 toCollection Collector&lt;T, ?, C&gt; 把流中元素收集到创建的集合 1Collection&lt;Employee&gt; emps =list.stream().collect(Collectors.toCollection(ArrayList::new)); 方法 返回类型 作用 counting Collector&lt;T, ?, Long&gt; 计算流中元素的个数 1long count = list.stream().collect(Collectors.counting()); 方法 返回类型 作用 summingInt Collector&lt;T, ?, Integer&gt; 对流中元素的整数属性求和 1int total=list.stream().collect(Collectors.summingInt(Employee::getSalary)); 方法 返回类型 作用 averagingInt Collector&lt;T, ?, Double&gt; 计算流中元素Integer属性的平均值 1double avg = list.stream().collect(Collectors.averagingInt(Employee::getSalary)); 方法 返回类型 作用 summarizingInt Collector&lt;T, ?, IntSummaryStatistics&gt; 收集流中Integer属性的统计值。如：平均值 1int SummaryStatisticsiss= list.stream().collect(Collectors.summarizingInt(Employee::getSalary)); 方法 返回类型 作用 joining Collector&lt;CharSequence, ?, String&gt; 连接流中每个字符串 1String str= list.stream().map(Employee::getName).collect(Collectors.joining()); 方法 返回类型 作用 maxBy Collector&lt;T, ?, Optional&gt; 根据比较器选择最大值 1Optional&lt;Emp&gt;max= list.stream().collect(Collectors.maxBy(comparingInt(Employee::getSalary))); 方法 返回类型 作用 minBy Collector&lt;T, ?, Optional&gt; 根据比较器选择最小值 1Optional&lt;Emp&gt; min = list.stream().collect(Collectors.minBy(comparingInt(Employee::getSalary))); 方法 返回类型 作用 reducing Collector&lt;T, ?, Optional&gt; 从一个作为累加器的初始值开始，利用BinaryOperator与流中元素逐个结合，从而归约成单个值 1int total=list.stream().collect(Collectors.reducing(0, Employee::getSalar, Integer::sum)); 方法 返回类型 作用 collectingAndThen Collector&lt;T,A,RR&gt; 包裹另一个收集器，对其结果转换函数 1int how= list.stream().collect(Collectors.collectingAndThen(Collectors.toList(), List::size)); 方法 返回类型 作用 groupingBy Collector&lt;T, ?, Map&lt;K, List&gt;&gt; 根据某属性值对流分组，属性为K，结果为V 1Map&lt;Emp.Status, List&lt;Emp&gt;&gt; map= list.stream().collect(Collectors.groupingBy(Employee::getStatus)); 方法 返回类型 作用 partitioningBy Collector&lt;T, ?, Map&lt;Boolean, List&gt;&gt; 根据true或false进行分区 1Map&lt;Boolean,List&lt;Emp&gt;&gt; vd = list.stream().collect(Collectors.partitioningBy(Employee::getManage)); 举例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879package com.atguigu.stream;import java.util.List;import java.util.Optional;import java.util.stream.Collectors;import java.util.stream.Stream;import org.junit.Test;public class StreamEndding &#123; @Test public void test01()&#123; Stream.of(1,2,3,4,5) .forEach(System.out::println); &#125; @Test public void test02()&#123; long count = Stream.of(1,2,3,4,5) .count(); System.out.println(&quot;count = &quot; + count); &#125; @Test public void test03()&#123; boolean result = Stream.of(1,3,5,7,9) .allMatch(t -&gt; t%2!=0); System.out.println(result); &#125; @Test public void test04()&#123; boolean result = Stream.of(1,3,5,7,9) .anyMatch(t -&gt; t%2==0); System.out.println(result); &#125; @Test public void test05()&#123; Optional&lt;Integer&gt; opt = Stream.of(1,3,5,7,9).findFirst(); System.out.println(opt); &#125; @Test public void test06()&#123; Optional&lt;Integer&gt; opt = Stream.of(1,2,3,4,5,7,9) .filter(t -&gt; t%3==0) .findFirst(); System.out.println(opt); &#125; @Test public void test07()&#123; Optional&lt;Integer&gt; opt = Stream.of(1,2,4,5,7,8) .filter(t -&gt; t%3==0) .findFirst(); System.out.println(opt); &#125; @Test public void test08()&#123; Optional&lt;Integer&gt; max = Stream.of(1,2,4,5,7,8) .max((t1,t2) -&gt; Integer.compare(t1, t2)); System.out.println(max); &#125; @Test public void test09()&#123; Integer reduce = Stream.of(1,2,4,5,7,8) .reduce(0, (t1,t2) -&gt; t1+t2);//BinaryOperator接口 T apply(T t1, T t2) System.out.println(reduce); &#125; @Test public void test10()&#123; Optional&lt;Integer&gt; max = Stream.of(1,2,4,5,7,8) .reduce((t1,t2) -&gt; t1&gt;t2?t1:t2);//BinaryOperator接口 T apply(T t1, T t2) System.out.println(max); &#125; @Test public void test11()&#123; List&lt;Integer&gt; list = Stream.of(1,2,4,5,7,8) .filter(t -&gt; t%2==0) .collect(Collectors.toList()); System.out.println(list); &#125; &#125; 5.5 Java9新增API新增1：Stream实例化方法 ofNullable()的使用： Java 8 中 Stream 不能完全为null，否则会报空指针异常。而 Java 9 中的 ofNullable 方法允许我们创建一个单元素 Stream，可以包含一个非空元素，也可以创建一个空 Stream。 1234567891011121314151617181920//报NullPointerException//Stream&lt;Object&gt; stream1 = Stream.of(null);//System.out.println(stream1.count());//不报异常，允许通过Stream&lt;String&gt; stringStream = Stream.of(&quot;AA&quot;, &quot;BB&quot;, null);System.out.println(stringStream.count());//3//不报异常，允许通过List&lt;String&gt; list = new ArrayList&lt;&gt;();list.add(&quot;AA&quot;);list.add(null);System.out.println(list.stream().count());//2//ofNullable()：允许值为nullStream&lt;Object&gt; stream1 = Stream.ofNullable(null);System.out.println(stream1.count());//0Stream&lt;String&gt; stream = Stream.ofNullable(&quot;hello world&quot;);System.out.println(stream.count());//1 iterator()重载的使用： 123456//原来的控制终止方式：Stream.iterate(1,i -&gt; i + 1).limit(10).forEach(System.out::println);//现在的终止方式：Stream.iterate(1,i -&gt; i &lt; 100,i -&gt; i + 1).forEach(System.out::println); 5.6 练习现在有两个 ArrayList 集合存储队伍当中的多个成员姓名，要求使用传统的for循环（或增强for循环）依次进行以下若干操作步骤： 第一个队伍只要名字为3个字的成员姓名；存储到一个新集合中。 第一个队伍筛选之后只要前3个人；存储到一个新集合中。 第二个队伍只要姓张的成员姓名；存储到一个新集合中。 第二个队伍筛选之后不要前2个人；存储到一个新集合中。 将两个队伍合并为一个队伍；存储到一个新集合中。 根据姓名创建 Person 对象；存储到一个新集合中。 打印整个队伍的Person对象信息。 Person 类的代码为： 1234567891011121314151617public class Person &#123; private String name; public Person() &#123;&#125; public Person(String name) &#123; this.name = name; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; @Override public String toString() &#123; return &quot;Person&#123;name=&#x27;&quot; + name + &quot;&#x27;&#125;&quot;; &#125;&#125; 两个队伍（集合）的代码如下： 1234567891011121314151617181920212223public static void main(String[] args) &#123; //第一支队伍 ArrayList&lt;String&gt; one = new ArrayList&lt;&gt;(); one.add(&quot;迪丽热巴&quot;); one.add(&quot;宋远桥&quot;); one.add(&quot;苏星河&quot;); one.add(&quot;石破天&quot;); one.add(&quot;石中玉&quot;); one.add(&quot;老子&quot;); one.add(&quot;庄子&quot;); one.add(&quot;洪七公&quot;); //第二支队伍 ArrayList&lt;String&gt; two = new ArrayList&lt;&gt;(); two.add(&quot;古力娜扎&quot;); two.add(&quot;张无忌&quot;); two.add(&quot;赵丽颖&quot;); two.add(&quot;张三丰&quot;); two.add(&quot;尼古拉斯赵四&quot;); two.add(&quot;张天爱&quot;); two.add(&quot;张二狗&quot;); // ....编写代码完成题目要求 &#125; 参考答案： 123456789101112131415161718192021222324252627282930313233343536public static void main(String[] args) &#123; //第一支队伍 ArrayList&lt;String&gt; one = new ArrayList&lt;&gt;(); one.add(&quot;迪丽热巴&quot;); one.add(&quot;宋远桥&quot;); one.add(&quot;苏星河&quot;); one.add(&quot;石破天&quot;); one.add(&quot;石中玉&quot;); one.add(&quot;老子&quot;); one.add(&quot;庄子&quot;); one.add(&quot;洪七公&quot;); //第二支队伍 ArrayList&lt;String&gt; two = new ArrayList&lt;&gt;(); two.add(&quot;古力娜扎&quot;); two.add(&quot;张无忌&quot;); two.add(&quot;赵丽颖&quot;); two.add(&quot;张三丰&quot;); two.add(&quot;尼古拉斯赵四&quot;); two.add(&quot;张天爱&quot;); two.add(&quot;张二狗&quot;); // 第一个队伍只要名字为3个字的成员姓名； // 第一个队伍筛选之后只要前3个人； Stream&lt;String&gt; streamOne = one.stream().filter(s ‐&gt; s.length() == 3).limit(3); // 第二个队伍只要姓张的成员姓名； // 第二个队伍筛选之后不要前2个人； Stream&lt;String&gt; streamTwo = two.stream().filter(s ‐&gt; s.startsWith(&quot;张&quot;)).skip(2); // 将两个队伍合并为一个队伍； // 根据姓名创建Person对象； // 打印整个队伍的Person对象信息。 Stream.concat(streamOne, streamTwo).map(Person::new).forEach(System.out::println); &#125;","categories":[],"tags":[]},{"title":"","slug":"Java/尚硅谷_第17章_反射机制/尚硅谷_宋红康_第17章_反射机制","date":"2023-10-07T11:18:34.245Z","updated":"2022-12-27T10:18:44.545Z","comments":true,"path":"2023/10/07/Java/尚硅谷_第17章_反射机制/尚硅谷_宋红康_第17章_反射机制/","link":"","permalink":"http://example.com/2023/10/07/Java/%E5%B0%9A%E7%A1%85%E8%B0%B7_%E7%AC%AC17%E7%AB%A0_%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/%E5%B0%9A%E7%A1%85%E8%B0%B7_%E5%AE%8B%E7%BA%A2%E5%BA%B7_%E7%AC%AC17%E7%AB%A0_%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/","excerpt":"","text":"第17章_反射机制讲师：尚硅谷-宋红康（江湖人称：康师傅） 官网：http://www.atguigu.com 本章专题与脉络 1. 反射(Reflection)的概念1.1 反射的出现背景Java程序中，所有的对象都有两种类型：编译时类型和运行时类型，而很多时候对象的编译时类型和运行时类型不一致。 Object obj &#x3D; new String(“hello”); obj.getClass() 例如：某些变量或形参的声明类型是Object类型，但是程序却需要调用该对象运行时类型的方法，该方法不是Object中的方法，那么如何解决呢？ 解决这个问题，有两种方案： 方案1：在编译和运行时都完全知道类型的具体信息，在这种情况下，我们可以直接先使用instanceof运算符进行判断，再利用强制类型转换符将其转换成运行时类型的变量即可。 方案2：编译时根本无法预知该对象和类的真实信息，程序只能依靠运行时信息来发现该对象和类的真实信息，这就必须使用反射。 1.2 反射概述Reflection（反射）是被视为动态语言的关键，反射机制允许程序在运行期间借助于Reflection API取得任何类的内部信息，并能直接操作任意对象的内部属性及方法。 加载完类之后，在堆内存的方法区中就产生了一个Class类型的对象（一个类只有一个Class对象），这个对象就包含了完整的类的结构信息。我们可以通过这个对象看到类的结构。这个对象就像一面镜子，透过这个镜子看到类的结构，所以，我们形象的称之为：反射。 从内存加载上看反射： 1.3 Java反射机制研究及应用Java反射机制提供的功能： 在运行时判断任意一个对象所属的类 在运行时构造任意一个类的对象 在运行时判断任意一个类所具有的成员变量和方法 在运行时获取泛型信息 在运行时调用任意一个对象的成员变量和方法 在运行时处理注解 生成动态代理 1.4 反射相关的主要APIjava.lang.Class：代表一个类java.lang.reflect.Method：代表类的方法java.lang.reflect.Field：代表类的成员变量java.lang.reflect.Constructor：代表类的构造器… … 1.5 反射的优缺点优点： 提高了Java程序的灵活性和扩展性，降低了耦合性，提高自适应能力 允许程序创建和控制任何类的对象，无需提前硬编码目标类 缺点： 反射的性能较低。 反射机制主要应用在对灵活性和扩展性要求很高的系统框架上 反射会模糊程序内部逻辑，可读性较差。 2. 理解Class类并获取Class实例要想解剖一个类，必须先要获取到该类的Class对象。而剖析一个类或用反射解决具体的问题就是使用相关API: java.lang.Class java.lang.reflect.* 所以，Class对象是反射的根源。 2.1 理解Class2.1.1 理论上在Object类中定义了以下的方法，此方法将被所有子类继承： 1public final Class getClass() 以上的方法返回值的类型是一个Class类，此类是Java反射的源头，实际上所谓反射从程序的运行结果来看也很好理解，即：可以通过对象反射求出类的名称。 对象照镜子后可以得到的信息：某个类的属性、方法和构造器、某个类到底实现了哪些接口。对于每个类而言，JRE 都为其保留一个不变的 Class 类型的对象。一个 Class 对象包含了特定某个结构(class&#x2F;interface&#x2F;enum&#x2F;annotation&#x2F;primitive type&#x2F;void&#x2F;[])的有关信息。 Class本身也是一个类 Class 对象只能由系统建立对象 一个加载的类在 JVM 中只会有一个Class实例 一个Class对象对应的是一个加载到JVM中的一个.class文件 每个类的实例都会记得自己是由哪个 Class 实例所生成 通过Class可以完整地得到一个类中的所有被加载的结构 Class类是Reflection的根源，针对任何你想动态加载、运行的类，唯有先获得相应的Class对象 2.1.2 内存结构上 说明：上图中字符串常量池在JDK6中存储在方法区；JDK7及以后，存储在堆空间。 2.2 获取Class类的实例(四种方法)方式1：要求编译期间已知类型 前提：若已知具体的类，通过类的class属性获取，该方法最为安全可靠，程序性能最高 实例： 1Class clazz = String.class; 方式2：获取对象的运行时类型 前提：已知某个类的实例，调用该实例的getClass()方法获取Class对象 实例： 1Class clazz = &quot;www.atguigu.com&quot;.getClass(); 方式3：可以获取编译期间未知的类型 前提：已知一个类的全类名，且该类在类路径下，可通过Class类的静态方法forName()获取，可能抛出ClassNotFoundException 实例： 1Class clazz = Class.forName(&quot;java.lang.String&quot;); 方式4：其他方式(不做要求) 前提：可以用系统类加载对象或自定义加载器对象加载指定路径下的类型 实例： 12ClassLoader cl = this.getClass().getClassLoader();Class clazz4 = cl.loadClass(&quot;类的全类名&quot;); 再举例： 12345678910111213141516171819public class GetClassObject &#123; @Test public void test01() throws ClassNotFoundException&#123; Class c1 = GetClassObject.class; GetClassObject obj = new GetClassObject(); Class c2 = obj.getClass(); Class c3 = Class.forName(&quot;com.atguigu.classtype.GetClassObject&quot;); Class c4 = ClassLoader.getSystemClassLoader().loadClass(&quot;com.atguigu.classtype.GetClassObject&quot;); System.out.println(&quot;c1 = &quot; + c1); System.out.println(&quot;c2 = &quot; + c2); System.out.println(&quot;c3 = &quot; + c3); System.out.println(&quot;c4 = &quot; + c4); System.out.println(c1 == c2); System.out.println(c1 == c3); System.out.println(c1 == c4); &#125;&#125; 2.3 哪些类型可以有Class对象简言之，所有Java类型！ （1）class：外部类，成员(成员内部类，静态内部类)，局部内部类，匿名内部类（2）interface：接口（3）[]：数组（4）enum：枚举（5）annotation：注解@interface（6）primitive type：基本数据类型（7）void 举例： 12345678910111213141516Class c1 = Object.class;Class c2 = Comparable.class;Class c3 = String[].class;Class c4 = int[][].class;Class c5 = ElementType.class;Class c6 = Override.class;Class c7 = int.class;Class c8 = void.class;Class c9 = Class.class;int[] a = new int[10];int[] b = new int[100];Class c10 = a.getClass();Class c11 = b.getClass();// 只要元素类型与维度一样，就是同一个ClassSystem.out.println(c10 == c11); 2.4 Class类的常用方法 方法名 功能说明 static Class forName(String name) 返回指定类名 name 的 Class 对象 Object newInstance() 调用缺省构造函数，返回该Class对象的一个实例 getName() 返回此Class对象所表示的实体（类、接口、数组类、基本类型或void）名称 Class getSuperClass() 返回当前Class对象的父类的Class对象 Class [] getInterfaces() 获取当前Class对象的接口 ClassLoader getClassLoader() 返回该类的类加载器 Class getSuperclass() 返回表示此Class所表示的实体的超类的Class Constructor[] getConstructors() 返回一个包含某些Constructor对象的数组 Field[] getDeclaredFields() 返回Field对象的一个数组 Method getMethod(String name,Class … paramTypes) 返回一个Method对象，此对象的形参类型为paramType 举例： 1234567891011String str = &quot;test4.Person&quot;;Class clazz = Class.forName(str);Object obj = clazz.newInstance();Field field = clazz.getField(&quot;name&quot;);field.set(obj, &quot;Peter&quot;);Object name = field.get(obj);System.out.println(name);//注：test4.Person是test4包下的Person类 3. 类的加载与ClassLoader的理解3.1 类的生命周期类在内存中完整的生命周期：加载–&gt;使用–&gt;卸载。其中加载过程又分为：装载、链接、初始化三个阶段。 3.2 类的加载过程当程序主动使用某个类时，如果该类还未被加载到内存中，系统会通过加载、链接、初始化三个步骤来对该类进行初始化。如果没有意外，JVM将会连续完成这三个步骤，所以有时也把这三个步骤统称为类加载。 类的加载又分为三个阶段： （1）装载（Loading） 将类的class文件读入内存，并为之创建一个java.lang.Class对象。此过程由类加载器完成 （2）链接（Linking） ①验证Verify：确保加载的类信息符合JVM规范，例如：以cafebabe开头，没有安全方面的问题。 ②准备Prepare：正式为类变量（static）分配内存并设置类变量默认初始值的阶段，这些内存都将在方法区中进行分配。 ③解析Resolve：虚拟机常量池内的符号引用（常量名）替换为直接引用（地址）的过程。 （3）初始化（Initialization） 执行类构造器&lt;clinit&gt;()方法的过程。类构造器&lt;clinit&gt;()方法是由编译期自动收集类中所有类变量的赋值动作和静态代码块中的语句合并产生的。（类构造器是构造类信息的，不是构造该类对象的构造器）。 当初始化一个类的时候，如果发现其父类还没有进行初始化，则需要先触发其父类的初始化。 虚拟机会保证一个类的&lt;clinit&gt;()方法在多线程环境中被正确加锁和同步。 3.3 类加载器（classloader) 3.3.1 类加载器的作用将class文件字节码内容加载到内存中，并将这些静态数据转换成方法区的运行时数据结构，然后在堆中生成一个代表这个类的java.lang.Class对象，作为方法区中类数据的访问入口。 类缓存：标准的JavaSE类加载器可以按要求查找类，但一旦某个类被加载到类加载器中，它将维持加载（缓存）一段时间。不过JVM垃圾回收机制可以回收这些Class对象。 3.3.2 类加载器的分类(JDK8为例)JVM支持两种类型的类加载器，分别为引导类加载器（Bootstrap ClassLoader）和自定义类加载器（User-Defined ClassLoader）。 从概念上来讲，自定义类加载器一般指的是程序中由开发人员自定义的一类类加载器，但是Java虚拟机规范却没有这么定义，而是将所有派生于抽象类ClassLoader的类加载器都划分为自定义类加载器。无论类加载器的类型如何划分，在程序中我们最常见的类加载器结构主要是如下情况： （1）启动类加载器（引导类加载器，Bootstrap ClassLoader） 这个类加载使用C/C++语言实现的，嵌套在JVM内部。获取它的对象时往往返回null 它用来加载Java的核心库（JAVA_HOME&#x2F;jre&#x2F;lib&#x2F;rt.jar或sun.boot.class.path路径下的内容）。用于提供JVM自身需要的类。 并不继承自java.lang.ClassLoader，没有父加载器。 出于安全考虑，Bootstrap启动类加载器只加载包名为java、javax、sun等开头的类 加载扩展类和应用程序类加载器，并指定为他们的父类加载器。 （2）扩展类加载器（Extension ClassLoader） Java语言编写，由sun.misc.Launcher$ExtClassLoader实现。 继承于ClassLoader类 父类加载器为启动类加载器 从java.ext.dirs系统属性所指定的目录中加载类库，或从JDK的安装目录的jre&#x2F;lib&#x2F;ext子目录下加载类库。如果用户创建的JAR放在此目录下，也会自动由扩展类加载器加载。 （3）应用程序类加载器（系统类加载器，AppClassLoader） java语言编写，由sun.misc.Launcher$AppClassLoader实现 继承于ClassLoader类 父类加载器为扩展类加载器 它负责加载环境变量classpath或系统属性 java.class.path 指定路径下的类库 应用程序中的类加载器默认是系统类加载器。 它是用户自定义类加载器的默认父加载器 通过ClassLoader的getSystemClassLoader()方法可以获取到该类加载器 （4）用户自定义类加载器（了解） 在Java的日常应用程序开发中，类的加载几乎是由上述3种类加载器相互配合执行的。在必要时，我们还可以自定义类加载器，来定制类的加载方式。 体现Java语言强大生命力和巨大魅力的关键因素之一便是，Java开发者可以自定义类加载器来实现类库的动态加载，加载源可以是本地的JAR包，也可以是网络上的远程资源。 同时，自定义加载器能够实现应用隔离，例如 Tomcat，Spring等中间件和组件框架都在内部实现了自定义的加载器，并通过自定义加载器隔离不同的组件模块。这种机制比C&#x2F;C++程序要好太多，想不修改C&#x2F;C++程序就能为其新增功能，几乎是不可能的，仅仅一个兼容性便能阻挡住所有美好的设想。 自定义类加载器通常需要继承于ClassLoader。 3.3.3 查看某个类的类加载器对象（1）获取默认的系统类加载器 1ClassLoader classloader = ClassLoader.getSystemClassLoader(); （2）查看某个类是哪个类加载器加载的 1234ClassLoader classloader = Class.forName(&quot;exer2.ClassloaderDemo&quot;).getClassLoader();//如果是根加载器加载的类，则会得到nullClassLoader classloader1 = Class.forName(&quot;java.lang.Object&quot;).getClassLoader(); （3）获取某个类加载器的父加载器 1ClassLoader parentClassloader = classloader.getParent(); 示例代码： 123456789101112131415161718192021222324252627282930313233343536package com.atguigu.loader;import org.junit.Test;public class TestClassLoader &#123; @Test public void test01()&#123; ClassLoader systemClassLoader = ClassLoader.getSystemClassLoader(); System.out.println(&quot;systemClassLoader = &quot; + systemClassLoader); &#125; @Test public void test02()throws Exception&#123; ClassLoader c1 = String.class.getClassLoader(); System.out.println(&quot;加载String类的类加载器：&quot; + c1); ClassLoader c2 = Class.forName(&quot;sun.util.resources.cldr.zh.TimeZoneNames_zh&quot;).getClassLoader(); System.out.println(&quot;加载sun.util.resources.cldr.zh.TimeZoneNames_zh类的类加载器：&quot; + c2); ClassLoader c3 = TestClassLoader.class.getClassLoader(); System.out.println(&quot;加载当前类的类加载器：&quot; + c3); &#125; @Test public void test03()&#123; ClassLoader c1 = TestClassLoader.class.getClassLoader(); System.out.println(&quot;加载当前类的类加载器c1=&quot; + c1); ClassLoader c2 = c1.getParent(); System.out.println(&quot;c1.parent = &quot; + c2); ClassLoader c3 = c2.getParent(); System.out.println(&quot;c2.parent = &quot; + c3); &#125;&#125; 3.3.4 使用ClassLoader获取流关于类加载器的一个主要方法：getResourceAsStream(String str):获取类路径下的指定文件的输入流 12345InputStream in = null;in = this.getClass().getClassLoader().getResourceAsStream(&quot;exer2\\\\test.properties&quot;);System.out.println(in); 举例： 1234567891011121314151617181920//需要掌握如下的代码 @Test public void test5() throws IOException &#123; Properties pros = new Properties(); //方式1：此时默认的相对路径是当前的module// FileInputStream is = new FileInputStream(&quot;info.properties&quot;);// FileInputStream is = new FileInputStream(&quot;src//info1.properties&quot;); //方式2：使用类的加载器 //此时默认的相对路径是当前module的src目录 InputStream is = ClassLoader.getSystemClassLoader().getResourceAsStream(&quot;info1.properties&quot;); pros.load(is); //获取配置文件中的信息 String name = pros.getProperty(&quot;name&quot;); String password = pros.getProperty(&quot;password&quot;); System.out.println(&quot;name = &quot; + name + &quot;, password = &quot; + password); &#125; 4. 反射的基本应用有了Class对象，能做什么？ 4.1 应用1：创建运行时类的对象这是反射机制应用最多的地方。创建运行时类的对象有两种方式： 方式1：直接调用Class对象的newInstance()方法 要 求： 1）类必须有一个无参数的构造器。2）类的构造器的访问权限需要足够。 方式2：通过获取构造器对象来进行实例化 方式一的步骤： 1）获取该类型的Class对象 2）调用Class对象的newInstance()方法创建对象 方式二的步骤： 1）通过Class类的getDeclaredConstructor(Class … parameterTypes)取得本类的指定形参类型的构造器2）向构造器的形参中传递一个对象数组进去，里面包含了构造器中所需的各个参数。3）通过Constructor实例化对象。 如果构造器的权限修饰符修饰的范围不可见，也可以调用setAccessible(true) 示例代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546package com.atguigu.reflect;import org.junit.Test;import java.lang.reflect.Constructor;public class TestCreateObject &#123; @Test public void test1() throws Exception&#123;// AtGuiguClass obj = new AtGuiguClass();//编译期间无法创建 Class&lt;?&gt; clazz = Class.forName(&quot;com.atguigu.ext.demo.AtGuiguClass&quot;); //clazz代表com.atguigu.ext.demo.AtGuiguClass类型 //clazz.newInstance()创建的就是AtGuiguClass的对象 Object obj = clazz.newInstance(); System.out.println(obj); &#125; @Test public void test2()throws Exception&#123; Class&lt;?&gt; clazz = Class.forName(&quot;com.atguigu.ext.demo.AtGuiguDemo&quot;); //java.lang.InstantiationException: com.atguigu.ext.demo.AtGuiguDemo //Caused by: java.lang.NoSuchMethodException: com.atguigu.ext.demo.AtGuiguDemo.&lt;init&gt;() //即说明AtGuiguDemo没有无参构造，就没有无参实例初始化方法&lt;init&gt; Object stu = clazz.newInstance(); System.out.println(stu); &#125; @Test public void test3()throws Exception&#123; //(1)获取Class对象 Class&lt;?&gt; clazz = Class.forName(&quot;com.atguigu.ext.demo.AtGuiguDemo&quot;); /* * 获取AtGuiguDemo类型中的有参构造 * 如果构造器有多个，我们通常是根据形参【类型】列表来获取指定的一个构造器的 * 例如：public AtGuiguDemo(String title, int num) */ //(2)获取构造器对象 Constructor&lt;?&gt; constructor = clazz.getDeclaredConstructor(String.class,int.class); //(3)创建实例对象 // T newInstance(Object... initargs) 这个Object...是在创建对象时，给有参构造的实参列表 Object obj = constructor.newInstance(&quot;尚硅谷&quot;,2022); System.out.println(obj); &#125;&#125; 4.2 应用2：获取运行时类的完整结构可以获取：包、修饰符、类型名、父类（包括泛型父类）、父接口（包括泛型父接口）、成员（属性、构造器、方法）、注解（类上的、方法上的、属性上的）。 4.2.1 相关API1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465//1.实现的全部接口public Class&lt;?&gt;[] getInterfaces() //确定此对象所表示的类或接口实现的接口。 //2.所继承的父类public Class&lt;? Super T&gt; getSuperclass()//返回表示此 Class 所表示的实体（类、接口、基本类型）的父类的 Class。//3.全部的构造器public Constructor&lt;T&gt;[] getConstructors()//返回此 Class 对象所表示的类的所有public构造方法。public Constructor&lt;T&gt;[] getDeclaredConstructors()//返回此 Class 对象表示的类声明的所有构造方法。//Constructor类中：//取得修饰符: public int getModifiers();//取得方法名称: public String getName();//取得参数的类型：public Class&lt;?&gt;[] getParameterTypes();//4.全部的方法public Method[] getDeclaredMethods()//返回此Class对象所表示的类或接口的全部方法public Method[] getMethods() //返回此Class对象所表示的类或接口的public的方法//Method类中：public Class&lt;?&gt; getReturnType()//取得全部的返回值public Class&lt;?&gt;[] getParameterTypes()//取得全部的参数public int getModifiers()//取得修饰符public Class&lt;?&gt;[] getExceptionTypes()//取得异常信息//5.全部的Fieldpublic Field[] getFields() //返回此Class对象所表示的类或接口的public的Field。public Field[] getDeclaredFields() //返回此Class对象所表示的类或接口的全部Field。//Field方法中：public int getModifiers()//以整数形式返回此Field的修饰符public Class&lt;?&gt; getType() //得到Field的属性类型public String getName() //返回Field的名称。//6. Annotation相关get Annotation(Class&lt;T&gt; annotationClass) getDeclaredAnnotations() //7.泛型相关//获取父类泛型类型：Type getGenericSuperclass()//泛型类型：ParameterizedType//获取实际的泛型类型参数数组：getActualTypeArguments()//8.类所在的包Package getPackage() 4.2.2 获取所有的属性及相关细节12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667package com.atguigu.java2;import java.lang.reflect.Field;import java.lang.reflect.Modifier;import org.junit.Test;import com.atguigu.java1.Person;public class FieldTest &#123; @Test public void test1()&#123; Class clazz = Person.class; //getFields():获取到运行时类本身及其所有的父类中声明为public权限的属性// Field[] fields = clazz.getFields();//// for(Field f : fields)&#123;// System.out.println(f);// &#125; //getDeclaredFields():获取当前运行时类中声明的所有属性 Field[] declaredFields = clazz.getDeclaredFields(); for(Field f : declaredFields)&#123; System.out.println(f); &#125; &#125; //权限修饰符 变量类型 变量名 @Test public void test2()&#123; Class clazz = Person.class; Field[] declaredFields = clazz.getDeclaredFields(); for(Field f : declaredFields)&#123; //1.权限修饰符 /* * 0x是十六进制 * PUBLIC = 0x00000001; 1 1 * PRIVATE = 0x00000002; 2 10 * PROTECTED = 0x00000004; 4 100 * STATIC = 0x00000008; 8 1000 * FINAL = 0x00000010; 16 10000 * ... * * 设计的理念，就是用二进制的某一位是1，来代表一种修饰符，整个二进制中只有一位是1，其余都是0 * * mod = 17 0x00000011 * if ((mod &amp; PUBLIC) != 0) 说明修饰符中有public * if ((mod &amp; FINAL) != 0) 说明修饰符中有final */ int modifier = f.getModifiers(); System.out.print(Modifier.toString(modifier) + &quot;\\t&quot;);// //2.数据类型 Class type = f.getType(); System.out.print(type.getName() + &quot;\\t&quot;);//// //3.变量名 String fName = f.getName(); System.out.print(fName);// System.out.println(); &#125; &#125;&#125; 4.2.3 获取所有的方法及相关细节1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586package com.atguigu.java2;import java.lang.annotation.Annotation;import java.lang.reflect.Method;import java.lang.reflect.Modifier;import org.junit.Test;import com.atguigu.java1.Person;public class MethodTest &#123; @Test public void test1() &#123; Class clazz = Person.class; // getMethods():获取到运行时类本身及其所有的父类中声明为public权限的方法 // Method[] methods = clazz.getMethods(); // // for(Method m : methods)&#123; // System.out.println(m); // &#125; // getDeclaredMethods():获取当前运行时类中声明的所有方法 Method[] declaredMethods = clazz.getDeclaredMethods(); for (Method m : declaredMethods) &#123; System.out.println(m); &#125; // &#125; // 注解信息 // 权限修饰符 返回值类型 方法名(形参类型1 参数1,形参类型2 参数2,...) throws 异常类型1,...&#123;&#125; @Test public void test2() &#123; Class clazz = Person.class; Method[] declaredMethods = clazz.getDeclaredMethods(); for (Method m : declaredMethods) &#123; // 1.获取方法声明的注解 Annotation[] annos = m.getAnnotations(); for (Annotation a : annos) &#123; System.out.println(a); &#125; // 2.权限修饰符 System.out.print(Modifier.toString(m.getModifiers()) + &quot;\\t&quot;); // 3.返回值类型 System.out.print(m.getReturnType().getName() + &quot;\\t&quot;); // 4.方法名 System.out.print(m.getName()); System.out.print(&quot;(&quot;); // 5.形参列表 Class[] parameterTypes = m.getParameterTypes(); if (!(parameterTypes == null &amp;&amp; parameterTypes.length == 0)) &#123; for (int i = 0; i &lt; parameterTypes.length; i++) &#123; if (i == parameterTypes.length - 1) &#123; System.out.print(parameterTypes[i].getName() + &quot; args_&quot; + i); break; &#125; System.out.print(parameterTypes[i].getName() + &quot; args_&quot; + i + &quot;,&quot;); &#125; &#125; System.out.print(&quot;)&quot;); // 6.抛出的异常 Class[] exceptionTypes = m.getExceptionTypes(); if (exceptionTypes.length &gt; 0) &#123; System.out.print(&quot;throws &quot;); for (int i = 0; i &lt; exceptionTypes.length; i++) &#123; if (i == exceptionTypes.length - 1) &#123; System.out.print(exceptionTypes[i].getName()); break; &#125; System.out.print(exceptionTypes[i].getName() + &quot;,&quot;); &#125; &#125; System.out.println(); &#125; &#125;&#125; 4.2.4 获取其他结构(构造器、父类、接口、包、注解等)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384package com.atguigu.java2;import com.atguigu.java1.Person;import org.junit.Test;import java.lang.annotation.Annotation;import java.lang.reflect.Constructor;import java.lang.reflect.ParameterizedType;import java.lang.reflect.Type;/** * @author 尚硅谷-宋红康 * @create 2020 下午 2:47 */public class OtherTest &#123; /* 获取当前类中的所有的构造器 */ @Test public void test1()&#123; Class clazz = Person.class; Constructor[] cons = clazz.getDeclaredConstructors(); for(Constructor c :cons)&#123; System.out.println(c); &#125; &#125; /* 获取运行时类的父类 */ @Test public void test2()&#123; Class clazz = Person.class; Class superclass = clazz.getSuperclass(); System.out.println(superclass);//class com.atguigu.java1.Creature &#125; /* 获取运行时类的所在的包 */ @Test public void test3()&#123; Class clazz = Person.class; Package pack = clazz.getPackage(); System.out.println(pack); &#125; /* 获取运行时类的注解 */ @Test public void test4()&#123; Class clazz = Person.class; Annotation[] annos = clazz.getAnnotations(); for (Annotation anno : annos) &#123; System.out.println(anno); &#125; &#125; /* 获取运行时类所实现的接口 */ @Test public void test5()&#123; Class clazz = Person.class; Class[] interfaces = clazz.getInterfaces(); for (Class anInterface : interfaces) &#123; System.out.println(anInterface); &#125; &#125; /* 获取运行时类的带泛型的父类 */ @Test public void test6()&#123; Class clazz = Person.class; Type genericSuperclass = clazz.getGenericSuperclass(); System.out.println(genericSuperclass);//com.atguigu.java1.Creature&lt;java.lang.String&gt; &#125;&#125; 4.2.5 获取泛型父类信息（选讲）示例代码获取泛型父类信息： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/* Type： * （1）Class * （2）ParameterizedType * 例如：Father&lt;String,Integer&gt; * ArrayList&lt;String&gt; * （3）TypeVariable * 例如：T，U,E,K,V * （4）WildcardType * 例如： * ArrayList&lt;?&gt; * ArrayList&lt;? super 下限&gt; * ArrayList&lt;? extends 上限&gt; * （5）GenericArrayType * 例如：T[] * */public class TestGeneric &#123; public static void main(String[] args) &#123; //需求：在运行时，获取Son类型的泛型父类的泛型实参&lt;String,Integer&gt; //（1）还是先获取Class对象 Class clazz = Son.class;//四种形式任意一种都可以 //（2）获取泛型父类// Class sc = clazz.getSuperclass();// System.out.println(sc); /* * getSuperclass()只能得到父类名，无法得到父类的泛型实参列表 */ Type type = clazz.getGenericSuperclass(); // Father&lt;String,Integer&gt;属于ParameterizedType ParameterizedType pt = (ParameterizedType) type; //（3）获取泛型父类的泛型实参列表 Type[] typeArray = pt.getActualTypeArguments(); for (Type type2 : typeArray) &#123; System.out.println(type2); &#125; &#125;&#125;//泛型形参：&lt;T,U&gt;class Father&lt;T,U&gt;&#123; &#125;//泛型实参：&lt;String,Integer&gt;class Son extends Father&lt;String,Integer&gt;&#123; &#125; 4.2.6 获取内部类或外部类信息（选讲）public Class&lt;?&gt;[] getClasses()：返回所有公共内部类和内部接口。包括从超类继承的公共类和接口成员以及该类声明的公共类和接口成员。 public Class&lt;?&gt;[] getDeclaredClasses()：返回 Class 对象的一个数组，这些对象反映声明为此 Class 对象所表示的类的成员的所有类和接口。包括该类所声明的公共、保护、默认（包）访问及私有类和接口，但不包括继承的类和接口。 public Class&lt;?&gt; getDeclaringClass()：如果此 Class 对象所表示的类或接口是一个内部类或内部接口，则返回它的外部类或外部接口，否则返回null。 Class&lt;?&gt; getEnclosingClass() ：返回某个内部类的外部类 123456789101112@Testpublic void test5()&#123; Class&lt;?&gt; clazz = Map.class; Class&lt;?&gt;[] inners = clazz.getDeclaredClasses(); for (Class&lt;?&gt; inner : inners) &#123; System.out.println(inner); &#125; Class&lt;?&gt; ec = Map.Entry.class; Class&lt;?&gt; outer = ec.getDeclaringClass(); System.out.println(outer);&#125; 4.2.7 小 结 在实际的操作中，取得类的信息的操作代码，并不会经常开发。 一定要熟悉java.lang.reflect包的作用，反射机制。 4.3 应用3：调用运行时类的指定结构4.3.1 调用指定的属性在反射机制中，可以直接通过Field类操作类中的属性，通过Field类提供的set()和get()方法就可以完成设置和取得属性内容的操作。 （1）获取该类型的Class对象 Class clazz &#x3D; Class.forName(“包.类名”); （2）获取属性对象 Field field &#x3D; clazz.getDeclaredField(“属性名”); （3）如果属性的权限修饰符不是public，那么需要设置属性可访问 field.setAccessible(true); （4）创建实例对象：如果操作的是非静态属性，需要创建实例对象 Object obj &#x3D; clazz.newInstance(); &#x2F;&#x2F;有公共的无参构造 Object obj &#x3D; 构造器对象.newInstance(实参…);&#x2F;&#x2F;通过特定构造器对象创建实例对象 （4）设置指定对象obj上此Field的属性内容 field.set(obj,”属性值”); 如果操作静态变量，那么实例对象可以省略，用null表示 （5）取得指定对象obj上此Field的属性内容 Object value &#x3D; field.get(obj); 如果操作静态变量，那么实例对象可以省略，用null表示 示例代码： 12345678910111213141516171819202122232425262728293031package com.atguigu.reflect;public class Student &#123; private int id; private String name; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; @Override public String toString() &#123; return &quot;Student&#123;&quot; + &quot;id=&quot; + id + &quot;, name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637package com.atguigu.reflect;import java.lang.reflect.Field;public class TestField &#123; public static void main(String[] args)throws Exception &#123; //1、获取Student的Class对象 Class clazz = Class.forName(&quot;com.atguigu.reflect.Student&quot;); //2、获取属性对象，例如：id属性 Field idField = clazz.getDeclaredField(&quot;id&quot;); //3、如果id是私有的等在当前类中不可访问access的，我们需要做如下操作 idField.setAccessible(true); //4、创建实例对象，即，创建Student对象 Object stu = clazz.newInstance(); //5、获取属性值 /* * 以前：int 变量= 学生对象.getId() * 现在：Object id属性对象.get(学生对象) */ Object value = idField.get(stu); System.out.println(&quot;id = &quot;+ value); //6、设置属性值 /* * 以前：学生对象.setId(值) * 现在：id属性对象.set(学生对象,值) */ idField.set(stu, 2); value = idField.get(stu); System.out.println(&quot;id = &quot;+ value); &#125;&#125; 关于setAccessible方法的使用： Method和Field、Constructor对象都有setAccessible()方法。 setAccessible启动和禁用访问安全检查的开关。 参数值为true则指示反射的对象在使用时应该取消Java语言访问检查。 提高反射的效率。如果代码中必须用反射，而该句代码需要频繁的被调用，那么请设置为true。 使得原本无法访问的私有成员也可以访问 参数值为false则指示反射的对象应该实施Java语言访问检查。 4.3.2 调用指定的方法 （1）获取该类型的Class对象 Class clazz &#x3D; Class.forName(“包.类名”); （2）获取方法对象 Method method &#x3D; clazz.getDeclaredMethod(“方法名”,方法的形参类型列表); （3）创建实例对象 Object obj &#x3D; clazz.newInstance(); （4）调用方法 Object result &#x3D; method.invoke(obj, 方法的实参值列表); 如果方法的权限修饰符修饰的范围不可见，也可以调用setAccessible(true) 如果方法是静态方法，实例对象也可以省略，用null代替 示例代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package com.atguigu.reflect;import org.junit.Test;import java.lang.reflect.Method;public class TestMethod &#123; @Test public void test()throws Exception &#123; // 1、获取Student的Class对象 Class&lt;?&gt; clazz = Class.forName(&quot;com.atguigu.reflect.Student&quot;); //2、获取方法对象 /* * 在一个类中，唯一定位到一个方法，需要：（1）方法名（2）形参列表，因为方法可能重载 * * 例如：void setName(String name) */ Method setNameMethod = clazz.getDeclaredMethod(&quot;setName&quot;, String.class); //3、创建实例对象 Object stu = clazz.newInstance(); //4、调用方法 /* * 以前：学生对象.setName(值) * 现在：方法对象.invoke(学生对象，值) */ Object setNameMethodReturnValue = setNameMethod.invoke(stu, &quot;张三&quot;); System.out.println(&quot;stu = &quot; + stu); //setName方法返回值类型void，没有返回值，所以setNameMethodReturnValue为null System.out.println(&quot;setNameMethodReturnValue = &quot; + setNameMethodReturnValue); Method getNameMethod = clazz.getDeclaredMethod(&quot;getName&quot;); Object getNameMethodReturnValue = getNameMethod.invoke(stu); //getName方法返回值类型String，有返回值，getNameMethod.invoke的返回值就是getName方法的返回值 System.out.println(&quot;getNameMethodReturnValue = &quot; + getNameMethodReturnValue);//张三 &#125; @Test public void test02()throws Exception&#123; Class&lt;?&gt; clazz = Class.forName(&quot;com.atguigu.ext.demo.AtGuiguClass&quot;); Method printInfoMethod = clazz.getMethod(&quot;printInfo&quot;, String.class); //printInfo方法是静态方法 printInfoMethod.invoke(null,&quot;尚硅谷&quot;); &#125;&#125; 4.3.3 练习读取user.properties文件中的数据，通过反射完成User类对象的创建及对应方法的调用。 配置文件：user.properties 12className:com.atguigu.bean.UsermethodName:show User.java文件： 1234567891011121314151617181920package com.atguigu.bean;/** * @author 尚硅谷-宋红康 * @create 18:41 */public class User &#123; private String name; public User() &#123; &#125; public User(String name) &#123; this.name = name; &#125; public void show()&#123; System.out.println(&quot;我是一个脉脉平台的用户&quot;); &#125;&#125; ReflectTest.java文件： 123456789101112131415161718192021222324252627282930313233343536373839404142package com.atguigu.java4;import org.junit.Test;import java.io.IOException;import java.io.InputStream;import java.lang.reflect.Method;import java.util.Properties;/** * @author 尚硅谷-宋红康 * @create 18:43 */public class ReflectTest &#123; @Test public void test() throws Exception &#123; //1.创建Properties对象 Properties pro = new Properties(); //2.加载配置文件，转换为一个集合 ClassLoader classLoader = ClassLoader.getSystemClassLoader(); InputStream is = classLoader.getResourceAsStream(&quot;user.properties&quot;); pro.load(is); //3.获取配置文件中定义的数据 String className = pro.getProperty(&quot;className&quot;); String methodName = pro.getProperty(&quot;methodName&quot;); //4.加载该类进内存 Class clazz = Class.forName(className); //5.创建对象 Object instance = clazz.newInstance(); //6.获取方法对象 Method showMethod = clazz.getMethod(methodName); //7.执行方法 showMethod.invoke(instance); &#125;&#125; 5. 应用4：读取注解信息一个完整的注解应该包含三个部分：（1）声明（2）使用（3）读取 5.1 声明自定义注解12345678910package com.atguigu.annotation;import java.lang.annotation.*;@Inherited@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)public @interface Table &#123; String value();&#125; 1234567891011package com.atguigu.annotation;import java.lang.annotation.*;@Inherited@Target(ElementType.FIELD)@Retention(RetentionPolicy.RUNTIME)public @interface Column &#123; String columnName(); String columnType();&#125; 自定义注解可以通过四个元注解@Retention,@Target，@Inherited,@Documented，分别说明它的声明周期，使用位置，是否被继承，是否被生成到API文档中。 Annotation 的成员在 Annotation 定义中以无参数有返回值的抽象方法的形式来声明，我们又称为配置参数。返回值类型只能是八种基本数据类型、String类型、Class类型、enum类型、Annotation类型、以上所有类型的数组 可以使用 default 关键字为抽象方法指定默认返回值 如果定义的注解含有抽象方法，那么使用时必须指定返回值，除非它有默认值。格式是“方法名 &#x3D; 返回值”，如果只有一个抽象方法需要赋值，且方法名为value，可以省略“value&#x3D;”，所以如果注解只有一个抽象方法成员，建议使用方法名value。 5.2 使用自定义注解12345678910111213141516171819202122232425262728293031323334package com.atguigu.annotation;@Table(&quot;t_stu&quot;)public class Student &#123; @Column(columnName = &quot;sid&quot;,columnType = &quot;int&quot;) private int id; @Column(columnName = &quot;sname&quot;,columnType = &quot;varchar(20)&quot;) private String name; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; @Override public String toString() &#123; return &quot;Student&#123;&quot; + &quot;id=&quot; + id + &quot;, name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125;&#125; 5.3 读取和处理自定义注解自定义注解必须配上注解的信息处理流程才有意义。 我们自己定义的注解，只能使用反射的代码读取。所以自定义注解的声明周期必须是RetentionPolicy.RUNTIME。 1234567891011121314151617181920212223242526272829303132333435package com.atguigu.annotation;import java.lang.reflect.Field;public class TestAnnotation &#123; public static void main(String[] args) &#123; Class studentClass = Student.class; Table tableAnnotation = (Table) studentClass.getAnnotation(Table.class); String tableName = &quot;&quot;; if(tableAnnotation != null)&#123; tableName = tableAnnotation.value(); &#125; Field[] declaredFields = studentClass.getDeclaredFields(); String[] columns = new String[declaredFields.length]; int index = 0; for (Field declaredField : declaredFields) &#123; Column column = declaredField.getAnnotation(Column.class); if(column!= null) &#123; columns[index++] = column.columnName(); &#125; &#125; String sql = &quot;select &quot;; for (int i=0; i&lt;index; i++) &#123; sql += columns[i]; if(i&lt;index-1)&#123; sql += &quot;,&quot;; &#125; &#125; sql += &quot; from &quot; + tableName; System.out.println(&quot;sql = &quot; + sql); &#125;&#125; 6. 体会反射的动态性体会1： 1234567891011121314151617181920public class ReflectionTest &#123; //体会反射的动态性：动态的创建给定字符串对应的类的对象 public &lt;T&gt; T getInstance(String className) throws Exception &#123; Class clazz = Class.forName(className); Constructor constructor = clazz.getDeclaredConstructor(); constructor.setAccessible(true); return (T) constructor.newInstance(); &#125; @Test public void test1() throws Exception &#123; String className = &quot;com.atguigu.java1.Person&quot;; Person p1 = getInstance(className); System.out.println(p1); &#125;&#125; 体会2： 12345678910111213141516171819202122public class ReflectionTest &#123; //体会反射的动态性：动态的创建指定字符串对应类的对象，并调用指定的方法 public Object invoke(String className,String methodName) throws Exception &#123; Class clazz = Class.forName(className); Constructor constructor = clazz.getDeclaredConstructor(); constructor.setAccessible(true); //动态的创建指定字符串对应类的对象 Object obj = constructor.newInstance(); Method method = clazz.getDeclaredMethod(methodName); method.setAccessible(true); return method.invoke(obj); &#125; @Test public void test2() throws Exception &#123; String info = (String) invoke(&quot;com.atguigu.java1.Person&quot;, &quot;show&quot;); System.out.println(&quot;返回值为：&quot; + info); &#125;&#125; 体会3： 12345678910111213141516171819202122232425262728293031323334353637383940414243public class ReflectionTest &#123; @Test public void test1() throws Exception &#123; //1.加载配置文件，并获取指定的fruitName值 Properties pros = new Properties(); InputStream is = ClassLoader.getSystemClassLoader().getResourceAsStream(&quot;config.properties&quot;); pros.load(is); String fruitStr = pros.getProperty(&quot;fruitName&quot;); //2.创建指定全类名对应类的实例 Class clazz = Class.forName(fruitStr); Constructor constructor = clazz.getDeclaredConstructor(); constructor.setAccessible(true); Fruit fruit = (Fruit) constructor.newInstance(); //3. 调用相关方法，进行测试 Juicer juicer = new Juicer(); juicer.run(fruit); &#125;&#125;interface Fruit &#123; public void squeeze();&#125;class Apple implements Fruit &#123; public void squeeze() &#123; System.out.println(&quot;榨出一杯苹果汁儿&quot;); &#125;&#125;class Orange implements Fruit &#123; public void squeeze() &#123; System.out.println(&quot;榨出一杯桔子汁儿&quot;); &#125;&#125;class Juicer &#123; public void run(Fruit f) &#123; f.squeeze(); &#125;&#125; 其中，配置文件【config.properties】存放在当前Module的src下 1com.atguigu.java1.Orange","categories":[],"tags":[]},{"title":"","slug":"Java/尚硅谷_第16章_网络编程/尚硅谷_宋红康_第16章_网络编程","date":"2023-10-07T11:18:34.203Z","updated":"2022-12-27T10:17:36.795Z","comments":true,"path":"2023/10/07/Java/尚硅谷_第16章_网络编程/尚硅谷_宋红康_第16章_网络编程/","link":"","permalink":"http://example.com/2023/10/07/Java/%E5%B0%9A%E7%A1%85%E8%B0%B7_%E7%AC%AC16%E7%AB%A0_%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/%E5%B0%9A%E7%A1%85%E8%B0%B7_%E5%AE%8B%E7%BA%A2%E5%BA%B7_%E7%AC%AC16%E7%AB%A0_%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/","excerpt":"","text":"第16章_网络编程讲师：尚硅谷-宋红康（江湖人称：康师傅） 官网：http://www.atguigu.com 本章专题与脉络 1. 网络编程概述Java是 Internet 上的语言，它从语言级上提供了对网络应用程序的支持，程序员能够很容易开发常见的网络应用程序。 Java提供的网络类库，可以实现无痛的网络连接，联网的底层细节被隐藏在 Java 的本机安装系统里，由 JVM 进行控制。并且 Java 实现了一个跨平台的网络库，程序员面对的是一个统一的网络编程环境。 1.1 软件架构 C&#x2F;S架构 ：全称为Client&#x2F;Server结构，是指客户端和服务器结构。常见程序有QQ、美团app、360安全卫士等软件。 B&#x2F;S架构 ：全称为Browser&#x2F;Server结构，是指浏览器和服务器结构。常见浏览器有IE、谷歌、火狐等。 两种架构各有优势，但是无论哪种架构，都离不开网络的支持。网络编程，就是在一定的协议下，实现两台计算机的通信的程序。 1.2 网络基础 计算机网络：把分布在不同地理区域的计算机与专门的外部设备用通信线路互连成一个规模大、功能强的网络系统，从而使众多的计算机可以方便地互相传递信息、共享硬件、软件、数据信息等资源。 网络编程的目的：直接或间接地通过网络协议与其它计算机实现数据交换，进行通讯。 网络编程中有三个主要的问题： 问题1：如何准确地定位网络上一台或多台主机 问题2：如何定位主机上的特定的应用 问题3：找到主机后，如何可靠、高效地进行数据传输 2. 网络通信要素2.1 如何实现网络中的主机互相通信 通信双方地址 IP 端口号 一定的规则：不同的硬件、操作系统之间的通信，所有的这一切都需要一种规则。而我们就把这种规则称为协议，即网络通信协议。 生活类比： 2.2 通信要素一：IP地址和域名2.2.1 IP地址IP地址：指互联网协议地址（Internet Protocol Address），俗称IP。IP地址用来给网络中的一台计算机设备做唯一的编号。假如我们把“个人电脑”比作“一台电话”的话，那么“IP地址”就相当于“电话号码”。 IP地址分类方式一： IPv4：是一个32位的二进制数，通常被分为4个字节，表示成a.b.c.d 的形式，以点分十进制表示，例如192.168.65.100 。其中a、b、c、d都是0~255之间的十进制整数。 - 这种方式最多可以表示42亿个。其中，30亿都在北美，亚洲4亿，中国2.9亿。2011年初已经用尽。 IP地址 &#x3D; 网络地址 +主机地址 网络地址：标识计算机或网络设备所在的网段 主机地址：标识特定主机或网络设备 其中，E类用于科研。 IPv6：由于互联网的蓬勃发展，IP地址的需求量愈来愈大，但是网络地址资源有限，使得IP的分配越发紧张。 为了扩大地址空间，拟通过IPv6重新定义地址空间，采用128位地址长度，共16个字节，写成8个无符号整数，每个整数用四个十六进制位表示，数之间用冒号（：）分开。比如：ABCD:EF01:2345:6789:ABCD:EF01:2345:6789，按保守方法估算IPv6实际可分配的地址，整个地球的每平方米面积上仍可分配1000多个地址，这样就解决了网络地址资源数量不够的问题。2012年6月6日，国际互联网协会举行了世界IPv6启动纪念日，这一天，全球IPv6网络正式启动。多家知名网站，如Google、Facebook和Yahoo等，于当天全球标准时间0点（北京时间8点整）开始永久性支持IPv6访问。2018年6月，三大运营商联合阿里云宣布，将全面对外提供IPv6服务，并计划在2025年前助推中国互联网真正实现“IPv6 Only”。 在IPv6的设计过程中除了一劳永逸地解决了地址短缺问题以外，还考虑了在IPv4中解决不好的其它问题，主要有端到端IP连接、服务质量（QoS）、安全性、多播、移动性、即插即用等。 IP地址分类方式二： 公网地址( 万维网使用）和 私有地址( 局域网使用）。192.168.开头的就是私有地址，范围即为192.168.0.0–192.168.255.255，专门为组织机构内部使用。 常用命令： 查看本机IP地址，在控制台输入： 1ipconfig 检查网络是否连通，在控制台输入： 12ping 空格 IP地址ping 220.181.57.216 特殊的IP地址： 本地回环地址(hostAddress)：127.0.0.1 主机名(hostName)：localhost 2.2.2 域名Internet上的主机有两种方式表示地址： 域名(hostName)：www.atguigu.com IP 地址(hostAddress)：202.108.35.210 域名解析：因为IP地址数字不便于记忆，因此出现了域名。域名容易记忆，当在连接网络时输入一个主机的域名后，域名服务器(DNS，Domain Name System，域名系统)负责将域名转化成IP地址，这样才能和主机建立连接。 简单理解： 详细理解： 在浏览器中输入www . qq .com 域名，操作系统会先检查自己本地的hosts文件是否有这个网址映射关系，如果有，就先调用这个IP地址映射，完成域名解析。 如果hosts里没有这个域名的映射，则查找本地DNS解析器缓存，是否有这个网址映射关系，如果有，直接返回，完成域名解析。 如果hosts与本地DNS解析器缓存都没有相应的网址映射关系，首先会找TCP&#x2F;IP参数中设置的首选DNS服务器，在此我们叫它本地DNS服务器，此服务器收到查询时，如果要查询的域名，包含在本地配置区域资源中，则返回解析结果给客户机，完成域名解析，此解析具有权威性。 如果要查询的域名，不由本地DNS服务器区域解析，但该服务器已缓存了此网址映射关系，则调用这个IP地址映射，完成域名解析，此解析不具有权威性。 如果本地DNS服务器本地区域文件与缓存解析都失效，则根据本地DNS服务器的设置（是否设置转发器）进行查询，如果未用转发模式，本地DNS就把请求发至13台根DNS，根DNS服务器收到请求后会判断这个域名(.com)是谁来授权管理，并会返回一个负责该顶级域名服务器的一个IP。本地DNS服务器收到IP信息后，将会联系负责.com域的这台服务器。这台负责.com域的服务器收到请求后，如果自己无法解析，它就会找一个管理.com域的下一级DNS服务器地址(http://qq.com)给本地DNS服务器。当本地DNS服务器收到这个地址后，就会找（http://qq.com)域服务器，重复上面的动作，进行查询，直至找到www.qq.com主机。 如果用的是转发模式，此DNS服务器就会把请求转发至上一级DNS服务器，由上一级服务器进行解析，上一级服务器如果不能解析，或找根DNS或把转请求转至上上级，以此循环。不管是本地DNS服务器用是是转发，还是根提示，最后都是把结果返回给本地DNS服务器，由此DNS服务器再返回给客户机。 2.3 通信要素二：端口号网络的通信，本质上是两个进程（应用程序）的通信。每台计算机都有很多的进程，那么在网络通信时，如何区分这些进程呢？ 如果说IP地址可以唯一标识网络中的设备，那么端口号就可以唯一标识设备中的进程（应用程序）。 不同的进程，设置不同的端口号。 端口号：用两个字节表示的整数，它的取值范围是0~65535。 公认端口：0~1023。被预先定义的服务通信占用，如：HTTP（80），FTP（21），Telnet（23） 注册端口：1024~49151。分配给用户进程或应用程序。如：Tomcat（8080），MySQL（3306），Oracle（1521）。 动态&#x2F; 私有端口：49152~65535。 如果端口号被另外一个服务或应用所占用，会导致当前程序启动失败。 2.4 通信要素三：网络通信协议通过计算机网络可以使多台计算机实现连接，位于同一个网络中的计算机在进行连接和通信时需要遵守一定的规则，这就好比在道路中行驶的汽车一定要遵守交通规则一样。 网络通信协议：在计算机网络中，这些连接和通信的规则被称为网络通信协议，它对数据的传输格式、传输速率、传输步骤、出错控制等做了统一规定，通信双方必须同时遵守才能完成数据交换。 新的问题：网络协议涉及内容太多、太复杂。如何解决？ 计算机网络通信涉及内容很多，比如指定源地址和目标地址，加密解密，压缩解压缩，差错控制，流量控制，路由控制，如何实现如此复杂的网络协议呢？通信协议分层思想。 在制定协议时，把复杂成份分解成一些简单的成份，再将它们复合起来。最常用的复合方式是层次方式，即同层间可以通信、上一层可以调用下一层，而与再下一层不发生关系。各层互不影响，利于系统的开发和扩展。 这里有两套参考模型 OSI参考模型：模型过于理想化，未能在因特网上进行广泛推广 TCP&#x2F;IP参考模型(或TCP&#x2F;IP协议)：事实上的国际标准。 上图中，OSI参考模型：模型过于理想化，未能在因特网上进行广泛推广。 TCP&#x2F;IP参考模型(或TCP&#x2F;IP协议)：事实上的国际标准。 TCP&#x2F;IP协议： 传输控制协议&#x2F;因特网互联协议( Transmission Control Protocol&#x2F;Internet Protocol)，TCP&#x2F;IP 以其两个主要协议：传输控制协议(TCP)和网络互联协议(IP)而得名，实际上是一组协议，包括多个具有不同功能且互为关联的协议。是Internet最基本、最广泛的协议。 TCP&#x2F;IP协议中的四层介绍： 应用层：应用层决定了向用户提供应用服务时通信的活动。主要协议有：HTTP协议、FTP协议、SNMP（简单网络管理协议）、SMTP（简单邮件传输协议）和POP3（Post Office Protocol 3的简称,即邮局协议的第3个版）等。 传输层：主要使网络程序进行通信，在进行网络通信时，可以采用TCP协议，也可以采用UDP协议。TCP（Transmission Control Protocol）协议，即传输控制协议，是一种面向连接的、可靠的、基于字节流的传输层通信协议。UDP(User Datagram Protocol，用户数据报协议)：是一个无连接的传输层协议、提供面向事务的简单不可靠的信息传送服务。 网络层：网络层是整个TCP&#x2F;IP协议的核心，支持网间互连的数据通信。它主要用于将传输的数据进行分组，将分组数据发送到目标计算机或者网络。而IP协议是一种非常重要的协议。IP（internet protocal）又称为互联网协议。IP的责任就是把数据从源传送到目的地。它在源地址和目的地址之间传送一种称之为数据包的东西，它还提供对数据大小的重新组装功能，以适应不同网络对包大小的要求。 物理+数据链路层：链路层是用于定义物理传输通道，通常是对某些网络连接设备的驱动协议，例如针对光纤、网线提供的驱动。 2. 谈传输层协议：TCP与UDP协议通信的协议还是比较复杂的，java.net 包中包含的类和接口，它们提供低层次的通信细节。我们可以直接使用这些类和接口，来专注于网络程序开发，而不用考虑通信的细节。 java.net 包中提供了两种常见的网络协议的支持： UDP：用户数据报协议(User Datagram Protocol)。 TCP：传输控制协议 (Transmission Control Protocol)。 2.1 TCP协议与UDP协议TCP协议： TCP协议进行通信的两个应用进程：客户端、服务端。 使用TCP协议前，须先建立TCP连接，形成基于字节流的传输数据通道 传输前，采用“三次握手”方式，点对点通信，是可靠的 TCP协议使用重发机制，当一个通信实体发送一个消息给另一个通信实体后，需要收到另一个通信实体确认信息，如果没有收到另一个通信实体确认信息，则会再次重复刚才发送的消息。 在连接中可进行大数据量的传输 传输完毕，需释放已建立的连接，效率低 UDP协议： UDP协议进行通信的两个应用进程：发送端、接收端。 将数据、源、目的封装成数据包（传输的基本单位），不需要建立连接 发送不管对方是否准备好，接收方收到也不确认，不能保证数据的完整性，故是不可靠的 每个数据报的大小限制在64K内 发送数据结束时无需释放资源，开销小，通信效率高 适用场景：音频、视频和普通数据的传输。例如视频会议 TCP生活案例：打电话 UDP生活案例：发送短信、发电报 2.2 三次握手TCP协议中，在发送数据的准备阶段，客户端与服务器之间的三次交互，以保证连接的可靠。 第一次握手，客户端向服务器端发起TCP连接的请求 第二次握手，服务器端发送针对客户端TCP连接请求的确认 第三次握手，客户端发送确认的确认 1、客户端会随机一个初始序列号seq&#x3D;x，设置SYN&#x3D;1 ，表示这是SYN握手报文。然后就可以把这个 SYN 报文发送给服务端了，表示向服务端发起连接，之后客户端处于同步已发送状态。 2、服务端收到客户端的 SYN 报文后，也随机一个初始序列号(seq&#x3D;y)，设置ack&#x3D;x+1，表示收到了客户端的x之前的数据，希望客户端下次发送的数据从x+1开始。设置 SYN&#x3D;1 和 ACK&#x3D;1。表示这是一个SYN握手和ACK确认应答报文。最后把该报文发给客户端，该报文也不包含应用层数据，之后服务端处于同步已接收状态。 3、客户端收到服务端报文后，还要向服务端回应最后一个应答报文，将ACK置为 1 ，表示这是一个应答报文ack&#x3D;y+1 ，表示收到了服务器的y之前的数据，希望服务器下次发送的数据从y+1开始。最后把报文发送给服务端，这次报文可以携带数据，之后客户端处于 连接已建立 状态。服务器收到客户端的应答报文后，也进入连接已建立状态。 完成三次握手，连接建立后，客户端和服务器就可以开始进行数据传输了。由于这种面向连接的特性，TCP协议可以保证传输数据的安全，所以应用十分广泛，例如下载文件、浏览网页等。 2.3 四次挥手TCP协议中，在发送数据结束后，释放连接时需要经过四次挥手。 第一次挥手：客户端向服务器端提出结束连接，让服务器做最后的准备工作。此时，客户端处于半关闭状态，即表示不再向服务器发送数据了，但是还可以接受数据。 第二次挥手：服务器接收到客户端释放连接的请求后，会将最后的数据发给客户端。并告知上层的应用进程不再接收数据。 第三次挥手：服务器发送完数据后，会给客户端发送一个释放连接的报文。那么客户端接收后就知道可以正式释放连接了。 第四次挥手：客户端接收到服务器最后的释放连接报文后，要回复一个彻底断开的报文。这样服务器收到后才会彻底释放连接。这里客户端，发送完最后的报文后，会等待2MSL，因为有可能服务器没有收到最后的报文，那么服务器迟迟没收到，就会再次给客户端发送释放连接的报文，此时客户端在等待时间范围内接收到，会重新发送最后的报文，并重新计时。如果等待2MSL后，没有收到，那么彻底断开。 1、客户端打算断开连接，向服务器发送FIN报文(FIN标记位被设置为1，1表示为FIN，0表示不是)，FIN报文中会指定一个序列号，之后客户端进入FIN_WAIT_1状态。也就是客户端发出连接释放报文段(FIN报文)，指定序列号seq &#x3D; u，主动关闭TCP连接，等待服务器的确认。 2、服务器收到连接释放报文段(FIN报文)后，就向客户端发送ACK应答报文，以客户端的FIN报文的序列号 seq+1 作为ACK应答报文段的确认序列号ack &#x3D; seq+1 &#x3D; u + 1。接着服务器进入CLOSE_WAIT(等待关闭)状态，此时的TCP处于半关闭状态(下面会说什么是半关闭状态)，客户端到服务器的连接释放。客户端收到来自服务器的ACK应答报文段后，进入FIN_WAIT_2状态。 3、服务器也打算断开连接，向客户端发送连接释放(FIN)报文段，之后服务器进入LASK_ACK(最后确认)状态，等待客户端的确认。服务器的连接释放(FIN)报文段的FIN&#x3D;1，ACK&#x3D;1，序列号seq&#x3D;m，确认序列号ack&#x3D;u+1。 4、客户端收到来自服务器的连接释放(FIN)报文段后，会向服务器发送一个ACK应答报文段，以连接释放(FIN)报文段的确认序号 ack 作为ACK应答报文段的序列号 seq，以连接释放(FIN)报文段的序列号 seq+1作为确认序号ack。 之后客户端进入TIME_WAIT(时间等待)状态，服务器收到ACK应答报文段后，服务器就进入CLOSE(关闭)状态，到此服务器的连接已经完成关闭。客户端处于TIME_WAIT状态时，此时的TCP还未释放掉，需要等待2MSL后，客户端才进入CLOSE状态。 3. 网络编程API3.1 InetAddress类InetAddress类主要表示IP地址，两个子类：Inet4Address、Inet6Address。 InetAddress 类没有提供公共的构造器，而是提供 了 如下几个 静态方法来获取InetAddress 实例 public static InetAddress getLocalHost() public static InetAddress getByName(String host) public static InetAddress getByAddress(byte[] addr) InetAddress 提供了如下几个常用的方法 public String getHostAddress() ：返回 IP 地址字符串（以文本表现形式） public String getHostName() ：获取此 IP 地址的主机名 public boolean isReachable(int timeout)：测试是否可以达到该地址 12345678910111213141516171819202122232425262728package com.atguigu.ip;import java.net.InetAddress;import java.net.UnknownHostException;import org.junit.Test;public class TestInetAddress &#123; @Test public void test01() throws UnknownHostException&#123; InetAddress localHost = InetAddress.getLocalHost(); System.out.println(localHost); &#125; @Test public void test02()throws UnknownHostException&#123; InetAddress atguigu = InetAddress.getByName(&quot;www.atguigu.com&quot;); System.out.println(atguigu); &#125; @Test public void test03()throws UnknownHostException&#123;// byte[] addr = &#123;112,54,108,98&#125;; byte[] addr = &#123;(byte)192,(byte)168,24,56&#125;; InetAddress atguigu = InetAddress.getByAddress(addr); System.out.println(atguigu); &#125;&#125; 3.2 Socket类 网络上具有唯一标识的IP地址和端口号组合在一起构成唯一能识别的标识符套接字（Socket）。 利用套接字(Socket)开发网络应用程序早已被广泛的采用，以至于成为事实上的标准。网络通信其实就是Socket间的通信。 通信的两端都要有Socket，是两台机器间通信的端点。 Socket允许程序把网络连接当成一个流，数据在两个Socket间通过IO传输。 一般主动发起通信的应用程序属客户端，等待通信请求的为服务端。 Socket分类： 流套接字（stream socket）：使用TCP提供可依赖的字节流服务 ServerSocket：此类实现TCP服务器套接字。服务器套接字等待请求通过网络传入。 Socket：此类实现客户端套接字（也可以就叫“套接字”）。套接字是两台机器间通信的端点。 数据报套接字（datagram socket）：使用UDP提供“尽力而为”的数据报服务 DatagramSocket：此类表示用来发送和接收UDP数据报包的套接字。 3.3 Socket相关类API3.3.1 ServerSocket类ServerSocket类的构造方法： ServerSocket(int port) ：创建绑定到特定端口的服务器套接字。 ServerSocket类的常用方法： Socket accept()：侦听并接受到此套接字的连接。 3.3.2 Socket类Socket类的常用构造方法： public Socket(InetAddress address,int port)：创建一个流套接字并将其连接到指定 IP 地址的指定端口号。 public Socket(String host,int port)：创建一个流套接字并将其连接到指定主机上的指定端口号。 Socket类的常用方法： public InputStream getInputStream()：返回此套接字的输入流，可以用于接收消息 public OutputStream getOutputStream()：返回此套接字的输出流，可以用于发送消息 public InetAddress getInetAddress()：此套接字连接到的远程 IP 地址；如果套接字是未连接的，则返回 null。 public InetAddress getLocalAddress()：获取套接字绑定的本地地址。 public int getPort()：此套接字连接到的远程端口号；如果尚未连接套接字，则返回 0。 public int getLocalPort()：返回此套接字绑定到的本地端口。如果尚未绑定套接字，则返回 -1。 public void close()：关闭此套接字。套接字被关闭后，便不可在以后的网络连接中使用（即无法重新连接或重新绑定）。需要创建新的套接字对象。 关闭此套接字也将会关闭该套接字的 InputStream 和 OutputStream。 public void shutdownInput()：如果在套接字上调用 shutdownInput() 后从套接字输入流读取内容，则流将返回 EOF（文件结束符）。 即不能在从此套接字的输入流中接收任何数据。 public void shutdownOutput()：禁用此套接字的输出流。对于 TCP 套接字，任何以前写入的数据都将被发送，并且后跟 TCP 的正常连接终止序列。 如果在套接字上调用 shutdownOutput() 后写入套接字输出流，则该流将抛出 IOException。 即不能通过此套接字的输出流发送任何数据。 注意：先后调用Socket的shutdownInput()和shutdownOutput()方法，仅仅关闭了输入流和输出流，并不等于调用Socket的close()方法。在通信结束后，仍然要调用Scoket的close()方法，因为只有该方法才会释放Socket占用的资源，比如占用的本地端口号等。 3.3.3 DatagramSocket类DatagramSocket 类的常用方法： public DatagramSocket(int port)创建数据报套接字并将其绑定到本地主机上的指定端口。套接字将被绑定到通配符地址，IP 地址由内核来选择。 public DatagramSocket(int port,InetAddress laddr)创建数据报套接字，将其绑定到指定的本地地址。本地端口必须在 0 到 65535 之间（包括两者）。如果 IP 地址为 0.0.0.0，套接字将被绑定到通配符地址，IP 地址由内核选择。 public void close()关闭此数据报套接字。 public void send(DatagramPacket p)从此套接字发送数据报包。DatagramPacket 包含的信息指示：将要发送的数据、其长度、远程主机的 IP 地址和远程主机的端口号。 public void receive(DatagramPacket p)从此套接字接收数据报包。当此方法返回时，DatagramPacket 的缓冲区填充了接收的数据。数据报包也包含发送方的 IP 地址和发送方机器上的端口号。 此方法在接收到数据报前一直阻塞。数据报包对象的 length 字段包含所接收信息的长度。如果信息比包的长度长，该信息将被截短。 public InetAddress getLocalAddress()获取套接字绑定的本地地址。 public int getLocalPort()返回此套接字绑定的本地主机上的端口号。 public InetAddress getInetAddress()返回此套接字连接的地址。如果套接字未连接，则返回 null。 public int getPort()返回此套接字的端口。如果套接字未连接，则返回 -1。 3.3.4 DatagramPacket类DatagramPacket类的常用方法： public DatagramPacket(byte[] buf,int length)构造 DatagramPacket，用来接收长度为 length 的数据包。 length 参数必须小于等于 buf.length。 public DatagramPacket(byte[] buf,int length,InetAddress address,int port)构造数据报包，用来将长度为 length 的包发送到指定主机上的指定端口号。length 参数必须小于等于 buf.length。 public InetAddress getAddress()返回某台机器的 IP 地址，此数据报将要发往该机器或者是从该机器接收到的。 public int getPort()返回某台远程主机的端口号，此数据报将要发往该主机或者是从该主机接收到的。 public byte[] getData()返回数据缓冲区。接收到的或将要发送的数据从缓冲区中的偏移量 offset 处开始，持续 length 长度。 public int getLength()返回将要发送或接收到的数据的长度。 4. TCP网络编程4.1 通信模型Java语言的基于套接字TCP编程分为服务端编程和客户端编程，其通信模型如图所示： 4.2 开发步骤客户端程序包含以下四个基本的步骤 ： 创建 Socket ：根据指定服务端的 IP 地址或端口号构造 Socket 类对象。若服务器端响应，则建立客户端到服务器的通信线路。若连接失败，会出现异常。 打开连接到 Socket 的输入&#x2F; 出流： 使用 getInputStream()方法获得输入流，使用getOutputStream()方法获得输出流，进行数据传输 按照一定的协议对 Socket 进行读&#x2F; 写操作：通过输入流读取服务器放入线路的信息（但不能读取自己放入线路的信息），通过输出流将信息写入线路。 关闭 Socket ：断开客户端到服务器的连接，释放线路 服务器端程序包含以下四个基本的 步骤： 调用 ServerSocket(int port) ：创建一个服务器端套接字，并绑定到指定端口上。用于监听客户端的请求。 调用 accept() ：监听连接请求，如果客户端请求连接，则接受连接，返回通信套接字对象。 调用 该Socket 类对象的 getOutputStream() 和 getInputStream () ：获取输出流和输入流，开始网络数据的发送和接收。 关闭Socket 对象：客户端访问结束，关闭通信套接字。 4.3 例题与练习 例题1：客户端发送内容给服务端，服务端将内容打印到控制台上。 例题2：客户端发送文件给服务端，服务端将文件保存在本地。 例题3：从客户端发送文件给服务端，服务端保存到本地。并返回“发送成功”给客户端。并关闭相应的连接。 练习1：服务端读取图片并发送给客户端，客户端保存图片到本地 练习2：客户端给服务端发送文本，服务端会将文本转成大写在返回给客户端。 演示单个客户端与服务器单次通信： 需求：客户端连接服务器，连接成功后给服务发送“lalala”，服务器收到消息后，给客户端返回“欢迎登录”，客户端接收消息后，断开连接 1、服务器端示例代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546package com.atguigu.tcp.one;import java.io.InputStream;import java.io.OutputStream;import java.net.InetAddress;import java.net.ServerSocket;import java.net.Socket;public class Server &#123; public static void main(String[] args)throws Exception &#123; //1、准备一个ServerSocket对象，并绑定8888端口 ServerSocket server = new ServerSocket(8888); System.out.println(&quot;等待连接....&quot;); //2、在8888端口监听客户端的连接，该方法是个阻塞的方法，如果没有客户端连接，将一直等待 Socket socket = server.accept(); InetAddress inetAddress = socket.getInetAddress(); System.out.println(inetAddress.getHostAddress() + &quot;客户端连接成功！！&quot;); //3、获取输入流，用来接收该客户端发送给服务器的数据 InputStream input = socket.getInputStream(); //接收数据 byte[] data = new byte[1024]; StringBuilder s = new StringBuilder(); int len; while ((len = input.read(data)) != -1) &#123; s.append(new String(data, 0, len)); &#125; System.out.println(inetAddress.getHostAddress() + &quot;客户端发送的消息是：&quot; + s); //4、获取输出流，用来发送数据给该客户端 OutputStream out = socket.getOutputStream(); //发送数据 out.write(&quot;欢迎登录&quot;.getBytes()); out.flush(); //5、关闭socket，不再与该客户端通信 //socket关闭，意味着InputStream和OutputStream也关闭了 socket.close(); //6、如果不再接收任何客户端通信，可以关闭ServerSocket server.close(); &#125;&#125; 2、客户端示例代码 123456789101112131415161718192021222324252627282930313233343536package com.atguigu.tcp.one;import java.io.InputStream;import java.io.OutputStream;import java.net.Socket;public class Client &#123; public static void main(String[] args) throws Exception &#123; // 1、准备Socket，连接服务器，需要指定服务器的IP地址和端口号 Socket socket = new Socket(&quot;127.0.0.1&quot;, 8888); // 2、获取输出流，用来发送数据给服务器 OutputStream out = socket.getOutputStream(); // 发送数据 out.write(&quot;lalala&quot;.getBytes()); //会在流末尾写入一个“流的末尾”标记，对方才能读到-1，否则对方的读取方法会一致阻塞 socket.shutdownOutput(); //3、获取输入流，用来接收服务器发送给该客户端的数据 InputStream input = socket.getInputStream(); // 接收数据 byte[] data = new byte[1024]; StringBuilder s = new StringBuilder(); int len; while ((len = input.read(data)) != -1) &#123; s.append(new String(data, 0, len)); &#125; System.out.println(&quot;服务器返回的消息是：&quot; + s); //4、关闭socket，不再与服务器通信，即断开与服务器的连接 //socket关闭，意味着InputStream和OutputStream也关闭了 socket.close(); &#125;&#125; 演示多个客户端与服务器之间的多次通信： 通常情况下，服务器不应该只接受一个客户端请求，而应该不断地接受来自客户端的所有请求，所以Java程序通常会通过循环，不断地调用ServerSocket的accept()方法。 如果服务器端要“同时”处理多个客户端的请求，因此服务器端需要为每一个客户端单独分配一个线程来处理，否则无法实现“同时”。 咱们之前学习IO流的时候，提到过装饰者设计模式，该设计使得不管底层IO流是怎样的节点流：文件流也好，网络Socket产生的流也好，程序都可以将其包装成处理流，甚至可以多层包装，从而提供更多方便的处理。 案例需求：多个客户端连接服务器，并进行多次通信 每一个客户端连接成功后，从键盘输入英文单词或中国成语，并发送给服务器 服务器收到客户端的消息后，把词语“反转”后返回给客户端 客户端接收服务器返回的“词语”，打印显示 当客户端输入“stop”时断开与服务器的连接 多个客户端可以同时给服务器发送“词语”，服务器可以“同时”处理多个客户端的请求 1、服务器端示例代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768package com.atguigu.tcp.many;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.io.PrintStream;import java.net.ServerSocket;import java.net.Socket;public class Server &#123; public static void main(String[] args) throws IOException &#123; // 1、准备一个ServerSocket ServerSocket server = new ServerSocket(8888); System.out.println(&quot;等待连接...&quot;); int count = 0; while(true)&#123; // 2、监听一个客户端的连接 Socket socket = server.accept(); System.out.println(&quot;第&quot; + ++count + &quot;个客户端&quot;+socket.getInetAddress().getHostAddress()+&quot;连接成功！！&quot;); ClientHandlerThread ct = new ClientHandlerThread(socket); ct.start(); &#125; //这里没有关闭server，永远监听 &#125; static class ClientHandlerThread extends Thread&#123; private Socket socket; private String ip; public ClientHandlerThread(Socket socket) &#123; super(); this.socket = socket; ip = socket.getInetAddress().getHostAddress(); &#125; public void run()&#123; try&#123; //（1）获取输入流，用来接收该客户端发送给服务器的数据 BufferedReader br = new BufferedReader(new InputStreamReader(socket.getInputStream())); //（2）获取输出流，用来发送数据给该客户端 PrintStream ps = new PrintStream(socket.getOutputStream()); String str; // （3）接收数据 while ((str = br.readLine()) != null) &#123; //（4）反转 StringBuilder word = new StringBuilder(str); word.reverse(); //（5）返回给客户端 ps.println(word); &#125; System.out.println(&quot;客户端&quot; + ip+&quot;正常退出&quot;); &#125;catch(Exception e)&#123; System.out.println(&quot;客户端&quot; + ip+&quot;意外退出&quot;); &#125;finally&#123; try &#123; //（6）断开连接 socket.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125; 2、客户端示例代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package com.atguigu.tcp.many;import java.io.BufferedReader;import java.io.InputStream;import java.io.InputStreamReader;import java.io.OutputStream;import java.io.PrintStream;import java.net.Socket;import java.util.Scanner;public class Client &#123; public static void main(String[] args) throws Exception &#123; // 1、准备Socket，连接服务器，需要指定服务器的IP地址和端口号 Socket socket = new Socket(&quot;127.0.0.1&quot;, 8888); // 2、获取输出流，用来发送数据给服务器 OutputStream out = socket.getOutputStream(); PrintStream ps = new PrintStream(out); // 3、获取输入流，用来接收服务器发送给该客户端的数据 InputStream input = socket.getInputStream(); BufferedReader br; if(args!= null &amp;&amp; args.length&gt;0) &#123; String encoding = args[0]; br = new BufferedReader(new InputStreamReader(input,encoding)); &#125;else&#123; br = new BufferedReader(new InputStreamReader(input)); &#125; Scanner scanner = new Scanner(System.in); while(true)&#123; System.out.println(&quot;输入发送给服务器的单词或成语：&quot;); String message = scanner.nextLine(); if(message.equals(&quot;stop&quot;))&#123; socket.shutdownOutput(); break; &#125; // 4、 发送数据 ps.println(message); // 接收数据 String feedback = br.readLine(); System.out.println(&quot;从服务器收到的反馈是：&quot; + feedback); &#125; //5、关闭socket，断开与服务器的连接 scanner.close(); socket.close(); &#125;&#125; 4.4 案例：聊天室服务端： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586package com.atguigu.tcp;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStream;import java.io.InputStreamReader;import java.io.OutputStream;import java.io.PrintStream;import java.net.ServerSocket;import java.net.Socket;import java.util.ArrayList;public class TestChatServer &#123; //这个集合用来存储所有在线的客户端 static ArrayList&lt;Socket&gt; online = new ArrayList&lt;Socket&gt;(); public static void main(String[] args)throws Exception &#123; //1、启动服务器，绑定端口号 ServerSocket server = new ServerSocket(8989); //2、接收n多的客户端同时连接 while(true)&#123; Socket accept = server.accept(); online.add(accept);//把新连接的客户端添加到online列表中 MessageHandler mh = new MessageHandler(accept); mh.start();// &#125; &#125; static class MessageHandler extends Thread&#123; private Socket socket; private String ip; public MessageHandler(Socket socket) &#123; super(); this.socket = socket; &#125; public void run()&#123; try &#123; ip = socket.getInetAddress().getHostAddress(); //插入：给其他客户端转发“我上线了” sendToOther(ip+&quot;上线了&quot;); //(1)接收该客户端的发送的消息 InputStream input = socket.getInputStream(); InputStreamReader reader = new InputStreamReader(input); BufferedReader br = new BufferedReader(reader); String str; while((str = br.readLine())!=null)&#123; //(2)给其他在线客户端转发 sendToOther(ip+&quot;:&quot;+str); &#125; sendToOther(ip+&quot;下线了&quot;); &#125; catch (IOException e) &#123; try &#123; sendToOther(ip+&quot;掉线了&quot;); &#125; catch (IOException e1) &#123; e1.printStackTrace(); &#125; &#125;finally&#123; //从在线人员中移除我 online.remove(socket); &#125; &#125; //封装一个方法：给其他客户端转发xxx消息 public void sendToOther(String message) throws IOException&#123; //遍历所有的在线客户端，一一转发 for (Socket on : online) &#123; OutputStream every = on.getOutputStream(); //为什么用PrintStream？目的用它的println方法，按行打印 PrintStream ps = new PrintStream(every); ps.println(message); &#125; &#125; &#125;&#125; 客户端： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283package com.atguigu.tcp;import java.io.IOException;import java.io.InputStream;import java.io.OutputStream;import java.io.PrintStream;import java.net.Socket;import java.util.Scanner;public class TestChatClient &#123; public static void main(String[] args)throws Exception &#123; //1、连接服务器 Socket socket = new Socket(&quot;127.0.0.1&quot;,8989); //2、开启两个线程 //(1)一个线程负责看别人聊，即接收服务器转发的消息 Receive receive = new Receive(socket); receive.start(); //(2)一个线程负责发送自己的话 Send send = new Send(socket); send.start(); send.join();//等我发送线程结束了，才结束整个程序 socket.close(); &#125;&#125;class Send extends Thread&#123; private Socket socket; public Send(Socket socket) &#123; super(); this.socket = socket; &#125; public void run()&#123; try &#123; OutputStream outputStream = socket.getOutputStream(); //按行打印 PrintStream ps = new PrintStream(outputStream); Scanner input = new Scanner(System.in); //从键盘不断的输入自己的话，给服务器发送，由服务器给其他人转发 while(true)&#123; System.out.print(&quot;自己的话：&quot;); String str = input.nextLine(); if(&quot;bye&quot;.equals(str))&#123; break; &#125; ps.println(str); &#125; input.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;class Receive extends Thread&#123; private Socket socket; public Receive(Socket socket) &#123; super(); this.socket = socket; &#125; public void run()&#123; try &#123; InputStream inputStream = socket.getInputStream(); Scanner input = new Scanner(inputStream); while(input.hasNextLine())&#123; String line = input.nextLine(); System.out.println(line); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 4.5 理解客户端、服务端 客户端： 自定义 浏览器(browser — server) 服务端： 自定义 Tomcat服务器 5. UDP网络编程UDP(User Datagram Protocol，用户数据报协议)：是一个无连接的传输层协议、提供面向事务的简单不可靠的信息传送服务，类似于短信。 5.1 通信模型UDP协议是一种面向非连接的协议，面向非连接指的是在正式通信前不必与对方先建立连接，不管对方状态就直接发送，至于对方是否可以接收到这些数据内容，UDP协议无法控制，因此说，UDP协议是一种不可靠的协议。无连接的好处就是快，省内存空间和流量，因为维护连接需要创建大量的数据结构。UDP会尽最大努力交付数据，但不保证可靠交付，没有TCP的确认机制、重传机制，如果因为网络原因没有传送到对端，UDP也不会给应用层返回错误信息。 UDP协议是面向数据报文的信息传送服务。UDP在发送端没有缓冲区，对于应用层交付下来的报文在添加了首部之后就直接交付于ip层，不会进行合并，也不会进行拆分，而是一次交付一个完整的报文。比如我们要发送100个字节的报文，我们调用一次send()方法就会发送100字节，接收方也需要用receive()方法一次性接收100字节，不能使用循环每次获取10个字节，获取十次这样的做法。 UDP协议没有拥塞控制，所以当网络出现的拥塞不会导致主机发送数据的速率降低。虽然UDP的接收端有缓冲区，但是这个缓冲区只负责接收，并不会保证UDP报文的到达顺序是否和发送的顺序一致。因为网络传输的时候，由于网络拥塞的存在是很大的可能导致先发的报文比后发的报文晚到达。如果此时缓冲区满了，后面到达的报文将直接被丢弃。这个对实时应用来说很重要，比如：视频通话、直播等应用。 因此UDP适用于一次只传送少量数据、对可靠性要求不高的应用环境，数据报大小限制在64K以下。 类 DatagramSocket 和 DatagramPacket 实现了基于 UDP 协议网络程序。 UDP数据报通过数据报套接字 DatagramSocket 发送和接收，系统不保证 UDP数据报一定能够安全送到目的地，也不能确定什么时候可以抵达。 DatagramPacket 对象封装了UDP数据报，在数据报中包含了发送端的IP地址和端口号以及接收端的IP地址和端口号。 UDP协议中每个数据报都给出了完整的地址信息，因此无须建立发送方和接收方的连接。如同发快递包裹一样。 5.2 开发步骤发送端程序包含以下四个基本的步骤： 创建DatagramSocket ：默认使用系统随机分配端口号。 创建DatagramPacket：将要发送的数据用字节数组表示，并指定要发送的数据长度，接收方的IP地址和端口号。 调用 该DatagramSocket 类对象的 send方法 ：发送数据报DatagramPacket对象。 关闭DatagramSocket 对象：发送端程序结束，关闭通信套接字。 接收端程序包含以下四个基本的步骤 ： 创建DatagramSocket ：指定监听的端口号。 创建DatagramPacket：指定接收数据用的字节数组，起到临时数据缓冲区的效果，并指定最大可以接收的数据长度。 调用 该DatagramSocket 类对象的receive方法 ：接收数据报DatagramPacket对象。。 关闭DatagramSocket ：接收端程序结束，关闭通信套接字。 5.3 演示发送和接收消息基于UDP协议的网络编程仍然需要在通信实例的两端各建立一个Socket，但这两个Socket之间并没有虚拟链路，这两个Socket只是发送、接收数据报的对象，Java提供了DatagramSocket对象作为基于UDP协议的Socket，使用DatagramPacket代表DatagramSocket发送、接收的数据报。 举例1：发送端： 12345678910111213DatagramSocket ds = null;try &#123; ds = new DatagramSocket(); byte[] by = &quot;hello,atguigu.com&quot;.getBytes(); DatagramPacket dp = new DatagramPacket(by, 0, by.length, InetAddress.getByName(&quot;127.0.0.1&quot;), 10000); ds.send(dp);&#125; catch (Exception e) &#123; e.printStackTrace();&#125; finally &#123; if (ds != null) ds.close();&#125; 接收端： 123456789101112131415DatagramSocket ds = null;try &#123; ds = new DatagramSocket(10000); byte[] by = new byte[1024*64]; DatagramPacket dp = new DatagramPacket(by, by.length); ds.receive(dp); String str = new String(dp.getData(), 0, dp.getLength()); System.out.println(str + &quot;--&quot; + dp.getAddress());&#125; catch (Exception e) &#123; e.printStackTrace();&#125; finally &#123; if (ds != null) ds.close();&#125; 举例2：发送端： 12345678910111213141516171819202122232425262728293031323334353637package com.atguigu.udp;import java.net.DatagramPacket;import java.net.DatagramSocket;import java.net.InetAddress;import java.util.ArrayList;public class Send &#123; public static void main(String[] args)throws Exception &#123;// 1、建立发送端的DatagramSocket DatagramSocket ds = new DatagramSocket(); //要发送的数据 ArrayList&lt;String&gt; all = new ArrayList&lt;String&gt;(); all.add(&quot;尚硅谷让天下没有难学的技术！&quot;); all.add(&quot;学高端前沿的IT技术来尚硅谷！&quot;); all.add(&quot;尚硅谷让你的梦想变得更具体！&quot;); all.add(&quot;尚硅谷让你的努力更有价值！&quot;); //接收方的IP地址 InetAddress ip = InetAddress.getByName(&quot;127.0.0.1&quot;); //接收方的监听端口号 int port = 9999; //发送多个数据报 for (int i = 0; i &lt; all.size(); i++) &#123;// 2、建立数据包DatagramPacket byte[] data = all.get(i).getBytes(); DatagramPacket dp = new DatagramPacket(data, 0, data.length, ip, port);// 3、调用Socket的发送方法 ds.send(dp); &#125;// 4、关闭Socket ds.close(); &#125;&#125; 接收端： 12345678910111213141516171819202122232425262728package com.atguigu.udp;import java.net.DatagramPacket;import java.net.DatagramSocket;public class Receive &#123; public static void main(String[] args) throws Exception &#123;// 1、建立接收端的DatagramSocket，需要指定本端的监听端口号 DatagramSocket ds = new DatagramSocket(9999); //一直监听数据 while(true)&#123; //2、建立数据包DatagramPacket byte[] buffer = new byte[1024*64]; DatagramPacket dp = new DatagramPacket(buffer,buffer.length); //3、调用Socket的接收方法 ds.receive(dp); //4、拆封数据 String str = new String(dp.getData(),0,dp.getLength()); System.out.println(str); &#125;// ds.close(); &#125;&#125; 6. URL编程6.1 URL类 URL(Uniform Resource Locator)：统一资源定位符，它表示 Internet 上某一资源的地址。 通过 URL 我们可以访问 Internet 上的各种网络资源，比如最常见的 www，ftp 站点。浏览器通过解析给定的 URL 可以在网络上查找相应的文件或其他资源。 URL的基本结构由5部分组成： 1&lt;传输协议&gt;://&lt;主机名&gt;:&lt;端口号&gt;/&lt;文件名&gt;#片段名?参数列表 例如: http://192.168.1.100:8080/helloworld/index.jsp#a?username=shkstart&amp;password=123 片段名：即锚点，例如看小说，直接定位到章节 参数列表格式：参数名&#x3D;参数值&amp;参数名&#x3D;参数值…. 为了表示URL，java.net 中实现了类 URL。我们可以通过下面的构造器来初始化一个 URL 对象： public URL (String spec)：通过一个表示URL地址的字符串可以构造一个URL对象。例如： 1URL url = new URL(&quot;http://www. atguigu.com/&quot;); public URL(URL context, String spec)：通过基 URL 和相对 URL 构造一个 URL 对象。例如： 1URL downloadUrl = new URL(url, “download.html&quot;) public URL(String protocol, String host, String file); 例如： 1URL url = new URL(&quot;http&quot;, &quot;www.atguigu.com&quot;, “download. html&quot;); public URL(String protocol, String host, int port, String file); 例如: 1URL gamelan = new URL(&quot;http&quot;, &quot;www.atguigu.com&quot;, 80, “download.html&quot;); URL类的构造器都声明抛出非运行时异常，必须要对这一异常进行处理，通常是用 try-catch 语句进行捕获。 6.2 URL类常用方法一个URL对象生成后，其属性是不能被改变的，但可以通过它给定的方法来获取这些属性： public String getProtocol( ) 获取该URL的协议名 public String getHost( ) 获取该URL的主机名 public String getPort( ) 获取该URL的端口号 public String getPath( ) 获取该URL的文件路径 public String getFile( ) 获取该URL的文件名 public String getQuery( ) 获取该URL的查询名 1234567URL url = new URL(&quot;http://localhost:8080/examples/myTest.txt&quot;);System.out.println(&quot;getProtocol() :&quot;+url.getProtocol());System.out.println(&quot;getHost() :&quot;+url.getHost());System.out.println(&quot;getPort() :&quot;+url.getPort());System.out.println(&quot;getPath() :&quot;+url.getPath());System.out.println(&quot;getFile() :&quot;+url.getFile());System.out.println(&quot;getQuery() :&quot;+url.getQuery()); 6.3 针对HTTP协议的URLConnection类 URL的方法 openStream()：能从网络上读取数据 若希望输出数据，例如向服务器端的 CGI （公共网关接口-Common Gateway Interface-的简称，是用户浏览器和服务器端的应用程序进行连接的接口）程序发送一些数据，则必须先与URL建立连接，然后才能对其进行读写，此时需要使用 URLConnection 。 URLConnection：表示到URL所引用的远程对象的连接。当与一个URL建立连接时，首先要在一个 URL 对象上通过方法 openConnection() 生成对应的 URLConnection 对象。如果连接过程失败，将产生IOException. URL netchinaren &#x3D; new URL (“http://www.atguigu.com/index.shtml“); URLConnectonn u &#x3D; netchinaren.openConnection( ); 通过URLConnection对象获取的输入流和输出流，即可以与现有的CGI程序进行交互。 public Object getContent( ) throws IOException public int getContentLength( ) public String getContentType( ) public long getDate( ) public long getLastModified( ) public InputStream getInputStream ( ) throws IOException public OutputSteram getOutputStream( )throws IOException 6.4 小结 位于网络中的计算机具有唯一的IP地址，这样不同的主机可以互相区分。 客户端－服务器是一种最常见的网络应用程序模型。服务器是一个为其客户端提供某种特定服务的硬件或软件。客户机是一个用户应用程序，用于访问某台服务器提供的服务。端口号是对一个服务的访问场所，它用于区分同一物理计算机上的多个服务。套接字用于连接客户端和服务器，客户端和服务器之间的每个通信会话使用一个不同的套接字。TCP协议用于实现面向连接的会话。 Java 中有关网络方面的功能都定义在 java.net 程序包中。Java 用 InetAddress 对象表示 IP 地址，该对象里有两个字段：主机名(String) 和 IP 地址(int)。 类 Socket 和 ServerSocket 实现了基于TCP协议的客户端－服务器程序。Socket是客户端和服务器之间的一个连接，连接创建的细节被隐藏了。这个连接提供了一个安全的数据传输通道，这是因为 TCP 协议可以解决数据在传送过程中的丢失、损坏、重复、乱序以及网络拥挤等问题，它保证数据可靠的传送。 类 URL 和 URLConnection 提供了最高级网络应用。URL 的网络资源的位置来同一表示 Internet 上各种网络资源。通过URL对象可以创建当前应用程序和 URL 表示的网络资源之间的连接，这样当前程序就可以读取网络资源数据，或者把自己的数据传送到网络上去。","categories":[],"tags":[]},{"title":"","slug":"Java/尚硅谷_第15章_File类与IO流/尚硅谷_宋红康_第15章_File类与IO流","date":"2023-10-07T11:18:33.106Z","updated":"2022-12-11T13:39:42.545Z","comments":true,"path":"2023/10/07/Java/尚硅谷_第15章_File类与IO流/尚硅谷_宋红康_第15章_File类与IO流/","link":"","permalink":"http://example.com/2023/10/07/Java/%E5%B0%9A%E7%A1%85%E8%B0%B7_%E7%AC%AC15%E7%AB%A0_File%E7%B1%BB%E4%B8%8EIO%E6%B5%81/%E5%B0%9A%E7%A1%85%E8%B0%B7_%E5%AE%8B%E7%BA%A2%E5%BA%B7_%E7%AC%AC15%E7%AB%A0_File%E7%B1%BB%E4%B8%8EIO%E6%B5%81/","excerpt":"","text":"第15章_File类与IO流讲师：尚硅谷-宋红康（江湖人称：康师傅） 官网：http://www.atguigu.com 本章专题与脉络 1. java.io.File类的使用1.1 概述 File类及本章下的各种流，都定义在java.io包下。 一个File对象代表硬盘或网络中可能存在的一个文件或者文件目录（俗称文件夹），与平台无关。（体会万事万物皆对象） File 能新建、删除、重命名文件和目录，但 File 不能访问文件内容本身。如果需要访问文件内容本身，则需要使用输入&#x2F;输出流。 File对象可以作为参数传递给流的构造器。 想要在Java程序中表示一个真实存在的文件或目录，那么必须有一个File对象，但是Java程序中的一个File对象，可能没有一个真实存在的文件或目录。 1.2 构造器 public File(String pathname) ：以pathname为路径创建File对象，可以是绝对路径或者相对路径，如果pathname是相对路径，则默认的当前路径在系统属性user.dir中存储。 public File(String parent, String child) ：以parent为父路径，child为子路径创建File对象。 public File(File parent, String child) ：根据一个父File对象和子文件路径创建File对象 关于路径： 绝对路径：从盘符开始的路径，这是一个完整的路径。 相对路径：相对于项目目录的路径，这是一个便捷的路径，开发中经常使用。 IDEA中，main中的文件的相对路径，是相对于”当前工程“ IDEA中，单元测试方法中的文件的相对路径，是相对于”当前module“ 举例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061package com.atguigu.file;import java.io.File;public class FileObjectTest &#123; public static void main(String[] args) &#123; // 文件路径名 String pathname = &quot;D:\\\\aaa.txt&quot;; File file1 = new File(pathname); // 文件路径名 String pathname2 = &quot;D:\\\\aaa\\\\bbb.txt&quot;; File file2 = new File(pathname2); // 通过父路径和子路径字符串 String parent = &quot;d:\\\\aaa&quot;; String child = &quot;bbb.txt&quot;; File file3 = new File(parent, child); // 通过父级File对象和子路径字符串 File parentDir = new File(&quot;d:\\\\aaa&quot;); String childFile = &quot;bbb.txt&quot;; File file4 = new File(parentDir, childFile); &#125; @Test public void test01() throws IOException&#123; File f1 = new File(&quot;d:\\\\atguigu\\\\javase\\\\HelloIO.java&quot;); //绝对路径 System.out.println(&quot;文件/目录的名称：&quot; + f1.getName()); System.out.println(&quot;文件/目录的构造路径名：&quot; + f1.getPath()); System.out.println(&quot;文件/目录的绝对路径名：&quot; + f1.getAbsolutePath()); System.out.println(&quot;文件/目录的父目录名：&quot; + f1.getParent()); &#125; @Test public void test02()throws IOException&#123; File f2 = new File(&quot;/HelloIO.java&quot;);//绝对路径，从根路径开始 System.out.println(&quot;文件/目录的名称：&quot; + f2.getName()); System.out.println(&quot;文件/目录的构造路径名：&quot; + f2.getPath()); System.out.println(&quot;文件/目录的绝对路径名：&quot; + f2.getAbsolutePath()); System.out.println(&quot;文件/目录的父目录名：&quot; + f2.getParent()); &#125; @Test public void test03() throws IOException &#123; File f3 = new File(&quot;HelloIO.java&quot;);//相对路径 System.out.println(&quot;user.dir =&quot; + System.getProperty(&quot;user.dir&quot;)); System.out.println(&quot;文件/目录的名称：&quot; + f3.getName()); System.out.println(&quot;文件/目录的构造路径名：&quot; + f3.getPath()); System.out.println(&quot;文件/目录的绝对路径名：&quot; + f3.getAbsolutePath()); System.out.println(&quot;文件/目录的父目录名：&quot; + f3.getParent()); &#125; @Test public void test04() throws IOException&#123; File f5 = new File(&quot;HelloIO.java&quot;);//相对路径 System.out.println(&quot;user.dir =&quot; + System.getProperty(&quot;user.dir&quot;)); System.out.println(&quot;文件/目录的名称：&quot; + f5.getName()); System.out.println(&quot;文件/目录的构造路径名：&quot; + f5.getPath()); System.out.println(&quot;文件/目录的绝对路径名：&quot; + f5.getAbsolutePath()); System.out.println(&quot;文件/目录的父目录名：&quot; + f5.getParent()); &#125;&#125; 注意： 无论该路径下是否存在文件或者目录，都不影响File对象的创建。 window的路径分隔符使用“\\”，而Java程序中的“\\”表示转义字符，所以在Windows中表示路径，需要用“\\”。或者直接使用“&#x2F;”也可以，Java程序支持将“&#x2F;”当成平台无关的路径分隔符。或者直接使用File.separator常量值表示。比如： File file2 &#x3D; new File(“d:” + File.separator + “atguigu” + File.separator + “info.txt”); 当构造路径是绝对路径时，那么getPath和getAbsolutePath结果一样 当构造路径是相对路径时，那么getAbsolutePath的路径 &#x3D; user.dir的路径 + 构造路径 1.3 常用方法1、获取文件和目录基本信息 public String getName() ：获取名称 public String getPath() ：获取路径 public String getAbsolutePath()：获取绝对路径 public File getAbsoluteFile()：获取绝对路径表示的文件 public String getParent()：获取上层文件目录路径。若无，返回null public long length() ：获取文件长度（即：字节数）。不能获取目录的长度。 public long lastModified() ：获取最后一次的修改时间，毫秒值 如果File对象代表的文件或目录存在，则File对象实例初始化时，就会用硬盘中对应文件或目录的属性信息（例如，时间、类型等）为File对象的属性赋值，否则除了路径和名称，File对象的其他属性将会保留默认值。 举例： 12345678910111213141516171819202122package com.atguigu.file;import java.io.File;import java.time.Instant;import java.time.LocalDateTime;import java.time.ZoneId;public class FileInfoMethod &#123; public static void main(String[] args) &#123; File f = new File(&quot;d:/aaa/bbb.txt&quot;); System.out.println(&quot;文件构造路径:&quot;+f.getPath()); System.out.println(&quot;文件名称:&quot;+f.getName()); System.out.println(&quot;文件长度:&quot;+f.length()+&quot;字节&quot;); System.out.println(&quot;文件最后修改时间：&quot; + LocalDateTime.ofInstant(Instant.ofEpochMilli(f.lastModified()),ZoneId.of(&quot;Asia/Shanghai&quot;))); File f2 = new File(&quot;d:/aaa&quot;); System.out.println(&quot;目录构造路径:&quot;+f2.getPath()); System.out.println(&quot;目录名称:&quot;+f2.getName()); System.out.println(&quot;目录长度:&quot;+f2.length()+&quot;字节&quot;); System.out.println(&quot;文件最后修改时间：&quot; + LocalDateTime.ofInstant(Instant.ofEpochMilli(f.lastModified()),ZoneId.of(&quot;Asia/Shanghai&quot;))); &#125;&#125; 12345678910输出结果：文件构造路径:d:\\aaa\\bbb.java文件名称:bbb.java文件长度:636字节文件最后修改时间：2022-07-23T22:01:32.065目录构造路径:d:\\aaa目录名称:aaa目录长度:4096字节文件最后修改时间：2022-07-23T22:01:32.065 2、列出目录的下一级 public String[] list() ：返回一个String数组，表示该File目录中的所有子文件或目录。 public File[] listFiles() ：返回一个File数组，表示该File目录中的所有的子文件或目录。 12345678910111213141516171819package com.atguigu.file;import org.junit.Test;import java.io.File;import java.io.FileFilter;import java.io.FilenameFilter;public class DirListFiles &#123; @Test public void test01() &#123; File dir = new File(&quot;d:/atguigu&quot;); String[] subs = dir.list(); for (String sub : subs) &#123; System.out.println(sub); &#125; &#125;&#125; 3、File类的重命名功能 public boolean renameTo(File dest):把文件重命名为指定的文件路径。 4、判断功能的方法 public boolean exists() ：此File表示的文件或目录是否实际存在。 public boolean isDirectory() ：此File表示的是否为目录。 public boolean isFile() ：此File表示的是否为文件。 public boolean canRead() ：判断是否可读 public boolean canWrite() ：判断是否可写 public boolean isHidden() ：判断是否隐藏 举例： 12345678910111213141516package com.atguigu.file;import java.io.File;public class FileIs &#123; public static void main(String[] args) &#123; File f = new File(&quot;d:\\\\aaa\\\\bbb.java&quot;); File f2 = new File(&quot;d:\\\\aaa&quot;); // 判断是否存在 System.out.println(&quot;d:\\\\aaa\\\\bbb.java 是否存在:&quot;+f.exists()); System.out.println(&quot;d:\\\\aaa 是否存在:&quot;+f2.exists()); // 判断是文件还是目录 System.out.println(&quot;d:\\\\aaa 文件?:&quot;+f2.isFile()); System.out.println(&quot;d:\\\\aaa 目录?:&quot;+f2.isDirectory()); &#125;&#125; 12345输出结果：d:\\aaa\\bbb.java 是否存在:trued:\\aaa 是否存在:trued:\\aaa 文件?:falsed:\\aaa 目录?:true 如果文件或目录不存在，那么exists()、isFile()和isDirectory()都是返回true 5、创建、删除功能 public boolean createNewFile() ：创建文件。若文件存在，则不创建，返回false。 public boolean mkdir() ：创建文件目录。如果此文件目录存在，就不创建了。如果此文件目录的上层目录不存在，也不创建。 public boolean mkdirs() ：创建文件目录。如果上层文件目录不存在，一并创建。 public boolean delete() ：删除文件或者文件夹删除注意事项：① Java中的删除不走回收站。② 要删除一个文件目录，请注意该文件目录内不能包含文件或者文件目录。 举例： 123456789101112131415161718192021222324252627282930313233343536package com.atguigu.file;import java.io.File;import java.io.IOException;public class FileCreateDelete &#123; public static void main(String[] args) throws IOException &#123; // 文件的创建 File f = new File(&quot;aaa.txt&quot;); System.out.println(&quot;aaa.txt是否存在:&quot;+f.exists()); System.out.println(&quot;aaa.txt是否创建:&quot;+f.createNewFile()); System.out.println(&quot;aaa.txt是否存在:&quot;+f.exists()); // 目录的创建 File f2= new File(&quot;newDir&quot;); System.out.println(&quot;newDir是否存在:&quot;+f2.exists()); System.out.println(&quot;newDir是否创建:&quot;+f2.mkdir()); System.out.println(&quot;newDir是否存在:&quot;+f2.exists()); // 创建一级目录 File f3= new File(&quot;newDira\\\\newDirb&quot;); System.out.println(&quot;newDira\\\\newDirb创建：&quot; + f3.mkdir()); File f4= new File(&quot;newDir\\\\newDirb&quot;); System.out.println(&quot;newDir\\\\newDirb创建：&quot; + f4.mkdir()); // 创建多级目录 File f5= new File(&quot;newDira\\\\newDirb&quot;); System.out.println(&quot;newDira\\\\newDirb创建：&quot; + f5.mkdirs()); // 文件的删除 System.out.println(&quot;aaa.txt删除：&quot; + f.delete()); // 目录的删除 System.out.println(&quot;newDir删除：&quot; + f2.delete()); System.out.println(&quot;newDir\\\\newDirb删除：&quot; + f4.delete()); &#125;&#125; 12345678910111213运行结果：aaa.txt是否存在:falseaaa.txt是否创建:trueaaa.txt是否存在:truenewDir是否存在:falsenewDir是否创建:truenewDir是否存在:truenewDira\\newDirb创建：falsenewDir\\newDirb创建：truenewDira\\newDirb创建：trueaaa.txt删除：truenewDir删除：falsenewDir\\newDirb删除：true API中说明：delete方法，如果此File表示目录，则目录必须为空才能删除。 1.4 练习练习1：利用File构造器，new 一个文件目录file ​ 1) 在其中创建多个文件和目录 ​ 2) 编写方法，实现删除file中指定文件的操作 练习2：判断指定目录下是否有后缀名为.jpg的文件。如果有，就输出该文件名称 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class FindJPGFileTest &#123; //方法1： @Test public void test1()&#123; File srcFile = new File(&quot;d:\\\\code&quot;); String[] fileNames = srcFile.list(); for(String fileName : fileNames)&#123; if(fileName.endsWith(&quot;.jpg&quot;))&#123; System.out.println(fileName); &#125; &#125; &#125; //方法2： @Test public void test2()&#123; File srcFile = new File(&quot;d:\\\\code&quot;); File[] listFiles = srcFile.listFiles(); for(File file : listFiles)&#123; if(file.getName().endsWith(&quot;.jpg&quot;))&#123; System.out.println(file.getAbsolutePath()); &#125; &#125; &#125; //方法3： /* * File类提供了两个文件过滤器方法 * public String[] list(FilenameFilter filter) * public File[] listFiles(FileFilter filter) */ @Test public void test3()&#123; File srcFile = new File(&quot;d:\\\\code&quot;); File[] subFiles = srcFile.listFiles(new FilenameFilter() &#123; @Override public boolean accept(File dir, String name) &#123; return name.endsWith(&quot;.jpg&quot;); &#125; &#125;); for(File file : subFiles)&#123; System.out.println(file.getAbsolutePath()); &#125; &#125; &#125; 练习3：遍历指定目录所有文件名称，包括子文件目录中的文件。 拓展1：并计算指定目录占用空间的大小 拓展2：删除指定文件目录及其下的所有文件 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071public class ListFilesTest &#123; //练习3：(方式1) public static void printSubFile(File dir) &#123; // 打印目录的子文件 File[] subfiles = dir.listFiles(); for (File f : subfiles) &#123; if (f.isDirectory()) &#123;// 文件目录 printSubFile(f); &#125; else &#123;// 文件 System.out.println(f.getAbsolutePath()); &#125; &#125; &#125; // //练习3：(方式2) public void listAllSubFiles(File file) &#123; if (file.isFile()) &#123; System.out.println(file); &#125; else &#123; File[] all = file.listFiles(); // 如果all[i]是文件，直接打印 // 如果all[i]是目录，接着再获取它的下一级 for (File f : all) &#123; listAllSubFiles(f);// 递归调用：自己调用自己就叫递归 &#125; &#125; &#125; @Test public void testListAllFiles()&#123; // 1.创建目录对象 File dir = new File(&quot;E:\\\\teach\\\\01_javaSE\\\\_尚硅谷Java编程语言\\\\3_软件&quot;); // 2.打印目录的子文件 printSubFile(dir); &#125; // 拓展1：求指定目录所在空间的大小 public long getDirectorySize(File file) &#123; // file是文件，那么直接返回file.length() // file是目录，把它的下一级的所有file大小加起来就是它的总大小 long size = 0; if (file.isFile()) &#123; size = file.length(); &#125; else &#123; File[] all = file.listFiles();// 获取file的下一级 // 累加all[i]的大小 for (File f : all) &#123; size += getDirectorySize(f);// f的大小; &#125; &#125; return size; &#125; // 拓展2：删除指定的目录 public void deleteDirectory(File file) &#123; // 如果file是文件，直接delete // 如果file是目录，先把它的下一级干掉，然后删除自己 if (file.isDirectory()) &#123; File[] all = file.listFiles(); // 循环删除的是file的下一级 for (File f : all) &#123;// f代表file的每一个下级 deleteDirectory(f); &#125; &#125; // 删除自己 file.delete(); &#125;&#125; 2. IO流原理及流的分类 2.1 Java IO原理 Java程序中，对于数据的输入&#x2F;输出操作以“流(stream)” 的方式进行，可以看做是一种数据的流动。 I&#x2F;O流中的I&#x2F;O是Input/Output的缩写， I&#x2F;O技术是非常实用的技术，用于处理设备之间的数据传输。如读&#x2F;写文件，网络通讯等。 输入input：读取外部数据（磁盘、光盘等存储设备的数据）到程序（内存）中。 输出output：将程序（内存）数据输出到磁盘、光盘等存储设备中。 2.2 流的分类java.io包下提供了各种“流”类和接口，用以获取不同种类的数据，并通过标准的方法输入或输出数据。 按数据的流向不同分为：输入流和输出流。 输入流 ：把数据从其他设备上读取到内存中的流。 以InputStream、Reader结尾 输出流 ：把数据从内存 中写出到其他设备上的流。 以OutputStream、Writer结尾 按操作数据单位的不同分为：字节流（8bit）和字符流（16bit）。 字节流 ：以字节为单位，读写数据的流。 以InputStream、OutputStream结尾 字符流 ：以字符为单位，读写数据的流。 以Reader、Writer结尾 根据IO流的角色不同分为：节点流和处理流。 节点流：直接从数据源或目的地读写数据 处理流：不直接连接到数据源或目的地，而是“连接”在已存在的流（节点流或处理流）之上，通过对数据的处理为程序提供更为强大的读写功能。 小结：图解 2.3 流的API Java的IO流共涉及40多个类，实际上非常规则，都是从如下4个抽象基类派生的。 （抽象基类） 输入流 输出流 字节流 InputStream OutputStream 字符流 Reader Writer 由这四个类派生出来的子类名称都是以其父类名作为子类名后缀。 常用的节点流： 文件流： FileInputStream、FileOutputStrean、FileReader、FileWriter 字节&#x2F;字符数组流： ByteArrayInputStream、ByteArrayOutputStream、CharArrayReader、CharArrayWriter 对数组进行处理的节点流（对应的不再是文件，而是内存中的一个数组）。 常用处理流： 缓冲流：BufferedInputStream、BufferedOutputStream、BufferedReader、BufferedWriter 作用：增加缓冲功能，避免频繁读写硬盘，进而提升读写效率。 转换流：InputStreamReader、OutputStreamReader 作用：实现字节流和字符流之间的转换。 对象流：ObjectInputStream、ObjectOutputStream 作用：提供直接读写Java对象功能 3. 节点流之一：FileReader\\FileWriter3.1 Reader与WriterJava提供一些字符流类，以字符为单位读写数据，专门用于处理文本文件。不能操作图片，视频等非文本文件。 常见的文本文件有如下的格式：.txt、.java、.c、.cpp、.py等 注意：.doc、.xls、.ppt这些都不是文本文件。 3.1.1 字符输入流：Readerjava.io.Reader抽象类是表示用于读取字符流的所有类的父类，可以读取字符信息到内存中。它定义了字符输入流的基本共性功能方法。 public int read()： 从输入流读取一个字符。 虽然读取了一个字符，但是会自动提升为int类型。返回该字符的Unicode编码值。如果已经到达流末尾了，则返回-1。 public int read(char[] cbuf)： 从输入流中读取一些字符，并将它们存储到字符数组 cbuf中 。每次最多读取cbuf.length个字符。返回实际读取的字符个数。如果已经到达流末尾，没有数据可读，则返回-1。 public int read(char[] cbuf,int off,int len)：从输入流中读取一些字符，并将它们存储到字符数组 cbuf中，从cbuf[off]开始的位置存储。每次最多读取len个字符。返回实际读取的字符个数。如果已经到达流末尾，没有数据可读，则返回-1。 public void close() ：关闭此流并释放与此流相关联的任何系统资源。 注意：当完成流的操作时，必须调用close()方法，释放系统资源，否则会造成内存泄漏。 3.1.2 字符输出流：Writerjava.io.Writer 抽象类是表示用于写出字符流的所有类的超类，将指定的字符信息写出到目的地。它定义了字节输出流的基本共性功能方法。 public void write(int c) ：写出单个字符。 public void write(char[] cbuf) ：写出字符数组。 public void write(char[] cbuf, int off, int len) ：写出字符数组的某一部分。off：数组的开始索引；len：写出的字符个数。 public void write(String str) ：写出字符串。 public void write(String str, int off, int len) ：写出字符串的某一部分。off：字符串的开始索引；len：写出的字符个数。 public void flush() ：刷新该流的缓冲。 public void close() ：关闭此流。 注意：当完成流的操作时，必须调用close()方法，释放系统资源，否则会造成内存泄漏。 3.2 FileReader 与 FileWriter3.2.1 FileReaderjava.io.FileReader 类用于读取字符文件，构造时使用系统默认的字符编码和默认字节缓冲区。 FileReader(File file)： 创建一个新的 FileReader ，给定要读取的File对象。 FileReader(String fileName)： 创建一个新的 FileReader ，给定要读取的文件的名称。 举例：读取hello.txt文件中的字符数据，并显示在控制台上 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113/** * @author 尚硅谷-宋红康 * @create 14:09 */public class FileReaderWriterTest &#123; //实现方式1 @Test public void test1() throws IOException &#123; //1. 创建File类的对象，对应着物理磁盘上的某个文件 File file = new File(&quot;hello.txt&quot;); //2. 创建FileReader流对象，将File类的对象作为参数传递到FileReader的构造器中 FileReader fr = new FileReader(file); //3. 通过相关流的方法，读取文件中的数据// int data = fr.read(); //每调用一次读取一个字符// while (data != -1) &#123;// System.out.print((char) data);// data = fr.read();// &#125; int data; while ((data = fr.read()) != -1) &#123; System.out.print((char) data); &#125; //4. 关闭相关的流资源，避免出现内存泄漏 fr.close(); &#125; //实现方式2：在方式1的基础上改进，使用try-catch-finally处理异常。保证流是可以关闭的 @Test public void test2() &#123; FileReader fr = null; try &#123; //1. 创建File类的对象，对应着物理磁盘上的某个文件 File file = new File(&quot;hello.txt&quot;); //2. 创建FileReader流对象，将File类的对象作为参数传递到FileReader的构造器中 fr = new FileReader(file); //3. 通过相关流的方法，读取文件中的数据 /* * read():每次从对接的文件中读取一个字符。并将此字符返回。 * 如果返回值为-1,则表示文件到了末尾，可以不再读取。 * */// int data = fr.read();// while(data != -1)&#123;// System.out.print((char)data);// data = fr.read();// &#125; int data; while ((data = fr.read()) != -1) &#123; System.out.println((char) data); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; //4. 关闭相关的流资源，避免出现内存泄漏 try &#123; if (fr != null) fr.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; //实现方式3：调用read(char[] cbuf),每次从文件中读取多个字符 @Test public void test3() &#123; FileReader fr = null; try &#123; //1. 创建File类的对象，对应着物理磁盘上的某个文件 File file = new File(&quot;hello.txt&quot;); //2. 创建FileReader流对象，将File类的对象作为参数传递到FileReader的构造器中 fr = new FileReader(file); //3. 通过相关流的方法，读取文件中的数据 char[] cbuf = new char[5]; /* * read(char[] cbuf) : 每次将文件中的数据读入到cbuf数组中，并返回读入到数组中的 * 字符的个数。 * */ int len; //记录每次读入的字符的个数 while ((len = fr.read(cbuf)) != -1) &#123; //处理char[]数组即可 //错误：// for(int i = 0;i &lt; cbuf.length;i++)&#123;// System.out.print(cbuf[i]);// &#125; //错误：// String str = new String(cbuf);// System.out.print(str); //正确：// for(int i = 0;i &lt; len;i++)&#123;// System.out.print(cbuf[i]);// &#125; //正确： String str = new String(cbuf, 0, len); System.out.print(str); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; //4. 关闭相关的流资源，避免出现内存泄漏 try &#123; if (fr != null) fr.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 不同实现方式的类比： 3.2.2 FileWriterjava.io.FileWriter 类用于写出字符到文件，构造时使用系统默认的字符编码和默认字节缓冲区。 FileWriter(File file)： 创建一个新的 FileWriter，给定要读取的File对象。 FileWriter(String fileName)： 创建一个新的 FileWriter，给定要读取的文件的名称。 FileWriter(File file,boolean append)： 创建一个新的 FileWriter，指明是否在现有文件末尾追加内容。 举例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081public class FWWrite &#123; //注意：应该使用try-catch-finally处理异常。这里出于方便阅读代码，使用了throws的方式 @Test public void test01()throws IOException &#123; // 使用文件名称创建流对象 FileWriter fw = new FileWriter(new File(&quot;fw.txt&quot;)); // 写出数据 fw.write(97); // 写出第1个字符 fw.write(&#x27;b&#x27;); // 写出第2个字符 fw.write(&#x27;C&#x27;); // 写出第3个字符 fw.write(30000); // 写出第4个字符，中文编码表中30000对应一个汉字。 //关闭资源 fw.close(); &#125; //注意：应该使用try-catch-finally处理异常。这里出于方便阅读代码，使用了throws的方式 @Test public void test02()throws IOException &#123; // 使用文件名称创建流对象 FileWriter fw = new FileWriter(new File(&quot;fw.txt&quot;)); // 字符串转换为字节数组 char[] chars = &quot;尚硅谷&quot;.toCharArray(); // 写出字符数组 fw.write(chars); // 尚硅谷 // 写出从索引1开始，2个字符。 fw.write(chars,1,2); // 硅谷 // 关闭资源 fw.close(); &#125; //注意：应该使用try-catch-finally处理异常。这里出于方便阅读代码，使用了throws的方式 @Test public void test03()throws IOException &#123; // 使用文件名称创建流对象 FileWriter fw = new FileWriter(&quot;fw.txt&quot;); // 字符串 String msg = &quot;尚硅谷&quot;; // 写出字符数组 fw.write(msg); //尚硅谷 // 写出从索引1开始，2个字符。 fw.write(msg,1,2); // 硅谷 // 关闭资源 fw.close(); &#125; @Test public void test04()&#123; FileWriter fw = null; try &#123; //1. 创建File的对象 File file = new File(&quot;personinfo.txt&quot;); //2. 创建FileWriter的对象，将File对象作为参数传递到FileWriter的构造器中 //如果输出的文件已存在，则会对现有的文件进行覆盖 fw = new FileWriter(file);// fw = new FileWriter(file,false); //如果输出的文件已存在，则会在现有的文件末尾写入数据// fw = new FileWriter(file,true); //3. 调用相关的方法，实现数据的写出操作 //write(String str) / write(char[] cbuf) fw.write(&quot;I love you,&quot;); fw.write(&quot;you love him.&quot;); fw.write(&quot;so sad&quot;.toCharArray()); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; //4. 关闭资源，避免内存泄漏 try &#123; if (fw != null) fw.close(); &#125; catch (IOException e) &#123; throw new RuntimeException(e); &#125; &#125; &#125;&#125; 3.2.3 小结1234567891011① 因为出现流资源的调用，为了避免内存泄漏，需要使用try-catch-finally处理异常② 对于输入流来说，File类的对象必须在物理磁盘上存在，否则执行就会报FileNotFoundException。如果传入的是一个目录，则会报IOException异常。对于输出流来说，File类的对象是可以不存在的。 &gt; 如果File类的对象不存在，则可以在输出的过程中，自动创建File类的对象 &gt; 如果File类的对象存在， &gt; 如果调用FileWriter(File file)或FileWriter(File file,false)，输出时会新建File文件覆盖已有的文件 &gt; 如果调用FileWriter(File file,true)构造器，则在现有的文件末尾追加写出内容。 3.3 关于flush（刷新）因为内置缓冲区的原因，如果FileWriter不关闭输出流，无法写出字符到文件中。但是关闭的流对象，是无法继续写出数据的。如果我们既想写出数据，又想继续使用流，就需要flush() 方法了。 flush() ：刷新缓冲区，流对象可以继续使用。 close() ：先刷新缓冲区，然后通知系统释放资源。流对象不可以再被使用了。 注意：即便是flush()方法写出了数据，操作的最后还是要调用close方法，释放系统资源。 举例： 12345678910111213141516171819public class FWWriteFlush &#123; //注意：应该使用try-catch-finally处理异常。这里出于方便阅读代码，使用了throws的方式 @Test public void test() throws IOException &#123; // 使用文件名称创建流对象 FileWriter fw = new FileWriter(&quot;fw.txt&quot;); // 写出数据，通过flush fw.write(&#x27;刷&#x27;); // 写出第1个字符 fw.flush(); fw.write(&#x27;新&#x27;); // 继续写出第2个字符，写出成功 fw.flush(); // 写出数据，通过close fw.write(&#x27;关&#x27;); // 写出第1个字符 fw.close(); fw.write(&#x27;闭&#x27;); // 继续写出第2个字符,【报错】java.io.IOException: Stream closed fw.close(); &#125;&#125; 4. 节点流之二：FileInputStream\\FileOutputStream如果我们读取或写出的数据是非文本文件，则Reader、Writer就无能为力了，必须使用字节流。 4.1 InputStream和OutputStream4.1.1 字节输入流：InputStreamjava.io.InputStream 抽象类是表示字节输入流的所有类的超类，可以读取字节信息到内存中。它定义了字节输入流的基本共性功能方法。 public int read()： 从输入流读取一个字节。返回读取的字节值。虽然读取了一个字节，但是会自动提升为int类型。如果已经到达流末尾，没有数据可读，则返回-1。 public int read(byte[] b)： 从输入流中读取一些字节数，并将它们存储到字节数组 b中 。每次最多读取b.length个字节。返回实际读取的字节个数。如果已经到达流末尾，没有数据可读，则返回-1。 public int read(byte[] b,int off,int len)：从输入流中读取一些字节数，并将它们存储到字节数组 b中，从b[off]开始存储，每次最多读取len个字节 。返回实际读取的字节个数。如果已经到达流末尾，没有数据可读，则返回-1。 public void close() ：关闭此输入流并释放与此流相关联的任何系统资源。 说明：close()方法，当完成流的操作时，必须调用此方法，释放系统资源。 4.1.2 字节输出流：OutputStreamjava.io.OutputStream 抽象类是表示字节输出流的所有类的超类，将指定的字节信息写出到目的地。它定义了字节输出流的基本共性功能方法。 public void write(int b) ：将指定的字节输出流。虽然参数为int类型四个字节，但是只会保留一个字节的信息写出。 public void write(byte[] b)：将 b.length字节从指定的字节数组写入此输出流。 public void write(byte[] b, int off, int len) ：从指定的字节数组写入 len字节，从偏移量 off开始输出到此输出流。 public void flush() ：刷新此输出流并强制任何缓冲的输出字节被写出。 public void close() ：关闭此输出流并释放与此流相关联的任何系统资源。 说明：close()方法，当完成流的操作时，必须调用此方法，释放系统资源。 4.2 FileInputStream 与 FileOutputStream4.2.1 FileInputStreamjava.io.FileInputStream 类是文件输入流，从文件中读取字节。 FileInputStream(File file)： 通过打开与实际文件的连接来创建一个 FileInputStream ，该文件由文件系统中的 File对象 file命名。 FileInputStream(String name)： 通过打开与实际文件的连接来创建一个 FileInputStream ，该文件由文件系统中的路径名 name命名。 举例： 12//read.txt文件中的内容如下：abcde 读取操作 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596public class FISRead &#123; //注意：应该使用try-catch-finally处理异常。这里出于方便阅读代码，使用了throws的方式 @Test public void test() throws IOException &#123; // 使用文件名称创建流对象 FileInputStream fis = new FileInputStream(&quot;read.txt&quot;); // 读取数据，返回一个字节 int read = fis.read(); System.out.println((char) read); read = fis.read(); System.out.println((char) read); read = fis.read(); System.out.println((char) read); read = fis.read(); System.out.println((char) read); read = fis.read(); System.out.println((char) read); // 读取到末尾,返回-1 read = fis.read(); System.out.println(read); // 关闭资源 fis.close(); /* 文件内容：abcde 输出结果： a b c d e -1 */ &#125; @Test public void test02()throws IOException&#123; // 使用文件名称创建流对象 FileInputStream fis = new FileInputStream(&quot;read.txt&quot;); // 定义变量，保存数据 int b; // 循环读取 while ((b = fis.read())!=-1) &#123; System.out.println((char)b); &#125; // 关闭资源 fis.close(); &#125; @Test public void test03()throws IOException&#123; // 使用文件名称创建流对象. FileInputStream fis = new FileInputStream(&quot;read.txt&quot;); // 文件中为abcde // 定义变量，作为有效个数 int len; // 定义字节数组，作为装字节数据的容器 byte[] b = new byte[2]; // 循环读取 while (( len= fis.read(b))!=-1) &#123; // 每次读取后,把数组变成字符串打印 System.out.println(new String(b)); &#125; // 关闭资源 fis.close(); /* 输出结果： ab cd ed 最后错误数据`d`，是由于最后一次读取时，只读取一个字节`e`，数组中， 上次读取的数据没有被完全替换，所以要通过`len` ，获取有效的字节 */ &#125; @Test public void test04()throws IOException&#123; // 使用文件名称创建流对象. FileInputStream fis = new FileInputStream(&quot;read.txt&quot;); // 文件中为abcde // 定义变量，作为有效个数 int len; // 定义字节数组，作为装字节数据的容器 byte[] b = new byte[2]; // 循环读取 while (( len= fis.read(b))!=-1) &#123; // 每次读取后,把数组的有效字节部分，变成字符串打印 System.out.println(new String(b,0,len));// len 每次读取的有效字节个数 &#125; // 关闭资源 fis.close(); /* 输出结果： ab cd e */ &#125;&#125; 4.2.2 FileOutputStreamjava.io.FileOutputStream 类是文件输出流，用于将数据写出到文件。 public FileOutputStream(File file)：创建文件输出流，写出由指定的 File对象表示的文件。 public FileOutputStream(String name)： 创建文件输出流，指定的名称为写出文件。 public FileOutputStream(File file, boolean append)： 创建文件输出流，指明是否在现有文件末尾追加内容。 举例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889package com.atguigu.fileio;import org.junit.Test;import java.io.FileOutputStream;import java.io.IOException;public class FOSWrite &#123; //注意：应该使用try-catch-finally处理异常。这里出于方便阅读代码，使用了throws的方式 @Test public void test01() throws IOException &#123; // 使用文件名称创建流对象 FileOutputStream fos = new FileOutputStream(&quot;fos.txt&quot;); // 写出数据 fos.write(97); // 写出第1个字节 fos.write(98); // 写出第2个字节 fos.write(99); // 写出第3个字节 // 关闭资源 fos.close(); /* 输出结果：abc*/ &#125; @Test public void test02()throws IOException &#123; // 使用文件名称创建流对象 FileOutputStream fos = new FileOutputStream(&quot;fos.txt&quot;); // 字符串转换为字节数组 byte[] b = &quot;abcde&quot;.getBytes(); // 写出从索引2开始，2个字节。索引2是c，两个字节，也就是cd。 fos.write(b,2,2); // 关闭资源 fos.close(); &#125; //这段程序如果多运行几次，每次都会在原来文件末尾追加abcde @Test public void test03()throws IOException &#123; // 使用文件名称创建流对象 FileOutputStream fos = new FileOutputStream(&quot;fos.txt&quot;,true); // 字符串转换为字节数组 byte[] b = &quot;abcde&quot;.getBytes(); fos.write(b); // 关闭资源 fos.close(); &#125; //使用FileInputStream\\FileOutputStream，实现对文件的复制 @Test public void test05() &#123; FileInputStream fis = null; FileOutputStream fos = null; try &#123; //1. 造文件-造流 //复制图片：成功// fis = new FileInputStream(new File(&quot;pony.jpg&quot;));// fos = new FileOutputStream(new File(&quot;pony_copy1.jpg&quot;)); //复制文本文件：成功 fis = new FileInputStream(new File(&quot;hello.txt&quot;)); fos = new FileOutputStream(new File(&quot;hello1.txt&quot;)); //2. 复制操作（读、写） byte[] buffer = new byte[1024]; int len;//每次读入到buffer中字节的个数 while ((len = fis.read(buffer)) != -1) &#123; fos.write(buffer, 0, len);// String str = new String(buffer,0,len);// System.out.print(str); &#125; System.out.println(&quot;复制成功&quot;); &#125; catch (IOException e) &#123; throw new RuntimeException(e); &#125; finally &#123; //3. 关闭资源 try &#123; if (fos != null) fos.close(); &#125; catch (IOException e) &#123; throw new RuntimeException(e); &#125; try &#123; if (fis != null) fis.close(); &#125; catch (IOException e) &#123; throw new RuntimeException(e); &#125; &#125; &#125;&#125; 4.3 练习练习：实现图片加密操作。 提示： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104/** * @author 尚硅谷-宋红康 * @create 8:59 */public class FileSecretTest &#123; /* * 图片的加密 * */ @Test public void test1()&#123; FileInputStream fis = null; FileOutputStream fos = null; try &#123; File file1 = new File(&quot;pony.jpg&quot;); File file2 = new File(&quot;pony_secret.jpg&quot;); fis = new FileInputStream(file1); fos = new FileOutputStream(file2); //方式1：每次读入一个字节，效率低// int data;// while((data = fis.read()) != -1)&#123;// fos.write(data ^ 5);// &#125; //方式2：每次读入一个字节数组，效率高 int len; byte[] buffer = new byte[1024]; while((len = fis.read(buffer)) != -1)&#123; for(int i = 0;i &lt; len;i++)&#123; buffer[i] = (byte) (buffer[i] ^ 5); &#125; fos.write(buffer,0,len); &#125; System.out.println(&quot;加密成功&quot;); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; fos.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; try &#123; fis.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; /* * 图片的解密 * */ @Test public void test2()&#123; FileInputStream fis = null; FileOutputStream fos = null; try &#123; File file1 = new File(&quot;pony_secret.jpg&quot;); File file2 = new File(&quot;pony_unsecret.jpg&quot;); fis = new FileInputStream(file1); fos = new FileOutputStream(file2); //方式1：每次读入一个字节，效率低// int data;// while((data = fis.read()) != -1)&#123;// fos.write(data ^ 5);// &#125; //方式2：每次读入一个字节数组，效率高 int len; byte[] buffer = new byte[1024]; while((len = fis.read(buffer)) != -1)&#123; for(int i = 0;i &lt; len;i++)&#123; buffer[i] = (byte) (buffer[i] ^ 5); &#125; fos.write(buffer,0,len); &#125; System.out.println(&quot;解密成功&quot;); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; fos.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; try &#123; fis.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 5. 处理流之一：缓冲流 为了提高数据读写的速度，Java API提供了带缓冲功能的流类：缓冲流。 缓冲流要“套接”在相应的节点流之上，根据数据操作单位可以把缓冲流分为： 字节缓冲流：BufferedInputStream，BufferedOutputStream 字符缓冲流：BufferedReader，BufferedWriter 缓冲流的基本原理：在创建流对象时，内部会创建一个缓冲区数组（缺省使用8192个字节(8Kb)的缓冲区），通过缓冲区读写，减少系统IO次数，从而提高读写的效率。 5.1 构造器 public BufferedInputStream(InputStream in) ：创建一个 新的字节型的缓冲输入流。 public BufferedOutputStream(OutputStream out)： 创建一个新的字节型的缓冲输出流。 代码举例： 1234// 创建字节缓冲输入流BufferedInputStream bis = new BufferedInputStream(new FileInputStream(&quot;abc.jpg&quot;));// 创建字节缓冲输出流BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(&quot;abc_copy.jpg&quot;)); public BufferedReader(Reader in) ：创建一个 新的字符型的缓冲输入流。 public BufferedWriter(Writer out)： 创建一个新的字符型的缓冲输出流。 代码举例： 1234// 创建字符缓冲输入流BufferedReader br = new BufferedReader(new FileReader(&quot;br.txt&quot;));// 创建字符缓冲输出流BufferedWriter bw = new BufferedWriter(new FileWriter(&quot;bw.txt&quot;)); 5.2 效率测试查询API，缓冲流读写方法与基本的流是一致的，我们通过复制大文件（375MB），测试它的效率。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107//方法1：使用FileInputStream\\FileOutputStream实现非文本文件的复制public void copyFileWithFileStream(String srcPath,String destPath)&#123; FileInputStream fis = null; FileOutputStream fos = null; try &#123; //1. 造文件-造流 fis = new FileInputStream(new File(srcPath)); fos = new FileOutputStream(new File(destPath)); //2. 复制操作（读、写） byte[] buffer = new byte[100]; int len;//每次读入到buffer中字节的个数 while ((len = fis.read(buffer)) != -1) &#123; fos.write(buffer, 0, len); &#125; System.out.println(&quot;复制成功&quot;); &#125; catch (IOException e) &#123; throw new RuntimeException(e); &#125; finally &#123; //3. 关闭资源 try &#123; if (fos != null) fos.close(); &#125; catch (IOException e) &#123; throw new RuntimeException(e); &#125; try &#123; if (fis != null) fis.close(); &#125; catch (IOException e) &#123; throw new RuntimeException(e); &#125; &#125;&#125;@Testpublic void test1()&#123; String srcPath = &quot;C:\\\\Users\\\\shkstart\\\\Desktop\\\\01-复习.mp4&quot;; String destPath = &quot;C:\\\\Users\\\\shkstart\\\\Desktop\\\\01-复习2.mp4&quot;; long start = System.currentTimeMillis(); copyFileWithFileStream(srcPath,destPath); long end = System.currentTimeMillis(); System.out.println(&quot;花费的时间为：&quot; + (end - start));//7677毫秒&#125;//方法2：使用BufferedInputStream\\BufferedOuputStream实现非文本文件的复制public void copyFileWithBufferedStream(String srcPath,String destPath)&#123; FileInputStream fis = null; FileOutputStream fos = null; BufferedInputStream bis = null; BufferedOutputStream bos = null; try &#123; //1. 造文件 File srcFile = new File(srcPath); File destFile = new File(destPath); //2. 造流 fis = new FileInputStream(srcFile); fos = new FileOutputStream(destFile); bis = new BufferedInputStream(fis); bos = new BufferedOutputStream(fos); //3. 读写操作 int len; byte[] buffer = new byte[100]; while ((len = bis.read(buffer)) != -1) &#123; bos.write(buffer, 0, len); &#125; System.out.println(&quot;复制成功&quot;); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; //4. 关闭资源(如果有多个流，我们需要先关闭外面的流，再关闭内部的流) try &#123; if (bos != null) bos.close(); &#125; catch (IOException e) &#123; throw new RuntimeException(e); &#125; try &#123; if (bis != null) bis.close(); &#125; catch (IOException e) &#123; throw new RuntimeException(e); &#125; &#125;&#125;@Testpublic void test2()&#123; String srcPath = &quot;C:\\\\Users\\\\shkstart\\\\Desktop\\\\01-复习.mp4&quot;; String destPath = &quot;C:\\\\Users\\\\shkstart\\\\Desktop\\\\01-复习2.mp4&quot;; long start = System.currentTimeMillis(); copyFileWithBufferedStream(srcPath,destPath); long end = System.currentTimeMillis(); System.out.println(&quot;花费的时间为：&quot; + (end - start));//415毫秒&#125; 5.3 字符缓冲流特有方法字符缓冲流的基本方法与普通字符流调用方式一致，不再阐述，我们来看它们具备的特有方法。 BufferedReader：public String readLine(): 读一行文字。 BufferedWriter：public void newLine(): 写一行行分隔符,由系统属性定义符号。 1234567891011121314151617181920212223242526272829303132public class BufferedIOLine &#123; @Test public void testReadLine()throws IOException &#123; // 创建流对象 BufferedReader br = new BufferedReader(new FileReader(&quot;in.txt&quot;)); // 定义字符串,保存读取的一行文字 String line; // 循环读取,读取到最后返回null while ((line = br.readLine())!=null) &#123; System.out.println(line); &#125; // 释放资源 br.close(); &#125; @Test public void testNewLine()throws IOException&#123; // 创建流对象 BufferedWriter bw = new BufferedWriter(new FileWriter(&quot;out.txt&quot;)); // 写出数据 bw.write(&quot;尚&quot;); // 写出换行 bw.newLine(); bw.write(&quot;硅&quot;); bw.newLine(); bw.write(&quot;谷&quot;); bw.newLine(); // 释放资源 bw.close(); &#125;&#125; 说明： 涉及到嵌套的多个流时，如果都显式关闭的话，需要先关闭外层的流，再关闭内层的流 其实在开发中，只需要关闭最外层的流即可，因为在关闭外层流时，内层的流也会被关闭。 5.4 练习练习1：分别使用节点流：FileInputStream、FileOutputStream和缓冲流：BufferedInputStream、BufferedOutputStream实现文本文件&#x2F;图片&#x2F;视频文件的复制。并比较二者在数据复制方面的效率。 练习2： 姓氏统计：一个文本文件中存储着北京所有高校在校生的姓名，格式如下： 1234每行一个名字，姓与名以空格分隔：张 三李 四王 小五 现在想统计所有的姓氏在文件中出现的次数，请描述一下你的解决方案。 1234567891011121314151617181920212223242526272829303132333435363738394041424344public static void main(String[] args) &#123; HashMap&lt;String, Integer&gt; map = new HashMap&lt;&gt;(); BufferedReader br = null; try &#123; br = new BufferedReader(new FileReader(new File(&quot;e:/name.txt&quot;))); String value = null; // 临时接收文件中的字符串变量 StringBuffer buffer = new StringBuffer(); flag: while ((value = br.readLine()) != null) &#123; // 开始读取文件中的字符 char[] c = value.toCharArray(); for (int i = 0; i &lt; c.length; i++) &#123; if (c[i] != &#x27; &#x27;) &#123; buffer.append(String.valueOf(c[i])); &#125; else &#123; if (map.containsKey(buffer.toString())) &#123; int count = map.get(buffer.toString()); map.put(buffer.toString(), count + 1); &#125; else &#123; map.put(buffer.toString(), 1); &#125; buffer.delete(0, buffer.length()); continue flag; &#125; &#125; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; if (br != null) &#123; try &#123; br.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; Set&lt;Map.Entry&lt;String, Integer&gt;&gt; set = map.entrySet(); Iterator&lt;Map.Entry&lt;String, Integer&gt;&gt; it = set.iterator(); while (it.hasNext()) &#123; Map.Entry&lt;String, Integer&gt; end = (Map.Entry&lt;String, Integer&gt;) it.next(); System.out.println(end); &#125; &#125; 6. 处理流之二：转换流6.1 问题引入引入情况1： 使用FileReader 读取项目中的文本文件。由于IDEA设置中针对项目设置了UTF-8编码，当读取Windows系统中创建的文本文件时，如果Windows系统默认的是GBK编码，则读入内存中会出现乱码。 123456789101112131415161718package com.atguigu.transfer;import java.io.FileReader;import java.io.IOException;public class Problem &#123; public static void main(String[] args) throws IOException &#123; FileReader fileReader = new FileReader(&quot;E:\\\\File_GBK.txt&quot;); int data; while ((data = fileReader.read()) != -1) &#123; System.out.print((char)data); &#125; fileReader.close(); &#125;&#125;输出结果：��� 那么如何读取GBK编码的文件呢？ 引入情况2： 针对文本文件，现在使用一个字节流进行数据的读入，希望将数据显示在控制台上。此时针对包含中文的文本数据，可能会出现乱码。 6.2 转换流的理解作用：转换流是字节与字符间的桥梁！ 具体来说： 6.3 InputStreamReader 与 OutputStreamWriter InputStreamReader 转换流java.io.InputStreamReader，是Reader的子类，是从字节流到字符流的桥梁。它读取字节，并使用指定的字符集将其解码为字符。它的字符集可以由名称指定，也可以接受平台的默认字符集。 构造器 InputStreamReader(InputStream in): 创建一个使用默认字符集的字符流。 InputStreamReader(InputStream in, String charsetName): 创建一个指定字符集的字符流。 举例 1234//使用默认字符集InputStreamReader isr1 = new InputStreamReader(new FileInputStream(&quot;in.txt&quot;));//使用指定字符集InputStreamReader isr2 = new InputStreamReader(new FileInputStream(&quot;in.txt&quot;) , &quot;GBK&quot;); 示例代码： 12345678910111213141516171819202122232425262728293031package com.atguigu.transfer;import java.io.FileInputStream;import java.io.IOException;import java.io.InputStreamReader;public class InputStreamReaderDemo &#123; public static void main(String[] args) throws IOException &#123; // 定义文件路径,文件为gbk编码 String fileName = &quot;E:\\\\file_gbk.txt&quot;; //方式1： // 创建流对象,默认UTF8编码 InputStreamReader isr1 = new InputStreamReader(new FileInputStream(fileName)); // 定义变量,保存字符 int charData; // 使用默认编码字符流读取,乱码 while ((charData = isr1.read()) != -1) &#123; System.out.print((char)charData); // ��Һ� &#125; isr1.close(); //方式2： // 创建流对象,指定GBK编码 InputStreamReader isr2 = new InputStreamReader(new FileInputStream(fileName) , &quot;GBK&quot;); // 使用指定编码字符流读取,正常解析 while ((charData = isr2.read()) != -1) &#123; System.out.print((char)charData);// 大家好 &#125; isr2.close(); &#125;&#125; OutputStreamWriter 转换流java.io.OutputStreamWriter ，是Writer的子类，是从字符流到字节流的桥梁。使用指定的字符集将字符编码为字节。它的字符集可以由名称指定，也可以接受平台的默认字符集。 构造器 OutputStreamWriter(OutputStream in): 创建一个使用默认字符集的字符流。 OutputStreamWriter(OutputStream in,String charsetName): 创建一个指定字符集的字符流。 举例： 1234//使用默认字符集OutputStreamWriter isr = new OutputStreamWriter(new FileOutputStream(&quot;out.txt&quot;));//使用指定的字符集OutputStreamWriter isr2 = new OutputStreamWriter(new FileOutputStream(&quot;out.txt&quot;) , &quot;GBK&quot;); 示例代码： 1234567891011121314151617181920212223242526package com.atguigu.transfer;import java.io.FileOutputStream;import java.io.IOException;import java.io.OutputStreamWriter;public class OutputStreamWriterDemo &#123; public static void main(String[] args) throws IOException &#123; // 定义文件路径 String FileName = &quot;E:\\\\out_utf8.txt&quot;; // 创建流对象,默认UTF8编码 OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream(FileName)); // 写出数据 osw.write(&quot;你好&quot;); // 保存为6个字节 osw.close(); // 定义文件路径 String FileName2 = &quot;E:\\\\out_gbk.txt&quot;; // 创建流对象,指定GBK编码 OutputStreamWriter osw2 = new OutputStreamWriter(new FileOutputStream(FileName2),&quot;GBK&quot;); // 写出数据 osw2.write(&quot;你好&quot;);// 保存为4个字节 osw2.close(); &#125;&#125; 6.4 字符编码和字符集6.4.1 编码与解码计算机中储存的信息都是用二进制数表示的，而我们在屏幕上看到的数字、英文、标点符号、汉字等字符是二进制数转换之后的结果。按照某种规则，将字符存储到计算机中，称为编码 。反之，将存储在计算机中的二进制数按照某种规则解析显示出来，称为解码 。 字符编码（Character Encoding） : 就是一套自然语言的字符与二进制数之间的对应规则。 编码表：生活中文字和计算机中二进制的对应规则 乱码的情况：按照A规则存储，同样按照A规则解析，那么就能显示正确的文本符号。反之，按照A规则存储，再按照B规则解析，就会导致乱码现象。 123编码:字符(人能看懂的)--字节(人看不懂的)解码:字节(人看不懂的)--&gt;字符(人能看懂的) 6.4.2 字符集 字符集Charset：也叫编码表。是一个系统支持的所有字符的集合，包括各国家文字、标点符号、图形符号、数字等。 计算机要准确的存储和识别各种字符集符号，需要进行字符编码，一套字符集必然至少有一套字符编码。常见字符集有ASCII字符集、GBK字符集、Unicode字符集等。 可见，当指定了编码，它所对应的字符集自然就指定了，所以编码才是我们最终要关心的。 ASCII字符集 ： ASCII码（American Standard Code for Information Interchange，美国信息交换标准代码）：上个世纪60年代，美国制定了一套字符编码，对英语字符与二进制位之间的关系，做了统一规定。这被称为ASCII码。 ASCII码用于显示现代英语，主要包括控制字符（回车键、退格、换行键等）和可显示字符（英文大小写字符、阿拉伯数字和西文符号）。 基本的ASCII字符集，使用7位（bits）表示一个字符（最前面的1位统一规定为0），共128个字符。比如：空格“SPACE”是32（二进制00100000），大写的字母A是65（二进制01000001）。 缺点：不能表示所有字符。 ISO-8859-1字符集： 拉丁码表，别名Latin-1，用于显示欧洲使用的语言，包括荷兰语、德语、意大利语、葡萄牙语等 ISO-8859-1使用单字节编码，兼容ASCII编码。 GBxxx字符集： GB就是国标的意思，是为了显示中文而设计的一套字符集。 GB2312：简体中文码表。一个小于127的字符的意义与原来相同，即向下兼容ASCII码。但两个大于127的字符连在一起时，就表示一个汉字，这样大约可以组合了包含7000多个简体汉字，此外数学符号、罗马希腊的字母、日文的假名们都编进去了，这就是常说的”全角”字符，而原来在127号以下的那些符号就叫”半角”字符了。 GBK：最常用的中文码表。是在GB2312标准基础上的扩展规范，使用了双字节编码方案，共收录了21003个汉字，完全兼容GB2312标准，同时支持繁体汉字以及日韩汉字等。 GB18030：最新的中文码表。收录汉字70244个，采用多字节编码，每个字可以由1个、2个或4个字节组成。支持中国国内少数民族的文字，同时支持繁体汉字以及日韩汉字等。 Unicode字符集 ： Unicode编码为表达任意语言的任意字符而设计，也称为统一码、标准万国码。Unicode 将世界上所有的文字用2个字节统一进行编码，为每个字符设定唯一的二进制编码，以满足跨语言、跨平台进行文本处理的要求。 Unicode 的缺点：这里有三个问题： 第一，英文字母只用一个字节表示就够了，如果用更多的字节存储是极大的浪费。 第二，如何才能区别Unicode和ASCII？计算机怎么知道两个字节表示一个符号，而不是分别表示两个符号呢？ 第三，如果和GBK等双字节编码方式一样，用最高位是1或0表示两个字节和一个字节，就少了很多值无法用于表示字符，不够表示所有字符。 Unicode在很长一段时间内无法推广，直到互联网的出现，为解决Unicode如何在网络上传输的问题，于是面向传输的众多 UTF（UCS Transfer Format）标准出现。具体来说，有三种编码方案，UTF-8、UTF-16和UTF-32。 UTF-8字符集： Unicode是字符集，UTF-8、UTF-16、UTF-32是三种将数字转换到程序数据的编码方案。顾名思义，UTF-8就是每次8个位传输数据，而UTF-16就是每次16个位。其中，UTF-8 是在互联网上使用最广的一种 Unicode 的实现方式。 互联网工程工作小组（IETF）要求所有互联网协议都必须支持UTF-8编码。所以，我们开发Web应用，也要使用UTF-8编码。UTF-8 是一种变长的编码方式。它使用1-4个字节为每个字符编码，编码规则： 128个US-ASCII字符，只需一个字节编码。 拉丁文等字符，需要二个字节编码。 大部分常用字（含中文），使用三个字节编码。 其他极少使用的Unicode辅助字符，使用四字节编码。 举例 Unicode符号范围 | UTF-8编码方式 1234567891011(十六进制) | （二进制）————————————————————|—–—–—–—–—–—–—–—–—–—–—–—–—–—–0000 0000-0000 007F | 0xxxxxxx（兼容原来的ASCII）0000 0080-0000 07FF | 110xxxxx 10xxxxxx0000 0800-0000 FFFF | 1110xxxx 10xxxxxx 10xxxxxx0001 0000-0010 FFFF | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx 小结 注意：在中文操作系统上，ANSI（美国国家标准学会、AMERICAN NATIONAL STANDARDS INSTITUTE: ANSI）编码即为GBK；在英文操作系统上，ANSI编码即为ISO-8859-1。 6.5 练习把当前module下的《康师傅的话.txt》字符编码为GBK，复制到电脑桌面目录下的《寄语.txt》，字符编码为UTF-8。 在当前module下的文本内容： 1234567六项精进：（一）付出不亚于任何人的努力（二）要谦虚，不要骄傲（三）要每天反省（四）活着，就要感谢（五）积善行、思利他（六）不要有感性的烦恼 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142/** * @author 尚硅谷-宋红康 * @create 9:06 */public class InputStreamReaderDemo &#123; @Test public void test() &#123; InputStreamReader isr = null; OutputStreamWriter osw = null; try &#123; isr = new InputStreamReader(new FileInputStream(&quot;康师傅的话.txt&quot;),&quot;gbk&quot;); osw = new OutputStreamWriter(new FileOutputStream(&quot;C:\\\\Users\\\\shkstart\\\\Desktop\\\\寄语.txt&quot;),&quot;utf-8&quot;); char[] cbuf = new char[1024]; int len; while ((len = isr.read(cbuf)) != -1) &#123; osw.write(cbuf, 0, len); osw.flush(); &#125; System.out.println(&quot;文件复制完成&quot;); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; if (isr != null) isr.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; try &#123; if (osw != null) osw.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 7. 处理流之三&#x2F;四：数据流、对象流7.1 数据流与对象流说明如果需要将内存中定义的变量（包括基本数据类型或引用数据类型）保存在文件中，那怎么办呢？ 12345678int age = 300;char gender = &#x27;男&#x27;;int energy = 5000;double price = 75.5;boolean relive = true;String name = &quot;巫师&quot;;Student stu = new Student(&quot;张三&quot;,23,89); Java提供了数据流和对象流来处理这些类型的数据： 数据流：DataOutputStream、DataInputStream DataOutputStream：允许应用程序将基本数据类型、String类型的变量写入输出流中 DataInputStream：允许应用程序以与机器无关的方式从底层输入流中读取基本数据类型、String类型的变量。 对象流DataInputStream中的方法： 12345byte readByte() short readShort()int readInt() long readLong()float readFloat() double readDouble()char readChar() boolean readBoolean() String readUTF() void readFully(byte[] b) 对象流DataOutputStream中的方法：将上述的方法的read改为相应的write即可。 数据流的弊端：只支持Java基本数据类型和字符串的读写，而不支持其它Java对象的类型。而ObjectOutputStream和ObjectInputStream既支持Java基本数据类型的数据读写，又支持Java对象的读写，所以重点介绍对象流ObjectOutputStream和ObjectInputStream。 对象流：ObjectOutputStream、ObjectInputStream ObjectOutputStream：将 Java 基本数据类型和对象写入字节输出流中。通过在流中使用文件可以实现Java各种基本数据类型的数据以及对象的持久存储。 ObjectInputStream：ObjectInputStream 对以前使用 ObjectOutputStream 写出的基本数据类型的数据和对象进行读入操作，保存在内存中。 说明：对象流的强大之处就是可以把Java中的对象写入到数据源中，也能把对象从数据源中还原回来。 7.2 对象流APIObjectOutputStream中的构造器： public ObjectOutputStream(OutputStream out) ： 创建一个指定的ObjectOutputStream。 12FileOutputStream fos = new FileOutputStream(&quot;game.dat&quot;);ObjectOutputStream oos = new ObjectOutputStream(fos); ObjectOutputStream中的方法： public void writeBoolean(boolean val)：写出一个 boolean 值。 public void writeByte(int val)：写出一个8位字节 public void writeShort(int val)：写出一个16位的 short 值 public void writeChar(int val)：写出一个16位的 char 值 public void writeInt(int val)：写出一个32位的 int 值 public void writeLong(long val)：写出一个64位的 long 值 public void writeFloat(float val)：写出一个32位的 float 值。 public void writeDouble(double val)：写出一个64位的 double 值 public void writeUTF(String str)：将表示长度信息的两个字节写入输出流，后跟字符串 s 中每个字符的 UTF-8 修改版表示形式。根据字符的值，将字符串 s 中每个字符转换成一个字节、两个字节或三个字节的字节组。注意，将 String 作为基本数据写入流中与将它作为 Object 写入流中明显不同。 如果 s 为 null，则抛出 NullPointerException。 public void writeObject(Object obj)：写出一个obj对象 public void close() ：关闭此输出流并释放与此流相关联的任何系统资源 ObjectInputStream中的构造器： public ObjectInputStream(InputStream in) ： 创建一个指定的ObjectInputStream。 12FileInputStream fis = new FileInputStream(&quot;game.dat&quot;);ObjectInputStream ois = new ObjectInputStream(fis); ObjectInputStream中的方法： public boolean readBoolean()：读取一个 boolean 值 public byte readByte()：读取一个 8 位的字节 public short readShort()：读取一个 16 位的 short 值 public char readChar()：读取一个 16 位的 char 值 public int readInt()：读取一个 32 位的 int 值 public long readLong()：读取一个 64 位的 long 值 public float readFloat()：读取一个 32 位的 float 值 public double readDouble()：读取一个 64 位的 double 值 public String readUTF()：读取 UTF-8 修改版格式的 String public void readObject(Object obj)：读入一个obj对象 public void close() ：关闭此输入流并释放与此流相关联的任何系统资源 7.3 认识对象序列化机制1、何为对象序列化机制？ 对象序列化机制允许把内存中的Java对象转换成平台无关的二进制流，从而允许把这种二进制流持久地保存在磁盘上，或通过网络将这种二进制流传输到另一个网络节点。&#x2F;&#x2F;当其它程序获取了这种二进制流，就可以恢复成原来的Java对象。 序列化过程：用一个字节序列可以表示一个对象，该字节序列包含该对象的类型和对象中存储的属性等信息。字节序列写出到文件之后，相当于文件中持久保存了一个对象的信息。 反序列化过程：该字节序列还可以从文件中读取回来，重构对象，对它进行反序列化。对象的数据、对象的类型和对象中存储的数据信息，都可以用来在内存中创建对象。 2、序列化机制的重要性 序列化是 RMI（Remote Method Invoke、远程方法调用）过程的参数和返回值都必须实现的机制，而 RMI 是 JavaEE 的基础。因此序列化机制是 JavaEE 平台的基础。 序列化的好处，在于可将任何实现了Serializable接口的对象转化为字节数据，使其在保存和传输时可被还原。 3、实现原理 序列化：用ObjectOutputStream类保存基本类型数据或对象的机制。方法为： public final void writeObject (Object obj) : 将指定的对象写出。 反序列化：用ObjectInputStream类读取基本类型数据或对象的机制。方法为： public final Object readObject () : 读取一个对象。 7.4 如何实现序列化机制如果需要让某个对象支持序列化机制，则必须让对象所属的类及其属性是可序列化的，为了让某个类是可序列化的，该类必须实现java.io.Serializable 接口。Serializable 是一个标记接口，不实现此接口的类将不会使任何状态序列化或反序列化，会抛出NotSerializableException 。 如果对象的某个属性也是引用数据类型，那么如果该属性也要序列化的话，也要实现Serializable 接口 该类的所有属性必须是可序列化的。如果有一个属性不需要可序列化的，则该属性必须注明是瞬态的，使用transient 关键字修饰。 静态（static）变量的值不会序列化。因为静态变量的值不属于某个对象。 举例1： 1234567891011121314151617181920212223242526272829303132333435363738394041package com.atguigu.object;import org.junit.Test;import java.io.*;public class ReadWriteDataOfAnyType &#123; @Test public void save() throws IOException &#123; String name = &quot;巫师&quot;; int age = 300; char gender = &#x27;男&#x27;; int energy = 5000; double price = 75.5; boolean relive = true; ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;game.dat&quot;)); oos.writeUTF(name); oos.writeInt(age); oos.writeChar(gender); oos.writeInt(energy); oos.writeDouble(price); oos.writeBoolean(relive); oos.close(); &#125; @Test public void reload()throws IOException&#123; ObjectInputStream ois = new ObjectInputStream(new FileInputStream(&quot;game.dat&quot;)); String name = ois.readUTF(); int age = ois.readInt(); char gender = ois.readChar(); int energy = ois.readInt(); double price = ois.readDouble(); boolean relive = ois.readBoolean(); System.out.println(name+&quot;,&quot; + age + &quot;,&quot; + gender + &quot;,&quot; + energy + &quot;,&quot; + price + &quot;,&quot; + relive); ois.close(); &#125;&#125; 举例2： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960package com.atguigu.object;import java.io.Serializable;public class Employee implements Serializable &#123; //static final long serialVersionUID = 23234234234L; public static String company; //static修饰的类变量，不会被序列化 public String name; public String address; public transient int age; // transient瞬态修饰成员,不会被序列化 public Employee(String name, String address, int age) &#123; this.name = name; this.address = address; this.age = age; &#125; public static String getCompany() &#123; return company; &#125; public static void setCompany(String company) &#123; Employee.company = company; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getAddress() &#123; return address; &#125; public void setAddress(String address) &#123; this.address = address; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; @Override public String toString() &#123; return &quot;Employee&#123;&quot; + &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, address=&#x27;&quot; + address + &#x27;\\&#x27;&#x27; + &quot;, age=&quot; + age + &quot;, company=&quot; + company + &#x27;&#125;&#x27;; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334package com.atguigu.object;import org.junit.Test;import java.io.*;public class ReadWriteObject &#123; @Test public void save() throws IOException &#123; Employee.setCompany(&quot;尚硅谷&quot;); Employee e = new Employee(&quot;小谷姐姐&quot;, &quot;宏福苑&quot;, 23); // 创建序列化流对象 ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;employee.dat&quot;)); // 写出对象 oos.writeObject(e); // 释放资源 oos.close(); System.out.println(&quot;Serialized data is saved&quot;); // 姓名，地址被序列化，年龄没有被序列化。 &#125; @Test public void reload() throws IOException, ClassNotFoundException &#123; // 创建反序列化流 FileInputStream fis = new FileInputStream(&quot;employee.dat&quot;); ObjectInputStream ois = new ObjectInputStream(fis); // 读取一个对象 Employee e = (Employee) ois.readObject(); // 释放资源 ois.close(); fis.close(); System.out.println(e); &#125;&#125; 举例3：如果有多个对象需要序列化，则可以将对象放到集合中，再序列化集合对象即可。 12345678910111213141516171819202122232425262728293031323334353637package com.atguigu.object;import org.junit.Test;import java.io.*;import java.util.ArrayList;public class ReadWriteCollection &#123; @Test public void save() throws IOException &#123; ArrayList&lt;Employee&gt; list = new ArrayList&lt;&gt;(); list.add(new Employee(&quot;张三&quot;, &quot;宏福苑&quot;, 23)); list.add(new Employee(&quot;李四&quot;, &quot;白庙&quot;, 24)); list.add(new Employee(&quot;王五&quot;, &quot;平西府&quot;, 25)); // 创建序列化流对象 ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;employees.dat&quot;)); // 写出对象 oos.writeObject(list); // 释放资源 oos.close(); &#125; @Test public void reload() throws IOException, ClassNotFoundException &#123; // 创建反序列化流 FileInputStream fis = new FileInputStream(&quot;employees.dat&quot;); ObjectInputStream ois = new ObjectInputStream(fis); // 读取一个对象 ArrayList&lt;Employee&gt; list = (ArrayList&lt;Employee&gt;) ois.readObject(); // 释放资源 ois.close(); fis.close(); System.out.println(list); &#125;&#125; 7.5 反序列化失败问题问题1： 对于JVM可以反序列化对象，它必须是能够找到class文件的类。如果找不到该类的class文件，则抛出一个 ClassNotFoundException 异常。 问题2： 当JVM反序列化对象时，能找到class文件，但是class文件在序列化对象之后发生了修改，那么反序列化操作也会失败，抛出一个InvalidClassException异常。发生这个异常的原因如下： 该类的序列版本号与从流中读取的类描述符的版本号不匹配 该类包含未知数据类型 解决办法： Serializable 接口给需要序列化的类，提供了一个序列版本号：serialVersionUID 。凡是实现 Serializable接口的类都应该有一个表示序列化版本标识符的静态变量： 1static final long serialVersionUID = 234242343243L; //它的值由程序员随意指定即可。 serialVersionUID用来表明类的不同版本间的兼容性。简单来说，Java的序列化机制是通过在运行时判断类的serialVersionUID来验证版本一致性的。在进行反序列化时，JVM会把传来的字节流中的serialVersionUID与本地相应实体类的serialVersionUID进行比较，如果相同就认为是一致的，可以进行反序列化，否则就会出现序列化版本不一致的异常(InvalidCastException)。 如果类没有显示定义这个静态常量，它的值是Java运行时环境根据类的内部细节自动生成的。若类的实例变量做了修改，serialVersionUID 可能发生变化。因此，建议显式声明。 如果声明了serialVersionUID，即使在序列化完成之后修改了类导致类重新编译，则原来的数据也能正常反序列化，只是新增的字段值是默认值而已。 123456789package com.atguigu.object;import java.io.Serializable;public class Employee implements Serializable &#123; private static final long serialVersionUID = 1324234L; //增加serialVersionUID //其它结构：略&#125; 7.6 面试题&amp;练习面试题：谈谈你对java.io.Serializable接口的理解，我们知道它用于序列化，是空方法接口，还有其它认识吗？ 1234实现了Serializable接口的对象，可将它们转换成一系列字节，并可在以后完全恢复回原来的样子。这一过程亦可通过网络进行。这意味着序列化机制能自动补偿操作系统间的差异。换句话说，可以先在Windows机器上创建一个对象，对其序列化，然后通过网络发给一台Unix机器，然后在那里准确无误地重新“装配”。不必关心数据在不同机器上如何表示，也不必关心字节的顺序或者其他任何细节。 由于大部分作为参数的类如String、Integer等都实现了java.io.Serializable的接口，也可以利用多态的性质，作为参数使接口更灵活。 练习： 需求说明： 网上购物时某用户填写订单，订单内容为产品列表，保存在“save.bin”中。 运行时，如果不存在“save.bin”，则进行新订单录入，如果存在，则显示并计算客户所需付款。 分析： 编写Save()方法保存对象到“save.bin” 编写Load()方法获得对象，计算客户所需付款 8. 其他流的使用8.1 标准输入、输出流 System.in和System.out分别代表了系统标准的输入和输出设备 默认输入设备是：键盘，输出设备是：显示器 System.in的类型是InputStream System.out的类型是PrintStream，其是OutputStream的子类FilterOutputStream 的子类 重定向：通过System类的setIn，setOut方法对默认设备进行改变。 public static void setIn(InputStream in) public static void setOut(PrintStream out) 举例： 从键盘输入字符串，要求将读取到的整行字符串转成大写输出。然后继续进行输入操作，直至当输入“e”或者“exit”时，退出程序。 1234567891011121314151617181920212223242526System.out.println(&quot;请输入信息(退出输入e或exit):&quot;);// 把&quot;标准&quot;输入流(键盘输入)这个字节流包装成字符流,再包装成缓冲流BufferedReader br = new BufferedReader(new InputStreamReader(System.in));String s = null;try &#123; while ((s = br.readLine()) != null) &#123; // 读取用户输入的一行数据 --&gt; 阻塞程序 if (&quot;e&quot;.equalsIgnoreCase(s) || &quot;exit&quot;.equalsIgnoreCase(s)) &#123; System.out.println(&quot;安全退出!!&quot;); break; &#125; // 将读取到的整行字符串转成大写输出 System.out.println(&quot;--&gt;:&quot; + s.toUpperCase()); System.out.println(&quot;继续输入信息&quot;); &#125;&#125; catch (IOException e) &#123; e.printStackTrace();&#125; finally &#123; try &#123; if (br != null) &#123; br.close(); // 关闭过滤流时,会自动关闭它包装的底层节点流 &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;&#125; 拓展： System类中有三个常量对象：System.out、System.in、System.err 查看System类中这三个常量对象的声明： 123public final static InputStream in = null;public final static PrintStream out = null;public final static PrintStream err = null; 奇怪的是， 这三个常量对象有final声明，但是却初始化为null。final声明的常量一旦赋值就不能修改，那么null不会空指针异常吗？ 这三个常量对象为什么要小写？final声明的常量按照命名规范不是应该大写吗？ 这三个常量的对象有set方法？final声明的常量不是不能修改值吗？set方法是如何修改它们的值的？ 1final声明的常量，表示在Java的语法体系中它们的值是不能修改的，而这三个常量对象的值是由C/C++等系统函数进行初始化和修改值的，所以它们故意没有用大写，也有set方法。 123456789101112131415161718192021public static void setOut(PrintStream out) &#123; checkIO(); setOut0(out);&#125;public static void setErr(PrintStream err) &#123; checkIO(); setErr0(err);&#125;public static void setIn(InputStream in) &#123; checkIO(); setIn0(in);&#125;private static void checkIO() &#123; SecurityManager sm = getSecurityManager(); if (sm != null) &#123; sm.checkPermission(new RuntimePermission(&quot;setIO&quot;)); &#125;&#125;private static native void setIn0(InputStream in);private static native void setOut0(PrintStream out);private static native void setErr0(PrintStream err); 练习： Create a program named MyInput.java: Contain the methods for reading int, double, float, boolean, short, byte and String values from the keyboard. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657package com.atguigu.java;// MyInput.java: Contain the methods for reading int, double, float, boolean, short, byte and// string values from the keyboardimport java.io.*;public class MyInput &#123; // Read a string from the keyboard public static String readString() &#123; BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); // Declare and initialize the string String string = &quot;&quot;; // Get the string from the keyboard try &#123; string = br.readLine(); &#125; catch (IOException ex) &#123; System.out.println(ex); &#125; // Return the string obtained from the keyboard return string; &#125; // Read an int value from the keyboard public static int readInt() &#123; return Integer.parseInt(readString()); &#125; // Read a double value from the keyboard public static double readDouble() &#123; return Double.parseDouble(readString()); &#125; // Read a byte value from the keyboard public static double readByte() &#123; return Byte.parseByte(readString()); &#125; // Read a short value from the keyboard public static double readShort() &#123; return Short.parseShort(readString()); &#125; // Read a long value from the keyboard public static double readLong() &#123; return Long.parseLong(readString()); &#125; // Read a float value from the keyboard public static double readFloat() &#123; return Float.parseFloat(readString()); &#125;&#125; 8.2 打印流 实现将基本数据类型的数据格式转化为字符串输出。 打印流：PrintStream和PrintWriter 提供了一系列重载的print()和println()方法，用于多种数据类型的输出 PrintStream和PrintWriter的输出不会抛出IOException异常 PrintStream和PrintWriter有自动flush功能 PrintStream 打印的所有字符都使用平台的默认字符编码转换为字节。在需要写入字符而不是写入字节的情况下，应该使用 PrintWriter 类。 System.out返回的是PrintStream的实例 构造器 PrintStream(File file) ：创建具有指定文件且不带自动行刷新的新打印流。 PrintStream(File file, String csn)：创建具有指定文件名称和字符集且不带自动行刷新的新打印流。 PrintStream(OutputStream out) ：创建新的打印流。 PrintStream(OutputStream out, boolean autoFlush)：创建新的打印流。 autoFlush如果为 true，则每当写入 byte 数组、调用其中一个 println 方法或写入换行符或字节 (‘\\n’) 时都会刷新输出缓冲区。 PrintStream(OutputStream out, boolean autoFlush, String encoding) ：创建新的打印流。 PrintStream(String fileName)：创建具有指定文件名称且不带自动行刷新的新打印流。 PrintStream(String fileName, String csn) ：创建具有指定文件名称和字符集且不带自动行刷新的新打印流。 代码举例1 123456789101112131415package com.atguigu.systemio;import java.io.FileNotFoundException;import java.io.PrintStream;public class TestPrintStream &#123; public static void main(String[] args) throws FileNotFoundException &#123; PrintStream ps = new PrintStream(&quot;io.txt&quot;); ps.println(&quot;hello&quot;); ps.println(1); ps.println(1.5); ps.close(); &#125;&#125; 代码举例2 12345678910111213141516171819202122PrintStream ps = null;try &#123; FileOutputStream fos = new FileOutputStream(new File(&quot;D:\\\\IO\\\\text.txt&quot;)); // 创建打印输出流,设置为自动刷新模式(写入换行符或字节 &#x27;\\n&#x27; 时都会刷新输出缓冲区) ps = new PrintStream(fos, true); if (ps != null) &#123;// 把标准输出流(控制台输出)改成文件 System.setOut(ps); &#125; for (int i = 0; i &lt;= 255; i++) &#123; // 输出ASCII字符 System.out.print((char) i); if (i % 50 == 0) &#123; // 每50个数据一行 System.out.println(); // 换行 &#125; &#125;&#125; catch (FileNotFoundException e) &#123; e.printStackTrace();&#125; finally &#123; if (ps != null) &#123; ps.close(); &#125;&#125; 代码举例3：自定义一个日志工具 123456789101112131415161718192021222324/*日志工具 */public class Logger &#123; /* 记录日志的方法。 */ public static void log(String msg) &#123; try &#123; // 指向一个日志文件 PrintStream out = new PrintStream(new FileOutputStream(&quot;log.txt&quot;, true)); // 改变输出方向 System.setOut(out); // 日期当前时间 Date nowTime = new Date(); SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss SSS&quot;); String strTime = sdf.format(nowTime); System.out.println(strTime + &quot;: &quot; + msg); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 12345678public class LogTest &#123; public static void main(String[] args) &#123; //测试工具类是否好用 Logger.log(&quot;调用了System类的gc()方法，建议启动垃圾回收&quot;); Logger.log(&quot;调用了TeamView的addMember()方法&quot;); Logger.log(&quot;用户尝试进行登录，验证失败&quot;); &#125;&#125; 8.3 Scanner类构造方法 Scanner(File source) ：构造一个新的 Scanner，它生成的值是从指定文件扫描的。 Scanner(File source, String charsetName) ：构造一个新的 Scanner，它生成的值是从指定文件扫描的。 Scanner(InputStream source) ：构造一个新的 Scanner，它生成的值是从指定的输入流扫描的。 Scanner(InputStream source, String charsetName) ：构造一个新的 Scanner，它生成的值是从指定的输入流扫描的。 常用方法： boolean hasNextXxx()： 如果通过使用nextXxx()方法，此扫描器输入信息中的下一个标记可以解释为默认基数中的一个 Xxx 值，则返回 true。 Xxx nextXxx()： 将输入信息的下一个标记扫描为一个Xxx 1234567891011121314151617181920212223242526272829303132333435package com.atguigu.systemio;import org.junit.Test;import java.io.*;import java.util.Scanner;public class TestScanner &#123; @Test public void test01() throws IOException &#123; Scanner input = new Scanner(System.in); PrintStream ps = new PrintStream(&quot;1.txt&quot;); while(true)&#123; System.out.print(&quot;请输入一个单词：&quot;); String str = input.nextLine(); if(&quot;stop&quot;.equals(str))&#123; break; &#125; ps.println(str); &#125; input.close(); ps.close(); &#125; @Test public void test2() throws IOException &#123; Scanner input = new Scanner(new FileInputStream(&quot;1.txt&quot;)); while(input.hasNextLine())&#123; String str = input.nextLine(); System.out.println(str); &#125; input.close(); &#125;&#125; 9. apache-common包的使用9.1 介绍IO技术开发中，代码量很大，而且代码的重复率较高，为此Apache软件基金会，开发了IO技术的工具类commonsIO，大大简化了IO开发。 Apahce软件基金会属于第三方，（Oracle公司第一方，我们自己第二方，其他都是第三方）我们要使用第三方开发好的工具，需要添加jar包。 9.2 导包及举例 在导入commons-io-2.5.jar包之后，内部的API都可以使用。 IOUtils类的使用 12- 静态方法：IOUtils.copy(InputStream in,OutputStream out)传递字节流，实现文件复制。- 静态方法：IOUtils.closeQuietly(任意流对象)悄悄的释放资源，自动处理close()方法抛出的异常。 12345678910111213141516public class Test01 &#123; public static void main(String[] args)throws Exception &#123; //- 静态方法：IOUtils.copy(InputStream in,OutputStream out)传递字节流，实现文件复制。 IOUtils.copy(new FileInputStream(&quot;E:\\\\Idea\\\\io\\\\1.jpg&quot;),new FileOutputStream(&quot;E:\\\\Idea\\\\io\\\\file\\\\柳岩.jpg&quot;)); //- 静态方法：IOUtils.closeQuietly(任意流对象)悄悄的释放资源，自动处理close()方法抛出的异常。 /* FileWriter fw = null; try &#123; fw = new FileWriter(&quot;day21\\\\io\\\\writer.txt&quot;); fw.write(&quot;hahah&quot;); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;finally &#123; IOUtils.closeQuietly(fw); &#125;*/ &#125;&#125; FileUtils类的使用 12345678- 静态方法：void copyDirectoryToDirectory(File src,File dest)：整个目录的复制，自动进行递归遍历 参数: src:要复制的文件夹路径 dest:要将文件夹粘贴到哪里去 - 静态方法：void writeStringToFile(File file,String content)：将内容content写入到file中- 静态方法：String readFileToString(File file)：读取文件内容，并返回一个String- 静态方法：void copyFile(File srcFile,File destFile)：文件复制 123456789101112131415161718192021public class Test02 &#123; public static void main(String[] args) &#123; try &#123; //- 静态方法：void copyDirectoryToDirectory(File src,File dest); FileUtils.copyDirectoryToDirectory(new File(&quot;E:\\\\Idea\\\\io\\\\aa&quot;),new File(&quot;E:\\\\Idea\\\\io\\\\file&quot;)); //- 静态方法：writeStringToFile(File file,String str) FileUtils.writeStringToFile(new File(&quot;day21\\\\io\\\\commons.txt&quot;),&quot;柳岩你好&quot;); //- 静态方法：String readFileToString(File file) String s = FileUtils.readFileToString(new File(&quot;day21\\\\io\\\\commons.txt&quot;)); System.out.println(s); //- 静态方法：void copyFile(File srcFile,File destFile) FileUtils.copyFile(new File(&quot;io\\\\yangm.png&quot;),new File(&quot;io\\\\yangm2.png&quot;)); System.out.println(&quot;复制成功&quot;); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125;","categories":[],"tags":[]},{"title":"","slug":"Java/尚硅谷_第14章_数据结构与集合源码/尚硅谷_宋红康_第14章_数据结构与集合源码","date":"2023-10-07T11:18:32.931Z","updated":"2022-12-27T10:15:18.675Z","comments":true,"path":"2023/10/07/Java/尚硅谷_第14章_数据结构与集合源码/尚硅谷_宋红康_第14章_数据结构与集合源码/","link":"","permalink":"http://example.com/2023/10/07/Java/%E5%B0%9A%E7%A1%85%E8%B0%B7_%E7%AC%AC14%E7%AB%A0_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81/%E5%B0%9A%E7%A1%85%E8%B0%B7_%E5%AE%8B%E7%BA%A2%E5%BA%B7_%E7%AC%AC14%E7%AB%A0_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81/","excerpt":"","text":"第14章_数据结构与集合源码讲师：尚硅谷-宋红康（江湖人称：康师傅） 官网：http://www.atguigu.com 本章专题与脉络 1. 数据结构剖析我们举一个形象的例子来理解数据结构的作用： 战场：程序运行所需的软件、硬件环境 敌人：项目或模块的功能需求 指挥官：编写程序的程序员 士兵和装备：一行一行的代码 战术和策略：数据结构 上图：没有战术，打仗事倍功半 上图：有战术，打仗事半功倍 总结：简单来说，数据结构，就是一种程序设计优化的方法论，研究数据的逻辑结构和物理结构以及它们之间相互关系，并对这种结构定义相应的运算，目的是加快程序的执行速度、减少内存占用的空间。 具体研究对象如下： 1.1 研究对象一：数据间逻辑关系数据的逻辑结构指反映数据元素之间的逻辑关系，而与数据的存储无关，是独立于计算机的。 集合结构：数据结构中的元素之间除了“同属一个集合” 的相互关系外，别无其他关系。集合元素之间没有逻辑关系。 线性结构：数据结构中的元素存在一对一的相互关系。比如：排队。结构中必须存在唯一的首元素和唯一的尾元素。体现为：一维数组、链表、栈、队列 树形结构：数据结构中的元素存在一对多的相互关系。比如：家谱、文件系统、组织架构 图形结构：数据结构中的元素存在多对多的相互关系。比如：全国铁路网、地铁图 1.2 研究对象二：数据的存储结构（或物理结构）数据的物理结构&#x2F;存储结构：包括数据元素的表示和关系的表示。数据的存储结构是逻辑结构用计算机语言的实现，它依赖于计算机语言。 结构1：顺序结构 顺序结构就是使用一组连续的存储单元依次存储逻辑上相邻的各个元素。 优点： 只需要申请存放数据本身的内存空间即可，支持下标访问，也可以实现随机访问。 缺点： 必须静态分配连续空间，内存空间的利用率比较低。插入或删除可能需要移动大量元素，效率比较低 结构2：链式结构 不使用连续的存储空间存放结构的元素，而是为每一个元素构造一个节点。节点中除了存放数据本身以外，还需要存放指向下一个节点的指针。 优点：不采用连续的存储空间导致内存空间利用率比较高，克服顺序存储结构中预知元素个数的缺点。插入或删除元素时，不需要移动大量的元素。 缺点：需要额外的空间来表达数据之间的逻辑关系，不支持下标访问和随机访问。 结构3：索引结构 除建立存储节点信息外，还建立附加的索引表来记录每个元素节点的地址。索引表由若干索引项组成。索引项的一般形式是：（关键字，地址）。 优点：用节点的索引号来确定结点存储地址，检索速度快。 缺点： 增加了附加的索引表，会占用较多的存储空间。在增加和删除数据时要修改索引表，因而会花费较多的时间。 结构4：散列结构 根据元素的关键字直接计算出该元素的存储地址，又称为Hash存储。 优点：检索、增加和删除结点的操作都很快。 缺点：不支持排序，一般比用线性表存储需要更多的空间，并且记录的关键字不能重复。 1.3 研究对象三：运算结构施加在数据上的运算包括运算的定义和实现。运算的定义是针对逻辑结构的，指出运算的功能；运算的实现是针对存储结构的，指出运算的具体操作步骤。 分配资源，建立结构，释放资源 插入和删除 获取和遍历 修改和排序 1.4 小结 2. 一维数组2.1 数组的特点 在Java中，数组是用来存放同一种数据类型的集合，注意只能存放同一种数据类型。 12345//只声明了类型和长度数据类型[] 数组名称 = new 数据类型[数组长度];//声明了类型，初始化赋值，大小由元素个数决定数据类型[] 数组名称 = &#123;数组元素1，数组元素2，......&#125; 例如：整型数组 例如：对象数组 物理结构特点： 申请内存：一次申请一大段连续的空间，一旦申请到了，内存就固定了。 不能动态扩展(初始化给大了，浪费；给小了，不够用)，插入快，删除和查找慢。 存储特点：所有数据存储在这个连续的空间中，数组中的每一个元素都是一个具体的数据（或对象），所有数据都紧密排布，不能有间隔。 具体的，如下图： 2.2 自定义数组123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109package com.atguigu01.overview.array;/** * @author 尚硅谷-宋红康 * @create 14:39 */class Array &#123; private Object[] elementData; private int size; public Array(int capacity)&#123; elementData = new Object[capacity]; &#125; /** * 添加元素 * @param value */ public void add(Object value)&#123; if(size &gt;= elementData.length)&#123; throw new RuntimeException(&quot;数组已满，不可添加&quot;); &#125; elementData[size] = value; size++; &#125; /** * 查询元素value在数组中的索引位置 * @param value * @return */ public int find(Object value)&#123; for (int i = 0; i &lt; size; i++) &#123; if(elementData[i].equals(value))&#123; return i; &#125; &#125; return -1; &#125; /** * 从当前数组中移除首次出现的value元素 * @param value * @return */ public boolean delete(Object value)&#123; int index = find(value); if(index == -1)&#123; return false; &#125; for(int i = index;i &lt; size - 1;i++)&#123; elementData[i] = elementData[i + 1]; &#125; elementData[size - 1] = null; size--; return true; &#125; /** * 将数组中首次出现的oldValue替换为newValue * @param oldValue * @param newValue * @return */ public boolean update(Object oldValue,Object newValue)&#123; int index = find(oldValue); if(index == -1)&#123; return false; &#125; elementData[index] = newValue; return true; &#125; /** * 遍历数组中所有数据 */ public void print()&#123; System.out.print(&quot;&#123;&quot;); for (int i = 0; i &lt; size; i++) &#123; if(i == size - 1)&#123; System.out.println(elementData[i] + &quot;&#125;&quot;); break; &#125; System.out.print(elementData[i] + &quot;,&quot;); &#125; &#125;&#125;//测试类public class ArrayTest &#123; public static void main(String[] args) &#123; Array arr = new Array(10); arr.add(123); arr.add(&quot;AA&quot;); arr.add(345); arr.add(345); arr.add(&quot;BB&quot;); arr.delete(345); arr.update(345,444); arr.print(); &#125;&#125; 3. 链表3.1 链表的特点 逻辑结构：线性结构 物理结构：不要求连续的存储空间 存储特点：链表由一系列结点node（链表中每一个元素称为结点）组成，结点可以在代码执行过程中动态创建。每个结点包括两个部分：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域。 常见的链表结构有如下的形式： 3.2 自定义链表3.2.1 自定义单向链表 12345678910111213141516171819202122232425/*单链表中的节点。节点是单向链表中基本的单元。每一个节点Node都有两个属性： 一个属性：是存储的数据。 另一个属性：是下一个节点的内存地址。 */public class Node &#123; // 存储的数据 Object data; // 下一个节点的内存地址 Node next; public Node()&#123; &#125; public Node(Object data, Node next)&#123; this.data = data; this.next = next; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263/*链表类(单向链表) */public class Link&lt;E&gt; &#123; // 头节点 Node header; private int size = 0; public int size()&#123; return size; &#125; // 向链表中添加元素的方法（向末尾添加） public void add(E data)&#123; //public void add(Object data)&#123; // 创建一个新的节点对象 // 让之前单链表的末尾节点next指向新节点对象。 // 有可能这个元素是第一个，也可能是第二个，也可能是第三个。 if(header == null)&#123; // 说明还没有节点。 // new一个新的节点对象，作为头节点对象。 // 这个时候的头节点既是一个头节点，又是一个末尾节点。 header = new Node(data, null); &#125;else &#123; // 说明头不是空！ // 头节点已经存在了！ // 找出当前末尾节点，让当前末尾节点的next是新节点。 Node currentLastNode = findLast(header); currentLastNode.next = new Node(data, null); &#125; size++; &#125; /** * 专门查找末尾节点的方法。 */ private Node findLast(Node node) &#123; if(node.next == null) &#123; // 如果一个节点的next是null // 说明这个节点就是末尾节点。 return node; &#125; // 程序能够到这里说明：node不是末尾节点。 return findLast(node.next); // 递归算法！ &#125; /*// 删除链表中某个数据的方法 public void remove(Object obj)&#123; //略 &#125; // 修改链表中某个数据的方法 public void modify(Object newObj)&#123; //略 &#125; // 查找链表中某个元素的方法。 public int find(Object obj)&#123; //略 &#125;*/&#125; 3.2.2 自定义双向链表 1234567891011121314/*双向链表中的节点。 */public class Node&lt;E&gt; &#123; Node prev; E data; Node next; Node(Node prev, E data, Node next) &#123; this.prev = prev; this.data = data; this.next = next; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104/** * 链表类(双向链表) * @author 尚硅谷-宋红康 * @create 15:05 */public class MyLinkedList&lt;E&gt; implements Iterable&lt;E&gt;&#123; private Node first; //链表的首元素 private Node last; //链表的尾元素 private int total; public void add(E e)&#123; Node newNode = new Node(last, e, null); if(first == null)&#123; first = newNode; &#125;else&#123; last.next = newNode; &#125; last = newNode; total++; &#125; public int size()&#123; return total; &#125; public void delete(Object obj)&#123; Node find = findNode(obj); if(find != null)&#123; if(find.prev != null)&#123; find.prev.next = find.next; &#125;else&#123; first = find.next; &#125; if(find.next != null)&#123; find.next.prev = find.prev; &#125;else&#123; last = find.prev; &#125; find.prev = null; find.next = null; find.data = null; total--; &#125; &#125; private Node findNode(Object obj)&#123; Node node = first; Node find = null; if(obj == null)&#123; while(node != null)&#123; if(node.data == null)&#123; find = node; break; &#125; node = node.next; &#125; &#125;else&#123; while(node != null)&#123; if(obj.equals(node.data))&#123; find = node; break; &#125; node = node.next; &#125; &#125; return find; &#125; public boolean contains(Object obj)&#123; return findNode(obj) != null; &#125; public void update(E old, E value)&#123; Node find = findNode(old); if(find != null)&#123; find.data = value; &#125; &#125; @Override public Iterator&lt;E&gt; iterator() &#123; return new Itr(); &#125; private class Itr implements Iterator&lt;E&gt;&#123; private Node&lt;E&gt; node = first; @Override public boolean hasNext() &#123; return node!=null; &#125; @Override public E next() &#123; E value = node.data; node = node.next; return value; &#125; &#125;&#125; 自定义双链表测试： 1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.atguigu.list;public class MyLinkedListTest &#123; public static void main(String[] args) &#123; MyLinkedList&lt;String&gt; my = new MyLinkedList&lt;&gt;(); my.add(&quot;hello&quot;); my.add(&quot;world&quot;); my.add(null); my.add(null); my.add(&quot;java&quot;); my.add(&quot;java&quot;); my.add(&quot;atguigu&quot;); System.out.println(&quot;一共有：&quot; + my.size()); System.out.println(&quot;所有元素：&quot;); for (String s : my) &#123; System.out.println(s); &#125; System.out.println(&quot;-------------------------------------&quot;); System.out.println(&quot;查找java,null,haha的结果：&quot;); System.out.println(my.contains(&quot;java&quot;)); System.out.println(my.contains(null)); System.out.println(my.contains(&quot;haha&quot;)); System.out.println(&quot;-------------------------------------&quot;); System.out.println(&quot;替换java,null后：&quot;); my.update(&quot;java&quot;,&quot;JAVA&quot;); my.update(null,&quot;songhk&quot;); System.out.println(&quot;所有元素：&quot;); for (String s : my) &#123; System.out.println(s); &#125; System.out.println(&quot;-------------------------------------&quot;); System.out.println(&quot;删除hello，JAVA,null，atguigu后：&quot;); my.delete(&quot;hello&quot;); my.delete(&quot;JAVA&quot;); my.delete(null); my.delete(&quot;atguigu&quot;); System.out.println(&quot;所有元素：&quot;); for (String s : my) &#123; System.out.println(s); &#125; &#125;&#125; 4. 栈4.1 栈的特点 栈（Stack）又称为堆栈或堆叠，是限制仅在表的一端进行插入和删除运算的线性表。 栈按照先进后出(FILO,first in last out)的原则存储数据，先进入的数据被压入栈底，最后的数据在栈顶。每次删除（退栈）的总是删除当前栈中最后插入（进栈）的元素，而最先插入的是被放在栈的底部，要到最后才能删除。 核心类库中的栈结构有Stack和LinkedList。 Stack就是顺序栈，它是Vector的子类。 LinkedList是链式栈。 体现栈结构的操作方法： peek()方法：查看栈顶元素，不弹出 pop()方法：弹出栈 push(E e)方法：压入栈 时间复杂度: 索引: O(n) 搜索: O(n) 插入: O(1) 移除: O(1) 图示： 4.2 Stack使用举例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960/** * @author 尚硅谷-宋红康 * @create 15:44 */public class TestStack &#123; /* * 测试Stack * */ @Test public void test1()&#123; Stack&lt;Integer&gt; list = new Stack&lt;&gt;(); list.push(1); list.push(2); list.push(3); System.out.println(&quot;list = &quot; + list); System.out.println(&quot;list.peek()=&quot; + list.peek()); System.out.println(&quot;list.peek()=&quot; + list.peek()); System.out.println(&quot;list.peek()=&quot; + list.peek());/* System.out.println(&quot;list.pop() =&quot; + list.pop()); System.out.println(&quot;list.pop() =&quot; + list.pop()); System.out.println(&quot;list.pop() =&quot; + list.pop()); System.out.println(&quot;list.pop() =&quot; + list.pop());//java.util.NoSuchElementException*/ while(!list.empty())&#123; System.out.println(&quot;list.pop() =&quot; + list.pop()); &#125; &#125; /* * 测试LinkedList * */ @Test public void test2()&#123; LinkedList&lt;Integer&gt; list = new LinkedList&lt;&gt;(); list.push(1); list.push(2); list.push(3); System.out.println(&quot;list = &quot; + list); System.out.println(&quot;list.peek()=&quot; + list.peek()); System.out.println(&quot;list.peek()=&quot; + list.peek()); System.out.println(&quot;list.peek()=&quot; + list.peek());/* System.out.println(&quot;list.pop() =&quot; + list.pop()); System.out.println(&quot;list.pop() =&quot; + list.pop()); System.out.println(&quot;list.pop() =&quot; + list.pop()); System.out.println(&quot;list.pop() =&quot; + list.pop());//java.util.NoSuchElementException*/ while(!list.isEmpty())&#123; System.out.println(&quot;list.pop() =&quot; + list.pop()); &#125; &#125;&#125; 4.3 自定义栈123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081public class MyStack &#123; // 向栈当中存储元素，我们这里使用一维数组模拟。存到栈中，就表示存储到数组中。 // 为什么选择Object类型数组？因为这个栈可以存储java中的任何引用类型的数据 private Object[] elements; // 栈帧，永远指向栈顶部元素 // 那么这个默认初始值应该是多少。注意：最初的栈是空的，一个元素都没有。 //private int index = 0; // 如果index采用0，表示栈帧指向了顶部元素的上方。 //private int index = -1; // 如果index采用-1，表示栈帧指向了顶部元素。 private int index; /** * 无参数构造方法。默认初始化栈容量10. */ public MyStack() &#123; // 一维数组动态初始化 // 默认初始化容量是10. this.elements = new Object[10]; // 给index初始化 this.index = -1; &#125; /** * 压栈的方法 * @param obj 被压入的元素 */ public void push(Object obj) throws Exception &#123; if(index &gt;= elements.length - 1)&#123; //方式1： //System.out.println(&quot;压栈失败，栈已满！&quot;); //return; //方式2： throw new Exception(&quot;压栈失败，栈已满！&quot;); &#125; // 程序能够走到这里，说明栈没满 // 向栈中加1个元素，栈帧向上移动一个位置。 index++; elements[index] = obj; System.out.println(&quot;压栈&quot; + obj + &quot;元素成功，栈帧指向&quot; + index); &#125; /** * 弹栈的方法，从数组中往外取元素。每取出一个元素，栈帧向下移动一位。 * @return */ public Object pop() throws Exception &#123; if (index &lt; 0) &#123; //方式1： //System.out.println(&quot;弹栈失败，栈已空！&quot;); //return; //方式2： throw new Exception(&quot;弹栈失败，栈已空！&quot;); &#125; // 程序能够执行到此处说明栈没有空。 Object obj = elements[index]; System.out.print(&quot;弹栈&quot; + obj + &quot;元素成功，&quot;); elements[index] = null; // 栈帧向下移动一位。 index--; return obj; &#125; // set和get也许用不上，但是你必须写上，这是规矩。你使用IDEA生成就行了。 // 封装：第一步：属性私有化，第二步：对外提供set和get方法。 public Object[] getElements() &#123; return elements; &#125; public void setElements(Object[] elements) &#123; this.elements = elements; &#125; public int getIndex() &#123; return index; &#125; public void setIndex(int index) &#123; this.index = index; &#125;&#125; 5. 队列 队列（Queue）是只允许在一端进行插入，而在另一端进行删除的运算受限的线性表。 队列是逻辑结构，其物理结构可以是数组，也可以是链表。 队列的修改原则：队列的修改是依先进先出（FIFO）的原则进行的。新来的成员总是加入队尾（即不允许”加塞”），每次离开的成员总是队列头上的（不允许中途离队），即当前”最老的”成员离队。 图示： 6. 树与二叉树6.1 树的理解 专有名词解释： 结点：树中的数据元素都称之为结点 根节点：最上面的结点称之为根，一颗树只有一个根且由根发展而来，从另外一个角度来说，每个结点都可以认为是其子树的根 父节点：结点的上层结点，如图中，结点K的父节点是E、结点L的父节点是G 子节点：节点的下层结点，如图中，节点E的子节点是K节点、节点G的子节点是L节点 兄弟节点：具有相同父节点的结点称为兄弟节点，图中F、G、H互为兄弟节点 结点的度数：每个结点所拥有的子树的个数称之为结点的度，如结点B的度为3 树叶：度数为0的结点，也叫作终端结点，图中D、K、F、L、H、I、J都是树叶 非终端节点（或分支节点）：树叶以外的节点，或度数不为0的节点。图中根、A、B、C、E、G都是 树的深度（或高度）：树中结点的最大层次数，图中树的深度为4 结点的层数：从根节点到树中某结点所经路径上的分支树称为该结点的层数，根节点的层数规定为1，其余结点的层数等于其父亲结点的层数+1 同代：在同一棵树中具有相同层数的节点 6.2 二叉树的基本概念二叉树（Binary tree）是树形结构的一个重要类型。二叉树特点是每个结点最多只能有两棵子树，且有左右之分。许多实际问题抽象出来的数据结构往往是二叉树形式，二叉树的存储结构及其算法都较为简单，因此二叉树显得特别重要。 6.3 二叉树的遍历 前序遍历：中左右（根左右） 即先访问根结点，再前序遍历左子树，最后再前序遍历右子 树。前序遍历运算访问二叉树各结点是以根、左、右的顺序进行访问的。 中序遍历：左中右（左根右） 即先中前序遍历左子树，然后再访问根结点，最后再中序遍 历右子树。中序遍历运算访问二叉树各结点是以左、根、右的顺序进行访问的。 后序遍历：左右中（左右根） 即先后序遍历左子树，然后再后序遍历右子树，最后访问根 结点。后序遍历运算访问二叉树各结点是以左、右、根的顺序进行访问的。 前序遍历：ABDHIECFG 中序遍历：HDIBEAFCG 后序遍历：HIDEBFGCA 6.4 经典二叉树 1、满二叉树： 除最后一层无任何子节点外，每一层上的所有结点都有两个子结点的二叉树。 第n层的结点数是2的n-1次方，总的结点个数是2的n次方-1 2、完全二叉树： 叶结点只能出现在最底层的两层，且最底层叶结点均处于次底层叶结点的左侧。 3、二叉排序/查找/搜索树：即为BST (binary search&#x2F;sort tree)。满足如下性质：（1）若它的左子树不为空，则左子树上所有结点的值均小于它的根节点的值；（2）若它的右子树上所有结点的值均大于它的根节点的值；（3）它的左、右子树也分别为二叉排序&#x2F;查找&#x2F;搜索树。 对二叉查找树进行中序遍历，得到有序集合。便于检索。 4、平衡二叉树：（Self-balancing binary search tree，AVL）首先是二叉排序树，此外具有以下性质：（1）它是一棵空树或它的左右两个子树的高度差的绝对值不超过1（2）并且左右两个子树也都是一棵平衡二叉树（3）不要求非叶节点都有两个子结点 平衡二叉树的目的是为了减少二叉查找树的层次，提高查找速度。平衡二叉树的常用实现有红黑树、AVL、替罪羊树、Treap、伸展树等。 6、红黑树：即Red-Black Tree。红黑树的每个节点上都有存储位表示节点的颜色，可以是红(Red)或黑(Black)。 红黑树是一种自平衡二叉查找树，是在计算机科学中用到的一种数据结构，它是在 1972 年由 Rudolf Bayer 发明的。红黑树是复杂的，但它的操作有着良好的最坏情况运行时间，并且在实践中是高效的：它可以在 O(log n)时间内做查找，插入和删除， 这里的 n 是树中元素的数目。 红黑树的特性： 每个节点是红色或者黑色 根节点是黑色 每个叶子节点（NIL）是黑色。（注意：这里叶子节点，是指为空(NIL或NULL)的叶子节点） 每个红色节点的两个子节点都是黑色的。(从每个叶子到根的所有路径上不能有两个连续的红色节点) 从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点（确保没有一条路径会比其他路径长出2倍） 当我们插入或删除节点时，可能会破坏已有的红黑树，使得它不满足以上5个要求，那么此时就需要进行处理，使得它继续满足以上的5个要求： 1、recolor ：将某个节点变红或变黑 2、rotation ：将红黑树某些结点分支进行旋转（左旋或右旋） 红黑树可以通过红色节点和黑色节点尽可能的保证二叉树的平衡。主要是用它来存储有序的数据，它的时间复杂度是O(logN)，效率非常之高。 6.5 二叉树及其结点的表示普通二叉树： 12345678910111213141516171819public class BinaryTree&lt;E&gt;&#123; private TreeNode root; //二叉树的根结点 private int total;//结点总个数 private class TreeNode&#123; //至少有以下几个部分 TreeNode parent; TreeNode left; E data; TreeNode right; public TreeNode(TreeNode parent, TreeNode left, E data, TreeNode right) &#123; this.parent = parent; this.left = left; this.data = data; this.right = right; &#125; &#125;&#125; TreeMap红黑树： 1234567891011121314151617181920212223public class TreeMap&lt;K,V&gt; &#123; private transient Entry&lt;K,V&gt; root; private transient int size = 0; static final class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; K key; V value; Entry&lt;K,V&gt; left; Entry&lt;K,V&gt; right; Entry&lt;K,V&gt; parent; boolean color = BLACK; /** * Make a new cell with given key, value, and parent, and with * &#123;@code null&#125; child links, and BLACK color. */ Entry(K key, V value, Entry&lt;K,V&gt; parent) &#123; this.key = key; this.value = value; this.parent = parent; &#125; &#125;&#125; 7. List接口分析7.1 List接口特点 List集合所有的元素是以一种线性方式进行存储的，例如，存元素的顺序是11、22、33。那么集合中，元素的存储就是按照11、22、33的顺序完成的）。 它是一个元素存取有序的集合。即元素的存入顺序和取出顺序有保证。 它是一个带有索引的集合，通过索引就可以精确的操作集合中的元素（与数组的索引是一个道理）。 集合中可以有重复的元素，通过元素的equals方法，来比较是否为重复的元素。 注意： List集合关心元素是否有序，而不关心是否重复，请大家记住这个原则。例如“张三”可以领取两个号。 List接口的主要实现类 ArrayList：动态数组 Vector：动态数组 LinkedList：双向链表 Stack：栈 7.2 动态数组ArrayList与VectorJava的List接口的实现类中有两个动态数组的实现：ArrayList 和 Vector。 7.2.1 ArrayList与Vector的区别它们的底层物理结构都是数组，我们称为动态数组。 ArrayList是新版的动态数组，线程不安全，效率高，Vector是旧版的动态数组，线程安全，效率低。 动态数组的扩容机制不同，ArrayList默认扩容为原来的1.5倍，Vector默认扩容增加为原来的2倍。 数组的初始化容量，如果在构建ArrayList与Vector的集合对象时，没有显式指定初始化容量，那么Vector的内部数组的初始容量默认为10，而ArrayList在JDK 6.0 及之前的版本也是10，JDK8.0 之后的版本ArrayList初始化为长度为0的空数组，之后在添加第一个元素时，再创建长度为10的数组。原因： 用的时候，再创建数组，避免浪费。因为很多方法的返回值是ArrayList类型，需要返回一个ArrayList的对象，例如：后期从数据库查询对象的方法，返回值很多就是ArrayList。有可能你要查询的数据不存在，要么返回null，要么返回一个没有元素的ArrayList对象。 7.2.2 ArrayList部分源码分析JDK1.7.0_07中： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121//属性private transient Object[] elementData; //存储底层数组元素private int size; //记录数组中存储的元素的个数//构造器public ArrayList() &#123; this(10); //指定初始容量为10&#125;public ArrayList(int initialCapacity) &#123; super(); //检查初始容量的合法性 if (initialCapacity &lt; 0) throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+ initialCapacity); //数组初始化为长度为initialCapacity的数组 this.elementData = new Object[initialCapacity]; &#125;//方法：add()相关方法public boolean add(E e) &#123; ensureCapacityInternal(size + 1); //查看当前数组是否够多存一个元素 elementData[size++] = e; //将元素e添加到elementData数组中 return true;&#125;private void ensureCapacityInternal(int minCapacity) &#123; modCount++; // 如果if条件满足，则进行数组的扩容 if (minCapacity - elementData.length &gt; 0) grow(minCapacity);&#125;private void grow(int minCapacity) &#123; // overflow-conscious code int oldCapacity = elementData.length; //当前数组容量 int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); //新数组容量是旧数组容量的1.5倍 if (newCapacity - minCapacity &lt; 0) //判断旧数组的1.5倍是否够 newCapacity = minCapacity; //判断旧数组的1.5倍是否超过最大数组限制 if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); //复制一个新数组 elementData = Arrays.copyOf(elementData, newCapacity);&#125;//方法：remove()相关方法public E remove(int index) &#123; rangeCheck(index); //判断index是否在有效的范围内 modCount++; //修改次数加1 //取出[index]位置的元素，[index]位置的元素就是要被删除的元素，用于最后返回被删除的元素 E oldValue = elementData(index); int numMoved = size - index - 1; //确定要移动的次数 //如果需要移动元素，就用System.arraycopy移动元素 if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); //将elementData[size-1]位置置空，让GC回收空间，元素个数减少 elementData[--size] = null; return oldValue;&#125;private void rangeCheck(int index) &#123; if (index &gt;= size) //index不合法的情况 throw new IndexOutOfBoundsException(outOfBoundsMsg(index));&#125;E elementData(int index) &#123; //返回指定位置的元素 return (E) elementData[index];&#125;//方法：set()方法相关public E set(int index, E element) &#123; rangeCheck(index); //检验index是否合法 //取出[index]位置的元素，[index]位置的元素就是要被替换的元素，用于最后返回被替换的元素 E oldValue = elementData(index); //用element替换[index]位置的元素 elementData[index] = element; return oldValue;&#125;//方法：get()相关方法public E get(int index) &#123; rangeCheck(index); //检验index是否合法 return elementData(index); //返回[index]位置的元素&#125;//方法：indexOf()public int indexOf(Object o) &#123; //分为o是否为空两种情况 if (o == null) &#123; //从前往后找 for (int i = 0; i &lt; size; i++) if (elementData[i]==null) return i; &#125; else &#123; for (int i = 0; i &lt; size; i++) if (o.equals(elementData[i])) return i; &#125; return -1;&#125;//方法：lastIndexOf()public int lastIndexOf(Object o) &#123; //分为o是否为空两种情况 if (o == null) &#123; //从后往前找 for (int i = size-1; i &gt;= 0; i--) if (elementData[i]==null) return i; &#125; else &#123; for (int i = size-1; i &gt;= 0; i--) if (o.equals(elementData[i])) return i; &#125; return -1;&#125; jdk1.8.0_271中： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354//属性transient Object[] elementData;private int size;private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;//构造器public ArrayList() &#123; this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA; //初始化为空数组&#125;//方法:add()相关方法public boolean add(E e) &#123; //查看当前数组是否够多存一个元素 ensureCapacityInternal(size + 1); // Increments modCount!! //存入新元素到[size]位置，然后size自增1 elementData[size++] = e; return true;&#125;private void ensureCapacityInternal(int minCapacity) &#123; ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));&#125;private static int calculateCapacity(Object[] elementData, int minCapacity) &#123; //如果当前数组还是空数组 if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123; //那么minCapacity取DEFAULT_CAPACITY与minCapacity的最大值 return Math.max(DEFAULT_CAPACITY, minCapacity); &#125; return minCapacity;&#125;//查看是否需要扩容private void ensureExplicitCapacity(int minCapacity) &#123; modCount++; //修改次数加1 //如果需要的最小容量比当前数组的长度大，即当前数组不够存，就扩容 if (minCapacity - elementData.length &gt; 0) grow(minCapacity);&#125;private void grow(int minCapacity) &#123; // overflow-conscious code int oldCapacity = elementData.length; //当前数组容量 int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); //新数组容量是旧数组容量的1.5倍 //看旧数组的1.5倍是否够 if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; //看旧数组的1.5倍是否超过最大数组限制 if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); //复制一个新数组 elementData = Arrays.copyOf(elementData, newCapacity);&#125; 7.2.3 ArrayList相关方法图示 ArrayList采用数组作为底层实现 ArrayList自动扩容过程 ArrayList的add(E e)方法 ArrayList的add(int index,E e)方法 7.2.4 Vector部分源码分析jdk1.8.0_271中： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117//属性protected Object[] elementData;protected int elementCount;//构造器public Vector() &#123; this(10); //指定初始容量initialCapacity为10&#125;public Vector(int initialCapacity) &#123; this(initialCapacity, 0); //指定capacityIncrement增量为0&#125;public Vector(int initialCapacity, int capacityIncrement) &#123; super(); //判断了形参初始容量initialCapacity的合法性 if (initialCapacity &lt; 0) throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+ initialCapacity); //创建了一个Object[]类型的数组 this.elementData = new Object[initialCapacity]; //增量，默认是0，如果是0，后面就按照2倍增加，如果不是0，后面就按照你指定的增量进行增量 this.capacityIncrement = capacityIncrement;&#125;//方法：add()相关方法//synchronized意味着线程安全的 public synchronized boolean add(E e) &#123; modCount++; //看是否需要扩容 ensureCapacityHelper(elementCount + 1); //把新的元素存入[elementCount]，存入后，elementCount元素的个数增1 elementData[elementCount++] = e; return true;&#125;private void ensureCapacityHelper(int minCapacity) &#123; //看是否超过了当前数组的容量 if (minCapacity - elementData.length &gt; 0) grow(minCapacity); //扩容&#125;private void grow(int minCapacity) &#123; // overflow-conscious code int oldCapacity = elementData.length; //获取目前数组的长度 //如果capacityIncrement增量是0，新容量 = oldCapacity的2倍 //如果capacityIncrement增量是不是0，新容量 = oldCapacity + capacityIncrement增量; int newCapacity = oldCapacity + ((capacityIncrement &gt; 0) ? capacityIncrement : oldCapacity); //如果按照上面计算的新容量还不够，就按照你指定的需要的最小容量来扩容minCapacity if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; //如果新容量超过了最大数组限制，那么单独处理 if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); //把旧数组中的数据复制到新数组中，新数组的长度为newCapacity elementData = Arrays.copyOf(elementData, newCapacity);&#125;//方法：remove()相关方法public boolean remove(Object o) &#123; return removeElement(o);&#125;public synchronized boolean removeElement(Object obj) &#123; modCount++; //查找obj在当前Vector中的下标 int i = indexOf(obj); //如果i&gt;=0，说明存在，删除[i]位置的元素 if (i &gt;= 0) &#123; removeElementAt(i); return true; &#125; return false;&#125;//方法：indexOf()public int indexOf(Object o) &#123; return indexOf(o, 0);&#125;public synchronized int indexOf(Object o, int index) &#123; if (o == null) &#123;//要查找的元素是null值 for (int i = index ; i &lt; elementCount ; i++) if (elementData[i]==null)//如果是null值，用==null判断 return i; &#125; else &#123;//要查找的元素是非null值 for (int i = index ; i &lt; elementCount ; i++) if (o.equals(elementData[i]))//如果是非null值，用equals判断 return i; &#125; return -1;&#125;//方法：removeElementAt()public synchronized void removeElementAt(int index) &#123; modCount++; //判断下标的合法性 if (index &gt;= elementCount) &#123; throw new ArrayIndexOutOfBoundsException(index + &quot; &gt;= &quot; + elementCount); &#125; else if (index &lt; 0) &#123; throw new ArrayIndexOutOfBoundsException(index); &#125; //j是要移动的元素的个数 int j = elementCount - index - 1; //如果需要移动元素，就调用System.arraycopy进行移动 if (j &gt; 0) &#123; //把index+1位置以及后面的元素往前移动 //index+1的位置的元素移动到index位置，依次类推 //一共移动j个 System.arraycopy(elementData, index + 1, elementData, index, j); &#125; //元素的总个数减少 elementCount--; //将elementData[elementCount]这个位置置空，用来添加新元素，位置的元素等着被GC回收 elementData[elementCount] = null; /* to let gc do its work */&#125; 7.3 链表LinkedListJava中有双链表的实现：LinkedList，它是List接口的实现类。 LinkedList是一个双向链表，如图所示： 7.3.1 链表与动态数组的区别动态数组底层的物理结构是数组，因此根据索引访问的效率非常高。但是非末尾位置的插入和删除效率不高，因为涉及到移动元素。另外添加操作时涉及到扩容问题，就会增加时空消耗。 链表底层的物理结构是链表，因此根据索引访问的效率不高，即查找元素慢。但是插入和删除不需要移动元素，只需要修改前后元素的指向关系即可，所以插入、删除元素快。而且链表的添加不会涉及到扩容问题。 7.3.2 LinkedList源码分析jdk1.8.0_271中： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167//属性transient Node&lt;E&gt; first; //记录第一个结点的位置transient Node&lt;E&gt; last; //记录当前链表的尾元素transient int size = 0; //记录最后一个结点的位置//构造器public LinkedList() &#123;&#125;//方法：add()相关方法public boolean add(E e) &#123; linkLast(e); //默认把新元素链接到链表尾部 return true;&#125;void linkLast(E e) &#123; final Node&lt;E&gt; l = last; //用 l 记录原来的最后一个结点 //创建新结点 final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null); //现在的新结点是最后一个结点了 last = newNode; //如果l==null，说明原来的链表是空的 if (l == null) //那么新结点同时也是第一个结点 first = newNode; else //否则把新结点链接到原来的最后一个结点的next中 l.next = newNode; //元素个数增加 size++; //修改次数增加 modCount++;&#125;//其中，Node类定义如下private static class Node&lt;E&gt; &#123; E item; //元素数据 Node&lt;E&gt; next; //下一个结点 Node&lt;E&gt; prev; //前一个结点 Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123; this.item = element; this.next = next; this.prev = prev; &#125;&#125;//方法：获取get()相关方法public E get(int index) &#123; checkElementIndex(index); return node(index).item;&#125; //方法：插入add()相关方法public void add(int index, E element) &#123; checkPositionIndex(index);//检查index范围 if (index == size)//如果index==size，连接到当前链表的尾部 linkLast(element); else linkBefore(element, node(index));&#125;Node&lt;E&gt; node(int index) &#123; // assert isElementIndex(index); /* index &lt; (size &gt;&gt; 1)采用二分思想，先将index与长度size的一半比较，如果index&lt;size/2，就只从位置0 往后遍历到位置index处，而如果index&gt;size/2，就只从位置size往前遍历到位置index处。这样可以减少一部 分不必要的遍历。 */ //如果index&lt;size/2，就从前往后找目标结点 if (index &lt; (size &gt;&gt; 1)) &#123; Node&lt;E&gt; x = first; for (int i = 0; i &lt; index; i++) x = x.next; return x; &#125; else &#123;//否则从后往前找目标结点 Node&lt;E&gt; x = last; for (int i = size - 1; i &gt; index; i--) x = x.prev; return x; &#125;&#125;//把新结点插入到[index]位置的结点succ前面void linkBefore(E e, Node&lt;E&gt; succ) &#123;//succ是[index]位置对应的结点 // assert succ != null; final Node&lt;E&gt; pred = succ.prev; //[index]位置的前一个结点 //新结点的prev是原来[index]位置的前一个结点 //新结点的next是原来[index]位置的结点 final Node&lt;E&gt; newNode = new Node&lt;&gt;(pred, e, succ); //[index]位置对应的结点的prev指向新结点 succ.prev = newNode; //如果原来[index]位置对应的结点是第一个结点，那么现在新结点是第一个结点 if (pred == null) first = newNode; else pred.next = newNode;//原来[index]位置的前一个结点的next指向新结点 size++; modCount++;&#125;//方法：remove()相关方法public boolean remove(Object o) &#123; //分o是否为空两种情况 if (o == null) &#123; //找到o对应的结点x for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123; if (x.item == null) &#123; unlink(x);//删除x结点 return true; &#125; &#125; &#125; else &#123; //找到o对应的结点x for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123; if (o.equals(x.item)) &#123; unlink(x);//删除x结点 return true; &#125; &#125; &#125; return false;&#125;E unlink(Node&lt;E&gt; x) &#123;//x是要被删除的结点 // assert x != null; final E element = x.item;//被删除结点的数据 final Node&lt;E&gt; next = x.next;//被删除结点的下一个结点 final Node&lt;E&gt; prev = x.prev;//被删除结点的上一个结点 //如果被删除结点的前面没有结点，说明被删除结点是第一个结点 if (prev == null) &#123; //那么被删除结点的下一个结点变为第一个结点 first = next; &#125; else &#123;//被删除结点不是第一个结点 //被删除结点的上一个结点的next指向被删除结点的下一个结点 prev.next = next; //断开被删除结点与上一个结点的链接 x.prev = null;//使得GC回收 &#125; //如果被删除结点的后面没有结点，说明被删除结点是最后一个结点 if (next == null) &#123; //那么被删除结点的上一个结点变为最后一个结点 last = prev; &#125; else &#123;//被删除结点不是最后一个结点 //被删除结点的下一个结点的prev执行被删除结点的上一个结点 next.prev = prev; //断开被删除结点与下一个结点的连接 x.next = null;//使得GC回收 &#125; //把被删除结点的数据也置空，使得GC回收 x.item = null; //元素个数减少 size--; //修改次数增加 modCount++; //返回被删除结点的数据 return element;&#125;public E remove(int index) &#123; //index是要删除元素的索引位置 checkElementIndex(index); return unlink(node(index));&#125; 7.3.3 LinkedList相关方法图示 只有1个元素的LinkedList 包含4个元素的LinkedList add(E e)方法 add(int index,E e)方法 remove(Object obj)方法 remove(int index)方法 8. Map接口分析8.1 哈希表的物理结构HashMap和Hashtable底层都是哈希表（也称散列表），其中维护了一个长度为2的幂次方的Entry类型的数组table，数组的每一个索引位置被称为一个桶(bucket)，你添加的映射关系(key,value)最终都被封装为一个Map.Entry类型的对象，放到某个table[index]桶中。 使用数组的目的是查询和添加的效率高，可以根据索引直接定位到某个table[index]。 8.2 HashMap中数据添加过程8.2.1 JDK7中过程分析12// 在底层创建了长度为16的Entry[] table的数组HashMap map = new HashMap(); 12345678910111213141516171819202122232425map.put(key1,value1);/*分析过程如下：将(key1,value1)添加到当前hashmap的对象中。首先会调用key1所在类的hashCode()方法，计算key1的哈希值1，此哈希值1再经过某种运算(hash())，得到哈希值2。此哈希值2再经过某种运算(indexFor())，确定在底层table数组中的索引位置i。 （1）如果数组索引为i上的数据为空，则(key1,value1)直接添加成功 ------位置1 （2）如果数组索引为i上的数据不为空，有(key2,value2)，则需要进一步判断： 判断key1的哈希值2与key2的哈希值是否相同： （3） 如果哈希值不同，则(key1,value1)直接添加成功 ------位置2 如果哈希值相同，则需要继续调用key1所在类的equals()方法，将key2放入equals()形参进行判断 （4） equals方法返回false : 则(key1,value1)直接添加成功 ------位置3 equals方法返回true : 默认情况下，value1会覆盖value2。位置1：直接将(key1,value1)以Entry对象的方式存放到table数组索引i的位置。位置2、位置3：(key1,value1) 与现有的元素以链表的方式存储在table数组索引i的位置，新添加的元素指向旧添加的元素。...在不断的添加的情况下，满足如下条件的情况下，会进行扩容:if ((size &gt;= threshold) &amp;&amp; (null != table[bucketIndex])) :默认情况下，当要添加的元素个数超过12(即：数组的长度 * loadFactor得到的结果)时，就要考虑扩容。补充：jdk7源码中定义的：static class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt;*/ 123456789map.get(key1);/*① 计算key1的hash值，用这个方法hash(key1)② 找index = table.length-1 &amp; hash;③ 如果table[index]不为空，那么就挨个比较哪个Entry的key与它相同，就返回它的value*/ 12345678map.remove(key1);/*① 计算key1的hash值，用这个方法hash(key1)② 找index = table.length-1 &amp; hash;③ 如果table[index]不为空，那么就挨个比较哪个Entry的key与它相同，就删除它，把它前面的Entry的next的值修改为被删除Entry的next*/ 8.2.2 JDK8中过程分析下面说明是JDK8相较于JDK7的不同之处： 12345678910111213141516/*①使用HashMap()的构造器创建对象时，并没有在底层初始化长度为16的table数组。②jdk8中添加的key,value封装到了HashMap.Node类的对象中。而非jdk7中的HashMap.Entry。③jdk8中新增的元素所在的索引位置如果有其他元素。在经过一系列判断后，如果能添加，则是旧的元素指向新的元素。而非jdk7中的新的元素指向旧的元素。“七上八下”④jdk7时底层的数据结构是：数组+单向链表。 而jdk8时，底层的数据结构是：数组+单向链表+红黑树。红黑树出现的时机：当某个索引位置i上的链表的长度达到8，且数组的长度超过64时，此索引位置上的元素要从单向链表改为红黑树。如果索引i位置是红黑树的结构，当不断删除元素的情况下，当前索引i位置上的元素的个数低于6时，要从红黑树改为单向链表。*/ 8.3 HashMap源码剖析8.3.1 JDK1.7.0_07中源码 1、Entrykey-value被封装为HashMap.Entry类型，而这个类型实现了Map.Entry接口。 123456789101112131415161718192021public class HashMap&lt;K,V&gt;&#123; transient Entry&lt;K,V&gt;[] table; static class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; final K key; V value; Entry&lt;K,V&gt; next; int hash; /** * Creates new entry. */ Entry(int h, K k, V v, Entry&lt;K,V&gt; n) &#123; value = v; next = n; key = k; hash = h; &#125; //略 &#125;&#125; 2、属性123456789101112//table数组的默认初始化长度static final int DEFAULT_INITIAL_CAPACITY = 16;//哈希表transient Entry&lt;K,V&gt;[] table;//哈希表中key-value的个数transient int size;//临界值、阈值（扩容的临界值）int threshold;//加载因子final float loadFactor;//默认加载因子static final float DEFAULT_LOAD_FACTOR = 0.75f; 3、构造器12345public HashMap() &#123; //DEFAULT_INITIAL_CAPACITY：默认初始容量16 //DEFAULT_LOAD_FACTOR：默认加载因子0.75 this(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR);&#125; 12345678910111213141516171819202122232425public HashMap(int initialCapacity, float loadFactor) &#123; //校验initialCapacity合法性 if (initialCapacity &lt; 0) throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; + initialCapacity); //校验initialCapacity合法性 if (initialCapacity &gt; MAXIMUM_CAPACITY) initialCapacity = MAXIMUM_CAPACITY; //校验loadFactor合法性 if (loadFactor &lt;= 0 || Float.isNaN(loadFactor)) throw new IllegalArgumentException(&quot;Illegal load factor: &quot; + loadFactor); //计算得到table数组的长度（保证capacity是2的整次幂） int capacity = 1; while (capacity &lt; initialCapacity) capacity &lt;&lt;= 1; //加载因子，初始化为0.75 this.loadFactor = loadFactor; // threshold 初始为默认容量 threshold = (int)Math.min(capacity * loadFactor, MAXIMUM_CAPACITY + 1); //初始化table数组 table = new Entry[capacity]; useAltHashing = sun.misc.VM.isBooted() &amp;&amp; (capacity &gt;= Holder.ALTERNATIVE_HASHING_THRESHOLD); init();&#125; 4、put()方法1234567891011121314151617181920212223242526272829303132public V put(K key, V value) &#123; //如果key是null，单独处理，存储到table[0]中，如果有另一个key为null，value覆盖 if (key == null) return putForNullKey(value); //对key的hashCode进行干扰，算出一个hash值 /* hashCode值 xxxxxxxxxx table.length-1 000001111 hashCode值 xxxxxxxxxx 无符号右移几位和原来的hashCode值做^运算，使得hashCode高位二进制值参与计算， 也发挥作用，降低index冲突的概率。 */ int hash = hash(key); //计算新的映射关系应该存到table[i]位置， //i = hash &amp; table.length-1，可以保证i在[0,table.length-1]范围内 int i = indexFor(hash, table.length); //检查table[i]下面有没有key与我新的映射关系的key重复，如果重复替换value for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) &#123; Object k; if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123; V oldValue = e.value; e.value = value; e.recordAccess(this); return oldValue; &#125; &#125; modCount++; //添加新的映射关系 addEntry(hash, key, value, i); return null;&#125; 其中， 12345678910111213141516//如果key是null，直接存入[0]的位置private V putForNullKey(V value) &#123; //判断是否有重复的key，如果有重复的，就替换value for (Entry&lt;K,V&gt; e = table[0]; e != null; e = e.next) &#123; if (e.key == null) &#123; V oldValue = e.value; e.value = value; e.recordAccess(this); return oldValue; &#125; &#125; modCount++; //把新的映射关系存入[0]的位置，而且key的hash值用0表示 addEntry(0, null, value, 0); return null;&#125; 1234567891011121314151617final int hash(Object k) &#123; int h = 0; if (useAltHashing) &#123; if (k instanceof String) &#123; return sun.misc.Hashing.stringHash32((String) k); &#125; h = hashSeed; &#125; h ^= k.hashCode(); // This function ensures that hashCodes that differ only by // constant multiples at each bit position have a bounded // number of collisions (approximately 8 at default load factor). h ^= (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12); return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4);&#125; 123static int indexFor(int h, int length) &#123; return h &amp; (length-1);&#125; 12345678910111213void addEntry(int hash, K key, V value, int bucketIndex) &#123; //判断是否需要库容 //扩容：（1）size达到阈值（2）table[i]正好非空 if ((size &gt;= threshold) &amp;&amp; (null != table[bucketIndex])) &#123; //table扩容为原来的2倍，并且扩容后，会重新调整所有key-value的存储位置 resize(2 * table.length); //新的key-value的hash和index也会重新计算 hash = (null != key) ? hash(key) : 0; bucketIndex = indexFor(hash, table.length); &#125; //存入table中 createEntry(hash, key, value, bucketIndex);&#125; 1234567void createEntry(int hash, K key, V value, int bucketIndex) &#123; Entry&lt;K,V&gt; e = table[bucketIndex]; //原来table[i]下面的映射关系作为新的映射关系next table[bucketIndex] = new Entry&lt;&gt;(hash, key, value, e); //个数增加 size++; &#125; 8.3.2 JDK1.8.0_271中源码1、Nodekey-value被封装为HashMap.Node类型或HashMap.TreeNode类型，它俩都直接或间接的实现了Map.Entry接口。 存储到table数组的可能是Node结点对象，也可能是TreeNode结点对象，它们也是Map.Entry接口的实现类。即table[index]下的映射关系可能串起来一个链表或一棵红黑树。 123456789101112131415161718192021222324252627282930313233public class HashMap&lt;K,V&gt;&#123; transient Node&lt;K,V&gt;[] table; //Node类 static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; final int hash; final K key; V value; Node&lt;K,V&gt; next; Node(int hash, K key, V value, Node&lt;K,V&gt; next) &#123; this.hash = hash; this.key = key; this.value = value; this.next = next; &#125; // 其它结构：略 &#125; //TreeNode类 static final class TreeNode&lt;K,V&gt; extends LinkedHashMap.Entry&lt;K,V&gt; &#123; TreeNode&lt;K,V&gt; parent; TreeNode&lt;K,V&gt; left; TreeNode&lt;K,V&gt; right; TreeNode&lt;K,V&gt; prev; boolean red; //是红结点还是黑结点 TreeNode(int hash, K key, V val, Node&lt;K,V&gt; next) &#123; super(hash, key, val, next); &#125; &#125; //....&#125; 2、属性1234567891011121314static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // 默认的初始容量 16static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30; //最大容量 1 &lt;&lt; 30static final float DEFAULT_LOAD_FACTOR = 0.75f; //默认加载因子static final int TREEIFY_THRESHOLD = 8; //默认树化阈值8，当链表的长度达到这个值后，要考虑树化static final int UNTREEIFY_THRESHOLD = 6;//默认反树化阈值6，当树中结点的个数达到此阈值后，要考虑变为链表//当单个的链表的结点个数达到8，并且table的长度达到64，才会树化。//当单个的链表的结点个数达到8，但是table的长度未达到64，会先扩容static final int MIN_TREEIFY_CAPACITY = 64; //最小树化容量64transient Node&lt;K,V&gt;[] table; //数组transient int size; //记录有效映射关系的对数，也是Entry对象的个数int threshold; //阈值，当size达到阈值时，考虑扩容final float loadFactor; //加载因子，影响扩容的频率 3、构造器123public HashMap() &#123; this.loadFactor = DEFAULT_LOAD_FACTOR; // all other fields defaulted (其他字段都是默认值)&#125; 4、put()方法123public V put(K key, V value) &#123; return putVal(hash(key), key, value, false, true);&#125; 其中， 12345678910111213static final int hash(Object key) &#123; int h; //如果key是null，hash是0 //如果key非null，用key的hashCode值 与 key的hashCode值高16进行异或 // 即就是用key的hashCode值高16位与低16位进行了异或的干扰运算 /* index = hash &amp; table.length-1 如果用key的原始的hashCode值 与 table.length-1 进行按位与，那么基本上高16没机会用上。 这样就会增加冲突的概率，为了降低冲突的概率，把高16位加入到hash信息中。 */ return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475final V putVal(int hash, K key, V value, boolean onlyIfAbsent,boolean evict) &#123; Node&lt;K,V&gt;[] tab; //数组 Node&lt;K,V&gt; p; //一个结点 int n, i; //n是数组的长度 i是下标 //tab和table等价 //如果table是空的 if ((tab = table) == null || (n = tab.length) == 0)&#123; n = (tab = resize()).length; /* tab = resize(); n = tab.length;*/ /* 如果table是空的，resize()完成了①创建了一个长度为16的数组②threshold = 12 n = 16 */ &#125; //i = (n - 1) &amp; hash ，下标 = 数组长度-1 &amp; hash //p = tab[i] 第1个结点 //if(p==null) 条件满足的话说明 table[i]还没有元素 if ((p = tab[i = (n - 1) &amp; hash]) == null)&#123; //把新的映射关系直接放入table[i] tab[i] = newNode(hash, key, value, null); //newNode（）方法就创建了一个Node类型的新结点，新结点的next是null &#125;else &#123; Node&lt;K,V&gt; e; K k; //p是table[i]中第一个结点 //if(table[i]的第一个结点与新的映射关系的key重复) if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) e = p;//用e记录这个table[i]的第一个结点 else if (p instanceof TreeNode)&#123; //如果table[i]第一个结点是一个树结点 //单独处理树结点 //如果树结点中，有key重复的，就返回那个重复的结点用e接收，即e!=null //如果树结点中，没有key重复的，就把新结点放到树中，并且返回null，即e=null e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); &#125;else &#123; //table[i]的第一个结点不是树结点，也与新的映射关系的key不重复 //binCount记录了table[i]下面的结点的个数 for (int binCount = 0; ; ++binCount) &#123; //如果p的下一个结点是空的，说明当前的p是最后一个结点 if ((e = p.next) == null) &#123; //把新的结点连接到table[i]的最后 p.next = newNode(hash, key, value, null); //如果binCount&gt;=8-1，达到7个时 if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st //要么扩容，要么树化 treeifyBin(tab, hash); break; &#125; //如果key重复了，就跳出for循环，此时e结点记录的就是那个key重复的结点 if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) break; p = e;//下一次循环，e=p.next，就类似于e=e.next，往链表下移动 &#125; &#125; //如果这个e不是null，说明有key重复，就考虑替换原来的value if (e != null) &#123; // existing mapping for key V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); //什么也没干 return oldValue; &#125; &#125; ++modCount; //元素个数增加 //size达到阈值 if (++size &gt; threshold) resize(); //一旦扩容，重新调整所有映射关系的位置 afterNodeInsertion(evict); //什么也没干 return null;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687final Node&lt;K,V&gt;[] resize() &#123; Node&lt;K,V&gt;[] oldTab = table; //oldTab原来的table //oldCap：原来数组的长度 int oldCap = (oldTab == null) ? 0 : oldTab.length; //oldThr：原来的阈值 int oldThr = threshold;//最开始threshold是0 //newCap，新容量 //newThr：新阈值 int newCap, newThr = 0; if (oldCap &gt; 0) &#123; //说明原来不是空数组 if (oldCap &gt;= MAXIMUM_CAPACITY) &#123; //是否达到数组最大限制 threshold = Integer.MAX_VALUE; return oldTab; &#125; else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY) //newCap = 旧的容量*2 ，新容量&lt;最大数组容量限制 //新容量：32,64，... //oldCap &gt;= 初始容量16 //新阈值重新算 = 24，48 .... newThr = oldThr &lt;&lt; 1; // double threshold &#125; else if (oldThr &gt; 0) // initial capacity was placed in threshold newCap = oldThr; else &#123; // zero initial threshold signifies using defaults newCap = DEFAULT_INITIAL_CAPACITY; //新容量是默认初始化容量16 //新阈值= 默认的加载因子 * 默认的初始化容量 = 0.75*16 = 12 newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); &#125; if (newThr == 0) &#123; float ft = (float)newCap * loadFactor; newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE); &#125; threshold = newThr; //阈值赋值为新阈值12，24.。。。 //创建了一个新数组，长度为newCap，16，32,64.。。 @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;) Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap]; table = newTab; if (oldTab != null) &#123; //原来不是空数组 //把原来的table中映射关系，倒腾到新的table中 for (int j = 0; j &lt; oldCap; ++j) &#123; Node&lt;K,V&gt; e; if ((e = oldTab[j]) != null) &#123;//e是table下面的结点 oldTab[j] = null; //把旧的table[j]位置清空 if (e.next == null) //如果是最后一个结点 newTab[e.hash &amp; (newCap - 1)] = e; //重新计算e的在新table中的存储位置，然后放入 else if (e instanceof TreeNode) //如果e是树结点 //把原来的树拆解，放到新的table ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap); else &#123; // preserve order Node&lt;K,V&gt; loHead = null, loTail = null; Node&lt;K,V&gt; hiHead = null, hiTail = null; Node&lt;K,V&gt; next; //把原来table[i]下面的整个链表，重新挪到了新的table中 do &#123; next = e.next; if ((e.hash &amp; oldCap) == 0) &#123; if (loTail == null) loHead = e; else loTail.next = e; loTail = e; &#125; else &#123; if (hiTail == null) hiHead = e; else hiTail.next = e; hiTail = e; &#125; &#125; while ((e = next) != null); if (loTail != null) &#123; loTail.next = null; newTab[j] = loHead; &#125; if (hiTail != null) &#123; hiTail.next = null; newTab[j + oldCap] = hiHead; &#125; &#125; &#125; &#125; &#125; return newTab;&#125; 1234Node&lt;K,V&gt; newNode(int hash, K key, V value, Node&lt;K,V&gt; next) &#123; //创建一个新结点 return new Node&lt;&gt;(hash, key, value, next);&#125; 1234567891011121314151617181920212223242526272829final void treeifyBin(Node&lt;K,V&gt;[] tab, int hash) &#123; int n, index; Node&lt;K,V&gt; e; //MIN_TREEIFY_CAPACITY：最小树化容量64 //如果table是空的，或者 table的长度没有达到64 if (tab == null || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY) resize();//先扩容 else if ((e = tab[index = (n - 1) &amp; hash]) != null) &#123; //用e记录table[index]的结点的地址 TreeNode&lt;K,V&gt; hd = null, tl = null; /* do...while，把table[index]链表的Node结点变为TreeNode类型的结点 */ do &#123; TreeNode&lt;K,V&gt; p = replacementTreeNode(e, null); if (tl == null) hd = p;//hd记录根结点 else &#123; p.prev = tl; tl.next = p; &#125; tl = p; &#125; while ((e = e.next) != null); //如果table[index]下面不是空 if ((tab[index] = hd) != null) hd.treeify(tab);//将table[index]下面的链表进行树化 &#125;&#125; 小结： 8.4 LinkedHashMap源码剖析8.4.1 源码内部定义的Entry如下： 1234567static class Entry&lt;K,V&gt; extends HashMap.Node&lt;K,V&gt; &#123; Entry&lt;K,V&gt; before, after; Entry(int hash, K key, V value, Node&lt;K,V&gt; next) &#123; super(hash, key, value, next); &#125;&#125; LinkedHashMap重写了HashMap中的newNode()方法： 123456Node&lt;K,V&gt; newNode(int hash, K key, V value, Node&lt;K,V&gt; e) &#123; LinkedHashMap.Entry&lt;K,V&gt; p = new LinkedHashMap.Entry&lt;K,V&gt;(hash, key, value, e); linkNodeLast(p); return p;&#125; 12345TreeNode&lt;K,V&gt; newTreeNode(int hash, K key, V value, Node&lt;K,V&gt; next) &#123; TreeNode&lt;K,V&gt; p = new TreeNode&lt;K,V&gt;(hash, key, value, next); linkNodeLast(p); return p;&#125; 8.4.2 图示 9. Set接口分析9.1 Set集合与Map集合的关系Set的内部实现其实是一个Map，Set中的元素，存储在HashMap的key中。即HashSet的内部实现是一个HashMap，TreeSet的内部实现是一个TreeMap，LinkedHashSet的内部实现是一个LinkedHashMap。 9.2 源码剖析HashSet源码： 123456789101112131415161718192021222324252627282930//构造器public HashSet() &#123; map = new HashMap&lt;&gt;();&#125;public HashSet(int initialCapacity, float loadFactor) &#123; map = new HashMap&lt;&gt;(initialCapacity, loadFactor);&#125;public HashSet(int initialCapacity) &#123; map = new HashMap&lt;&gt;(initialCapacity);&#125;//这个构造器是给子类LinkedHashSet调用的HashSet(int initialCapacity, float loadFactor, boolean dummy) &#123; map = new LinkedHashMap&lt;&gt;(initialCapacity, loadFactor);&#125;//add()方法：public boolean add(E e) &#123; return map.put(e, PRESENT)==null;&#125;//其中，private transient HashMap&lt;E,Object&gt; map;private static final Object PRESENT = new Object();//iterator()方法：public Iterator&lt;E&gt; iterator() &#123; return map.keySet().iterator();&#125; LinkedHashSet源码： 12345678910//构造器public LinkedHashSet() &#123; super(16, .75f, true);&#125; public LinkedHashSet(int initialCapacity) &#123; super(initialCapacity, .75f, true);//调用HashSet的某个构造器&#125;public LinkedHashSet(int initialCapacity, float loadFactor) &#123; super(initialCapacity, loadFactor, true);//调用HashSet的某个构造器&#125; TreeSet源码： 12345678910111213141516public TreeSet() &#123; this(new TreeMap&lt;E,Object&gt;());&#125;TreeSet(NavigableMap&lt;E,Object&gt; m) &#123; this.m = m;&#125;//其中，private transient NavigableMap&lt;E,Object&gt; m;//add()方法：public boolean add(E e) &#123; return m.put(e, PRESENT)==null;&#125;//其中，private static final Object PRESENT = new Object(); 10. 【拓展】HashMap的相关问题1、说说你理解的哈希算法hash算法是一种可以从任何数据中提取出其“指纹”的数据摘要算法，它将任意大小的数据映射到一个固定大小的序列上，这个序列被称为hash code、数据摘要或者指纹。比较出名的hash算法有MD5、SHA。hash是具有唯一性且不可逆的，唯一性是指相同的“对象”产生的hash code永远是一样的。 2、Entry中的hash属性为什么不直接使用key的hashCode()返回值呢？不管是JDK1.7还是JDK1.8中，都不是直接用key的hashCode值直接与table.length-1计算求下标的，而是先对key的hashCode值进行了一个运算，JDK1.7和JDK1.8关于hash()的实现代码不一样，但是不管怎么样都是为了提高hash code值与 (table.length-1)的按位与完的结果，尽量的均匀分布。 JDK1.7： 12345678910final int hash(Object k) &#123; int h = hashSeed; if (0 != h &amp;&amp; k instanceof String) &#123; return sun.misc.Hashing.stringHash32((String) k); &#125; h ^= k.hashCode(); h ^= (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12); return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4);&#125; JDK1.8： 1234static final int hash(Object key) &#123; int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16); &#125; 虽然算法不同，但是思路都是将hashCode值的高位二进制与低位二进制值进行了异或，然高位二进制参与到index的计算中。 为什么要hashCode值的二进制的高位参与到index计算呢？ 因为一个HashMap的table数组一般不会特别大，至少在不断扩容之前，那么table.length-1的大部分高位都是0，直接用hashCode和table.length-1进行&amp;运算的话，就会导致总是只有最低的几位是有效的，那么就算你的hashCode()实现的再好也难以避免发生碰撞，这时让高位参与进来的意义就体现出来了。它对hashcode的低位添加了随机性并且混合了高位的部分特征，显著减少了碰撞冲突的发生。 3、HashMap是如何决定某个key-value存在哪个桶的呢？因为hash值是一个整数，而数组的长度也是一个整数，有两种思路： ①hash 值 % table.length会得到一个[0,table.length-1]范围的值，正好是下标范围，但是用%运算效率没有位运算符&amp;高。 ②hash 值 &amp; (table.length-1)，任何数 &amp; (table.length-1)的结果也一定在[0, table.length-1]范围。 JDK1.7： 1234static int indexFor(int h, int length) &#123; // assert Integer.bitCount(length) == 1 : &quot;length must be a non-zero power of 2&quot;; return h &amp; (length-1); //此处h就是hash&#125; JDK1.8： 12345678final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; if ((p = tab[i = (n - 1) &amp; hash]) == null) // i = (n - 1) &amp; hash tab[i] = newNode(hash, key, value, null); //....省略大量代码&#125; 4、为什么要保持table数组一直是2的n次幂呢？因为如果数组的长度为2的n次幂，那么table.length-1的二进制就是一个高位全是0，低位全是1的数字，这样才能保证每一个下标位置都有机会被用到。 举例1： 123456789101112hashCode值是 ？table.length是10table.length-1是9？ ????????9 00001001&amp;_____________ 00000000 [0] 00000001 [1] 00001000 [8] 00001001 [9] 一定[0]~[9] 举例2： 1234567891011121314hashCode值是 ？table.length是16table.length-1是15？ ????????15 00001111&amp;_____________ 00000000 [0] 00000001 [1] 00000010 [2] 00000011 [3] ... 00001111 [15] 范围是[0,15]，一定在[0,table.length-1]范围内 5、解决[index]冲突问题虽然从设计hashCode()到上面HashMap的hash()函数，都尽量减少冲突，但是仍然存在两个不同的对象返回的hashCode值相同，或者hashCode值就算不同，通过hash()函数计算后，得到的index也会存在大量的相同，因此key分布完全均匀的情况是不存在的。那么发生碰撞冲突时怎么办？ JDK1.8之间使用：数组+链表的结构。 JDK1.8之后使用：数组+链表&#x2F;红黑树的结构。 即hash相同或hash&amp;(table.lengt-1)的值相同，那么就存入同一个“桶”table[index]中，使用链表或红黑树连接起来。 6、为什么JDK1.8会出现红黑树和链表共存呢？因为当冲突比较严重时，table[index]下面的链表就会很长，那么会导致查找效率大大降低，而如果此时选用二叉树可以大大提高查询效率。 但是二叉树的结构又过于复杂，占用内存也较多，如果结点个数比较少的时候，那么选择链表反而更简单。所以会出现红黑树和链表共存。 7、加载因子的值大小有什么关系？如果太大，threshold就会很大，那么如果冲突比较严重的话，就会导致table[index]下面的结点个数很多，影响效率。 如果太小，threshold就会很小，那么数组扩容的频率就会提高，数组的使用率也会降低，那么会造成空间的浪费。 8、什么时候树化？什么时候反树化？123static final int TREEIFY_THRESHOLD = 8;//树化阈值static final int UNTREEIFY_THRESHOLD = 6;//反树化阈值static final int MIN_TREEIFY_CAPACITY = 64;//最小树化容量 当某table[index]下的链表的结点个数达到8，并且table.length&gt;&#x3D;64，那么如果新Entry对象还添加到该table[index]中，那么就会将table[index]的链表进行树化。 当某table[index]下的红黑树结点个数少于6个，此时， 当继续删除table[index]下的树结点，最后这个根结点的左右结点有null，或根结点的左结点的左结点为null，会反树化 当重新添加新的映射关系到map中，导致了map重新扩容了，这个时候如果table[index]下面还是小于等于6的个数，那么会反树化 1234567891011121314151617181920212223242526272829303132333435363738package com.atguigu.map;public class MyKey&#123; int num; public MyKey(int num) &#123; super(); this.num = num; &#125; @Override public int hashCode() &#123; if(num&lt;=20)&#123; return 1; &#125;else&#123; final int prime = 31; int result = 1; result = prime * result + num; return result; &#125; &#125; @Override public boolean equals(Object obj) &#123; if (this == obj) return true; if (obj == null) return false; if (getClass() != obj.getClass()) return false; MyKey other = (MyKey) obj; if (num != other.num) return false; return true; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243package com.atguigu.map;import org.junit.Test;import java.util.HashMap;public class TestHashMapMyKey &#123; @Test public void test1()&#123; //这里为了演示的效果，我们造一个特殊的类，这个类的hashCode（）方法返回固定值1 //因为这样就可以造成冲突问题，使得它们都存到table[1]中 HashMap&lt;MyKey, String&gt; map = new HashMap&lt;&gt;(); for (int i = 1; i &lt;= 11; i++) &#123; map.put(new MyKey(i), &quot;value&quot;+i);//树化演示 &#125; &#125; @Test public void test2()&#123; HashMap&lt;MyKey, String&gt; map = new HashMap&lt;&gt;(); for (int i = 1; i &lt;= 11; i++) &#123; map.put(new MyKey(i), &quot;value&quot;+i); &#125; for (int i = 1; i &lt;=11; i++) &#123; map.remove(new MyKey(i));//反树化演示 &#125; &#125; @Test public void test3()&#123; HashMap&lt;MyKey, String&gt; map = new HashMap&lt;&gt;(); for (int i = 1; i &lt;= 11; i++) &#123; map.put(new MyKey(i), &quot;value&quot;+i); &#125; for (int i = 1; i &lt;=5; i++) &#123; map.remove(new MyKey(i)); &#125;//table[1]下剩余6个结点 for (int i = 21; i &lt;= 100; i++) &#123; map.put(new MyKey(i), &quot;value&quot;+i);//添加到扩容时，反树化 &#125; &#125;&#125; 9、key-value中的key是否可以修改？key-value存储到HashMap中会存储key的hash值，这样就不用在每次查找时重新计算每一个Entry或Node（TreeNode）的hash值了，因此如果已经put到Map中的key-value，再修改key的属性，而这个属性又参与hashcode值的计算，那么会导致匹配不上。 这个规则也同样适用于LinkedHashMap、HashSet、LinkedHashSet、Hashtable等所有散列存储结构的集合。 10、JDK1.7中HashMap的循环链表是怎么回事？如何解决？ 避免HashMap发生死循环的常用解决方案： 多线程环境下，使用线程安全的ConcurrentHashMap替代HashMap，推荐 多线程环境下，使用synchronized或Lock加锁，但会影响性能，不推荐 多线程环境下，使用线程安全的Hashtable替代，性能低，不推荐 HashMap死循环只会发生在JDK1.7版本中，主要原因：头插法+链表+多线程并发+扩容。 在JDK1.8中，HashMap改用尾插法，解决了链表死循环的问题。","categories":[],"tags":[]},{"title":"","slug":"赠：程序员的日常工作解密","date":"2023-09-27T14:15:58.895Z","updated":"2023-08-22T08:46:41.047Z","comments":true,"path":"2023/09/27/赠：程序员的日常工作解密/","link":"","permalink":"http://example.com/2023/09/27/%E8%B5%A0%EF%BC%9A%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E6%97%A5%E5%B8%B8%E5%B7%A5%E4%BD%9C%E8%A7%A3%E5%AF%86/","excerpt":"","text":"程序员的日常工作解密调研1、后端工程师典型的日常1：国企受访人 22岁 平时每天的上班时间和下班时间分别是？ 早上 9 点上班， 晚上 6 点下班 最近一周有加班么？加班的天数是？一般加到多晚？ 最近一周加班三天，工作日加班到晚上8点30左右，周末一天加班一整天，晚上不加。 描述一下你的「典型的一天」 住公司提供的宿舍，早上8:40起床， 9点到公司食堂吃早饭， 9:30左右开始正式上班， 到11:30会稍微休息一会，然后浏览一些技术博客、运动相关的东西。 12点在公司的食堂吃午饭， 12:30到13:30回宿舍休息， 14点左右再回到工位上开始上班。刚开始到位置上，如果任务赶的话直接开始敲代码，如果任务不赶，会拿30分钟到1一个小时看一下公司的前端框架。 期间会在公司的休闲室休息一会，然后到18.00下班。 18:00 去健身房锻炼一个小时 19:30 训练结束回到宿舍，洗澡，准备晚饭。 20:00 吃完饭，这时候追两集动漫，看看视频，刷刷微博 到22:00 因为自我感觉基础非常薄弱，这个时候通常会学一点东西。 在上边描述的日常中，你最想吐槽的是什么？ 毕业之后一直在负责维护一个公司比较旧版本的项目，所以经常出现一些非常奇怪的需求。还有一些非常老旧的代码，找不到之前的author，也不知道如何调试。 在上边描述的日常中，你最满意的是什么？ 很自由，我可以在正常的上班时间之内自己支配。 在现在这个职位上，你遇到的最大的技术挑战是什么？怎么解决的？ 在熟悉公司新开发的一套框架上。因为文档不齐全，而且前端相对薄弱，所以一直不知道如何去下手。 后面为了能够快速熟悉起来，我就找带我的小哥要了一个很简单的任务，直接进行下手，然后直接在开发中对遇到的问题 进行跟踪调试，开发完这个模块花了一个礼拜，虽然进度很慢..但是现在对这个框架已经有点熟悉了。 你是怎么度过从新人到熟手的阶段的？公司有安排培训么？如果有，你觉得其中对你最有用的内容是什么？ 其实现在还是一个新人。公司曾在我们实习的时候安排了一个月的培训，主要是对公司在使用中的框架（Spring MyBatis）等进行培训。我觉得最有用的还是给我们上课的大牛给我们的一些学习方法，以及工作方法。 你对即将入职这个岗位的新人，有什么建议？（做什么、不要做什么） 要做：我是一个非985&#x2F;211大学的学生，等我有职业规划的想法的时候已经是大三下学期了，所以我感觉自己起步非常非常慢，技术也很差。所以我想说的是，如果想走技术这条路，那一定不要呆在懒惰区，而且对基础的东西要更重视，同时也要关注新的技术。 不要做：对自己的规划模棱俩可.不知道自己为什么要做技术相关的工作。 调研2、后端工程师典型的日常2：知名创业公司受访人 23 岁，后端产品研发工程师。 平时每天的上班时间和下班时间分别是？ 前公司一般是 11 点上班，现在是 10 点，下班时间我一般工作外也会待在公司做些别的，大概平均也得 9、10 点吧。 最近一周有加班么？加班的天数是？一般加到多晚？ 属于比较忙的组，之前一直封闭开发，差不多 11、10、6 吧（也就持续一两周）。 描述一下你的「典型的一天」 9:00 起床 10:00 打车到公司 上午主要是整理性质，会开站会，整理下今天要做的事（不光工作，翻翻邮件、订阅的博客、Github 之类的） 12:00 在食堂吃饭，然后出去散散步，没有午睡的习惯 下午基本都在工作 19:00 在食堂吃晚饭 之后如果工作还比较忙就接着弄工作，否则会按照优先级选一些个人的事去做（Side Project、知识积累、阅读） 21:00~22:00 下班回家。到家基本上就只是放松了，看看日剧、追番 偶尔有很感兴趣的事驱动的时候（比如 Side Project 灵感很多的时候），会熬夜做，大概到 3:00 为底线 在上边描述的日常中，你最想吐槽的是什么？ 目前在新公司还有两个比较严重的问题： 对任务的估时准确度不高，很多时候要么过忙，要么被严重 Block。 对任务的优先级分配有问题，我希望能静下心做一些重要且不紧急的事情，但是实际上大部分时间都在帮别人解决一些小问题。 在上边描述的日常中，你最满意的是什么？ 上家公司是技术很好的小团队（ 好到什么程度呢？后端 + 平台 15 人左右，能维护一套微服务，并且自研容器编排 ），但是很遗憾的是业务本身没有太大量级，对后端来说历练还太小。 来新公司主要是为了技术挑战，业务上的压力肯定是有的，就看自己能不能抓住机会了。 在现在这个职位上，你遇到的最大的技术挑战是什么？怎么解决的？ 技术挑战可能不会太多，我认为很多业务场景都是有取巧的解决方案的（取巧可能形容有误，非贬义，类似于分库分表即使不需要太多技术也可以 Hard Coding 实现，并且能有效解决问题）。而中小型公司的平台方案一般又都是追随开源的，所以我也选择尽量追随开源社区。 在现在这个职位上，你遇到的最大的非技术挑战是什么？怎么解决的？ 我比较不擅长编程以外的任何事，最不擅长的就是与人相处。讨厌漫长的会议，讨厌一些混日子的同事。 你是怎么度过从新人到熟手的阶段的？公司有安排培训么？如果有，你觉得其中对你最有用的内容是什么？ 呆的都是中小型公司，没参与过什么培训，个人感觉比较幸运的主要还是多逛开源社区吧，很多时候公司交给我去做的事都是因为我之前有过了解（哪怕只是简单了解，也比大部分人强很多），这样慢慢的就能成为良性循环。 你对即将入职这个岗位的新人，有什么建议？（做什么、不要做什么） 不要盲目崇拜自己公司的技术，很多时候技术会因为架构师的喜好、成本、甚至一些和技术无关的因素而决定。即使去用了，也要明白这些技术有哪些优点、哪些缺点、如何改进。这样你至少迈出了第一步：不会因为最开始运气不好去了一家不好的公司或是部门而陷入技术上的恶性循环。 其次就是无论前端也好、后端也好，多去了解了解新技术，即使作为一个后端我也会偶尔和 Android 同事聊聊 Kotlin，和前端同事聊聊 React、Vue，你会发现只需花费非常低的成本就能学到一门可以弥补你短板的新技术，让你之前很多看似做不到的想法都可以轻松实现。 调研3、前端工程师典型的日常3：知名互联网公司受访人 21岁，在北京某D轮知名移动互联网公司担任前端。 平时每天的上班时间和下班时间分别是？ 早9点，晚6:30。 最近一周有加班么？加班的天数是？一般加到多晚？ 最近有加班因为双11，基本天天加班，加班到7:30，平时较少加班。 你的「典型的一天」？ 每天 8:30 起床， 接近 9 点出门， 到公司 9 点多一点， 中午 11:30 骑摩拜去公司另一个食堂吃饭， 回来 12:30 开始午休， 1:30 缓一会儿看看邮件消息， 2点开始干活， 6:30去楼下食堂吃饭然后回家 在上边描述的日常中，你最想吐槽的是什么？ 最想吐槽日常低效率的沟通，每天花费在看邮件和消息的时间比较多，很多内容和自己没有太大的关系，比较影响工作效率，还有就是需求变更比较频繁。 在上边描述的日常中，你最满意的是什么？ 日常比较满意的是宽松的工作氛围，和谐的上下级关系，以及团队有技术上的大牛，当然还有很多妹纸~ 在现在这个职位上，你遇到的最大的技术挑战是什么？怎么解决的？ 其实目前来说还没有遇到真正意义上的技术挑战，因为轮子已经有前人造好了，挑战可能更多的是需要自己去了解这些实现细节。如果确实遇到困难，我会先去看看之前项目里面的代码别人是怎么实现的，然后自己也会了。 在现在这个职位上，你遇到的最大的非技术挑战是什么？怎么解决的？ 非技术挑战可能是需要协调好在开发过程中与PM，设计，运营以及其他工程师之间的teamwork，避免因为交流不够彻底而导致做一些无意义或者重复的事情。 解决这个问题其实是比较困难的，我们可能有时问同一项目里面不同两个人对相同的问题给出不同的答案，这个时候我一般会明确的这个问题真正的需求是什么，同时会和同一团队的成员都确认一下。 你是怎么度过从新人到熟手的阶段的？公司有安排培训么？如果有，你觉得其中对你最有用的内容是什么？ 从新人到现在的转变就是不明确的或者不会的地方，就去看前人是怎么实现，再不会就问leader(一般很少发生这种情况)。 公司有安排培训，培训的价值其实在输出的内容上并没有对我有多大的提升，反倒是让我对认识问题的态度有很大的转变，我们喜欢用事实标准去讲一个问题，而不是通过别人的经验或者某些技术博客的介绍就认为问题就是这样。 技术人看待问题就应该是非常严谨，就像写代码一样，我们要做到bug free，虽然这是不可能的。 你对即将入职这个岗位的新人，有什么建议？（做什么、不要做什么） 我想说，与其把大把的时间花在学习几个瞬息万变的新框架API使用中，不如多花点时间在基础知识学习。我认为这才是真正决定一个技术人能走多远的基石，虽然这句话可能你已经听烦了。 新的东西解决了很多问题，但是很多人甚至都不知道为什么会存在这些问题更别谈解决方案和实现的原理，还有就是不要盲目的相信技术网红的一些观点，他们不一定是正确或者恰当的。 前端最不缺网红，工作后我才认识到大部分真正牛逼的人都是比较低调的(但并不是高调的人就不牛)；在有一些基础后可以多看一些原理性质或者质量高的博客，多读一些业界认可度高的书籍，看看一些开源项目从简单的入手，自己去实践并验证你学习到的知识，同时多关注开源社区 你在这些年的工作中，有没有遇到特别好的工具、资料、书籍之类，想要推荐给大家？一两样也行哦。 推荐一本书《JavaScript高级程序设计》，相当于 Web API Wiki 的 MDN ，以及 Google 开发者文档中的 Web 部分，更细节可以看看 W3C 标准、ECMAScript 标准、WHATWG 标准。在准备读一本书的时候可以先去豆瓣上看看评价，如果只有6、7分你就要慎重了，因为他可能不仅仅是在浪费你的时间还可能误导你。 调研4、创业公司技术负责人的日常4受访人 27岁 ，5月份离开微博到深圳已经半年，目前与几个朋友创业中，负责技术部分。 平时每天的上班时间和下班时间分别是？ 创建阶段也没有固定吧，其实也与大家都差不多。 最近一周有加班么？加班的天数是？一般加到多晚？ 创业阶段就没有加班一说了，因为也没有固定的下班时间，有事情就多忙一会儿，晚点回家，没事就早点回去。 你的「典型的一天」？ 一般是 8 点左右起床， 然后 9 点从坪洲站出发， 9 点 50 左右到水湾站，出站就是公司所在地：深圳自贸中心。 整体感觉还是很方便的。 中午楼下吃饭， 然后工作到 7-8 点左右回家。 在上边描述的日常中，你最想吐槽的是什么？ 其实相对于北京，深圳给我的印象没有太多槽点，大家都很有秩序的排队是印象最深刻的，地铁也不挤（也许是我9点才出发的原因吧）， 因为我住坪洲，办公室在深圳自贸中心稍微离我稍微远一点，40-50 分钟左右的地铁也许是最差的一点了吧，不过都还能接受了。 在上边描述的日常中，你最满意的是什么？ 最满意的就是团队了，几个合伙人的执行力是我见过最棒的，然后很满意的就是公司环境很好，大家有空可以来参观一下。 在现在这个职位上，你遇到的最大的技术挑战是什么？怎么解决的？ 由于我们是创业项目，线上线下联动，并非纯互联网项目，我们没有太多的难点需要解决，所以大部分是在接入一些服务时感觉比较麻烦一些吧，目前来讲没有遇到什么技术难题，因为不管从项目复杂度上还是用户量级上都还没有到有挑战的程度。 在现在这个职位上，你遇到的最大的非技术挑战是什么？怎么解决的？ 作为技术负责人，除了搞定技术问题外，更多的时间都是与大家在讨论产品，用户体验，以及一些未来规划可能需要做的准备工作。另外就是需要扩大技术广度来避免团队扩大时的管理难题。目前来讲就是在时间管理上还需要一些调整，不是太能控制好个人时间。 你是怎么度过从新人到熟手的阶段的？公司有安排培训么？如果有，你觉得其中对你最有用的内容是什么？ 其实很多的实践经验基本都来自公司项目或者自己业余项目，工作之外的时间主要就是做一些基础知识的积累。还是得感谢这几年经历的几家公司，对我的成长提升都很大，在微博的两年，领导的大力支持给了我很多帮助。然后折腾开源项目的时间也是我个人成长过程中收益最大的投入。 公司培训的话，有过，不过比较少，更多的是团队内的知识分享，这方面手机微博做得还是很棒的。其实分享不在于能让你在这么短时间内学会什么，我觉得它最大的益处就是增加知识面：你会的东西，在分享过程中可能会看到新的玩法，或者更有效的玩法，你不会的东西，增加知识广度，新东西能增加个人的学习气氛（折腾新东西的时候持续的兴奋感特别棒）。另外主动分享也能锻炼表达能力。 你对即将入职这个岗位的新人，有什么建议？（做什么、不要做什么） 新人最大的难点可能在选择上，这个选择包括很多方面吧，比如用什么语言（这个争吵太多了）、用什么编辑器到用什么框架、写不写注释等等，我个人的建议是：把握一个方向，找比较能入手的（像 PHP 就很容易入手），大家都在用的（或者说用得人多的）深入学习，精通它，在项目中去实践，然后扩大知识面，了解一下其它周边的东西，比如你写后端，你起码也得懂 CSS，js 之类的基础使用比较好。少看社区八卦，他们爱吵不吵，不要受影响，相信自己的选择。因为到后面你会发现，真正的牛人，不是在于哪个语言他用得 6 不 6，而是在项目上的架构能力，解决问题的能力才是最厉害的。 你在这些年的工作中，有没有遇到特别好的工具、资料、书籍之类，想要推荐给大家？一两样也行哦。 太多了，不过不常用的我就不提了，自己常用的东西有： 工具方面（全部已购买正版授权）： 写代码：Sublime Text 3 + PHPStorm(开源授权) 做设计：Sketch 数据库：Sequel pro 记笔记：Bear TODO：Things 3 办公：企业微信 项目管理：Teambition 其它工具：1password、Charles、Item2 等 书籍方面其实我不太有发言权，因为比较懒，不过还是有本认为很棒的推荐给大家：《C和指针》系列。 调研5、CTO的日常受访人 39岁，北京某云计算公司 CTO ，原知名上市公司研发总监。 平时每天的上班时间和下班时间分别是？ 早10:30到晚8:30。 最近一周有加班么？加班的天数是？一般加到多晚？ 有加班，2天，一般加班到9点30。 能否按小时描述一下你的「典型的一天」？ 8点起床， 9点出门， 10点半到公司，处理邮件，处理和工作相关的微信，和同事讨论工作进展情况， 12点吃饭， 12点半看业内资讯、技术文章， 1点半休息半小时， 2点会议或者面试， 3点会议或者面试， 4点和同事或者客户沟通工作， 5点看工作相关的运营数据、邮件、文档、了解各项工作的进展， 6点吃饭，有时候约了饭局出发，不出去的话， 6点半和同事沟通工作， 8点半下班。 在上边描述的日常中，你最想吐槽的是什么？ 上班太远，路上总堵车。 在上边描述的日常中，你最满意的是什么？ 发展空间大。 在现在这个职位上，你遇到的最大的技术挑战是什么？怎么解决的？ 产品和服务的质量，体现在服务的响应速度快、稳定性好故障率底，主要通过不断改进系统的缺陷，完善技术开发和变更的流程机制。 在现在这个职位上，你遇到的最大的非技术挑战是什么？怎么解决的？ 非技术挑战就是拓展业务，跟更多的潜在客户沟通，介绍公司的产品，争取测试的机会。 你是怎么度过从新人到熟手的阶段的？公司有安排培训么？如果有，你觉得其中对你最有用的内容是什么？ 自己和公司的人多沟通，了解公司的人、流程、部门。 你在这些年的工作中，有没有遇到特别好的工具、资料、书籍之类，想要推荐给大家？一两样也行哦。 事物管理工具用 JIRA ，文档管理用 Confluence ，代码管理用 BitBucket 。 案例来自于掘金小册《程序员职业小白书 —— 如何规划和经营你的职业》欢迎大家订阅。如侵删。","categories":[],"tags":[]},{"title":"优秀程序员的五个特质","slug":"赠：优秀程序员的五个特质","date":"2023-09-27T14:15:54.896Z","updated":"2023-09-29T05:52:40.550Z","comments":true,"path":"2023/09/27/赠：优秀程序员的五个特质/","link":"","permalink":"http://example.com/2023/09/27/%E8%B5%A0%EF%BC%9A%E4%BC%98%E7%A7%80%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E4%BA%94%E4%B8%AA%E7%89%B9%E8%B4%A8/","excerpt":"","text":"1、程序员的焦虑我们的焦虑来自于对未来的不确定性，而这种不确定性是一个特定时代加上特定行业的产物。 今天的我们处在一个人类历史上少有的快速发展时代，我们看不清以后的人生，大脑却还停留在上一代人的思维习惯上。 IT 行业在国内的大发展也就最近20多年的事，行业里很少有走过完整职业生涯的程序员。 也正是因为如此，我们经常会产生了各种焦虑： 我刚刚入行时，有人问，程序员能做到 30 岁吗？ 我快 30 岁时，有人问，35 岁还能做程序员吗？ 我 35 岁时，讨论变成了 40 岁的程序员该怎么办？ 估计等国内有越来越多的程序员走完了整个职业生涯，就会有人关心，程序员退休之后的生活应该是什么样子了。 2、坦然面对当前的问题接下来，我们要踏上征程，一步一个脚印的看清楚当前面临的问题。 如果你还什么都不会，那就应该从HelloWorld编码开始。 如果你已经能够写好普通的代码，那就应该尝试去练习更复杂算法的代码。 如果你实现一个具体功能都没问题了，那就去做架构设计，让程序有更好的组织。 如果你已经能完成一个普通的系统设计，那就应该去设计业务量更大的系统。 如果你还没有工作，那有一份编程的工作就好。 如果你已经有一份收入尚可的工作，那就可以考虑冲击下有挑战性的岗位或大厂。 3、什么样的程序员才是优秀的程序员呢？ 本人眼中：写的一手好代码，做过几个大项目，设计、编程不在话下 同学眼中：刚毕业就去了大厂，各种福利待遇羡慕的不行 同事眼中：人挺好，干活挺快 HR眼中：省钱、出活 4、五个关键特质1、熟练操作一门编程语言 优秀的程序员需要写的一手好代码。把标准降低来说，最起码需要熟练使用一门编程语言。 熟练了之后，很多语法、语句在我们编写程序的时候，会下意识地就流露出来。正如，我们中国人会熟练的使用筷子夹各种食物；很多年轻人会熟练的骑自行车，下意识的避开路上的障碍。如果我们设计一个线程类，在编写代码时，至少 class 和 extends 这两个关键字的使用是不需要大脑有意识地参与的。 编程语言，基本上是相通的。掌握了第一门编程语言后，第二门语言学起来就快很多，第三门语言学起来更快。现在我们几乎都是多语言使用者，但一定要先精通一门语言，达到像用筷子那样的熟练程度。 2、解决实际问题的能力 代码是要解决具体的问题的，我们需要通过编程语言把解决问题的办法和思路表达出来。 要解决具体的问题，仅仅做到熟练使用编程语言是远远不够的，优秀的程序员还要深入理解问题，懂得问题的最核心价值。 只有理解了问题，看到了解决问题的价值，我们才能够真正解决好问题，并且从中获得满满的成就感。我们一定要记得，程序员的存在不是为了写代码，而是为了解决现实问题，实现现实价值。 真实的作品，都带着我们对于现实问题的理解。而打磨一个这样的作品，需要缜密的逻辑、 突破创新和贯彻执行。通过使用合适的工具，把简单的、一行一行的代码，耐心地粘合、打 磨成优秀的作品。 这里举例几个：阿里合伙人 前蚂蚁金服CEO胡晓明：中专 前阿里集团CTO张建峰：中专(温州机械工业学校) 前蚂蚁金服CTO胡喜：大学肄业(大连外国语) 现蚂蚁金服CTO倪行军：大专(浙江财经学院) 3、发现关键问题的能力 能够发现关键的问题，是一个好程序员和优秀程序员的分水岭。 优秀的程序员，能够发现一门编程语言的缺陷，一个顺手工具的局限。所以，他知道该怎么选择最合适的工具，该怎么避免不必要的麻烦。 优秀的程序员，能够发现解决方案背后的妥协和风险。所以，他可以预设风险防范措施，设置软件的适用边界。 优秀的程序员，能够敏锐地观察到产品的关键问题，或者客户未被满足的需求。所以，他可以推动产品持续地进步和演化。 能够发现关键的问题，意味着我们可以从一个被动的做事情的程序员，升级为一个主动找事情的程序员。 能够发现关键的问题，往往需要我们对一个领域有很深入的研究和深厚的积累，并且对新鲜事物保持充分的好奇心和求知欲。 我们写的每一行代码，都可能存在问题。有时候，我发现别人的代码的问题；有时候，别人 发现我的代码的问题。我们最后都会明白，要坦诚地面对别人的问题，也要坦然地面对自己的问题。在解决问题和帮助别人解决问题中，我们把一个产品变得越来越好，问题越来越少。 4、是可以依赖的伙伴 优秀的程序员是一个领导型的人。他能够倾听，持续地获取他人的优秀想法，以及不同的意见。他能够表达，准确地传递自己的想法，恰当地陈述自己的意见。 他是一个给予者，给别人尊重，给别人启发，给别人指导，给别人施展才华的空间。 他是一个索取者，需要获得尊重，需要获得支持，需要持续学习，需要一个自主决策的空间。他能够应对压力，承担责 任，积极主动，大部分时候保持克制和冷静，偶尔也会表达愤怒。 他具有一定的影响力，以及良好的人际关系，能够和各种类型的人相处，能够引发反对意见，但是又不损害人际关 系。他知道什么时候可以妥协，什么时候应该坚持。 上面的这些，通常称为“软技能”。如果说，编程语言、花样工具、逻辑思维、解决问题这些“硬技能”可以决定我们的起点的话，影响力、人际关系这些“软技能”通常影响着我们可以到达的高度。因为，无论我们是加入他人的团队，或者组建自己的团队，我们只有在团队中才能变得越来越出色，做的事情越来越重要。所以，我们需要成为优秀的团队成员，接受影响，也影响他人。 5、自律、适度的偏执 当谈到成为优秀的程序员时，自律和适度的偏执是两个非常重要的特质。它们有助于提高工作效率、代码质量和问题解决能力。 一个自律的程序员能够有效地管理时间、资源和任务，以达到最佳的工作成果。以下是自律如何在编程中发挥作用的几个方面： 时间管理：自律的程序员能够设定合理的工作时间表，并遵循这些时间表来完成任务。他们知道何时专注于编码，何时进行休息和放松，以保持高效率。 任务优先级：自律的程序员能够识别任务的重要性和紧急性，并根据优先级合理地分配时间和精力。这有助于避免陷入无谓的琐事，而是专注于关键的项目和问题。 学习和成长：优秀的程序员不断学习新技术和工具。自律的程序员会制定学习计划，定期投入时间来提升自己的技能，以保持竞争力。 代码质量：自律的程序员遵循最佳实践，编写干净、可维护和可扩展的代码。他们会花时间进行代码审查和测试，以确保交付高质量的软件。 适度的偏执是指对细节的高度关注和追求完美的态度。在编程中，这种偏执可以带来以下好处： Bug 的挖掘：适度的偏执使程序员对代码的每个细节都充满敏感。他们会仔细检查可能的边界情况和潜在的错误，从而减少Bug的出现概率。 性能优化：偏执的程序员会追求代码的高效性能。他们会关注算法的时间和空间复杂度，以及代码执行的速度，以确保软件在各种情况下都能够高效运行。 代码审查：偏执的程序员会在代码审查过程中严格要求自己和同事。他们会挑剔地检查代码，确保代码质量和一致性。 综上所述，自律和适度的偏执是成为优秀程序员的关键特质。自律能够帮助管理时间和资源，以及保持持续的学习和提升。适度的偏执则有助于保障代码质量，挖掘潜在问题，并提供出色的用户体验。这两个特质相互补充，共同促使程序员在不断变化的技术环境中脱颖而出。","categories":[{"name":"程序猿","slug":"程序猿","permalink":"http://example.com/categories/%E7%A8%8B%E5%BA%8F%E7%8C%BF/"}],"tags":[{"name":"经验","slug":"经验","permalink":"http://example.com/tags/%E7%BB%8F%E9%AA%8C/"}]},{"title":"八、终极实战：SpringBoot版微头条实战","slug":"SSM/八、终极实战：SpringBoot版微头条实战/八、终极实战：SpringBoot版微头条实战","date":"2022-10-02T10:55:54.000Z","updated":"2023-09-28T00:33:28.583Z","comments":true,"path":"2022/10/02/SSM/八、终极实战：SpringBoot版微头条实战/八、终极实战：SpringBoot版微头条实战/","link":"","permalink":"http://example.com/2022/10/02/SSM/%E5%85%AB%E3%80%81%E7%BB%88%E6%9E%81%E5%AE%9E%E6%88%98%EF%BC%9ASpringBoot%E7%89%88%E5%BE%AE%E5%A4%B4%E6%9D%A1%E5%AE%9E%E6%88%98/%E5%85%AB%E3%80%81%E7%BB%88%E6%9E%81%E5%AE%9E%E6%88%98%EF%BC%9ASpringBoot%E7%89%88%E5%BE%AE%E5%A4%B4%E6%9D%A1%E5%AE%9E%E6%88%98/","excerpt":"","text":"八、终极实战：SpringBoot版微头条实战目录 一、微头条案例介绍 微头条业务简介 技术栈介绍 功能展示 二、微头条前端搭建 三、基于SpringBoot搭建项目基础架构 1. 数据库脚本执行 2. 搭建SprintBoot工程 3. MybatisX逆向工程 四、后台功能开发 4.1 用户模块开发 4.2 首页模块开发 4.3 头条模块开发 五、前后端联调 一、微头条案例介绍微头条业务简介 用户功能 注册功能 登录功能 jwt实现 头条新闻 新闻的分页浏览 通过标题关键字搜索新闻 查看新闻详情 新闻的修改和删除 技术栈介绍 前端技术栈 ES6作为基础JS语法 nodejs用于运行环境 npm用于项目依赖管理工具 vite用于项目的构建架工具 Vue3用于项目数据的渲染框架 Axios用于前后端数据的交互 Router用于页面的跳转 Pinia用于存储用户的数据 LocalStorage作为用户校验token的存储手段 Element-Plus提供组件 后端技术栈 JAVA作为开发语言,版本为JDK17 Tomcat作为服务容器,版本为10.1.7 Mysql8用于项目存储数据 SpringMVC用于控制层实现前后端数据交互 MyBatis-Plus用于实现数据的CURD Druid用于提供数据源的连接池 SpringBoot作为项目基础架构 MD5用于用户密码的加密 Jwt用于token的生成和校验 Jackson用于转换JSON 功能展示 头条首页信息搜索 登录功能 注册功能 展示功能 发布头条功能 修改头条功能 删除头条功能 二、微头条前端搭建 确保本地node，npm，vscode安装完毕！ 如果没有安装可以回看ssm整合实战！ 解压前端项目代码并存放到磁盘的合适位置 atguigu-headline.rar 使用vscode打开工程 进入项目后打开集成终端或者在src上右击选择在集成终端中打开 通过 npm run dev启动前端项目 12npm install npm run dev 三、基于SpringBoot搭建项目基础架构1. 数据库脚本执行执行数据库脚本: top_news.sql 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293CREATE DATABASE sm_db;USE sm_db;SET NAMES utf8mb4;SET FOREIGN_KEY_CHECKS = 0;-- ------------------------------ Table structure for news_headline-- ----------------------------DROP TABLE IF EXISTS `news_headline`;CREATE TABLE `news_headline` ( `hid` INT NOT NULL AUTO_INCREMENT COMMENT &#x27;头条id&#x27;, `title` VARCHAR(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT &#x27;头条标题&#x27;, `article` VARCHAR(5000) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT &#x27;头条新闻内容&#x27;, `type` INT NOT NULL COMMENT &#x27;头条类型id&#x27;, `publisher` INT NOT NULL COMMENT &#x27;头条发布用户id&#x27;, `page_views` INT NOT NULL COMMENT &#x27;头条浏览量&#x27;, `create_time` DATETIME(0) NULL DEFAULT NULL COMMENT &#x27;头条发布时间&#x27;, `update_time` DATETIME(0) NULL DEFAULT NULL COMMENT &#x27;头条最后的修改时间&#x27;, `version` INT DEFAULT 1 COMMENT &#x27;乐观锁&#x27;, `is_deleted` INT DEFAULT 0 COMMENT &#x27;头条是否被删除 1 删除 0 未删除&#x27;, PRIMARY KEY (`hid`) USING BTREE) ENGINE = INNODB AUTO_INCREMENT = 1 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = DYNAMIC;-- ------------------------------ Records of news_headline-- ----------------------------INSERT INTO `news_headline` (hid,title,article,TYPE,publisher,page_views,create_time,update_time,is_deleted) VALUES (1, &#x27;特色产业激发乡村振兴新活力&#x27;, &#x27;推进中国式现代化，必须全面推进乡村振兴。习近平总书记指出，产业振兴是乡村振兴的重中之重，也是实际工作的切入点。近日，记者走进乡村一线，看到各地以特色产业为抓手，拓展产业链发展产业集群，一二三产业融合发展，培育乡村振兴新动能。\\n\\n 这个端午，广东茂名高州市根子镇柏桥村的荔枝迎来了丰收。今年4月，习近平总书记来到柏桥村考察调研。总书记走进荔枝种植园，了解当地发展特色种植产业和文旅产业等情况，并同现场技术人员亲切交流。&#x27;, 1, 1, 0, &#x27;2023-06-25 09:26:20&#x27;, &#x27;2023-06-25 09:26:20&#x27;, 0);INSERT INTO `news_headline` (hid,title,article,TYPE,publisher,page_views,create_time,update_time,is_deleted) VALUES (2, &#x27;北京连续三天最高温超40℃，6月“炎值”因何爆表？&#x27;, &#x27; 中新社北京6月24日电 (记者 陈杭 徐婧)京城连续三日“热晴不减”，且高温红色预警持续生效。截至24日13时51分，作为北京地区气象观测代表站的南郊观象台气温突破40℃，这是该站观测史上首次连续三天气温超40℃。22日以来，北京高温“烤验”突出。22日，北京南郊观象台最高气温达41.1℃，这是有观测纪录以来历史第二高(并列)。北京市气象局表示，观象台1951年建站以来极端最高气温为41.9℃，出现在1999年7月24日。\\n\\n 23日，北京南郊观象台最高气温为40.3℃，这是该观象台建站以来首次出现连续两天最高气温超40℃。当天，北京时隔9年再次发布最高级别的高温红色预警信号。&#x27;, 1, 1, 0, &#x27;2023-06-25 09:28:06&#x27;, &#x27;2023-06-25 09:28:06&#x27;, 0);INSERT INTO `news_headline` (hid,title,article,TYPE,publisher,page_views,create_time,update_time,is_deleted) VALUES (3, &#x27;今年夏天，极端高温是否会成为常态？&#x27;, &#x27;针对京津冀地区持续高温天气，23日下午，中国气象局召开高温天气新闻通气会。\\n\\n 刚过6月就出现极端高温天，今年夏天还会有多少高温天呢？对此，国家气候中心首席预报员高辉表示，根据国家气候中心预计，今年夏天全国大部分地区气温都比常年同期要偏高，这也对应着高温日数也要高于常年同期。但不同的地区，高温集中时段不一样，比如南方地区是在盛夏时间段进入高温季，而北方地区往往是在初夏时间段，所以从今年夏季来说，要区分不同的地区来考虑高温的影响。\\n\\n 我国各地高温集中时段有明显的地域差异。对华北地区来说，通常雨季前的6月至7月初更容易出现高温天气，连续数天的高温在6月也比较常见。高辉说，这段时间主要是干热型高温为主，表现为气温高湿度小。进入7月后期，随着副高北跳和夏季风往北推进，水汽输送和大气湿度增加，云量也会增多，会出现闷热天气，也就是湿热型高温。就最高气温而言，前一时段气温最高值通常高于后一时段。但也需要说明的是，人体体感温度不仅和气温有关，还受到湿度影响，往往这种湿热型高温会加重人体体感温度。&#x27;, 1, 1, 0, &#x27;2023-06-25 09:31:00&#x27;, &#x27;2023-06-25 09:31:00&#x27;, 0);INSERT INTO `news_headline` (hid,title,article,TYPE,publisher,page_views,create_time,update_time,is_deleted) VALUES (4, &#x27;中央气象台发布今年首个高温橙色预警&#x27;, &#x27;新华社北京6月22日电（记者黄垚）22日18时，中央气象台升级发布今年首个高温橙色预警。预计23日白天，华北、黄淮等地将继续出现35℃以上的高温天气，北京、天津、河北中南部、山东中北部等地部分地区最高气温可达40℃左右。\\n\\n 气象监测显示，22日8时至16时，北京、天津、河北中部、山东北部等地气温上升迅猛，最高气温升至40℃以上。上述4省份共有17个国家气象观测站最高气温突破历史极值。&#x27;, 1, 1, 0, &#x27;2023-06-25 09:31:36&#x27;, &#x27;2023-06-25 09:31:36&#x27;, 0);INSERT INTO `news_headline` (hid,title,article,TYPE,publisher,page_views,create_time,update_time,is_deleted) VALUES (5, &#x27;江南水乡 龙舟竞渡&#x27;, &#x27;江南水乡 龙舟竞渡---6月18日，浙江省湖州市“我们的节日·端午”暨第七届江南·民当端午民俗文化旅游节在南浔区和孚镇民当村开幕，来自南浔区各个乡镇的农民选手在河道中赛龙舟、划菱桶，体验传统端午民俗。&#x27;, 1, 1, 0, &#x27;2023-06-25 09:32:13&#x27;, &#x27;2023-06-25 09:32:13&#x27;, 0);INSERT INTO `news_headline` (hid,title,article,TYPE,publisher,page_views,create_time,update_time,is_deleted) VALUES (6, &#x27;螃蟹粽、印花蛋、艾草凉粉……你知道端午有哪些创意美食吗？&#x27;, &#x27;端午有旅行路上的见闻，有诗画里的艺术，也少不了舌尖上的风韵。听风入夏粽香佐茶，您还知道端午有哪些创意美食吗？端午至味，总少不了粽子这一味。甜的、咸的，肉馅的、蛋黄的、红枣的、豆沙的……一起来寻味端午！\\n\\n 古人其实早就喜欢把各种果干放进粽子里，美食家苏轼还发明了杨梅粽。《玉台新咏》中说，“酒中喜桃子，粽里觅杨梅。”后来苏轼曾借用过这个典故，在元祐三年所写的端午帖子中说，“不独盘中见卢橘，时于粽里得杨梅”。&#x27;, 1, 1, 0, &#x27;2023-06-25 09:32:40&#x27;, &#x27;2023-06-25 09:32:40&#x27;, 0);INSERT INTO `news_headline` (hid,title,article,TYPE,publisher,page_views,create_time,update_time,is_deleted) VALUES (7, &#x27;尼克斯拒绝执行罗斯球队选项 罗斯成自由球员&#x27;, &#x27;北京时间6月25日，据多方消息源报道，尼克斯拒绝执行德里克-罗斯下赛季的球队选项，罗斯成为完全自由球员。\\n\\n 34岁的罗斯在刚刚结束的赛季队内角色严重下滑，他仅出战27场比赛，场均登场12.5分钟，得到5.6分1.5篮板1.7助攻。\\n\\n 2021年，罗斯与尼克斯签下3年4300万美元的续约合同，其中最后一年为1560万美元球队选项。&#x27;, 2, 2, 0, &#x27;2023-06-25 09:34:26&#x27;, &#x27;2023-06-25 09:34:26&#x27;, 0);INSERT INTO `news_headline` (hid,title,article,TYPE,publisher,page_views,create_time,update_time,is_deleted) VALUES (8, &#x27;班凯罗承诺代表美国男篮打世界杯 名单仅差1人&#x27;, &#x27;北京时间6月25日，据著名NBA记者沙姆斯-查拉尼亚报道，魔术前锋保罗-班凯罗承诺将代表美国男篮参加2023年男篮世界杯。\\n\\n 班凯罗在刚刚结束的赛季场均能够砍下20.0分6.9篮板3.7助攻，获得了NBA2022-23赛季年度最佳新秀。&#x27;, 2, 2, 0, &#x27;2023-06-25 09:34:59&#x27;, &#x27;2023-06-25 09:34:59&#x27;, 0);INSERT INTO `news_headline` (hid,title,article,TYPE,publisher,page_views,create_time,update_time,is_deleted) VALUES (9, &#x27;F1加拿大大奖赛正赛：维斯塔潘冠军 阿隆索亚军&#x27;, &#x27;2023年F1加拿大大奖赛正式比赛结束。红牛车队维斯塔潘杆位发车一路轻松领跑，再次完成了Pole-to-Win！这是红牛车队历史上的第100座分站冠军！同时也是维斯塔潘F1生涯的第41座分站冠军，追平了“车神”埃尔顿·塞纳的冠军数！阿斯顿马丁车队阿隆索亚军，梅赛德斯车队汉密尔顿季军。&#x27;, 2, 2, 0, &#x27;2023-06-25 09:35:43&#x27;, &#x27;2023-06-25 09:35:43&#x27;, 0);INSERT INTO `news_headline` (hid,title,article,TYPE,publisher,page_views,create_time,update_time,is_deleted) VALUES (10, &#x27;CTCC绍兴柯桥站圆满落幕 张志强曹宏炜各取一冠&#x27;, &#x27;6月24日，2023赛季CTCC中国汽车场地职业联赛绍兴柯桥站在雨中的浙江国际赛车场上演了两回合决赛的巅峰角逐。在线上线下观众的共同见证下，超级杯-TCR中国系列赛、运动杯-长三角赛车节联袂献上高水平对决，以精彩的比赛献礼这个端午节假期！TCR 中国系列赛第三回合于今天上午率先开战。来自壳牌捷凯领克车队的张志强穿云破雾夺得冠军；夺得该回合亚军的是驾驶新赛车出战的东风本田车手高度，季军则由Z.SPEED N车队的张臻东斩获。这也是超级杯四冠王本赛季首次登台。&#x27;, 2, 2, 0, &#x27;2023-06-25 09:36:18&#x27;, &#x27;2023-06-25 09:36:18&#x27;, 0);INSERT INTO `news_headline` (hid,title,article,TYPE,publisher,page_views,create_time,update_time,is_deleted) VALUES (11, &#x27;国象联赛常规赛收兵：杭州银行第一 山东成功上岸&#x27;, &#x27;6月17日，“武陵山大裂谷杯”中国国际象棋甲级联赛常规赛在武陵云海国际酒店进行了最后一轮的争夺，杭州银行弈和山东队，抢到常规赛的冠军；山东队也是凭借这场平局，成功脱离保级区。本轮最大的悬念是第八名的争夺——在年底进行的甲级联赛总决赛中，前八名为上半区争冠组，保级无忧；而第九至十二名为保级区，不仅夺冠无望，还要为保级而苦战。&#x27;, 2, 2, 0, &#x27;2023-06-25 09:36:51&#x27;, &#x27;2023-06-25 09:36:51&#x27;, 0);INSERT INTO `news_headline` (hid,title,article,TYPE,publisher,page_views,create_time,update_time,is_deleted) VALUES (12, &#x27;围棋名宿解读高考作文:人生如棋 要先学会下“本手”&#x27;, &#x27;今年高考开考了，在语文考试后，体育借势冲上了社交媒体的热搜榜。奥运相关话题进入高考，是意料之中。不过当记者看到关于围棋术语“本手、妙手和俗手”的作文命题时，着实觉得有些难。在被迅速刷屏的朋友圈里，记者感受到了很多从业者的激动、兴奋乃至油然而生的自豪感。但也有人则为那些没学过棋的孩子感到担心，这么难的题目，究竟该如何解题？\\n\\n “围棋正在深入人心。题目有些难，‘俗手’如何定义？但确实应该先下好‘本手’。”翻到中国围棋协会副主席、国家围棋队领队华学明的这条朋友圈动态时，记者瞬间觉得这道公认的难题有了解题的思路。正如高考作文材料中所说，本手是基础。只有持之以恒地打好基础，补强短板，守住不发生系统性风险的底线，才有可能在本手的基础上，下出妙手，避免俗手。而如果脱离了基础，所谓的妙手很可能就是花拳绣腿，经不起推敲，更经不起对手的冲击。世界冠军柯洁表示：“很多人在对局中经常会拘泥于局部，下出假妙手。想下出真正的妙手，必须在平日里有一定的经验积累和训练，才可能完成真正卓越的妙手。”人生如棋，棋如人生。“其实人生中大部分时间都是在下本手”，围棋名宿曹大元九段说。&#x27;, 2, 2, 0, &#x27;2023-06-25 09:37:43&#x27;, &#x27;2023-06-25 09:37:43&#x27;, 0);INSERT INTO `news_headline` (hid,title,article,TYPE,publisher,page_views,create_time,update_time,is_deleted) VALUES (13, &#x27;不甘人后：被生成式AI弥漫的亚马逊&#x27;, &#x27;今年早些时候，随着ChatGPT席卷全球，亚马逊的经理们要求员工开动脑筋，想想如何使用人工智能（AI）聊天机器人技术来改进自家产品和工作流程。\\n\\n 其中一些想法被分享在一份名为《生成式AI——ChatGPT的影响和机会分析》的内部文件中。这份文件共列了ChatGPT和类似应用程序在亚马逊多个团队中的67个潜在应用案例。\\n\\n 早在20世纪90年代，亚马逊就靠在网上卖书创造了互联网界首个真正的商业奇迹。\\n\\n 随后，Kindle阅读器带来革命性体验，Alexa和Echo智能音箱又带来了语音计算，而AWS则创造了云计算行业，ChatGPT就运行在这个行业之上。\\n\\n 但这次热潮中拿到先发优势的是同为科技大厂的微软。微软现在是OpenAI背后的金主，且还在忙着把ChatGPT的底层技术融进微软产品和服务中。&#x27;, 4, 5, 0, &#x27;2023-06-25 09:40:20&#x27;, &#x27;2023-06-25 09:40:20&#x27;, 0);INSERT INTO `news_headline` (hid,title,article,TYPE,publisher,page_views,create_time,update_time,is_deleted) VALUES (14, &#x27;微创新超实用：米家旅行箱居然想到了这一点&#x27;, &#x27;旅行说走就走，除非老板没安排。名义上是旅游，实则执行任务，对内讲“为公司负重前行”，对外称“带薪游山玩水”，一介打工人，两副扑克脸，个中苦乐谁人知！\\n\\n“差旅人”精明如我，随身携带更偏向实用。\\n\\n必备日用之外，能路上买的尽量不带，华而不实的东西，往包里多塞一个都算我输。行李箱尺寸自然也要浓缩到小巧但够装的20英寸，拉着轻松又顺手，常用小物件转移到背包，“轻装上战场”。&#x27;, 4, 5, 0, &#x27;2023-06-25 09:41:04&#x27;, &#x27;2023-06-25 09:41:04&#x27;, 0);INSERT INTO `news_headline` (hid,title,article,TYPE,publisher,page_views,create_time,update_time,is_deleted) VALUES (15, &#x27;小鹏G6动态试驾：辅助驾驶很惊喜&#x27;, &#x27;这次我们开着小鹏G6上了赛道，又体验了最新版本的高速NGP和城市NGP，小鹏，还顺便测了下充电速度，那么小鹏G6驾驶感受如何？辅助驾驶表现怎么样？&#x27;, 4, 5, 0, &#x27;2023-06-25 09:42:07&#x27;, &#x27;2023-06-25 09:42:07&#x27;, 0);INSERT INTO `news_headline` (hid,title,article,TYPE,publisher,page_views,create_time,update_time,is_deleted) VALUES (16, &#x27;养车市场陷入低价内卷，“虎猫狗”还没等到春天&#x27;, &#x27;今年“618”期间，汽车后市场的玩家们都打出了“低价牌”。比如途虎养车宣布推出“6.18全民养车季”活动，在此期间北京车主可享受“轮胎买一送一”以及多品牌轮胎降价促销的活动。\\n\\n 与此同时，京东养车和天猫养车两大大厂玩家，在本次618期间也喊出了各自的营销口号。\\n\\n 前者不仅喊出了“养车爱车立省不止30%”的口号，还推出了轮胎、保养买贵赔两倍、“轮胎免费装、三年无忧质保”、5公里无服务门店赔双倍安装费等举措；天猫养车的618活动，则覆盖了更大的零部件范围，比如推出了空调清洗、机油和轮胎更换等低价服务。\\n\\n 这样看，在本次618期间，途虎养车、京东养车和天猫养车均贯彻着“以价换量”的战略，以至于让行业价格战一触即发。这些玩家会这样做，主要是为了与传统4S店、以及与彼此竞争，以便保证自身获得更多的市场份额。&#x27;, 4, 5, 0, &#x27;2023-06-25 09:42:51&#x27;, &#x27;2023-06-25 09:42:51&#x27;, 0);INSERT INTO `news_headline` (hid,title,article,TYPE,publisher,page_views,create_time,update_time,is_deleted) VALUES (17, &#x27;微软股价历史新高 聊天机器人技术潜力显现&#x27;, &#x27;周四，微软股价创下历史新高，成为今年继英伟达和苹果之后，又一家市值达到新高点的大型科技公司。这家软件巨头正致力于在其产品和服务中添加生成式人工智能功能，旨在全面改造其Office产品阵容，其中包括Excel、PowerPoint、Outlook和Word等。股价上涨3.2%，收于每股348.1美元，为2021年11月19日以来的最高收盘价。自今年初起，微软股价累计上涨了45%，市值增加约8006亿美元。微软持有OpenAI的大部分股份，这家初创公司凭借聊天机器人ChatGPT引发生成式人工智能的热潮。近几个月来，该工具广受欢迎，展示了聊天机器人技术所具有的巨大潜力。微软于今年1月宣布将再向OpenAI投资100亿美元。然而有报道称，微软与OpenAI之间既有合作，亦存竞争，这种特殊的双重关系导致了双方关系的紧张和潜在冲突。科技股如英伟达等同样受益于生成式人工智能技术的应用，各公司将此技术融入各自产品，进而推动相关芯片需求。英伟达股价今年已飙升192%，被视为最大赢家。&#x27;, 4, 5, 0, &#x27;2023-06-25 09:43:48&#x27;, &#x27;2023-06-25 09:43:48&#x27;, 0);INSERT INTO `news_headline` (hid,title,article,TYPE,publisher,page_views,create_time,update_time,is_deleted) VALUES (18, &#x27;再获11亿美元投资：蔚来“长期主义”的底气&#x27;, &#x27;如果说全系降价3万是李斌的“阳谋”，那么蔚来ET5T的发布，则是李斌的又一次诚意之作。\\n\\n ET5T是蔚来首款售价下探到30万元以下的新车，作为ET5的姐妹车型，ET5T和ET5的双车合璧，得以在30万以下快速开疆辟土。\\n\\n 这样的做法有迹可循：特斯拉曾经在Model Y上实践过，并大获成功。\\n\\n Model Y和Model 3共用平台，零部件复用率高达75%，研发成本骤降。尽管Model Y最初被用户吐槽是Model 3的放大版，但不置可否的是Model Y确实解决了用户对Model 3空间不足的槽点。\\n\\n 不过，最为关键的还是Model Y的价格足够低，直接降低了特斯拉的购买门槛，给那些对价格敏感，本犹豫要不要多花四五万的消费者一个充足的理由。\\n\\n 蔚来ET5T正在用一种经受了市场验证过的方式，直面与特斯拉的竞争。但同时，蔚来ET5T在智能化、空间表现、设计以及产品力上，都正在接近、超越特斯拉Model Y。\\n\\n 蔚来ET5T，平替特斯拉Model Y？\\n\\n 小家庭，预算30万左右，消费者到底会选哪款纯电动车？\\n\\n 全球市场的反馈是，特斯拉Model Y ——一款紧凑型SUV。2022年，Model Y的全球销量为74.7万辆，其在中国的销量为31.5万台，约占其全球份额的42.2%。\\n\\n 按照车型大小，SUV可以分为大型、中型、小型、紧凑型四大类。按照价位，SUV又可以分为实用型、经济型、中高档型、豪华型、超豪华型等。\\n\\n Model Y 在中高端SUV的细分市场中一骑绝尘，可以说是没有对手。因为无论是奔驰EQC、宝马iX3，还是国产的比亚迪唐EV等，和Model Y相比，都不能对其构成威胁。奔驰EQC、宝马iX3这两款车型都是“油改电”，算不上真正的电动车。而比亚迪的智能化能力，远及不特斯拉，座舱、智驾上的核心模块还来自于供应商方案，并非自研。\\n\\n 雷峰网认为，此前，国内的自主品牌中只有蔚来的ES6能和Model Y一较高下。不过ES6的均价比Model Y高出一大截，二者入门版之间的价差大约在10万左右。但在蔚来推出ET5T后，局势必然会发生逆转。&#x27;, 4, 5, 0, &#x27;2023-06-25 09:44:20&#x27;, &#x27;2023-06-25 09:44:20&#x27;, 0);-- ------------------------------ Table structure for news_type-- ----------------------------DROP TABLE IF EXISTS `news_type`;CREATE TABLE `news_type` ( `tid` INT NOT NULL AUTO_INCREMENT COMMENT &#x27;新闻类型id&#x27;, `tname` VARCHAR(10) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT &#x27;新闻类型描述&#x27;, `version` INT DEFAULT 1 COMMENT &#x27;乐观锁&#x27;, `is_deleted` INT DEFAULT 0 COMMENT &#x27;头条是否被删除 1 删除 0 未删除&#x27;, PRIMARY KEY (`tid`) USING BTREE) ENGINE = INNODB AUTO_INCREMENT = 8 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = DYNAMIC;-- ------------------------------ Records of news_type-- ----------------------------INSERT INTO `news_type` (tid,tname) VALUES (1, &#x27;新闻&#x27;);INSERT INTO `news_type` (tid,tname) VALUES (2, &#x27;体育&#x27;);INSERT INTO `news_type` (tid,tname) VALUES (3, &#x27;娱乐&#x27;);INSERT INTO `news_type` (tid,tname) VALUES (4, &#x27;科技&#x27;);INSERT INTO `news_type` (tid,tname) VALUES (5, &#x27;其他&#x27;);-- ------------------------------ Table structure for news_user-- ----------------------------DROP TABLE IF EXISTS `news_user`;CREATE TABLE `news_user` ( `uid` INT NOT NULL AUTO_INCREMENT COMMENT &#x27;用户id&#x27;, `username` VARCHAR(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT &#x27;用户登录名&#x27;, `user_pwd` VARCHAR(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT &#x27;用户登录密码密文&#x27;, `nick_name` VARCHAR(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT &#x27;用户昵称&#x27;, `version` INT DEFAULT 1 COMMENT &#x27;乐观锁&#x27;, `is_deleted` INT DEFAULT 0 COMMENT &#x27;头条是否被删除 1 删除 0 未删除&#x27;, PRIMARY KEY (`uid`) USING BTREE, UNIQUE INDEX `username_unique`(`username`) USING BTREE) ENGINE = INNODB AUTO_INCREMENT = 9 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = DYNAMIC;-- ------------------------------ Records of news_user-- ----------------------------INSERT INTO `news_user` (uid,username,user_pwd,nick_name) VALUES (1, &#x27;zhangsan&#x27;, &#x27;e10adc3949ba59abbe56e057f20f883e&#x27;, &#x27;张三&#x27;);INSERT INTO `news_user` (uid,username,user_pwd,nick_name) VALUES (2, &#x27;lisi&#x27;, &#x27;e10adc3949ba59abbe56e057f20f883e&#x27;, &#x27;李四&#x27;);INSERT INTO `news_user` (uid,username,user_pwd,nick_name) VALUES (5, &#x27;zhangxiaoming&#x27;, &#x27;e10adc3949ba59abbe56e057f20f883e&#x27;, &#x27;张小明&#x27;);INSERT INTO `news_user` (uid,username,user_pwd,nick_name)VALUES (6, &#x27;xiaohei&#x27;, &#x27;e10adc3949ba59abbe56e057f20f883e&#x27;, &#x27;李小黑&#x27;);SET FOREIGN_KEY_CHECKS = 1; 2. 搭建SprintBoot工程 创建boot工程 导入依赖 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;3.0.5&lt;/version&gt;&lt;/parent&gt;&lt;groupId&gt;com.atguigu&lt;/groupId&gt;&lt;artifactId&gt;springboot-headline&lt;/artifactId&gt;&lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;&lt;properties&gt; &lt;maven.compiler.source&gt;17&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;17&lt;/maven.compiler.target&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;&lt;/properties&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- mybatis-plus --&gt; &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.5.3.1&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 数据库相关配置启动器 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- druid启动器的依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-3-starter&lt;/artifactId&gt; &lt;version&gt;1.2.18&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 驱动类--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.28&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.28&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt;&lt;/dependencies&gt; org.springframework.boot spring-boot-maven-plugin 123456789101112131415161718192021222324252627283. 编写配置 application.yaml ```yaml # server配置 server: port: 8080 servlet: context-path: / # 连接池配置 spring: datasource: type: com.alibaba.druid.pool.DruidDataSource druid: url: jdbc:mysql:///sm_db1 username: root password: root driver-class-name: com.mysql.cj.jdbc.Driver # mybatis-plus的配置 mybatis-plus: type-aliases-package: com.atguigu.pojo global-config: db-config: logic-delete-field: isDeleted #全局逻辑删除 id-type: auto #主键策略自增长 table-prefix: news_ # 设置表的前缀 druid兼容springboot3文件 文件名和内容 12文件名:org.springframework.boot.autoconfigure.AutoConfiguration.imports内容:com.alibaba.druid.spring.boot3.autoconfigure.DruidDataSourceAutoConfigure 启动类和mybatis-plus配置 包: com.atguigu 1234567891011121314151617181920@SpringBootApplication@MapperScan(&quot;com.atguigu.mapper&quot;)public class Main &#123; public static void main(String[] args) &#123; SpringApplication.run(Main.class,args); &#125; //配置mybatis-plus插件 @Bean public MybatisPlusInterceptor mybatisPlusInterceptor() &#123; MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor(); interceptor.addInnerInterceptor(new PaginationInnerInterceptor(DbType.MYSQL)); //分页 interceptor.addInnerInterceptor(new OptimisticLockerInnerInterceptor()); //乐观锁 interceptor.addInnerInterceptor(new BlockAttackInnerInterceptor()); //防全局修改和删除 return interceptor; &#125;&#125; 工具类准备 结果封装类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667/** * 全局统一返回结果类 */public class Result&lt;T&gt; &#123; // 返回码 private Integer code; // 返回消息 private String message; // 返回数据 private T data; public Result()&#123;&#125; // 返回数据 protected static &lt;T&gt; Result&lt;T&gt; build(T data) &#123; Result&lt;T&gt; result = new Result&lt;T&gt;(); if (data != null) result.setData(data); return result; &#125; public static &lt;T&gt; Result&lt;T&gt; build(T body, Integer code, String message) &#123; Result&lt;T&gt; result = build(body); result.setCode(code); result.setMessage(message); return result; &#125; public static &lt;T&gt; Result&lt;T&gt; build(T body, ResultCodeEnum resultCodeEnum) &#123; Result&lt;T&gt; result = build(body); result.setCode(resultCodeEnum.getCode()); result.setMessage(resultCodeEnum.getMessage()); return result; &#125; /** * 操作成功 * @param data baseCategory1List * @param &lt;T&gt; * @return */ public static&lt;T&gt; Result&lt;T&gt; ok(T data)&#123; Result&lt;T&gt; result = build(data); return build(data, ResultCodeEnum.SUCCESS); &#125; public Result&lt;T&gt; message(String msg)&#123; this.setMessage(msg); return this; &#125; public Result&lt;T&gt; code(Integer code)&#123; this.setCode(code); return this; &#125; public Integer getCode() &#123; return code; &#125; public void setCode(Integer code) &#123; this.code = code; &#125; public String getMessage() &#123; return message; &#125; public void setMessage(String message) &#123; this.message = message; &#125; public T getData() &#123; return data; &#125; public void setData(T data) &#123; this.data = data; &#125;&#125; 解决枚举类 1234567891011121314151617181920212223242526/** * 统一返回结果状态信息类 * */public enum ResultCodeEnum &#123; SUCCESS(200,&quot;success&quot;), USERNAME_ERROR(501,&quot;usernameError&quot;), PASSWORD_ERROR(503,&quot;passwordError&quot;), NOTLOGIN(504,&quot;notLogin&quot;), USERNAME_USED(505,&quot;userNameUsed&quot;); private Integer code; private String message; private ResultCodeEnum(Integer code, String message) &#123; this.code = code; this.message = message; &#125; public Integer getCode() &#123; return code; &#125; public String getMessage() &#123; return message; &#125;&#125; MD5加密工具类 12345678910111213141516171819202122232425262728import java.security.MessageDigest;import java.security.NoSuchAlgorithmException;@Componentpublic final class MD5Util &#123; public static String encrypt(String strSrc) &#123; try &#123; char hexChars[] = &#123; &#x27;0&#x27;, &#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;4&#x27;, &#x27;5&#x27;, &#x27;6&#x27;, &#x27;7&#x27;, &#x27;8&#x27;, &#x27;9&#x27;, &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;, &#x27;f&#x27; &#125;; byte[] bytes = strSrc.getBytes(); MessageDigest md = MessageDigest.getInstance(&quot;MD5&quot;); md.update(bytes); bytes = md.digest(); int j = bytes.length; char[] chars = new char[j * 2]; int k = 0; for (int i = 0; i &lt; bytes.length; i++) &#123; byte b = bytes[i]; chars[k++] = hexChars[b &gt;&gt;&gt; 4 &amp; 0xf]; chars[k++] = hexChars[b &amp; 0xf]; &#125; return new String(chars); &#125; catch (NoSuchAlgorithmException e) &#123; e.printStackTrace(); throw new RuntimeException(&quot;MD5加密出错！！+&quot; + e); &#125; &#125;&#125; 3. MybatisX逆向工程 逆向工程 完善实体类注解 删除tableName注解,全局统一设置 添加主键,乐观锁,逻辑删除注解!!! 1234567891011121314151617181920@Datapublic class User implements Serializable &#123; @TableId private Integer uid; private String username; private String userPwd; private String nickName; @Version private Integer version; @TableLogic private Integer isDeleted; private static final long serialVersionUID = 1L;&#125; 四、后台功能开发4.1 用户模块开发 1.1 jwt和token介绍 token介绍 令牌（Token）：在计算机领域，令牌是一种代表某种访问权限或身份认证信息的令牌。它可以是一串随机生成的字符或数字，用于验证用户的身份或授权用户对特定资源的访问。普通的令牌可能以各种形式出现，如访问令牌、身份令牌、刷新令牌等。 简单理解 : 每个用户生成的唯一字符串标识,可以进行用户识别和校验 类似技术: 天王盖地虎 ,小鸡炖蘑菇 优势: token验证标识无法直接识别用户的信息,盗取token后也无法`登录`程序! 相对安全! jwt介绍 Token是一项规范和标准(接口) JWT(JSON Web Token)是具体可以生成,校验,解析等动作Token的技术(实现类) jwt工作流程 用户提供其凭据（通常是用户名和密码）进行身份验证。 服务器对这些凭据进行验证，并在验证成功后创建一个JWT。 服务器将JWT发送给客户端，并客户端在后续的请求中将JWT附加在请求头或参数中。 服务器接收到请求后，验证JWT的签名和有效性，并根据JWT中的声明进行身份验证和授权操作 jwt数据组成和包含信息 JWT由三部分组成: header(头部).payload(载荷).signature(签名) 我们需要理解的是, jwt可以携带很多信息! 一般情况,需要加入:有效时间,签名秘钥,其他用户标识信息! 有效时间为了保证token的时效性,过期可以重新登录获取! 签名秘钥为了防止其他人随意解析和校验token数据! 用户信息为了我们自己解析的时候,知道Token对应的具体用户! jwt使用和测试 导入依赖 1234567891011&lt;dependency&gt; &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt; &lt;artifactId&gt;jjwt&lt;/artifactId&gt; &lt;version&gt;0.9.1&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;javax.xml.bind&lt;/groupId&gt; &lt;artifactId&gt;jaxb-api&lt;/artifactId&gt; &lt;version&gt;2.3.0&lt;/version&gt;&lt;/dependency&gt; 编写配置 application.yaml 12345#jwt配置jwt: token: tokenExpiration: 120 #有效时间,单位分钟 tokenSignKey: headline123456 #当前程序签名秘钥 自定义 导入工具类 封装jwt技术工具类 123456789101112131415161718192021222324252627282930313233343536373839404142package com.atguigu.utils;import com.alibaba.druid.util.StringUtils;import io.jsonwebtoken.*;import lombok.Data;import org.springframework.boot.context.properties.ConfigurationProperties;import org.springframework.context.annotation.Configuration;import org.springframework.stereotype.Component;import java.util.Date;@Data@Component@ConfigurationProperties(prefix = &quot;jwt.token&quot;)public class JwtHelper &#123; private long tokenExpiration; //有效时间,单位毫秒 1000毫秒 == 1秒 private String tokenSignKey; //当前程序签名秘钥 //生成token字符串 public String createToken(Long userId) &#123; System.out.println(&quot;tokenExpiration = &quot; + tokenExpiration); System.out.println(&quot;tokenSignKey = &quot; + tokenSignKey); String token = Jwts.builder() .setSubject(&quot;YYGH-USER&quot;) .setExpiration(new Date(System.currentTimeMillis() + tokenExpiration*1000*60)) //单位分钟 .claim(&quot;userId&quot;, userId) .signWith(SignatureAlgorithm.HS512, tokenSignKey) .compressWith(CompressionCodecs.GZIP) .compact(); return token; &#125; //从token字符串获取userid public Long getUserId(String token) &#123; if(StringUtils.isEmpty(token)) return null; Jws&lt;Claims&gt; claimsJws = Jwts.parser().setSigningKey(tokenSignKey).parseClaimsJws(token); Claims claims = claimsJws.getBody(); Integer userId = (Integer)claims.get(&quot;userId&quot;); return userId.longValue(); &#125; //判断token是否有效 public boolean isExpiration(String token)&#123; try &#123; boolean isExpire = Jwts.parser() .setSigningKey(tokenSignKey) .parseClaimsJws(token) .getBody() .getExpiration().before(new Date()); //没有过期，有效，返回false return isExpire; &#125;catch(Exception e) &#123; //过期出现异常，返回true return true; &#125; &#125; &#125; 1234567891011121314151617181920212223244. 使用和测试 ```java @org.springframework.boot.test.context.SpringBootTest public class SpringBootTest &#123; @Autowired private JwtHelper jwtHelper; @Test public void test()&#123; //生成 传入用户标识 String token = jwtHelper.createToken(1L); System.out.println(&quot;token = &quot; + token); //解析用户标识 int userId = jwtHelper.getUserId(token).intValue(); System.out.println(&quot;userId = &quot; + userId); //校验是否到期! false 未到期 true到期 boolean expiration = jwtHelper.isExpiration(token); System.out.println(&quot;expiration = &quot; + expiration); &#125; &#125; 1.2 登录功能实现 需求描述 用户在客户端输入用户名密码并向后端提交,后端根据用户名和密码判断登录是否成功,用户有误或者密码有误响应不同的提示信息！ 接口描述 url地址： user&#x2F;login 请求方式：POST 请求参数： 1234&#123; &quot;username&quot;:&quot;zhangsan&quot;, //用户名 &quot;userPwd&quot;:&quot;123456&quot; //明文密码&#125; 响应数据： 成功 1234567&#123; &quot;code&quot;:&quot;200&quot;, // 成功状态码 &quot;message&quot;:&quot;success&quot; // 成功状态描述 &quot;data&quot;:&#123; &quot;token&quot;:&quot;... ...&quot; // 用户id的token &#125;&#125; 失败 12345&#123; &quot;code&quot;:&quot;501&quot;, &quot;message&quot;:&quot;用户名有误&quot; &quot;data&quot;:&#123;&#125;&#125; 12345&#123; &quot;code&quot;:&quot;503&quot;, &quot;message&quot;:&quot;密码有误&quot; &quot;data&quot;:&#123;&#125;&#125; 实现代码 controller1234@RestController@RequestMapping(&quot;user&quot;)@CrossOriginpublic class UserController &#123; @Autowired private UserService userService; /** * 登录需求 * 地址: /user/login * 方式: post * 参数: * &#123; * &quot;username&quot;:&quot;zhangsan&quot;, //用户名 * &quot;userPwd&quot;:&quot;123456&quot; //明文密码 * &#125; * 返回: * &#123; * &quot;code&quot;:&quot;200&quot;, // 成功状态码 * &quot;message&quot;:&quot;success&quot; // 成功状态描述 * &quot;data&quot;:&#123; * &quot;token&quot;:&quot;... ...&quot; // 用户id的token * &#125; * &#125; * * 大概流程: * 1. 账号进行数据库查询 返回用户对象 * 2. 对比用户密码(md5加密) * 3. 成功,根据userId生成token -&gt; map key=token value=token值 - result封装 * 4. 失败,判断账号还是密码错误,封装对应的枚举错误即可 */ @PostMapping(&quot;login&quot;) public Result login(@RequestBody User user)&#123; Result result = userService.login(user); System.out.println(&quot;result = &quot; + result); return result; &#125; &#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546472. service ```java @Service public class UserServiceImpl extends ServiceImpl&lt;UserMapper, User&gt; implements UserService&#123; @Autowired private JwtHelper jwtHelper; @Autowired private UserMapper userMapper; /** * 登录业务实现 * @param user * @return result封装 */ @Override public Result login(User user) &#123; //根据账号查询 LambdaQueryWrapper&lt;User&gt; queryWrapper = new LambdaQueryWrapper&lt;&gt;(); queryWrapper.eq(User::getUsername,user.getUsername()); User loginUser = userMapper.selectOne(queryWrapper); //账号判断 if (loginUser == null) &#123; //账号错误 return Result.build(null, ResultCodeEnum.USERNAME_ERROR); &#125; //判断密码 if (!StringUtils.isEmpty(user.getUserPwd()) &amp;&amp; loginUser.getUserPwd().equals(MD5Util.encrypt(user.getUserPwd()))) &#123; //账号密码正确 //根据用户唯一标识生成token String token = jwtHelper.createToken(Long.valueOf(loginUser.getUid())); Map data = new HashMap(); data.put(&quot;token&quot;,token); return Result.ok(data); &#125; //密码错误 return Result.build(null,ResultCodeEnum.PASSWORD_ERROR); &#125; &#125; 1.3 根据token获取用户数据 需求描述 客户端发送请求,提交token请求头,后端根据token请求头获取登录用户的详细信息并响应给客户端进行存储 接口描述 url地址：user&#x2F;getUserInfo 请求方式：GET 请求头： 1token: token内容 响应数据： 成功 123456789101112&#123; &quot;code&quot;: 200, &quot;message&quot;: &quot;success&quot;, &quot;data&quot;: &#123; &quot;loginUser&quot;: &#123; &quot;uid&quot;: 1, &quot;username&quot;: &quot;zhangsan&quot;, &quot;userPwd&quot;: &quot;&quot;, &quot;nickName&quot;: &quot;张三&quot; &#125; &#125;&#125; 失败 12345&#123; &quot;code&quot;: 504, &quot;message&quot;: &quot;notLogin&quot;, &quot;data&quot;: null&#125; 代码实现 controller1234567891011121314151617181920212223242526272829/** * 地址: user/getUserInfo * 方式: get * 请求头: token = token内容 * 返回: * &#123; * &quot;code&quot;: 200, * &quot;message&quot;: &quot;success&quot;, * &quot;data&quot;: &#123; * &quot;loginUser&quot;: &#123; * &quot;uid&quot;: 1, * &quot;username&quot;: &quot;zhangsan&quot;, * &quot;userPwd&quot;: &quot;&quot;, * &quot;nickName&quot;: &quot;张三&quot; * &#125; * &#125; * &#125; * * 大概流程: * 1.获取token,解析token对应的userId * 2.根据userId,查询用户数据 * 3.将用户数据的密码置空,并且把用户数据封装到结果中key = loginUser * 4.失败返回504 (本次先写到当前业务,后期提取到拦截器和全局异常处理器) */@GetMapping(&quot;getUserInfo&quot;)public Result userInfo(@RequestHeader String token)&#123; Result result = userService.getUserInfo(token); return result;&#125; service1234567891011121314151617181920212223242526272829/** * 查询用户数据 * @param token * @return result封装 */@Overridepublic Result getUserInfo(String token) &#123; //1.判定是否有效期 if (jwtHelper.isExpiration(token)) &#123; //true过期,直接返回未登录 return Result.build(null,ResultCodeEnum.NOTLOGIN); &#125; //2.获取token对应的用户 int userId = jwtHelper.getUserId(token).intValue(); //3.查询数据 User user = userMapper.selectById(userId); if (user != null) &#123; user.setUserPwd(null); Map data = new HashMap(); data.put(&quot;loginUser&quot;,user); return Result.ok(data); &#125; return Result.build(null,ResultCodeEnum.NOTLOGIN);&#125; 1.4 注册用户名检查 需求描述 用户在注册时输入用户名时,立刻将用户名发送给后端,后端根据用户名查询用户名是否可用并做出响应 接口描述 url地址：user&#x2F;checkUserName 请求方式：POST 请求参数：param形式 1username=zhangsan 响应数据： 成功 12345&#123; &quot;code&quot;:&quot;200&quot;, &quot;message&quot;:&quot;success&quot; &quot;data&quot;:&#123;&#125;&#125; 失败 12345&#123; &quot;code&quot;:&quot;505&quot;, &quot;message&quot;:&quot;用户名占用&quot; &quot;data&quot;:&#123;&#125;&#125; 代码实现 controller12345678910111213141516171819202122/** * url地址：user/checkUserName * 请求方式：POST * 请求参数：param形式 * username=zhangsan * 响应数据: * &#123; * &quot;code&quot;:&quot;200&quot;, * &quot;message&quot;:&quot;success&quot; * &quot;data&quot;:&#123;&#125; * &#125; * * 实现步骤: * 1. 获取账号数据 * 2. 根据账号进行数据库查询 * 3. 结果封装 */@PostMapping(&quot;checkUserName&quot;)public Result checkUserName(String username)&#123; Result result = userService.checkUserName(username); return result;&#125; service&#x20;12345678910111213141516171819/** * 检查账号是否可以注册 * * @param username 账号信息 * @return */@Overridepublic Result checkUserName(String username) &#123; LambdaQueryWrapper&lt;User&gt; queryWrapper = new LambdaQueryWrapper&lt;&gt;(); queryWrapper.eq(User::getUsername,username); User user = userMapper.selectOne(queryWrapper); if (user != null)&#123; return Result.build(null,ResultCodeEnum.USERNAME_USED); &#125; return Result.ok(null);&#125; 1.5 用户注册功能 需求描述 客户端将新用户信息发送给服务端,服务端将新用户存入数据库,存入之前做用户名是否被占用校验,校验通过响应成功提示,否则响应失败提示 接口描述 url地址：user&#x2F;regist 请求方式：POST 请求参数： 12345&#123; &quot;username&quot;:&quot;zhangsan&quot;, &quot;userPwd&quot;:&quot;123456&quot;, &quot;nickName&quot;:&quot;张三&quot;&#125; 响应数据： 成功 12345&#123; &quot;code&quot;:&quot;200&quot;, &quot;message&quot;:&quot;success&quot; &quot;data&quot;:&#123;&#125;&#125; 失败 12345&#123; &quot;code&quot;:&quot;505&quot;, &quot;message&quot;:&quot;用户名占用&quot; &quot;data&quot;:&#123;&#125;&#125; 代码实现 controller123456789101112131415161718192021222324252627/*** url地址：user/regist* 请求方式：POST* 请求参数：* &#123;* &quot;username&quot;:&quot;zhangsan&quot;,* &quot;userPwd&quot;:&quot;123456&quot;,* &quot;nickName&quot;:&quot;张三&quot;* &#125;* 响应数据：* &#123;* &quot;code&quot;:&quot;200&quot;,* &quot;message&quot;:&quot;success&quot;* &quot;data&quot;:&#123;&#125;* &#125;** 实现步骤:* 1. 将密码加密* 2. 将数据插入* 3. 判断结果,成 返回200 失败 505*/@PostMapping(&quot;regist&quot;)public Result regist(@RequestBody User user)&#123; Result result = userService.regist(user); return result;&#125; service&#x20;123456789101112131415@Overridepublic Result regist(User user) &#123; LambdaQueryWrapper&lt;User&gt; queryWrapper = new LambdaQueryWrapper&lt;&gt;(); queryWrapper.eq(User::getUsername,user.getUsername()); Long count = userMapper.selectCount(queryWrapper); if (count &gt; 0)&#123; return Result.build(null,ResultCodeEnum.USERNAME_USED); &#125; user.setUserPwd(MD5Util.encrypt(user.getUserPwd())); int rows = userMapper.insert(user); System.out.println(&quot;rows = &quot; + rows); return Result.ok(null);&#125; 4.2 首页模块开发 2.1 查询首页分类 需求描述 进入新闻首页,查询所有分类并动态展示新闻类别栏位 接口描述 url地址：portal&#x2F;findAllTypes 请求方式：get 请求参数：无 响应数据： 成功 12345678910111213141516171819202122232425262728&#123; &quot;code&quot;:&quot;200&quot;, &quot;message&quot;:&quot;OK&quot; &quot;data&quot;:&#123; [ &#123; &quot;tid&quot;:&quot;1&quot;, &quot;tname&quot;:&quot;新闻&quot; &#125;, &#123; &quot;tid&quot;:&quot;2&quot;, &quot;tname&quot;:&quot;体育&quot; &#125;, &#123; &quot;tid&quot;:&quot;3&quot;, &quot;tname&quot;:&quot;娱乐&quot; &#125;, &#123; &quot;tid&quot;:&quot;4&quot;, &quot;tname&quot;:&quot;科技&quot; &#125;, &#123; &quot;tid&quot;:&quot;5&quot;, &quot;tname&quot;:&quot;其他&quot; &#125; ] &#125;&#125; 代码实现 controller12345678910111213141516171819@RestController@RequestMapping(&quot;portal&quot;)@CrossOriginpublic class PortalController &#123; @Autowired private TypeService typeService; /** * 查询全部类别信息 * @return */ @GetMapping(&quot;findAllTypes&quot;) public Result findAllTypes()&#123; //直接调用业务层,查询全部数据 List&lt;Type&gt; list = typeService.list(); return Result.ok(list); &#125;&#125; 2.2 分页查询首页头条信息 需求描述 客户端向服务端发送查询关键字,新闻类别,页码数,页大小 服务端根据条件搜索分页信息,返回含页码数,页大小,总页数,总记录数,当前页数据等信息,并根据时间降序,浏览量降序排序 接口描述 url地址：portal&#x2F;findNewsPage 请求方式：post 请求参数: 123456&#123; &quot;keyWords&quot;:&quot;马斯克&quot;, // 搜索标题关键字 &quot;type&quot;:0, // 新闻类型 &quot;pageNum&quot;:1, // 页码数 &quot;pageSize&quot;:10 // 页大小&#125; 响应数据： 成功 1234567891011121314151617181920212223242526272829303132333435363738&#123; &quot;code&quot;:&quot;200&quot;, &quot;message&quot;:&quot;success&quot; &quot;data&quot;:&#123; &quot;pageInfo&quot;:&#123; &quot;pageData&quot;:[ &#123; &quot;hid&quot;:&quot;1&quot;, // 新闻id &quot;title&quot;:&quot;尚硅谷宣布 ... ...&quot;, // 新闻标题 &quot;type&quot;:&quot;1&quot;, // 新闻所属类别编号 &quot;pageViews&quot;:&quot;40&quot;, // 新闻浏览量 &quot;pastHours&quot;:&quot;3&quot; , // 发布时间已过小时数 &quot;publisher&quot;:&quot;1&quot; // 发布用户ID &#125;, &#123; &quot;hid&quot;:&quot;1&quot;, // 新闻id &quot;title&quot;:&quot;尚硅谷宣布 ... ...&quot;, // 新闻标题 &quot;type&quot;:&quot;1&quot;, // 新闻所属类别编号 &quot;pageViews&quot;:&quot;40&quot;, // 新闻浏览量 &quot;pastHours&quot;:&quot;3&quot;, // 发布时间已过小时数 &quot;publisher&quot;:&quot;1&quot; // 发布用户ID &#125;, &#123; &quot;hid&quot;:&quot;1&quot;, // 新闻id &quot;title&quot;:&quot;尚硅谷宣布 ... ...&quot;, // 新闻标题 &quot;type&quot;:&quot;1&quot;, // 新闻所属类别编号 &quot;pageViews&quot;:&quot;40&quot;, // 新闻浏览量 &quot;pastHours&quot;:&quot;3&quot;, // 发布时间已过小时数 &quot;publisher&quot;:&quot;1&quot; // 发布用户ID &#125; ], &quot;pageNum&quot;:1, //页码数 &quot;pageSize&quot;:10, // 页大小 &quot;totalPage&quot;:20, // 总页数 &quot;totalSize&quot;:200 // 总记录数 &#125; &#125;&#125; 代码实现 准备条件实体类 12345678@Datapublic class PortalVo &#123; private String keyWords; private Integer type; private Integer pageNum = 1; private Integer pageSize =10;&#125; controller 123456789/** * 首页分页查询 * @return */@PostMapping(&quot;findNewPage&quot;)public Result findNewPage(@RequestBody PortalVo portalVo)&#123; Result result = headlineService.findNewPage(portalVo); return result;&#125; service 12345678910111213141516171819202122232425262728293031323334353637383940414243@Servicepublic class HeadlineServiceImpl extends ServiceImpl&lt;HeadlineMapper, Headline&gt; implements HeadlineService&#123; @Autowired private HeadlineMapper headlineMapper; /** * 首页数据查询 * @param portalVo * @return */ @Override public Result findNewPage(PortalVo portalVo) &#123; //1.条件拼接 需要非空判断 LambdaQueryWrapper&lt;Headline&gt; queryWrapper = new LambdaQueryWrapper&lt;&gt;(); queryWrapper.like(!StringUtils.isEmpty(portalVo.getKeyWords()),Headline::getTitle,portalVo.getKeyWords()) .eq(portalVo.getType()!= null,Headline::getType,portalVo.getType()); //2.分页参数 IPage&lt;Headline&gt; page = new Page&lt;&gt;(portalVo.getPageNum(),portalVo.getPageSize()); //3.分页查询 //查询的结果 &quot;pastHours&quot;:&quot;3&quot; // 发布时间已过小时数 我们查询返回一个map //自定义方法 headlineMapper.selectPageMap(page, portalVo); //4.结果封装 //分页数据封装 Map&lt;String,Object&gt; pageInfo =new HashMap&lt;&gt;(); pageInfo.put(&quot;pageData&quot;,page.getRecords()); pageInfo.put(&quot;pageNum&quot;,page.getCurrent()); pageInfo.put(&quot;pageSize&quot;,page.getSize()); pageInfo.put(&quot;totalPage&quot;,page.getPages()); pageInfo.put(&quot;totalSize&quot;,page.getTotal()); Map&lt;String,Object&gt; pageInfoMap=new HashMap&lt;&gt;(); pageInfoMap.put(&quot;pageInfo&quot;,pageInfo); // 响应JSON return Result.ok(pageInfoMap); &#125;&#125; mapper 接口: 123456public interface HeadlineMapper extends BaseMapper&lt;Headline&gt; &#123; //自定义分页查询方法 IPage&lt;Map&gt; selectPageMap(IPage&lt;Headline&gt; page, @Param(&quot;portalVo&quot;) PortalVo portalVo);&#125; mapperxml: 12345678910&lt;select id=&quot;selectPageMap&quot; resultType=&quot;map&quot;&gt; select hid,title,type,page_views pageViews,TIMESTAMPDIFF(HOUR,create_time,NOW()) pastHours, publisher from news_headline where is_deleted=0 &lt;if test=&quot;portalVo.keyWords !=null and portalVo.keyWords.length()&gt;0 &quot;&gt; and title like concat(&#x27;%&#x27;,#&#123;portalVo.keyWords&#125;,&#x27;%&#x27;) &lt;/if&gt; &lt;if test=&quot;portalVo.type != null and portalVo.type != 0&quot;&gt; and type = #&#123;portalVo.type&#125; &lt;/if&gt;&lt;/select&gt; 2.3 查询头条详情 需求描述 用户点击”查看全文”时,向服务端发送新闻id 后端根据新闻id查询完整新闻文章信息并返回 后端要同时让新闻的浏览量+1 接口描述 url地址：portal&#x2F;showHeadlineDetail 请求方式：post 请求参数: 1hid=1 param形成参数 响应数据： 成功 1234567891011121314151617&#123; &quot;code&quot;:&quot;200&quot;, &quot;message&quot;:&quot;success&quot;, &quot;data&quot;:&#123; &quot;headline&quot;:&#123; &quot;hid&quot;:&quot;1&quot;, // 新闻id &quot;title&quot;:&quot;马斯克宣布 ... ...&quot;, // 新闻标题 &quot;article&quot;:&quot;... ...&quot; // 新闻正文 &quot;type&quot;:&quot;1&quot;, // 新闻所属类别编号 &quot;typeName&quot;:&quot;科技&quot;, // 新闻所属类别 &quot;pageViews&quot;:&quot;40&quot;, // 新闻浏览量 &quot;pastHours&quot;:&quot;3&quot; , // 发布时间已过小时数 &quot;publisher&quot;:&quot;1&quot; , // 发布用户ID &quot;author&quot;:&quot;张三&quot; // 新闻作者 &#125; &#125;&#125; 代码实现 controller 12345678910 /** * 首页详情接口 * @param hid * @return */@PostMapping(&quot;showHeadlineDetail&quot;)public Result showHeadlineDetail(Integer hid)&#123; Result result = headlineService.showHeadlineDetail(hid); return result;&#125; service 12345678910111213141516171819202122232425262728293031323334/** * 详情数据查询 * &quot;headline&quot;:&#123; * &quot;hid&quot;:&quot;1&quot;, // 新闻id * &quot;title&quot;:&quot;马斯克宣布 ... ...&quot;, // 新闻标题 * &quot;article&quot;:&quot;... ...&quot; // 新闻正文 * &quot;type&quot;:&quot;1&quot;, // 新闻所属类别编号 * &quot;typeName&quot;:&quot;科技&quot;, // 新闻所属类别 * &quot;pageViews&quot;:&quot;40&quot;, // 新闻浏览量 * &quot;pastHours&quot;:&quot;3&quot; , // 发布时间已过小时数 * &quot;publisher&quot;:&quot;1&quot; , // 发布用户ID * &quot;author&quot;:&quot;张三&quot; // 新闻作者 * &#125; * 注意: 是多表查询 , 需要更新浏览量+1 * * @param hid * @return */@Overridepublic Result showHeadlineDetail(Integer hid) &#123; //1.实现根据id的查询(多表 Map headLineDetail = headlineMapper.selectDetailMap(hid); //2.拼接头条对象(阅读量和version)进行数据更新 Headline headline = new Headline(); headline.setHid(hid); headline.setPageViews((Integer) headLineDetail.get(&quot;pageViews&quot;)+1); //阅读量+1 headline.setVersion((Integer) headLineDetail.get(&quot;version&quot;)); //设置版本 headlineMapper.updateById(headline); Map&lt;String,Object&gt; pageInfoMap=new HashMap&lt;&gt;(); pageInfoMap.put(&quot;headline&quot;,headLineDetail); return Result.ok(pageInfoMap);&#125; mapper 接口: 123456/** * 分页查询头条详情 * @param hid * @return */Map selectDetailMap(Integer hid); mapperxml: 123456789&lt;!-- Map selectDetailMap(Integer hid);--&gt;&lt;select id=&quot;selectDetailMap&quot; resultType=&quot;map&quot;&gt; select hid,title,article,type, h.version ,tname typeName ,page_views pageViews ,TIMESTAMPDIFF(HOUR,create_time,NOW()) pastHours,publisher ,nick_name author from news_headline h left join news_type t on h.type = t.tid left join news_user u on h.publisher = u.uid where hid = #&#123;hid&#125;&lt;/select&gt; 4.3 头条模块开发 **3.1 登陆验证和保护 ** 需求描述 客户端在进入发布页前、发布新闻前、进入修改页前、修改前、删除新闻前先向服务端发送请求携带token请求头 后端接收token请求头后,校验用户登录是否过期并做响应 前端根据响应信息提示用户进入登录页还是进入正常业务页面 接口描述 url地址：user&#x2F;checkLogin 请求方式：get 请求参数: 无 请求头： token: 用户token 响应数据： 未过期： 12345&#123; &quot;code&quot;:&quot;200&quot;, &quot;message&quot;:&quot;success&quot;, &quot;data&quot;:&#123;&#125;&#125; 过期： 12345&#123; &quot;code&quot;:&quot;504&quot;, &quot;message&quot;:&quot;loginExpired&quot;, &quot;data&quot;:&#123;&#125;&#125; 代码实现 controller 【登录检查】123456789@GetMapping(&quot;checkLogin&quot;)public Result checkLogin(@RequestHeader String token)&#123; if (StringUtils.isEmpty(token) || jwtHelper.isExpiration(token))&#123; //没有传或者过期 未登录 return Result.build(null, ResultCodeEnum.NOTLOGIN); &#125; return Result.ok(null);&#125; 拦截器 【所有&#x2F;headline开头都需要检查登陆】1234567891011121314151617181920212223@Componentpublic class LoginProtectInterceptor implements HandlerInterceptor &#123; @Autowired private JwtHelper jwtHelper; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; String token = request.getHeader(&quot;token&quot;); if (StringUtils.isEmpty(token) || jwtHelper.isExpiration(token))&#123; Result result = Result.build(null, ResultCodeEnum.NOTLOGIN); ObjectMapper objectMapper = new ObjectMapper(); String json = objectMapper.writeValueAsString(result); response.getWriter().print(json); //拦截 return false; &#125;else&#123; //放行 return true; &#125; &#125;&#125; 拦截器配置1234567891011@Configurationpublic class WebMvcConfig implements WebMvcConfigurer &#123; @Autowired private LoginProtectInterceptor loginProtectInterceptor; @Override public void addInterceptors(InterceptorRegistry registry) &#123; registry.addInterceptor(loginProtectInterceptor).addPathPatterns(&quot;/headline/**&quot;); &#125;&#125; 3.2 头条发布实现 需求描述 用户在客户端输入发布的新闻信息完毕后 发布前先请求后端的登录校验接口验证登录 登录通过则提交新闻信息 后端将新闻信息存入数据库 接口描述 url地址：headline&#x2F;publish 请求方式：post 请求头:&#x20; 1token: ... ... 请求参数: 12345&#123; &quot;title&quot;:&quot;尚硅谷宣布 ... ...&quot;, // 文章标题 &quot;article&quot;:&quot;... ...&quot;, // 文章内容 &quot;type&quot;:&quot;1&quot; // 文章类别&#125; 响应数据： 未登录 12345&#123; &quot;code&quot;:&quot;504&quot;, &quot;message&quot;:&quot;loginExpired&quot;, &quot;data&quot;:&#123;&#125;&#125; 成功 123456&#123; &quot;code&quot;:&quot;200&quot;, &quot;message&quot;:&quot;success&quot;, &quot;data&quot;:&#123;&#125;&#125; 代码实现 controller1234567891011121314/** * 实现步骤: * 1. token获取userId [无需校验,拦截器会校验] * 2. 封装headline数据 * 3. 插入数据即可 */@PostMapping(&quot;publish&quot;)public Result publish(@RequestBody Headline headline,@RequestHeader String token)&#123; int userId = jwtHelper.getUserId(token).intValue(); headline.setPublisher(userId); Result result = headlineService.publish(headline); return result;&#125; service12345678910111213/** * 发布数据 * @param headline * @return */@Overridepublic Result publish(Headline headline) &#123; headline.setCreateTime(new Date()); headline.setUpdateTime(new Date()); headline.setPageViews(0); headlineMapper.insert(headline); return Result.ok(null);&#125; 3.3 修改头条回显 需求描述 前端先调用登录校验接口,校验登录是否过期 登录校验通过后 ,则根据新闻id查询新闻的完整信息并响应给前端 接口描述 url地址：headline&#x2F;findHeadlineByHid 请求方式：post 请求参数: 1hid=1 param形成参数 响应数据： 成功 123456789101112&#123; &quot;code&quot;:&quot;200&quot;, &quot;message&quot;:&quot;success&quot;, &quot;data&quot;:&#123; &quot;headline&quot;:&#123; &quot;hid&quot;:&quot;1&quot;, &quot;title&quot;:&quot;马斯克宣布&quot;, &quot;article&quot;:&quot;... ... &quot;, &quot;type&quot;:&quot;2&quot; &#125; &#125;&#125; 代码实现 controller12345@PostMapping(&quot;findHeadlineByHid&quot;)public Result findHeadlineByHid(Integer hid)&#123; Result result = headlineService.findHeadlineByHid(hid); return result;&#125; service123456789101112/** * 根据id查询详情 * @param hid * @return */@Overridepublic Result findHeadlineByHid(Integer hid) &#123; Headline headline = headlineMapper.selectById(hid); Map&lt;String,Object&gt; pageInfoMap=new HashMap&lt;&gt;(); pageInfoMap.put(&quot;headline&quot;,headline); return Result.ok(pageInfoMap);&#125; 3.4 头条修改实现 需求描述 客户端将新闻信息修改后,提交前先请求登录校验接口校验登录状态 登录校验通过则提交修改后的新闻信息,后端接收并更新进入数据库 接口描述 url地址：headline&#x2F;update 请求方式：post 请求参数: 123456&#123; &quot;hid&quot;:&quot;1&quot;, &quot;title&quot;:&quot;尚硅谷宣布 ... ...&quot;, &quot;article&quot;:&quot;... ...&quot;, &quot;type&quot;:&quot;2&quot;&#125; 响应数据： 成功 12345&#123; &quot;code&quot;:&quot;200&quot;, &quot;message&quot;:&quot;success&quot;, &quot;data&quot;:&#123;&#125;&#125; 代码实现 controller12345@PostMapping(&quot;update&quot;)public Result update(@RequestBody Headline headline)&#123; Result result = headlineService.updateHeadLine(headline); return result;&#125; service123456789101112131415161718192021 /** * 修改业务 * 1.查询version版本 * 2.补全属性,修改时间 , 版本! * * @param headline * @return */@Overridepublic Result updateHeadLine(Headline headline) &#123; //读取版本 Integer version = headlineMapper.selectById(headline.getHid()).getVersion(); headline.setVersion(version); headline.setUpdateTime(new Date()); headlineMapper.updateById(headline); return Result.ok(null);&#125; 3.5 删除头条功能 需求描述 将要删除的新闻id发送给服务端 服务端校验登录是否过期,未过期则直接删除,过期则响应登录过期信息 接口描述 url地址：headline&#x2F;removeByHid 请求方式：post 请求参数: 1hid=1 param形成参数 响应数据： 成功 12345&#123; &quot;code&quot;:&quot;200&quot;, &quot;message&quot;:&quot;success&quot;, &quot;data&quot;:&#123;&#125;&#125; 代码实现 controller12345@PostMapping(&quot;removeByHid&quot;)public Result removeById(Integer hid)&#123; headlineService.removeById(hid); return Result.ok(null);&#125; 五、前后端联调","categories":[{"name":"SSM框架","slug":"SSM框架","permalink":"http://example.com/categories/SSM%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"ssm","slug":"ssm","permalink":"http://example.com/tags/ssm/"}]},{"title":"七、MyBatis-Plus高级用法：最优化持久层开发","slug":"SSM/七、MyBatis-Plus高级用法：最优化持久层开发/七、MyBatis-Plus高级用法：最优化持久层开发","date":"2022-10-02T09:55:54.000Z","updated":"2023-09-28T00:33:12.215Z","comments":true,"path":"2022/10/02/SSM/七、MyBatis-Plus高级用法：最优化持久层开发/七、MyBatis-Plus高级用法：最优化持久层开发/","link":"","permalink":"http://example.com/2022/10/02/SSM/%E4%B8%83%E3%80%81MyBatis-Plus%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95%EF%BC%9A%E6%9C%80%E4%BC%98%E5%8C%96%E6%8C%81%E4%B9%85%E5%B1%82%E5%BC%80%E5%8F%91/%E4%B8%83%E3%80%81MyBatis-Plus%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95%EF%BC%9A%E6%9C%80%E4%BC%98%E5%8C%96%E6%8C%81%E4%B9%85%E5%B1%82%E5%BC%80%E5%8F%91/","excerpt":"","text":"七、MyBatis-Plus高级用法：最优化持久层开发目录 一、MyBatis-Plus快速入门 1.1 简介 1.2 快速入门 二、MyBatis-Plus核心功能 2.1 基于Mapper接口CRUD Insert方法 Delete方法 Update方法 Select方法 自定义和多表映射 2.2 基于Service接口CRUD 对比Mapper接口CRUD区别： 使用Iservice接口方式 CRUD方法介绍 2.3 分页查询实现 2.4 条件构造器使用 2.4.1 条件构造器作用 2.4.2 条件构造器继承结构 2.4.3 基于QueryWrapper 组装条件 2.3.4 基于 UpdateWrapper组装条件 2.3.5 基于LambdaQueryWrapper组装条件 2.3.6 基于LambdaUpdateWrapper组装条件 2.5 核心注解使用 三、MyBatis-Plus高级扩展 3.1 逻辑删除实现 3.2 乐观锁实现 3.2.1 悲观锁和乐观锁场景和介绍 3.2.2 使用mybatis-plus数据使用乐观锁 3.3 防全表更新和删除实现 四、MyBatis-Plus代码生成器(MyBatisX插件) 4.1 Mybatisx插件逆向工程 4.2 MyBatisX快速代码生成 一、MyBatis-Plus快速入门1.1 简介 课程版本：3.5.3.1 https://baomidou.com/ MyBatis-Plus (opens new window)（简称 MP）是一个 MyBatis (opens new window) 的增强工具，在 MyBatis 的基础上只做增强不做改变，为简化开发、提高效率而生。 特性： 无侵入：只做增强不做改变，引入它不会对现有工程产生影响，如丝般顺滑 损耗小：启动即会自动注入基本 CURD，性能基本无损耗，直接面向对象操作 强大的 CRUD 操作：内置通用 Mapper、通用 Service，仅仅通过少量配置即可实现单表大部分 CRUD 操作，更有强大的条件构造器，满足各类使用需求 支持 Lambda 形式调用：通过 Lambda 表达式，方便的编写各类查询条件，无需再担心字段写错 支持主键自动生成：支持多达 4 种主键策略（内含分布式唯一 ID 生成器 - Sequence），可自由配置，完美解决主键问题 支持 ActiveRecord 模式：支持 ActiveRecord 形式调用，实体类只需继承 Model 类即可进行强大的 CRUD 操作 支持自定义全局通用操作：支持全局通用方法注入（ Write once, use anywhere ） 内置代码生成器：采用代码或者 Maven 插件可快速生成 Mapper 、 Model 、 Service 、 Controller 层代码，支持模板引擎，更有超多自定义配置等您来使用 内置分页插件：基于 MyBatis 物理分页，开发者无需关心具体操作，配置好插件之后，写分页等同于普通 List 查询 分页插件支持多种数据库：支持 MySQL、MariaDB、Oracle、DB2、H2、HSQL、SQLite、Postgre、SQLServer 等多种数据库 内置性能分析插件：可输出 SQL 语句以及其执行时间，建议开发测试时启用该功能，能快速揪出慢查询 内置全局拦截插件：提供全表 delete 、 update 操作智能分析阻断，也可自定义拦截规则，预防误操作 支持数据库： MySQL，Oracle，DB2，H2，HSQL，SQLite，PostgreSQL，SQLServer，Phoenix，Gauss ，ClickHouse，Sybase，OceanBase，Firebird，Cubrid，Goldilocks，csiidb，informix，TDengine，redshift 达梦数据库，虚谷数据库，人大金仓数据库，南大通用(华库)数据库，南大通用数据库，神通数据库，瀚高数据库，优炫数据库 mybatis-plus总结： 自动生成单表的CRUD功能 提供丰富的条件拼接方式 全自动ORM类型持久层框架 1.2 快速入门 准备数据库脚本 现有一张 User 表，其表结构如下： id name age email 1 Jone 18 test1@baomidou.com 2 Jack 20 test2@baomidou.com 3 Tom 28 test3@baomidou.com 4 Sandy 21 test4@baomidou.com 5 Billie 24 test5@baomidou.com 12345678910DROP TABLE IF EXISTS user;CREATE TABLE user( id BIGINT(20) NOT NULL COMMENT &#x27;主键ID&#x27;, name VARCHAR(30) NULL DEFAULT NULL COMMENT &#x27;姓名&#x27;, age INT(11) NULL DEFAULT NULL COMMENT &#x27;年龄&#x27;, email VARCHAR(50) NULL DEFAULT NULL COMMENT &#x27;邮箱&#x27;, PRIMARY KEY (id)); INSERT INTO user (id, name, age, email) VALUES (1, ‘Jone’, 18, ‘&#x74;&#x65;&#115;&#116;&#49;&#64;&#98;&#x61;&#111;&#x6d;&#x69;&#100;&#x6f;&#x75;&#x2e;&#99;&#x6f;&#x6d;‘), (2, ‘Jack’, 20, ‘&#116;&#101;&#115;&#x74;&#50;&#64;&#98;&#97;&#x6f;&#x6d;&#105;&#100;&#111;&#x75;&#46;&#99;&#x6f;&#x6d;‘), (3, ‘Tom’, 28, ‘&#116;&#x65;&#115;&#116;&#x33;&#x40;&#98;&#x61;&#x6f;&#x6d;&#x69;&#100;&#x6f;&#117;&#46;&#x63;&#x6f;&#109;‘), (4, ‘Sandy’, 21, ‘&#116;&#101;&#x73;&#116;&#52;&#x40;&#98;&#97;&#x6f;&#x6d;&#x69;&#100;&#111;&#117;&#46;&#x63;&#111;&#109;‘), (5, ‘Billie’, 24, ‘&#x74;&#x65;&#115;&#x74;&#x35;&#x40;&#x62;&#x61;&#111;&#x6d;&#x69;&#100;&#111;&#117;&#x2e;&#x63;&#x6f;&#109;‘); 12345678910111213141516171819202122232. 准备boot工程3. 导入依赖 ```xml &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;3.0.5&lt;/version&gt; &lt;/parent&gt; &lt;groupId&gt;com.atguigu&lt;/groupId&gt; &lt;artifactId&gt;springboot-starter-mybatis-plus-06&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;17&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;17&lt;/maven.compiler.target&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- 测试环境 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- mybatis-plus --&gt; &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.5.3.1&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 数据库相关配置启动器 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- druid启动器的依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-3-starter&lt;/artifactId&gt; &lt;version&gt;1.2.18&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 驱动类--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.28&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.28&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;!-- SpringBoot应用打包插件--&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; 1234567891011121314151617181920212223244. 配置文件和启动类 完善连接池配置： 文件夹：META-INF.spring 文件名： org.springframework.boot.autoconfigure.AutoConfiguration.imports 内容：com.alibaba.druid.spring.boot3.autoconfigure.DruidDataSourceAutoConfigure application.yaml ```yaml # 连接池配置 spring: datasource: type: com.alibaba.druid.pool.DruidDataSource druid: url: jdbc:mysql:///day01 username: root password: root driver-class-name: com.mysql.cj.jdbc.Driver 启动类 12345678910@MapperScan(&quot;com.atguigu.mapper&quot;)@SpringBootApplicationpublic class MainApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(MainApplication.class,args); &#125; &#125; 功能编码 编写实体类 User.java（此处使用了 Lombok 简化代码） 12345678@Datapublic class User &#123; private Long id; private String name; private Integer age; private String email;&#125; 编写 Mapper 包下的 UserMapper接口 1234public interface UserMapper extends BaseMapper&lt;User&gt; &#123;&#125; 继承mybatis-plus提供的基础Mapper接口，自带crud方法！ 测试和使用 添加测试类，进行功能测试： 1234567891011121314@SpringBootTest //springboot下测试环境注解public class SampleTest &#123; @Autowired private UserMapper userMapper; @Test public void testSelect() &#123; System.out.println((&quot;----- selectAll method test ------&quot;)); List&lt;User&gt; userList = userMapper.selectList(null); userList.forEach(System.out::println); &#125;&#125; 小结 通过以上几个简单的步骤，我们就实现了 User 表的 CRUD 功能，甚至连 XML 文件都不用编写！ 从以上步骤中，我们可以看到集成MyBatis-Plus非常的简单，只需要引入 starter 工程，并配置 mapper 扫描路径即可。 二、MyBatis-Plus核心功能2.1 基于Mapper接口CRUD 通用 CRUD 封装BaseMapper (opens new window)接口， Mybatis-Plus 启动时自动解析实体表关系映射转换为 Mybatis 内部对象注入容器! 内部包含常见的单表操作！ Insert方法1234// 插入一条记录// T 就是要插入的实体对象// 默认主键生成策略为雪花算法（后面讲解）int insert(T entity); 类型 参数名 描述 T entity 实体对象 Delete方法1234567891011// 根据 entity 条件，删除记录int delete(@Param(Constants.WRAPPER) Wrapper&lt;T&gt; wrapper);// 删除（根据ID 批量删除）int deleteBatchIds(@Param(Constants.COLLECTION) Collection&lt;? extends Serializable&gt; idList);// 根据 ID 删除int deleteById(Serializable id);// 根据 columnMap 条件，删除记录int deleteByMap(@Param(Constants.COLUMN_MAP) Map&lt;String, Object&gt; columnMap); 类型 参数名 描述 Wrapper&lt;T&gt; wrapper 实体对象封装操作类（可以为 null） Collection&lt;? extends Serializable&gt; idList 主键 ID 列表(不能为 null 以及 empty) Serializable id 主键 ID Map&lt;String, Object&gt; columnMap 表字段 map 对象 Update方法123456// 根据 whereWrapper 条件，更新记录int update(@Param(Constants.ENTITY) T updateEntity, @Param(Constants.WRAPPER) Wrapper&lt;T&gt; whereWrapper);// 根据 ID 修改 主键属性必须值int updateById(@Param(Constants.ENTITY) T entity); 类型 参数名 描述 T entity 实体对象 (set 条件值,可为 null) Wrapper&lt;T&gt; updateWrapper 实体对象封装操作类（可以为 null,里面的 entity 用于生成 where 语句） Select方法1234567891011121314151617181920212223242526272829// 根据 ID 查询T selectById(Serializable id);// 根据 entity 条件，查询一条记录T selectOne(@Param(Constants.WRAPPER) Wrapper&lt;T&gt; queryWrapper);// 查询（根据ID 批量查询）List&lt;T&gt; selectBatchIds(@Param(Constants.COLLECTION) Collection&lt;? extends Serializable&gt; idList);// 根据 entity 条件，查询全部记录List&lt;T&gt; selectList(@Param(Constants.WRAPPER) Wrapper&lt;T&gt; queryWrapper);// 查询（根据 columnMap 条件）List&lt;T&gt; selectByMap(@Param(Constants.COLUMN_MAP) Map&lt;String, Object&gt; columnMap);// 根据 Wrapper 条件，查询全部记录List&lt;Map&lt;String, Object&gt;&gt; selectMaps(@Param(Constants.WRAPPER) Wrapper&lt;T&gt; queryWrapper);// 根据 Wrapper 条件，查询全部记录。注意： 只返回第一个字段的值List&lt;Object&gt; selectObjs(@Param(Constants.WRAPPER) Wrapper&lt;T&gt; queryWrapper);// 根据 entity 条件，查询全部记录（并翻页）IPage&lt;T&gt; selectPage(IPage&lt;T&gt; page, @Param(Constants.WRAPPER) Wrapper&lt;T&gt; queryWrapper);// 根据 Wrapper 条件，查询全部记录（并翻页）IPage&lt;Map&lt;String, Object&gt;&gt; selectMapsPage(IPage&lt;T&gt; page, @Param(Constants.WRAPPER) Wrapper&lt;T&gt; queryWrapper);// 根据 Wrapper 条件，查询总记录数Integer selectCount(@Param(Constants.WRAPPER) Wrapper&lt;T&gt; queryWrapper); 参数说明 类型 参数名 描述 Serializable id 主键 ID Wrapper&lt;T&gt; queryWrapper 实体对象封装操作类（可以为 null） Collection&lt;? extends Serializable&gt; idList 主键 ID 列表(不能为 null 以及 empty) Map&lt;String, Object&gt; columnMap 表字段 map 对象 IPage&lt;T&gt; page 分页查询条件（可以为 RowBounds.DEFAULT） 自定义和多表映射mybatis-plus的默认mapperxml位置 123mybatis-plus: # mybatis-plus的配置 # 默认位置 private String[] mapperLocations = new String[]&#123;&quot;classpath*:/mapper/**/*.xml&quot;&#125;; mapper-locations: classpath:/mapper/*.xml 自定义mapper方法： 1234567public interface UserMapper extends BaseMapper&lt;User&gt; &#123; //正常自定义方法！ //可以使用注解@Select或者mapper.xml实现 List&lt;User&gt; queryAll();&#125; 基于mapper.xml实现： 1234567891011&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;https://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;!-- namespace = 接口的全限定符 --&gt;&lt;mapper namespace=&quot;com.atguigu.mapper.UserMapper&quot;&gt; &lt;select id=&quot;queryAll&quot; resultType=&quot;user&quot; &gt; select * from user &lt;/select&gt;&lt;/mapper&gt; 2.2 基于Service接口CRUD通用 Service CRUD 封装IService (opens new window)接口，进一步封装 CRUD 采用 get 查询单行 remove 删除 list 查询集合 page 分页 前缀命名方式区分 Mapper 层避免混淆， 对比Mapper接口CRUD区别： service添加了批量方法 service层的方法自动添加事务 使用Iservice接口方式接口继承IService接口 123public interface UserService extends IService&lt;User&gt; &#123;&#125; 类继承ServiceImpl实现类 12345@Servicepublic class UserServiceImpl extends ServiceImpl&lt;UserMapper,User&gt; implements UserService&#123;&#125; CRUD方法介绍1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980保存：// 插入一条记录（选择字段，策略插入）boolean save(T entity);// 插入（批量）boolean saveBatch(Collection&lt;T&gt; entityList);// 插入（批量）boolean saveBatch(Collection&lt;T&gt; entityList, int batchSize);修改或者保存：// TableId 注解存在更新记录，否插入一条记录boolean saveOrUpdate(T entity);// 根据updateWrapper尝试更新，否继续执行saveOrUpdate(T)方法boolean saveOrUpdate(T entity, Wrapper&lt;T&gt; updateWrapper);// 批量修改插入boolean saveOrUpdateBatch(Collection&lt;T&gt; entityList);// 批量修改插入boolean saveOrUpdateBatch(Collection&lt;T&gt; entityList, int batchSize);移除：// 根据 queryWrapper 设置的条件，删除记录boolean remove(Wrapper&lt;T&gt; queryWrapper);// 根据 ID 删除boolean removeById(Serializable id);// 根据 columnMap 条件，删除记录boolean removeByMap(Map&lt;String, Object&gt; columnMap);// 删除（根据ID 批量删除）boolean removeByIds(Collection&lt;? extends Serializable&gt; idList);更新：// 根据 UpdateWrapper 条件，更新记录 需要设置sqlsetboolean update(Wrapper&lt;T&gt; updateWrapper);// 根据 whereWrapper 条件，更新记录boolean update(T updateEntity, Wrapper&lt;T&gt; whereWrapper);// 根据 ID 选择修改boolean updateById(T entity);// 根据ID 批量更新boolean updateBatchById(Collection&lt;T&gt; entityList);// 根据ID 批量更新boolean updateBatchById(Collection&lt;T&gt; entityList, int batchSize);数量： // 查询总记录数int count();// 根据 Wrapper 条件，查询总记录数int count(Wrapper&lt;T&gt; queryWrapper);查询：// 根据 ID 查询T getById(Serializable id);// 根据 Wrapper，查询一条记录。结果集，如果是多个会抛出异常，随机取一条加上限制条件 wrapper.last(&quot;LIMIT 1&quot;)T getOne(Wrapper&lt;T&gt; queryWrapper);// 根据 Wrapper，查询一条记录T getOne(Wrapper&lt;T&gt; queryWrapper, boolean throwEx);// 根据 Wrapper，查询一条记录Map&lt;String, Object&gt; getMap(Wrapper&lt;T&gt; queryWrapper);// 根据 Wrapper，查询一条记录&lt;V&gt; V getObj(Wrapper&lt;T&gt; queryWrapper, Function&lt;? super Object, V&gt; mapper);集合：// 查询所有List&lt;T&gt; list();// 查询列表List&lt;T&gt; list(Wrapper&lt;T&gt; queryWrapper);// 查询（根据ID 批量查询）Collection&lt;T&gt; listByIds(Collection&lt;? extends Serializable&gt; idList);// 查询（根据 columnMap 条件）Collection&lt;T&gt; listByMap(Map&lt;String, Object&gt; columnMap);// 查询所有列表List&lt;Map&lt;String, Object&gt;&gt; listMaps();// 查询列表List&lt;Map&lt;String, Object&gt;&gt; listMaps(Wrapper&lt;T&gt; queryWrapper);// 查询全部记录List&lt;Object&gt; listObjs();// 查询全部记录&lt;V&gt; List&lt;V&gt; listObjs(Function&lt;? super Object, V&gt; mapper);// 根据 Wrapper 条件，查询全部记录List&lt;Object&gt; listObjs(Wrapper&lt;T&gt; queryWrapper);// 根据 Wrapper 条件，查询全部记录&lt;V&gt; List&lt;V&gt; listObjs(Wrapper&lt;T&gt; queryWrapper, Function&lt;? super Object, V&gt; mapper); 2.3 分页查询实现 导入分页插件 123456@Beanpublic MybatisPlusInterceptor mybatisPlusInterceptor() &#123; MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor(); interceptor.addInnerInterceptor(new PaginationInnerInterceptor(DbType.MYSQL)); return interceptor;&#125; 使用分页查询 123456789101112131415@Testpublic void testPageQuery()&#123; //设置分页参数 Page&lt;User&gt; page = new Page&lt;&gt;(1, 5); userMapper.selectPage(page, null); //获取分页数据 List&lt;User&gt; list = page.getRecords(); list.forEach(System.out::println); System.out.println(&quot;当前页：&quot;+page.getCurrent()); System.out.println(&quot;每页显示的条数：&quot;+page.getSize()); System.out.println(&quot;总记录数：&quot;+page.getTotal()); System.out.println(&quot;总页数：&quot;+page.getPages()); System.out.println(&quot;是否有上一页：&quot;+page.hasPrevious()); System.out.println(&quot;是否有下一页：&quot;+page.hasNext());&#125; 自定义的mapper方法使用分页 方法 1234//传入参数携带Ipage接口//返回结果为IPageIPage&lt;User&gt; selectPageVo(IPage&lt;?&gt; page, Integer id); 接口实现 123&lt;select id=&quot;selectPageVo&quot; resultType=&quot;xxx.xxx.xxx.User&quot;&gt; SELECT * FROM user WHERE id &gt; #&#123;id&#125;&lt;/select&gt; 测试 1234567891011121314151617@Testpublic void testQuick()&#123; IPage page = new Page(1,2); userMapper.selectPageVo(page,2); long current = page.getCurrent(); System.out.println(&quot;current = &quot; + current); long pages = page.getPages(); System.out.println(&quot;pages = &quot; + pages); long total = page.getTotal(); System.out.println(&quot;total = &quot; + total); List records = page.getRecords(); System.out.println(&quot;records = &quot; + records);&#125; 2.4 条件构造器使用2.4.1 条件构造器作用实例代码： 123456789QueryWrapper&lt;User&gt; queryWrapper = new QueryWrapper&lt;&gt;();queryWrapper.eq(&quot;name&quot;, &quot;John&quot;); // 添加等于条件queryWrapper.ne(&quot;age&quot;, 30); // 添加不等于条件queryWrapper.like(&quot;email&quot;, &quot;@gmail.com&quot;); // 添加模糊匹配条件等同于： delete from user where name = &quot;John&quot; and age != 30 and email like &quot;%@gmail.com%&quot;// 根据 entity 条件，删除记录int delete(@Param(Constants.WRAPPER) Wrapper&lt;T&gt; wrapper); 使用MyBatis-Plus的条件构造器，你可以构建灵活、高效的查询条件，而不需要手动编写复杂的 SQL 语句。它提供了许多方法来支持各种条件操作符，并且可以通过链式调用来组合多个条件。这样可以简化查询的编写过程，并提高开发效率。 2.4.2 条件构造器继承结构条件构造器类结构： Wrapper ： 条件构造抽象类，最顶端父类 AbstractWrapper ： 用于查询条件封装，生成 sql 的 where 条件 QueryWrapper ： 查询&#x2F;删除条件封装 UpdateWrapper ： 修改条件封装 AbstractLambdaWrapper ： 使用Lambda 语法 LambdaQueryWrapper ：用于Lambda语法使用的查询Wrapper LambdaUpdateWrapper ： Lambda 更新封装Wrapper 2.4.3 基于QueryWrapper 组装条件 组装查询条件： 1234567891011@Testpublic void test01()&#123; //查询用户名包含a，年龄在20到30之间，并且邮箱不为null的用户信息 //SELECT id,username AS name,age,email,is_deleted FROM t_user WHERE is_deleted=0 AND (username LIKE ? AND age BETWEEN ? AND ? AND email IS NOT NULL) QueryWrapper&lt;User&gt; queryWrapper = new QueryWrapper&lt;&gt;(); queryWrapper.like(&quot;username&quot;, &quot;a&quot;) .between(&quot;age&quot;, 20, 30) .isNotNull(&quot;email&quot;); List&lt;User&gt; list = userMapper.selectList(queryWrapper); list.forEach(System.out::println); 组装排序条件: 1234567891011@Testpublic void test02()&#123; //按年龄降序查询用户，如果年龄相同则按id升序排列 //SELECT id,username AS name,age,email,is_deleted FROM t_user WHERE is_deleted=0 ORDER BY age DESC,id ASC QueryWrapper&lt;User&gt; queryWrapper = new QueryWrapper&lt;&gt;(); queryWrapper .orderByDesc(&quot;age&quot;) .orderByAsc(&quot;id&quot;); List&lt;User&gt; users = userMapper.selectList(queryWrapper); users.forEach(System.out::println);&#125; 组装删除条件: 12345678910@Testpublic void test03()&#123; //删除email为空的用户 //DELETE FROM t_user WHERE (email IS NULL) QueryWrapper&lt;User&gt; queryWrapper = new QueryWrapper&lt;&gt;(); queryWrapper.isNull(&quot;email&quot;); //条件构造器也可以构建删除语句的条件 int result = userMapper.delete(queryWrapper); System.out.println(&quot;受影响的行数：&quot; + result);&#125; and和or关键字使用(修改)： 12345678910111213141516@Testpublic void test04() &#123; QueryWrapper&lt;User&gt; queryWrapper = new QueryWrapper&lt;&gt;(); //将年龄大于20并且用户名中包含有a或邮箱为null的用户信息修改 //UPDATE t_user SET age=?, email=? WHERE username LIKE ? AND age &gt; ? OR email IS NULL) queryWrapper .like(&quot;username&quot;, &quot;a&quot;) .gt(&quot;age&quot;, 20) .or() .isNull(&quot;email&quot;); User user = new User(); user.setAge(18); user.setEmail(&quot;user@atguigu.com&quot;); int result = userMapper.update(user, queryWrapper); System.out.println(&quot;受影响的行数：&quot; + result);&#125; 指定列映射查询： 12345678910@Testpublic void test05() &#123; //查询用户信息的username和age字段 //SELECT username,age FROM t_user QueryWrapper&lt;User&gt; queryWrapper = new QueryWrapper&lt;&gt;(); queryWrapper.select(&quot;username&quot;, &quot;age&quot;); //selectMaps()返回Map集合列表，通常配合select()使用，避免User对象中没有被查询到的列值为null List&lt;Map&lt;String, Object&gt;&gt; maps = userMapper.selectMaps(queryWrapper); maps.forEach(System.out::println);&#125; condition判断组织条件: 1234567891011121314151617181920212223 @Testpublic void testQuick3()&#123; String name = &quot;root&quot;; int age = 18; QueryWrapper&lt;User&gt; queryWrapper = new QueryWrapper&lt;&gt;(); //判断条件拼接 //当name不为null拼接等于, age &gt; 1 拼接等于判断 //方案1: 手动判断 if (!StringUtils.isEmpty(name))&#123; queryWrapper.eq(&quot;name&quot;,name); &#125; if (age &gt; 1)&#123; queryWrapper.eq(&quot;age&quot;,age); &#125; //方案2: 拼接condition判断 //每个条件拼接方法都condition参数,这是一个比较运算,为true追加当前条件! //eq(condition,列名,值) queryWrapper.eq(!StringUtils.isEmpty(name),&quot;name&quot;,name) .eq(age&gt;1,&quot;age&quot;,age); &#125; 2.3.4 基于 UpdateWrapper组装条件使用queryWrapper: 12345678910111213141516@Testpublic void test04() &#123; QueryWrapper&lt;User&gt; queryWrapper = new QueryWrapper&lt;&gt;(); //将年龄大于20并且用户名中包含有a或邮箱为null的用户信息修改 //UPDATE t_user SET age=?, email=? WHERE username LIKE ? AND age &gt; ? OR email IS NULL) queryWrapper .like(&quot;username&quot;, &quot;a&quot;) .gt(&quot;age&quot;, 20) .or() .isNull(&quot;email&quot;); User user = new User(); user.setAge(18); user.setEmail(&quot;user@atguigu.com&quot;); int result = userMapper.update(user, queryWrapper); System.out.println(&quot;受影响的行数：&quot; + result);&#125; 注意：使用queryWrapper + 实体类形式可以实现修改，但是无法将列值修改为null值！ 使用updateWrapper: 12345678910111213@Testpublic void testQuick2()&#123; UpdateWrapper&lt;User&gt; updateWrapper = new UpdateWrapper&lt;&gt;(); //将id = 3 的email设置为null, age = 18 updateWrapper.eq(&quot;id&quot;,3) .set(&quot;email&quot;,null) // set 指定列和结果 .set(&quot;age&quot;,18); //如果使用updateWrapper 实体对象写null即可! int result = userMapper.update(null, updateWrapper); System.out.println(&quot;result = &quot; + result);&#125; 使用updateWrapper可以随意设置列的值！！ 2.3.5 基于LambdaQueryWrapper组装条件1. LambdaQueryWrapper对比QueryWrapper优势 QueryWrapper 示例代码： 123456QueryWrapper&lt;User&gt; queryWrapper = new QueryWrapper&lt;&gt;();queryWrapper.eq(&quot;name&quot;, &quot;John&quot;) .ge(&quot;age&quot;, 18) .orderByDesc(&quot;create_time&quot;) .last(&quot;limit 10&quot;);List&lt;User&gt; userList = userMapper.selectList(queryWrapper); LambdaQueryWrapper 示例代码： 1234567LambdaQueryWrapper&lt;User&gt; lambdaQueryWrapper = new LambdaQueryWrapper&lt;&gt;();lambdaQueryWrapper.eq(User::getName, &quot;John&quot;) .ge(User::getAge, 18) .orderByDesc(User::getCreateTime) .last(&quot;limit 10&quot;);List&lt;User&gt; userList = userMapper.selectList(lambdaQueryWrapper); 从上面的代码对比可以看出，相比于 QueryWrapper，LambdaQueryWrapper 使用了实体类的属性引用（例如 User::getName、User::getAge），而不是字符串来表示字段名，这提高了代码的可读性和可维护性。 2. lambda表达式回顾 Lambda 表达式是 Java 8 引入的一种函数式编程特性，它提供了一种更简洁、更直观的方式来表示匿名函数或函数式接口的实现。Lambda 表达式可以用于简化代码，提高代码的可读性和可维护性。 Lambda 表达式的语法可以分为以下几个部分： 参数列表： 参数列表用小括号 () 括起来，可以指定零个或多个参数。如果没有参数，可以省略小括号；如果只有一个参数，可以省略小括号。 示例：(a, b), x -&gt;, () -&gt; 箭头符号： 箭头符号 -&gt; 分割参数列表和 Lambda 表达式的主体部分。 示例：-&gt; Lambda 表达式的主体： Lambda 表达式的主体部分可以是一个表达式或一个代码块。如果是一个表达式，可以省略 return 关键字；如果是多条语句的代码块，需要使用大括号 &#123;&#125; 括起来，并且需要明确指定 return 关键字。 示例： 单个表达式：x -&gt; x * x 代码块：(x, y) -&gt; &#123; int sum = x + y; return sum; &#125; Lambda 表达式的语法可以更具体地描述如下： 123456789101112131415161718192021222324252627// 使用 Lambda 表达式实现一个接口的方法interface Greeting &#123; void sayHello();&#125;public class LambdaExample &#123; public static void main(String[] args) &#123; //原始匿名内部类方式 Greeting greeting = new Greeting() &#123; @Override public void sayHello(int a) &#123; System.out.println(&quot;Hello, world!&quot;); &#125; &#125;; a-&gt;System.out.println(&quot;Hello, world!&quot;) // 使用 Lambda 表达式实现接口的方法 greeting = () -&gt; System.out.println(&quot;Hello, world!&quot;); System.out::println; () -&gt; 类.XXX(); -&gt; 类：：方法名 // 调用接口的方法 greeting.sayHello(); &#125;&#125; 3. 方法引用回顾: 方法引用是 Java 8 中引入的一种语法特性，它提供了一种简洁的方式来直接引用已有的方法或构造函数。方法引用可以替代 Lambda 表达式，使代码更简洁、更易读。 Java 8 支持以下几种方法引用的形式： 静态方法引用： 引用静态方法，语法为 类名::静态方法名。 实例方法引用： 引用实例方法，语法为 实例对象::实例方法名。 对象方法引用： 引用特定对象的实例方法，语法为 类名::实例方法名。 构造函数引用： 引用构造函数，语法为 类名::new。 演示代码: 12345678910111213import java.util.Arrays;import java.util.List;import java.util.function.Consumer;public class MethodReferenceExample &#123; public static void main(String[] args) &#123; List&lt;String&gt; names = Arrays.asList(&quot;John&quot;, &quot;Tom&quot;, &quot;Alice&quot;); // 使用 Lambda 表达式 names.forEach(name -&gt; System.out.println(name)); // 使用方法引用 names.forEach(System.out::println); &#125;&#125; 4. lambdaQueryWrapper使用案例: 1234567891011121314151617181920@Testpublic void testQuick4()&#123; String name = &quot;root&quot;; int age = 18; QueryWrapper&lt;User&gt; queryWrapper = new QueryWrapper&lt;&gt;(); //每个条件拼接方法都condition参数,这是一个比较运算,为true追加当前条件! //eq(condition,列名,值) queryWrapper.eq(!StringUtils.isEmpty(name),&quot;name&quot;,name) .eq(age&gt;1,&quot;age&quot;,age); //TODO: 使用lambdaQueryWrapper LambdaQueryWrapper&lt;User&gt; lambdaQueryWrapper = new LambdaQueryWrapper&lt;&gt;(); //注意: 需要使用方法引用 //技巧: 类名::方法名 lambdaQueryWrapper.eq(!StringUtils.isEmpty(name), User::getName,name); List&lt;User&gt; users= userMapper.selectList(lambdaQueryWrapper); System.out.println(users);&#125; 2.3.6 基于LambdaUpdateWrapper组装条件使用案例: 12345678910111213141516171819@Testpublic void testQuick2()&#123; UpdateWrapper&lt;User&gt; updateWrapper = new UpdateWrapper&lt;&gt;(); //将id = 3 的email设置为null, age = 18 updateWrapper.eq(&quot;id&quot;,3) .set(&quot;email&quot;,null) // set 指定列和结果 .set(&quot;age&quot;,18); //使用lambdaUpdateWrapper LambdaUpdateWrapper&lt;User&gt; updateWrapper1 = new LambdaUpdateWrapper&lt;&gt;(); updateWrapper1.eq(User::getId,3) .set(User::getEmail,null) .set(User::getAge,18); //如果使用updateWrapper 实体对象写null即可! int result = userMapper.update(null, updateWrapper); System.out.println(&quot;result = &quot; + result);&#125; 2.5 核心注解使用 理解和介绍 MyBatis-Plus是一个基于MyBatis框架的增强工具，提供了一系列简化和增强的功能，用于加快开发人员在使用MyBatis进行数据库访问时的效率。 MyBatis-Plus提供了一种基于注解的方式来定义和映射数据库操作，其中的注解起到了重要作用。 理解： 123public interface UserMapper extends BaseMapper&lt;User&gt; &#123;&#125; 此接口对应的方法为什么会自动触发 user表的crud呢？ 默认情况下， 根据指定的&lt;实体类&gt;的名称对应数据库表名，属性名对应数据库的列名！ 但是不是所有数据库的信息和实体类都完全映射！ 例如： 表名 t_user → 实体类 User 这时候就不对应了！ 自定义映射关系就可以使用mybatis-plus提供的注解即可！ @TableName注解 描述：表名注解，标识实体类对应的表 使用位置：实体类12345678@TableName(&quot;sys_user&quot;) //对应数据库表名public class User &#123; private Long id; private String name; private Integer age; private String email;&#125; 特殊情况：如果表名和实体类名相同（忽略大小写）可以省略该注解！ 其他解决方案：全局设置前缀 (https://www.baomidou.com/pages/56bac0/#基本配置) 1234mybatis-plus: # mybatis-plus的配置 global-config: db-config: table-prefix: sys_ # 表名前缀字符串 @TableId 注解 描述：主键注解 使用位置：实体类主键字段123456789@TableName(&quot;sys_user&quot;)public class User &#123; @TableId(value=&quot;主键列名&quot;,type=主键策略) private Long id; private String name; private Integer age; private String email;&#125; | 属性 | 类型 | 必须指定 | 默认值 | 描述 | | —————————————————————————————————————————————————————- | —— | —- | ———– | —— || value | String | 否 | “” | 主键字段名 || type | Enum | 否 | IdType.NONE | 指定主键类型 || IdType属性可选值： | | | | | 值 描述 AUTO 数据库 ID 自增 (mysql配置主键自增长) ASSIGN_ID（默认） 分配 ID(主键类型为 Number(Long )或 String)(since 3.3.0),使用接口IdentifierGenerator的方法nextId(默认实现类为DefaultIdentifierGenerator雪花算法) 全局配置修改主键策略: 12345678910mybatis-plus: configuration: # 配置MyBatis日志 log-impl: org.apache.ibatis.logging.stdout.StdOutImpl global-config: db-config: # 配置MyBatis-Plus操作表的默认前缀 table-prefix: t_ # 配置MyBatis-Plus的主键策略 id-type: auto 在以下场景下，添加@TableId注解是必要的： 实体类的字段与数据库表的主键字段不同名：如果实体类中的字段与数据库表的主键字段不一致，需要使用@TableId注解来指定实体类中表示主键的字段。 主键生成策略不是默认策略：如果需要使用除了默认主键生成策略以外的策略，也需要添加@TableId注解，并通过value属性指定生成策略。 雪花算法使用场景 雪花算法（Snowflake Algorithm）是一种用于生成唯一ID的算法。它由Twitter公司提出，用于解决分布式系统中生成全局唯一ID的需求。 在传统的自增ID生成方式中，使用单点数据库生成ID会成为系统的瓶颈，而雪花算法通过在分布式系统中生成唯一ID，避免了单点故障和性能瓶颈的问题。 雪花算法生成的ID是一个64位的整数，由以下几个部分组成： 时间戳：41位，精确到毫秒级，可以使用69年。 节点ID：10位，用于标识分布式系统中的不同节点。 序列号：12位，表示在同一毫秒内生成的不同ID的序号。通过将这三个部分组合在一起，雪花算法可以在分布式系统中生成全局唯一的ID，并保证ID的生成顺序性。雪花算法的工作方式如下： 当前时间戳从某一固定的起始时间开始计算，可以用于计算ID的时间部分。 节点ID是分布式系统中每个节点的唯一标识，可以通过配置或自动分配的方式获得。 序列号用于记录在同一毫秒内生成的不同ID的序号，从0开始自增，最多支持4096个ID生成。需要注意的是，雪花算法依赖于系统的时钟，需要确保系统时钟的准确性和单调性，否则可能会导致生成的ID不唯一或不符合预期的顺序。雪花算法是一种简单但有效的生成唯一ID的算法，广泛应用于分布式系统中，如微服务架构、分布式数据库、分布式锁等场景，以满足全局唯一标识的需求。 你需要记住的: 雪花算法生成的数字,需要使用Long 或者 String类型主键!! @TableField 描述：字段注解（非主键） 123456789@TableName(&quot;sys_user&quot;)public class User &#123; @TableId private Long id; @TableField(&quot;nickname&quot;) private String name; private Integer age; private String email;&#125; 属性 类型 必须指定 默认值 描述value String 否 “” 数据库字段名exist boolean 否 true 是否为数据库表字段 MyBatis-Plus会自动开启驼峰命名风格映射!!! 三、MyBatis-Plus高级扩展3.1 逻辑删除实现概念: 逻辑删除，可以方便地实现对数据库记录的逻辑删除而不是物理删除。逻辑删除是指通过更改记录的状态或添加标记字段来模拟删除操作，从而保留了删除前的数据，便于后续的数据分析和恢复。 物理删除：真实删除，将对应数据从数据库中删除，之后查询不到此条被删除的数据 逻辑删除：假删除，将对应数据中代表是否被删除字段的状态修改为“被删除状态”，之后在数据库中仍旧能看到此条数据记录 逻辑删除实现: 数据库和实体类添加逻辑删除字段 表添加逻辑删除字段 可以是一个布尔类型、整数类型或枚举类型。 1ALTER TABLE USER ADD deleted INT DEFAULT 0 ; # int 类型 1 逻辑删除 0 未逻辑删除 实体类添加逻辑删除属性 1234567891011121314@Datapublic class User &#123; // @TableId private Integer id; private String name; private Integer age; private String email; @TableLogic //逻辑删除字段 int mybatis-plus下,默认 逻辑删除值为1 未逻辑删除 1 private Integer deleted;&#125; 指定逻辑删除字段和属性值 单一指定123456789101112@Datapublic class User &#123; // @TableId private Integer id; private String name; private Integer age; private String email; @TableLogic //逻辑删除字段 int mybatis-plus下,默认 逻辑删除值为1 未逻辑删除 1 private Integer deleted;&#125; 全局指定123456mybatis-plus: global-config: db-config: logic-delete-field: deleted # 全局逻辑删除的实体字段名(since 3.3.0,配置后可以忽略不配置步骤2) logic-delete-value: 1 # 逻辑已删除值(默认为 1) logic-not-delete-value: 0 # 逻辑未删除值(默认为 0) 演示逻辑删除操作 逻辑删除以后,没有真正的删除语句,删除改为修改语句!删除代码: 123456//逻辑删除@Testpublic void testQuick5()&#123; //逻辑删除 userMapper.deleteById(5);&#125; 执行效果: JDBC Connection [com.alibaba.druid.proxy.jdbc.ConnectionProxyImpl@5871a482] will not be managed by Spring=&#x3D;&gt; Preparing: UPDATE user SET deleted&#x3D;1 WHERE id&#x3D;? AND deleted&#x3D;0=&#x3D;&gt; Parameters: 5(Integer)&lt;&#x3D;&#x3D; Updates: 1 测试查询数据 1234567@Testpublic void testQuick6()&#123; //正常查询.默认查询非逻辑删除数据 userMapper.selectList(null);&#125;//SELECT id,name,age,email,deleted FROM user WHERE deleted=0 3.2 乐观锁实现3.2.1 悲观锁和乐观锁场景和介绍并发问题场景演示: **解决思路: ** 乐观锁和悲观锁是在并发编程中用于处理并发访问和资源竞争的两种不同的锁机制!! 悲观锁： &#x20;悲观锁的基本思想是，在整个数据访问过程中，将共享资源锁定，以确保其他线程或进程不能同时访问和修改该资源。悲观锁的核心思想是”先保护，再修改”。在悲观锁的应用中，线程在访问共享资源之前会获取到锁，并在整个操作过程中保持锁的状态，阻塞其他线程的访问。只有当前线程完成操作后，才会释放锁，让其他线程继续操作资源。这种锁机制可以确保资源独占性和数据的一致性，但是在高并发环境下，悲观锁的效率相对较低。 乐观锁： &#x20;乐观锁的基本思想是，认为并发冲突的概率较低，因此不需要提前加锁，而是在数据更新阶段进行冲突检测和处理。乐观锁的核心思想是”先修改，后校验”。在乐观锁的应用中，线程在读取共享资源时不会加锁，而是记录特定的版本信息。当线程准备更新资源时，会先检查该资源的版本信息是否与之前读取的版本信息一致，如果一致则执行更新操作，否则说明有其他线程修改了该资源，需要进行相应的冲突处理。乐观锁通过避免加锁操作，提高了系统的并发性能和吞吐量，但是在并发冲突较为频繁的情况下，乐观锁会导致较多的冲突处理和重试操作。 理解点: 悲观锁和乐观锁是两种解决并发数据问题的思路,不是具体技术!!! 具体技术和方案: 乐观锁实现方案和技术： 版本号&#x2F;时间戳：为数据添加一个版本号或时间戳字段，每次更新数据时，比较当前版本号或时间戳与期望值是否一致，若一致则更新成功，否则表示数据已被修改，需要进行冲突处理。 CAS（Compare-and-Swap）：使用原子操作比较当前值与旧值是否一致，若一致则进行更新操作，否则重新尝试。 无锁数据结构：采用无锁数据结构，如无锁队列、无锁哈希表等，通过使用原子操作实现并发安全。 悲观锁实现方案和技术： 锁机制：使用传统的锁机制，如互斥锁（Mutex Lock）或读写锁（Read-Write Lock）来保证对共享资源的独占访问。 数据库锁：在数据库层面使用行级锁或表级锁来控制并发访问。 信号量（Semaphore）：使用信号量来限制对资源的并发访问。 介绍版本号乐观锁技术的实现流程: 每条数据添加一个版本号字段version 取出记录时，获取当前 version 更新时，检查获取版本号是不是数据库当前最新版本号 如果是[证明没有人修改数据], 执行更新, set 数据更新 , version &#x3D; version+ 1&#x20; 如果 version 不对[证明有人已经修改了]，我们现在的其他记录就是失效数据!就更新失败 3.2.2 使用mybatis-plus数据使用乐观锁&#x20;1. 添加版本号更新插件 123456@Beanpublic MybatisPlusInterceptor mybatisPlusInterceptor() &#123; MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor(); interceptor.addInnerInterceptor(new OptimisticLockerInnerInterceptor()); return interceptor;&#125; 乐观锁字段添加@Version注解 注意: 数据库也需要添加version字段 1ALTER TABLE USER ADD VERSION INT DEFAULT 1 ; # int 类型 乐观锁字段 支持的数据类型只有:int,Integer,long,Long,Date,Timestamp,LocalDateTime 仅支持 updateById(id) 与 update(entity, wrapper) 方法12@Versionprivate Integer version; 正常更新使用即可 123456789101112131415//演示乐观锁生效场景@Testpublic void testQuick7()&#123; //步骤1: 先查询,在更新 获取version数据 //同时查询两条,但是version唯一,最后更新的失败 User user = userMapper.selectById(5); User user1 = userMapper.selectById(5); user.setAge(20); user1.setAge(30); userMapper.updateById(user); //乐观锁生效,失败! userMapper.updateById(user1);&#125; 3.3 防全表更新和删除实现针对 update 和 delete 语句 作用: 阻止恶意的全表更新删除 添加防止全表更新和删除拦截器 1234567@Beanpublic MybatisPlusInterceptor mybatisPlusInterceptor() &#123; MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor(); interceptor.addInnerInterceptor(new BlockAttackInnerInterceptor()); return interceptor;&#125;&#125; 测试全部更新或者删除 123456789@Testpublic void testQuick8()&#123; User user = new User(); user.setName(&quot;custom_name&quot;); user.setEmail(&quot;xxx@mail.com&quot;); //Caused by: com.baomidou.mybatisplus.core.exceptions.MybatisPlusException: Prohibition of table update operation //全局更新,报错 userService.saveOrUpdate(user,null);&#125; 四、MyBatis-Plus代码生成器(MyBatisX插件)4.1 Mybatisx插件逆向工程MyBatis-Plus为我们提供了强大的mapper和service模板，能够大大的提高开发效率 但是在真正开发过程中，MyBatis-Plus并不能为我们解决所有问题，例如一些复杂的SQL，多表联查，我们就需要自己去编写代码和SQL语句，我们该如何快速的解决这个问题呢，这个时候可以使用MyBatisX插件 MyBatisX一款基于 IDEA 的快速开发插件，为效率而生。 4.2 MyBatisX快速代码生成使用mybatisX插件,自动生成sql语句实现 https://baomidou.com/pages/ba5b24/#功能","categories":[{"name":"SSM框架","slug":"SSM框架","permalink":"http://example.com/categories/SSM%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"ssm","slug":"ssm","permalink":"http://example.com/tags/ssm/"}]},{"title":"六、快速启动框架：SpringBoot3实战","slug":"SSM/六、快速启动框架：SpringBoot3实战/六、快速启动框架：SpringBoot3实战","date":"2022-10-01T11:55:54.000Z","updated":"2023-09-28T00:34:09.604Z","comments":true,"path":"2022/10/01/SSM/六、快速启动框架：SpringBoot3实战/六、快速启动框架：SpringBoot3实战/","link":"","permalink":"http://example.com/2022/10/01/SSM/%E5%85%AD%E3%80%81%E5%BF%AB%E9%80%9F%E5%90%AF%E5%8A%A8%E6%A1%86%E6%9E%B6%EF%BC%9ASpringBoot3%E5%AE%9E%E6%88%98/%E5%85%AD%E3%80%81%E5%BF%AB%E9%80%9F%E5%90%AF%E5%8A%A8%E6%A1%86%E6%9E%B6%EF%BC%9ASpringBoot3%E5%AE%9E%E6%88%98/","excerpt":"","text":"六、快速启动框架：SpringBoot3实战目录 一、SpringBoot3介绍 1.1 SpringBoot3简介 1.2 系统要求 1.3 快速入门 1.4 入门总结 二、SpringBoot3配置文件 2.1 统一配置管理概述 2.2 属性配置文件使用 2.3 YAML配置文件使用 2.4 批量配置文件注入 2.5 多环境配置和使用 三、SpringBoot3整合SpringMVC 3.1 实现过程 3.2 web相关配置 3.3 静态资源处理 3.4 自定义拦截器(SpringMVC配置) 四、SpringBoot3整合Druid数据源 五、SpringBoot3整合Mybatis 5.1 MyBatis整合步骤 5.2 Mybatis整合实践 5.3 声明式事务整合配置 5.4 AOP整合配置 六、SpringBoot3项目打包和运行 6.1 添加打包插件 6.2 执行打包 6.3 命令启动和参数说明 一、SpringBoot3介绍1.1 SpringBoot3简介 课程使用SpringBoot版本：3.0.5 https://docs.spring.io/spring-boot/docs/current/reference/html/getting-started.html#getting-started.introducing-spring-boot 到目前为止，你已经学习了多种配置Spring程序的方式。但是无论使用XML、注解、Java配置类还是他们的混合用法，你都会觉得配置文件过于复杂和繁琐，让人头疼！ SpringBoot 帮我们简单、快速地创建一个独立的、生产级别的 Spring 应用（说明：SpringBoot底层是Spring），大多数 SpringBoot 应用只需要编写少量配置即可快速整合 Spring 平台以及第三方技术！ SpringBoot的主要目标是： 为所有 Spring 开发提供更快速、可广泛访问的入门体验。 开箱即用，设置合理的默认值，但是也可以根据需求进行适当的调整。 提供一系列大型项目通用的非功能性程序（如嵌入式服务器、安全性、指标、运行检查等）。 约定大于配置，基本不需要主动编写配置类、也不需要 XML 配置文件。 总结：简化开发，简化配置，简化整合，简化部署，简化监控，简化运维。 1.2 系统要求 技术&amp;工具 版本（or later） maven 3.6.3 or later 3.6.3 或更高版本 Tomcat 10.0+ Servlet 9.0+ JDK 17+ 1.3 快速入门 场景：浏览器发送 &#x2F;hello请求，返回”Hello,Spring Boot 3!“ 开发步骤 创建Maven工程 添加依赖(springboot父工程依赖 , web启动器依赖) 编写启动引导类(springboot项目运行的入口) 编写处理器Controller 启动项目 创建项目 添加依赖 3.1 添加父工程坐标 SpringBoot可以帮我们方便的管理项目依赖 , 在Spring Boot提供了一个名为spring-boot-starter-parent的工程，里面已经对各种常用依赖的版本进行了管理，我们的项目需要以这个项目为父工程，这样我们就不用操心依赖的版本问题了，需要什么依赖，直接引入坐标(不需要添加版本)即可！ 123456&lt;!--所有springboot项目都必须继承自 spring-boot-starter-parent--&gt;&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;3.0.5&lt;/version&gt;&lt;/parent&gt; 3.2 添加web启动器 为了让Spring Boot帮我们完成各种自动配置，我们必须引入Spring Boot提供的自动配置依赖，我们称为启动器。因为我们是web项目，这里我们引入web启动器，在 pom.xml 文件中加入如下依赖： 1234567&lt;dependencies&gt;&lt;!--web开发的场景启动器--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 创建启动类 创建package：com.atguigu 创建启动类：MainApplication 12345678910111213141516171819202122232425package com.atguigu;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;/** * @SpringBootApplication是一个特殊的注解，用于标识一个Spring Boot应用程序的入口类。它的主要作用是将三个常用注解组合在一起，简化了配置的过程。 * * 具体而言，@SpringBootApplication注解包含以下三个注解的功能： * @Configuration：将该类标识为应用程序的配置类。它允许使用Java代码定义和配置Bean。 * @EnableAutoConfiguration：启用Spring Boot的自动配置机制。它根据项目的依赖项自动配置Spring应用程序的行为。自动配置根据类路径、注解和配置属性等条件来决定要使用的功能和配置。 * @ComponentScan：自动扫描并加载应用程序中的组件，如控制器、服务、存储库等。它默认扫描@SpringBootApplication注解所在类的包及其子包中的组件。 * * 使用@SpringBootApplication注解，可以将上述三个注解的功能集中在一个注解上，简化了配置文件的编写和组件的加载和扫描过程。它是Spring Boot应用程序的入口点，标识了应用程序的主类， * 并告诉Spring Boot在启动时应如何配置和加载应用程序。 */@SpringBootApplicationpublic class MainApplication &#123; //SpringApplication.run() 方法是启动 Spring Boot 应用程序的关键步骤。它创建应用程序上下文、 // 自动配置应用程序、启动应用程序，并处理命令行参数，使应用程序能够运行和提供所需的功能 public static void main(String[] args) &#123; SpringApplication.run(MainApplication.class,args); &#125;&#125; 编写处理器Controller 创建package：com.atguigu.controller 创建类：HelloController 注意： IoC和DI注解需要在启动类的同包或者子包下方可生效！无需指定，约束俗称。 1234567891011121314package com.atguigu.controller;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RestController;@RestControllerpublic class HelloController &#123; @GetMapping(&quot;/hello&quot;) public String hello()&#123; return &quot;Hello,Spring Boot 3!&quot;; &#125;&#125; 启动测试 1.4 入门总结 为什么依赖不需要写版本？ 每个boot项目都有一个父项目spring-boot-starter-parent parent的父项目是spring-boot-dependencies 父项目 版本仲裁中心，把所有常见的jar的依赖版本都声明好了。 比如：mysql-connector-j 启动器(Starter)是何方神圣？ Spring Boot提供了一种叫做Starter的概念，它是一组预定义的依赖项集合，旨在简化Spring应用程序的配置和构建过程。Starter包含了一组相关的依赖项，以便在启动应用程序时自动引入所需的库、配置和功能。 主要作用如下： 简化依赖管理：Spring Boot Starter通过捆绑和管理一组相关的依赖项，减少了手动解析和配置依赖项的工作。只需引入一个相关的Starter依赖，即可获取应用程序所需的全部依赖。 自动配置：Spring Boot Starter在应用程序启动时自动配置所需的组件和功能。通过根据类路径和其他设置的自动检测，Starter可以自动配置Spring Bean、数据源、消息传递等常见组件，从而使应用程序的配置变得简单和维护成本降低。 提供约定优于配置：Spring Boot Starter遵循“约定优于配置”的原则，通过提供一组默认设置和约定，减少了手动配置的需要。它定义了标准的配置文件命名约定、默认属性值、日志配置等，使得开发者可以更专注于业务逻辑而不是繁琐的配置细节。 快速启动和开发应用程序：Spring Boot Starter使得从零开始构建一个完整的Spring Boot应用程序变得容易。它提供了主要领域（如Web开发、数据访问、安全性、消息传递等）的Starter，帮助开发者快速搭建一个具备特定功能的应用程序原型。 模块化和可扩展性：Spring Boot Starter的组织结构使得应用程序的不同模块可以进行分离和解耦。每个模块可以有自己的Starter和依赖项，使得应用程序的不同部分可以按需进行开发和扩展。Spring Boot提供了许多预定义的Starter，例如spring-boot-starter-web用于构建Web应用程序，spring-boot-starter-data-jpa用于使用JPA进行数据库访问，spring-boot-starter-security用于安全认证和授权等等。 使用Starter非常简单，只需要在项目的构建文件（例如Maven的pom.xml）中添加所需的Starter依赖，Spring Boot会自动处理依赖管理和配置。 通过使用Starter，开发人员可以方便地引入和配置应用程序所需的功能，避免了手动添加大量的依赖项和编写冗长的配置文件的繁琐过程。同时，Starter也提供了一致的依赖项版本管理，确保依赖项之间的兼容性和稳定性。 spring boot提供的全部启动器地址： https://docs.spring.io/spring-boot/docs/current/reference/html/using.html#using.build-systems.starters 命名规范： 官方提供的场景：命名为：spring-boot-starter-* 第三方提供场景：命名为：*-spring-boot-starter @SpringBootApplication注解的功效？ @SpringBootApplication添加到启动类上，是一个组合注解，他的功效有具体的子注解实现！ 12345@SpringBootConfiguration@EnableAutoConfiguration@ComponentScanpublic @interface SpringBootApplication &#123;&#125; @SpringBootApplication注解是Spring Boot框架中的核心注解，它的主要作用是简化和加速Spring Boot应用程序的配置和启动过程。 具体而言，@SpringBootApplication注解起到以下几个主要作用： 自动配置：@SpringBootApplication注解包含了@EnableAutoConfiguration注解，用于启用Spring Boot的自动配置机制。自动配置会根据应用程序的依赖项和类路径，自动配置各种常见的Spring配置和功能，减少开发者的手动配置工作。它通过智能地分析类路径、加载配置和条件判断，为应用程序提供适当的默认配置。 组件扫描：@SpringBootApplication注解包含了@ComponentScan注解，用于自动扫描并加载应用程序中的组件，例如控制器（Controllers）、服务（Services）、存储库（Repositories）等。它默认会扫描@SpringBootApplication注解所在类的包及其子包中的组件，并将它们纳入Spring Boot应用程序的上下文中，使它们可被自动注入和使用。 声明配置类：@SpringBootApplication注解本身就是一个组合注解，它包含了@Configuration注解，将被标注的类声明为配置类。配置类可以包含Spring框架相关的配置、Bean定义，以及其他的自定义配置。通过@SpringBootApplication注解，开发者可以将配置类与启动类合并在一起，使得配置和启动可以同时发生。总的来说，@SpringBootApplication注解的主要作用是简化Spring Boot应用程序的配置和启动过程。它自动配置应用程序、扫描并加载组件，并将配置和启动类合二为一，简化了开发者的工作量，提高了开发效率。 二、SpringBoot3配置文件2.1 统一配置管理概述SpringBoot工程下，进行统一的配置管理，你想设置的任何参数（端口号、项目根路径、数据库连接信息等等)都集中到一个固定位置和命名的配置文件（application.properties或application.yml）中！ 配置文件应该放置在Spring Boot工程的src/main/resources目录下。这是因为src/main/resources目录是Spring Boot默认的类路径（classpath），配置文件会被自动加载并可供应用程序访问。 功能配置参数说明： https://docs.spring.io/spring-boot/docs/current/reference/html/application-properties.html#appendix.application-properties 细节总结： 集中式管理配置。统一在一个文件完成程序功能参数设置和自定义参数声明 。 位置：resources文件夹下，必须命名application 后缀 .properties &#x2F; .yaml &#x2F; .yml 。 如果同时存在application.properties | application.yml(.yaml) , properties的优先级更高。 配置基本都有默认值。 2.2 属性配置文件使用 配置文件 在 resource 文件夹下面新建 application.properties 配置文件 12345678910111213# application.properties 为统一配置文件# 内部包含: 固定功能的key,自定义的key# 此处的配置信息,我们都可以在程序中@Value等注解读取# 固定的key# 启动端口号server.port=80 # 自定义spring.jdbc.datasource.driverClassName=com.mysql.cj.jdbc.driverspring.jdbc.datasource.url=jdbc:mysql:///springboot_01spring.jdbc.datasource.username=rootspring.jdbc.datasource.password=root 读取配置文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263package com.atguigu.properties;import org.springframework.beans.factory.annotation.Value;import org.springframework.stereotype.Component;@Componentpublic class DataSourceProperties &#123; @Value(&quot;$&#123;spring.jdbc.datasource.driverClassName&#125;&quot;) private String driverClassName; @Value(&quot;$&#123;spring.jdbc.datasource.url&#125;&quot;) private String url; @Value(&quot;$&#123;spring.jdbc.datasource.username&#125;&quot;) private String username; @Value(&quot;$&#123;spring.jdbc.datasource.password&#125;&quot;) private String password; // 生成get set 和 toString方法 public String getDriverClassName() &#123; return driverClassName; &#125; public void setDriverClassName(String driverClassName) &#123; this.driverClassName = driverClassName; &#125; public String getUrl() &#123; return url; &#125; public void setUrl(String url) &#123; this.url = url; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; @Override public String toString() &#123; return &quot;DataSourceProperties&#123;&quot; + &quot;driverClassName=&#x27;&quot; + driverClassName + &#x27;\\&#x27;&#x27; + &quot;, url=&#x27;&quot; + url + &#x27;\\&#x27;&#x27; + &quot;, username=&#x27;&quot; + username + &#x27;\\&#x27;&#x27; + &quot;, password=&#x27;&quot; + password + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125;&#125; 测试效果 在controller注入，输出进行测试 12345678@Autowiredprivate DataSourceProperties dataSourceProperties ;@RequestMapping(path = &quot;/hello&quot;)public String sayHello() &#123; System.out.println(dataSourceProperties); return &quot;Hello Spring Boot ! &quot; ;&#125; 浏览器访问路径，控制台查看效果 2.3 YAML配置文件使用 yaml格式介绍 YAML（YAML Ain’t Markup Language）是一种基于层次结构的数据序列化格式，旨在提供一种易读、人类友好的数据表示方式。 与.properties文件相比，YAML格式有以下优势： 层次结构：YAML文件使用缩进和冒号来表示层次结构，使得数据之间的关系更加清晰和直观。这样可以更容易理解和维护复杂的配置，特别适用于深层次嵌套的配置情况。 自我描述性：YAML文件具有自我描述性，字段和值之间使用冒号分隔，并使用缩进表示层级关系。这使得配置文件更易于阅读和理解，并且可以减少冗余的标点符号和引号。 注释支持：YAML格式支持注释，可以在配置文件中添加说明性的注释，使配置更具可读性和可维护性。相比之下，.properties文件不支持注释，无法提供类似的解释和说明。 多行文本：YAML格式支持多行文本的表示，可以更方便地表示长文本或数据块。相比之下，.properties文件需要使用转义符或将长文本拆分为多行。 类型支持：YAML格式天然支持复杂的数据类型，如列表、映射等。这使得在配置文件中表示嵌套结构或数据集合更加容易，而不需要进行额外的解析或转换。 更好的可读性：由于YAML格式的特点，它更容易被人类读懂和解释。它减少了配置文件中需要的特殊字符和语法，让配置更加清晰明了，从而减少了错误和歧义。综上所述，YAML格式相对于.properties文件具有更好的层次结构表示、自我描述性、注释支持、多行文本表示、复杂数据类型支持和更好的可读性。这些特点使YAML成为一种有力的配置文件格式，尤其适用于复杂的配置需求和人类可读的场景。然而，选择使用YAML还是.properties取决于实际需求和团队的偏好，简单的配置可以使用.properties，而复杂的配置可以选择YAML以获得更多的灵活性和可读性 yaml语法说明 数据结构用树形结构呈现，通过缩进来表示层级， 连续的项目（集合）通过减号 ” - ” 来表示 键值结构里面的key&#x2F;value对用冒号 ” : ” 来分隔。 YAML配置文件的扩展名是yaml 或 yml 例如：12345678910111213141516171819# YAML配置文件示例app_name: 我的应用程序version: 1.0.0author: 张三database: host: localhost port: 5432 username: admin password: password123features: - 登录 - 注册 - 仪表盘settings: analytics: true theme: dark 配置文件 12345678910spring: jdbc: datasource: driverClassName: com.mysql.jdbc.Driver url: jdbc:mysql:///springboot_02 username: root password: root server: port: 80 读取配置文件 读取方式和properties一致 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263package com.atguigu.properties;import org.springframework.beans.factory.annotation.Value;import org.springframework.stereotype.Component;@Componentpublic class DataSourceProperties &#123; @Value(&quot;$&#123;spring.jdbc.datasource.driverClassName&#125;&quot;) private String driverClassName; @Value(&quot;$&#123;spring.jdbc.datasource.url&#125;&quot;) private String url; @Value(&quot;$&#123;spring.jdbc.datasource.username&#125;&quot;) private String username; @Value(&quot;$&#123;spring.jdbc.datasource.password&#125;&quot;) private String password; // 生成get set 和 toString方法 public String getDriverClassName() &#123; return driverClassName; &#125; public void setDriverClassName(String driverClassName) &#123; this.driverClassName = driverClassName; &#125; public String getUrl() &#123; return url; &#125; public void setUrl(String url) &#123; this.url = url; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; @Override public String toString() &#123; return &quot;DataSourceProperties&#123;&quot; + &quot;driverClassName=&#x27;&quot; + driverClassName + &#x27;\\&#x27;&#x27; + &quot;, url=&#x27;&quot; + url + &#x27;\\&#x27;&#x27; + &quot;, username=&#x27;&quot; + username + &#x27;\\&#x27;&#x27; + &quot;, password=&#x27;&quot; + password + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125;&#125; 测试效果 在controller注入，输出进行测试 12345678@Autowiredprivate DataSourceProperties dataSourceProperties ;@RequestMapping(path = &quot;/hello&quot;)public String sayHello() &#123; System.out.println(dataSourceProperties); return &quot;Hello Spring Boot ! &quot; ;&#125; 浏览器访问路径，控制台查看效果 2.4 批量配置文件注入 &#x20;@ConfigurationProperties是SpringBoot提供的重要注解, 他可以将一些配置属性批量注入到bean对象。 创建类，添加属性和注解 在类上通过@ConfigurationProperties注解声明该类要读取属性配置 prefix&#x3D;”spring.jdbc.datasource” 读取属性文件中前缀为spring.jdbc.datasource的值。前缀和属性名称和配置文件中的key必须要保持一致才可以注入成功 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556package com.atguigu.properties;import org.springframework.boot.context.properties.ConfigurationProperties;import org.springframework.stereotype.Component;@Component@ConfigurationProperties(prefix = &quot;spring.jdbc.datasource&quot;)public class DataSourceConfigurationProperties &#123; private String driverClassName; private String url; private String username; private String password; public String getDriverClassName() &#123; return driverClassName; &#125; public void setDriverClassName(String driverClassName) &#123; this.driverClassName = driverClassName; &#125; public String getUrl() &#123; return url; &#125; public void setUrl(String url) &#123; this.url = url; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; @Override public String toString() &#123; return &quot;DataSourceConfigurationProperties&#123;&quot; + &quot;driverClassName=&#x27;&quot; + driverClassName + &#x27;\\&#x27;&#x27; + &quot;, url=&#x27;&quot; + url + &#x27;\\&#x27;&#x27; + &quot;, username=&#x27;&quot; + username + &#x27;\\&#x27;&#x27; + &quot;, password=&#x27;&quot; + password + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125;&#125; 测试效果 12345678910111213141516@RestControllerpublic class HelloController &#123; @Autowired private DataSourceProperties dataSourceProperties; @Autowired private DataSourceConfigurationProperties dataSourceConfigurationProperties; @GetMapping(&quot;/hello&quot;) public String hello()&#123; System.out.println(&quot;dataSourceProperties = &quot; + dataSourceProperties); System.out.println(&quot;dataSourceConfigurationProperties = &quot; + dataSourceConfigurationProperties); return &quot;Hello,Spring Boot 3!&quot;; &#125;&#125; 浏览器访问路径，控制台查看效果 2.5 多环境配置和使用 需求 在Spring Boot中，可以使用多环境配置来根据不同的运行环境（如开发、测试、生产）加载不同的配置。SpringBoot支持多环境配置让应用程序在不同的环境中使用不同的配置参数，例如数据库连接信息、日志级别、缓存配置等。 以下是实现Spring Boot多环境配置的常见方法： 属性文件分离：将应用程序的配置参数分离到不同的属性文件中，每个环境对应一个属性文件。例如，可以创建application-dev.properties、application-prod.properties和application-test.properties等文件。在这些文件中，可以定义各自环境的配置参数，如数据库连接信息、端口号等。然后，在application.properties中通过spring.profiles.active属性指定当前使用的环境。Spring Boot会根据该属性来加载对应环境的属性文件，覆盖默认的配置。 YAML配置文件：与属性文件类似，可以将配置参数分离到不同的YAML文件中，每个环境对应一个文件。例如，可以创建application-dev.yml、application-prod.yml和application-test.yml等文件。在这些文件中，可以使用YAML语法定义各自环境的配置参数。同样，通过spring.profiles.active属性指定当前的环境，Spring Boot会加载相应的YAML文件。 命令行参数(动态)：可以通过命令行参数来指定当前的环境。例如，可以使用--spring.profiles.active=dev来指定使用开发环境的配置。通过上述方法，Spring Boot会根据当前指定的环境来加载相应的配置文件或参数，从而实现多环境配置。这样可以简化在不同环境之间的配置切换，并且确保应用程序在不同环境中具有正确的配置。 多环境配置（基于方式b实践） 创建开发、测试、生产三个环境的配置文件application-dev.yml（开发） 1234567spring: jdbc: datasource: driverClassName: com.mysql.cj.jdbc.Driver url: jdbc:mysql:///dev username: root password: root application-test.yml（测试） 1234567spring: jdbc: datasource: driverClassName: com.mysql.cj.jdbc.Driver url: jdbc:mysql:///test username: root password: root application-prod.yml（生产） 1234567spring: jdbc: datasource: driverClassName: com.mysql.cj.jdbc.Driver url: jdbc:mysql:///prod username: root password: root 环境激活 123spring: profiles: active: dev 测试效果 注意 : 如果设置了spring.profiles.active，并且和application有重叠属性，以active设置优先。 如果设置了spring.profiles.active，和application无重叠属性，application设置依然生效！ 三、SpringBoot3整合SpringMVC3.1 实现过程 创建程序 引入依赖 12345678910111213141516171819202122232425262728293031&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;3.0.5&lt;/version&gt; &lt;/parent&gt; &lt;groupId&gt;com.atguigu&lt;/groupId&gt; &lt;artifactId&gt;springboot-starter-springmvc-03&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;17&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;17&lt;/maven.compiler.target&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!-- web开发的场景启动器 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 创建启动类 12345678@SpringBootApplicationpublic class MainApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(MainApplication.class,args); &#125;&#125; 创建实体类 12345678910111213141516171819202122232425262728293031323334353637383940package com.atguigu.pojo;public class User &#123; private String username ; private String password ; private Integer age ; private String sex ; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; public Integer getAge() &#123; return age; &#125; public void setAge(Integer age) &#123; this.age = age; &#125; public String getSex() &#123; return sex; &#125; public void setSex(String sex) &#123; this.sex = sex; &#125;&#125; 编写Controller 123456789101112131415161718192021222324package com.atguigu.controller;import com.atguigu.pojo.User;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.ResponseBody;@Controller@RequestMapping(&quot;/user&quot;)public class UserController &#123; @GetMapping(&quot;/getUser&quot;) @ResponseBody public User getUser()&#123; User user = new User(); user.setUsername(&quot;杨过&quot;); user.setPassword(&quot;123456&quot;); user.setAge(18); user.setSex(&quot;男&quot;); return user; &#125;&#125; 访问测试 3.2 web相关配置位置：application.yml 12345678# web相关的配置# https://docs.spring.io/spring-boot/docs/current/reference/html/application-properties.html#appendix.application-properties.serverserver: # 端口号设置 port: 80 # 项目根路径 servlet: context-path: /boot 当涉及Spring Boot的Web应用程序配置时，以下是五个重要的配置参数： server.port: 指定应用程序的HTTP服务器端口号。默认情况下，Spring Boot使用8080作为默认端口。您可以通过在配置文件中设置server.port来更改端口号。 server.servlet.context-path: 设置应用程序的上下文路径。这是应用程序在URL中的基本路径。默认情况下，上下文路径为空。您可以通过在配置文件中设置server.servlet.context-path属性来指定自定义的上下文路径。 spring.mvc.view.prefix和spring.mvc.view.suffix: 这两个属性用于配置视图解析器的前缀和后缀。视图解析器用于解析控制器返回的视图名称，并将其映射到实际的视图页面。spring.mvc.view.prefix定义视图的前缀，spring.mvc.view.suffix定义视图的后缀。 spring.resources.static-locations: 配置静态资源的位置。静态资源可以是CSS、JavaScript、图像等。默认情况下，Spring Boot会将静态资源放在classpath:/static目录下。您可以通过在配置文件中设置spring.resources.static-locations属性来自定义静态资源的位置。 spring.http.encoding.charset和spring.http.encoding.enabled: 这两个属性用于配置HTTP请求和响应的字符编码。spring.http.encoding.charset定义字符编码的名称（例如UTF-8），spring.http.encoding.enabled用于启用或禁用字符编码的自动配置。 这些是在Spring Boot的配置文件中与Web应用程序相关的一些重要配置参数。根据您的需求，您可以在配置文件中设置这些参数来定制和配置您的Web应用程序 3.3 静态资源处理 在WEB开发中我们需要引入一些静态资源 , 例如 : HTML , CSS , JS , 图片等 , 如果是普通的项目静态资源可以放在项目的webapp目录下。现在使用Spring Boot做开发 , 项目中没有webapp目录 , 我们的项目是一个jar工程，那么就没有webapp，我们的静态资源该放哪里呢？ 默认路径 在springboot中就定义了静态资源的默认查找路径： 123456789101112131415161718package org.springframework.boot.autoconfigure.web;//..................public static class Resources &#123; private static final String[] CLASSPATH_RESOURCE_LOCATIONS = new String[]&#123;&quot;classpath:/META-INF/resources/&quot;, &quot;classpath:/resources/&quot;, &quot;classpath:/static/&quot;, &quot;classpath:/public/&quot;&#125;; private String[] staticLocations; private boolean addMappings; private boolean customized; private final Chain chain; private final Cache cache; public Resources() &#123; this.staticLocations = CLASSPATH_RESOURCE_LOCATIONS; this.addMappings = true; this.customized = false; this.chain = new Chain(); this.cache = new Cache(); &#125;//........... 默认的静态资源路径为： · classpath:&#x2F;META-INF&#x2F;resources&#x2F; · classpath:&#x2F;resources&#x2F; · classpath:&#x2F;static&#x2F; · classpath:&#x2F;public&#x2F; 我们只要静态资源放在这些目录中任何一个，SpringMVC都会帮我们处理。 我们习惯会把静态资源放在classpath:&#x2F;static&#x2F; 目录下。在resources目录下创建index.html文件 打开浏览器输入 : http://localhost:8080/index.html 覆盖路径 12345678910111213# web相关的配置# https://docs.spring.io/spring-boot/docs/current/reference/html/application-properties.html#appendix.application-properties.serverserver: # 端口号设置 port: 80 # 项目根路径 servlet: context-path: /bootspring: web: resources: # 配置静态资源地址,如果设置,会覆盖默认值 static-locations: classpath:/webapp 访问地址：http://localhost/boot/login.html 3.4 自定义拦截器(SpringMVC配置) 拦截器声明 1234567891011121314151617181920212223242526package com.atguigu.interceptor;import jakarta.servlet.http.HttpServletRequest;import jakarta.servlet.http.HttpServletResponse;import org.springframework.stereotype.Component;import org.springframework.web.servlet.HandlerInterceptor;import org.springframework.web.servlet.ModelAndView;@Componentpublic class MyInterceptor implements HandlerInterceptor &#123; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; System.out.println(&quot;MyInterceptor拦截器的preHandle方法执行....&quot;); return true; &#125; @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; System.out.println(&quot;MyInterceptor拦截器的postHandle方法执行....&quot;); &#125; @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; System.out.println(&quot;MyInterceptor拦截器的afterCompletion方法执行....&quot;); &#125;&#125; 拦截器配置 正常使用配置类，只要保证，配置类要在启动类的同包或者子包方可生效！ 123456789101112131415161718192021222324package com.atguigu.config;import com.atguigu.interceptor.MyInterceptor;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.context.annotation.Configuration;import org.springframework.web.servlet.config.annotation.InterceptorRegistry;import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;@Configurationpublic class MvcConfig implements WebMvcConfigurer &#123; @Autowired private MyInterceptor myInterceptor ; /** * /** 拦截当前目录及子目录下的所有路径 /user/** /user/findAll /user/order/findAll * /* 拦截当前目录下的以及子路径 /user/* /user/findAll * @param registry */ @Override public void addInterceptors(InterceptorRegistry registry) &#123; registry.addInterceptor(myInterceptor).addPathPatterns(&quot;/**&quot;); &#125;&#125; 拦截器效果测试 四、SpringBoot3整合Druid数据源 创建程序 引入依赖 1234567891011121314151617181920&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;3.0.5&lt;/version&gt; &lt;/parent&gt; &lt;groupId&gt;com.atguigu&lt;/groupId&gt; &lt;artifactId&gt;springboot-starter-druid-04&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;17&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;17&lt;/maven.compiler.target&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!-- web开发的场景启动器 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- 数据库相关配置启动器 jdbctemplate 事务相关--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- druid启动器的依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-3-starter&lt;/artifactId&gt; &lt;version&gt;1.2.18&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 驱动类--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.28&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.28&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;!-- SpringBoot应用打包插件--&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; 123456789103. 启动类 ```java @SpringBootApplication public class MainApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(MainApplication.class,args); &#125; &#125; 配置文件编写 添加druid连接池的基本配置 1234567891011121314151617181920212223242526272829303132333435363738394041spring: datasource: # 连接池类型 type: com.alibaba.druid.pool.DruidDataSource # Druid的其他属性配置 springboot3整合情况下,数据库连接信息必须在Druid属性下! druid: url: jdbc:mysql://localhost:3306/day01 username: root password: root driver-class-name: com.mysql.cj.jdbc.Driver # 初始化时建立物理连接的个数 initial-size: 5 # 连接池的最小空闲数量 min-idle: 5 # 连接池最大连接数量 max-active: 20 # 获取连接时最大等待时间，单位毫秒 max-wait: 60000 # 申请连接的时候检测，如果空闲时间大于timeBetweenEvictionRunsMillis，执行validationQuery检测连接是否有效。 test-while-idle: true # 既作为检测的间隔时间又作为testWhileIdel执行的依据 time-between-eviction-runs-millis: 60000 # 销毁线程时检测当前连接的最后活动时间和当前时间差大于该值时，关闭当前连接(配置连接在池中的最小生存时间) min-evictable-idle-time-millis: 30000 # 用来检测数据库连接是否有效的sql 必须是一个查询语句(oracle中为 select 1 from dual) validation-query: select 1 # 申请连接时会执行validationQuery检测连接是否有效,开启会降低性能,默认为true test-on-borrow: false # 归还连接时会执行validationQuery检测连接是否有效,开启会降低性能,默认为true test-on-return: false # 是否缓存preparedStatement, 也就是PSCache,PSCache对支持游标的数据库性能提升巨大，比如说oracle,在mysql下建议关闭。 pool-prepared-statements: false # 要启用PSCache，必须配置大于0，当大于0时，poolPreparedStatements自动触发修改为true。在Druid中，不会存在Oracle下PSCache占用内存过多的问题，可以把这个数值配置大一些，比如说100 max-pool-prepared-statement-per-connection-size: -1 # 合并多个DruidDataSource的监控数据 use-global-data-source-stat: truelogging: level: root: debug 编写Controller 123456789101112131415161718@Slf4j@Controller@RequestMapping(&quot;/user&quot;)public class UserController &#123; @Autowired private JdbcTemplate jdbcTemplate; @GetMapping(&quot;/getUser&quot;) @ResponseBody public User getUser()&#123; String sql = &quot;select * from users where id = ? ; &quot;; User user = jdbcTemplate.queryForObject(sql, new BeanPropertyRowMapper&lt;&gt;(User.class), 1); log.info(&quot;查询的user数据为:&#123;&#125;&quot;,user.toString()); return user; &#125; &#125; 启动测试 问题解决 通过源码分析，druid-spring-boot-3-starter目前最新版本是1.2.18，虽然适配了SpringBoot3，但缺少自动装配的配置文件，需要手动在resources目录下创建META-INF&#x2F;spring&#x2F;org.springframework.boot.autoconfigure.AutoConfiguration.imports，文件内容如下! 1com.alibaba.druid.spring.boot3.autoconfigure.DruidDataSourceAutoConfigure 五、SpringBoot3整合Mybatis5.1 MyBatis整合步骤 导入依赖：在您的Spring Boot项目的构建文件（如pom.xml）中添加MyBatis和数据库驱动的相关依赖。例如，如果使用MySQL数据库，您需要添加MyBatis和MySQL驱动的依赖。 配置数据源：在application.properties或application.yml中配置数据库连接信息，包括数据库URL、用户名、密码、mybatis的功能配置等。 创建实体类：创建与数据库表对应的实体类。 创建Mapper接口：创建与数据库表交互的Mapper接口。 创建Mapper接口SQL实现： 可以使用mapperxml文件或者注解方式 创建程序启动类 注解扫描：在Spring Boot的主应用类上添加@MapperScan注解，用于扫描和注册Mapper接口。 使用Mapper接口：在需要使用数据库操作的地方，通过依赖注入或直接实例化Mapper接口，并调用其中的方法进行数据库操作。 5.2 Mybatis整合实践 创建项目 导入依赖 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;3.0.5&lt;/version&gt;&lt;/parent&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.0.1&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 数据库相关配置启动器 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- druid启动器的依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-3-starter&lt;/artifactId&gt; &lt;version&gt;1.2.18&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 驱动类--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.28&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.28&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 配置文件 1234567891011121314151617181920server: port: 80 servlet: context-path: /spring: datasource: type: com.alibaba.druid.pool.DruidDataSource druid: url: jdbc:mysql:///day01 username: root password: root driver-class-name: com.mysql.cj.jdbc.Driver mybatis: configuration: # setting配置 auto-mapping-behavior: full map-underscore-to-camel-case: true log-impl: org.apache.ibatis.logging.slf4j.Slf4jImpl type-aliases-package: com.atguigu.pojo # 配置别名 mapper-locations: classpath:/mapper/*.xml # mapperxml位置 实体类准备 12345678910111213141516171819202122232425262728293031323334353637383940package com.atguigu.pojo;public class User &#123; private String account ; private String password ; private Integer id ; public String getAccount() &#123; return account; &#125; public void setAccount(String account) &#123; this.account = account; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; @Override public String toString() &#123; return &quot;User&#123;&quot; + &quot;account=&#x27;&quot; + account + &#x27;\\&#x27;&#x27; + &quot;, password=&#x27;&quot; + password + &#x27;\\&#x27;&#x27; + &quot;, id=&quot; + id + &#x27;&#125;&#x27;; &#125;&#125; Mapper接口准备 1234public interface UserMapper &#123; List&lt;User&gt; queryAll();&#125; Mapper接口实现（XML） 位置：resources&#x2F;mapper&#x2F;UserMapper.xml 123456789101112&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;https://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;!-- namespace = 接口的全限定符 --&gt;&lt;mapper namespace=&quot;com.atguigu.mapper.UserMapper&quot;&gt; &lt;select id=&quot;queryAll&quot; resultType=&quot;user&quot;&gt; select * from users &lt;/select&gt;&lt;/mapper&gt; 编写三层架构代码 伪代码，不添加业务接口！ controller1234@Slf4j@Controller@RequestMapping(&quot;/user&quot;)public class UserController &#123; @Autowired private UserService userService; @GetMapping(&quot;/list&quot;) @ResponseBody public List&lt;User&gt; getUser()&#123; List&lt;User&gt; userList = userService.findList(); log.info(&quot;查询的user数据为:&#123;&#125;&quot;,userList); return userList; &#125; &#125; 1234567891011121314152. service ```java @Slf4j @Service public class UserService &#123; @Autowired private UserMapper userMapper; public List&lt;User&gt; findList()&#123; List&lt;User&gt; users = userMapper.queryAll(); log.info(&quot;查询全部数据:&#123;&#125;&quot;,users); return users; &#125; &#125; 启动类和接口扫描 123456789@MapperScan(&quot;com.atguigu.mapper&quot;) //mapper接口扫描配置@SpringBootApplicationpublic class MainApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(MainApplication.class,args); &#125;&#125; 启动测试 5.3 声明式事务整合配置依赖导入: 1234 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;&lt;/dependency&gt; 注：SpringBoot项目会自动配置一个 DataSourceTransactionManager，所以我们只需在方法（或者类）加上 @Transactional 注解，就自动纳入 Spring 的事务管理了 12345678@Transactionalpublic void update()&#123; User user = new User(); user.setId(1); user.setPassword(&quot;test2&quot;); user.setAccount(&quot;test2&quot;); userMapper.update(user);&#125; 5.4 AOP整合配置依赖导入: 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt;&lt;/dependency&gt; 直接使用aop注解即可:&#x20; 1234567891011@Component@Aspectpublic class LogAdvice &#123; @Before(&quot;execution(* com..service.*.*(..))&quot;) public void before(JoinPoint joinPoint)&#123; System.out.println(&quot;LogAdvice.before&quot;); System.out.println(&quot;joinPoint = &quot; + joinPoint); &#125;&#125; 六、SpringBoot3项目打包和运行6.1 添加打包插件 在Spring Boot项目中添加spring-boot-maven-plugin插件是为了支持将项目打包成可执行的可运行jar包。如果不添加spring-boot-maven-plugin插件配置，使用常规的java -jar命令来运行打包后的Spring Boot项目是无法找到应用程序的入口点，因此导致无法运行。 123456789&lt;!-- SpringBoot应用打包插件--&gt;&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 6.2 执行打包在idea点击package进行打包 可以在编译的target文件中查看jar包 6.3 命令启动和参数说明java -jar命令用于在Java环境中执行可执行的JAR文件。下面是关于java -jar命令的说明： 1命令格式：java -jar [选项] [参数] &lt;jar文件名&gt; -D&lt;name&gt;=&lt;value&gt;：设置系统属性，可以通过System.getProperty()方法在应用程序中获取该属性值。例如：java -jar -Dserver.port=8080 myapp.jar。 -X：设置JVM参数，例如内存大小、垃圾回收策略等。常用的选项包括： -Xmx&lt;size&gt;：设置JVM的最大堆内存大小，例如 -Xmx512m 表示设置最大堆内存为512MB。 -Xms&lt;size&gt;：设置JVM的初始堆内存大小，例如 -Xms256m 表示设置初始堆内存为256MB。 -Dspring.profiles.active=&lt;profile&gt;：指定Spring Boot的激活配置文件，可以通过application-&lt;profile&gt;.properties或application-&lt;profile&gt;.yml文件来加载相应的配置。例如：java -jar -Dspring.profiles.active=dev myapp.jar。 启动和测试： 注意： -D 参数必须要在jar之前！否者不生效！","categories":[{"name":"SSM框架","slug":"SSM框架","permalink":"http://example.com/categories/SSM%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"ssm","slug":"ssm","permalink":"http://example.com/tags/ssm/"}]},{"title":"五、框架实战：SSM整合原理和实战","slug":"SSM/五、框架实战：SSM整合原理和实战/五、框架实战：SSM整合原理和实战","date":"2022-10-01T09:55:54.000Z","updated":"2023-09-28T00:32:42.246Z","comments":true,"path":"2022/10/01/SSM/五、框架实战：SSM整合原理和实战/五、框架实战：SSM整合原理和实战/","link":"","permalink":"http://example.com/2022/10/01/SSM/%E4%BA%94%E3%80%81%E6%A1%86%E6%9E%B6%E5%AE%9E%E6%88%98%EF%BC%9ASSM%E6%95%B4%E5%90%88%E5%8E%9F%E7%90%86%E5%92%8C%E5%AE%9E%E6%88%98/%E4%BA%94%E3%80%81%E6%A1%86%E6%9E%B6%E5%AE%9E%E6%88%98%EF%BC%9ASSM%E6%95%B4%E5%90%88%E5%8E%9F%E7%90%86%E5%92%8C%E5%AE%9E%E6%88%98/","excerpt":"","text":"五、框架实战：SSM整合原理和实战目录 一、SSM整合理解 1.1 什么是SSM整合？ 1.2 SSM整合核心问题明确 1.2.1 第一问：SSM整合需要几个IoC容器？ 1.2.2 第二问：每个IoC容器对应哪些类型组件？ 1.2.3 第三问：IoC容器之间关系和调用方向？ 1.2.4 第四问：具体多少配置类以及对应容器关系？ 1.2.5 第五问：IoC初始化方式和配置位置？ 二、SSM整合配置实战 2.1 依赖整合和添加 2.2 控制层配置编写(SpringMVC整合) 2.3 业务层配置编写(AOP &#x2F; TX整合） 2.4 持久层配置编写(MyBatis整合) 2.5 容器初始化配置类 2.6 整合测试 三、《任务列表案例》前端程序搭建和运行 3.1 整合案例介绍和接口分析 3.1.1 案例功能预览 3.1.2接口分析 3.2 前端工程导入 3.2.1 前端环境搭建 3.2.2 导入前端程序 3.3 启动测试 四、《任务列表案例》后端程序实现和测试 4.1 准备工作 4.2 功能实现 4.3 前后联调 一、SSM整合理解1.1 什么是SSM整合？微观：将学习的Spring SpringMVC Mybatis框架应用到项目中! SpringMVC框架负责控制层 Spring 框架负责整体和业务层的声明式事务管理 MyBatis框架负责数据库访问层 宏观：Spring接管一切（将框架核心组件交给Spring进行IoC管理），代码更加简洁。 SpringMVC管理表述层、SpringMVC相关组件 Spring管理业务层、持久层、以及数据库相关（DataSource,MyBatis）的组件 使用IoC的方式管理一切所需组件 实施：通过编写配置文件，实现SpringIoC容器接管一切组件。 1.2 SSM整合核心问题明确1.2.1 第一问：SSM整合需要几个IoC容器？两个容器 本质上说，整合就是将三层架构和框架核心API组件交给SpringIoC容器管理！ 一个容器可能就够了，但是我们常见的操作是创建两个IoC容器（web容器和root容器），组件分类管理！ 这种做法有以下好处和目的： 分离关注点：通过初始化两个容器，可以将各个层次的关注点进行分离。这种分离使得各个层次的组件能够更好地聚焦于各自的责任和功能。 解耦合：各个层次组件分离装配不同的IoC容器，这样可以进行解耦。这种解耦合使得各个模块可以独立操作和测试，提高了代码的可维护性和可测试性。 灵活配置：通过使用两个容器，可以为每个容器提供各自的配置，以满足不同层次和组件的特定需求。每个配置文件也更加清晰和灵活。 总的来说，初始化两个容器在SSM整合中可以实现关注点分离、解耦合、灵活配置等好处。它们各自负责不同的层次和功能，并通过合适的集成方式协同工作，提供一个高效、可维护和可扩展的应用程序架构！ 1.2.2 第二问：每个IoC容器对应哪些类型组件？图解： 总结： 容器名 盛放组件 web容器 web相关组件（controller,springmvc核心组件） root容器 业务和持久层相关组件（service,aop,tx,dataSource,mybatis,mapper等） 1.2.3 第三问：IoC容器之间关系和调用方向？情况1：两个无关联IoC容器之间的组件无法注入！ 情况2：子IoC容器可以单向的注入父IoC容器的组件！ 结论：web容器是root容器的子容器，父子容器关系。 父容器：root容器，盛放service、mapper、mybatis等相关组件 子容器：web容器，盛放controller、web相关组件 源码体现： FrameworkServlet 655行！ 123456789101112131415161718192021222324protected WebApplicationContext createWebApplicationContext(@Nullable ApplicationContext parent) &#123; Class&lt;?&gt; contextClass = getContextClass(); if (!ConfigurableWebApplicationContext.class.isAssignableFrom(contextClass)) &#123; throw new ApplicationContextException( &quot;Fatal initialization error in servlet with name &#x27;&quot; + getServletName() + &quot;&#x27;: custom WebApplicationContext class [&quot; + contextClass.getName() + &quot;] is not of type ConfigurableWebApplicationContext&quot;); &#125; ConfigurableWebApplicationContext wac = (ConfigurableWebApplicationContext) BeanUtils.instantiateClass(contextClass); wac.setEnvironment(getEnvironment()); //wac 就是web ioc容器 //parent 就是root ioc容器 //web容器设置root容器为父容器，所以web容器可以引用root容器 wac.setParent(parent); String configLocation = getContextConfigLocation(); if (configLocation != null) &#123; wac.setConfigLocation(configLocation); &#125; configureAndRefreshWebApplicationContext(wac); return wac; &#125; 调用流程图解： 1.2.4 第四问：具体多少配置类以及对应容器关系？配置类的数量不是固定的，但是至少要两个，为了方便编写，我们可以三层架构每层对应一个配置类，分别指定两个容器加载即可！ 建议配置文件： 配置名 对应内容 对应容器 WebJavaConfig controller,springmvc相关 web容器 ServiceJavaConfig service,aop,tx相关 root容器 MapperJavaConfig mapper,datasource,mybatis相关 root容器 1.2.5 第五问：IoC初始化方式和配置位置？在web项目下，我们可以选择web.xml和配置类方式进行ioc配置，推荐配置类。 对于使用基于 web 的 Spring 配置的应用程序，建议这样做，如以下示例所示： 123456789101112131415161718192021public class MyWebAppInitializer extends AbstractAnnotationConfigDispatcherServletInitializer &#123; //指定root容器对应的配置类 //root容器的配置类 @Override protected Class&lt;?&gt;[] getRootConfigClasses() &#123; return new Class&lt;?&gt;[] &#123; ServiceJavaConfig.class,MapperJavaConfig.class &#125;; &#125; //指定web容器对应的配置类 webioc容器的配置类 @Override protected Class&lt;?&gt;[] getServletConfigClasses() &#123; return new Class&lt;?&gt;[] &#123; WebJavaConfig.class &#125;; &#125; //指定dispatcherServlet处理路径，通常为 / @Override protected String[] getServletMappings() &#123; return new String[] &#123; &quot;/&quot; &#125;; &#125;&#125; 图解配置类和容器配置： 二、SSM整合配置实战2.1 依赖整合和添加 数据库准备 依然沿用mybatis数据库测试脚本！ 1234567891011121314CREATE DATABASE `mybatis-example`;USE `mybatis-example`;CREATE TABLE `t_emp`( emp_id INT AUTO_INCREMENT, emp_name CHAR(100), emp_salary DOUBLE(10,5), PRIMARY KEY(emp_id));INSERT INTO `t_emp`(emp_name,emp_salary) VALUES(&quot;tom&quot;,200.33);INSERT INTO `t_emp`(emp_name,emp_salary) VALUES(&quot;jerry&quot;,666.66);INSERT INTO `t_emp`(emp_name,emp_salary) VALUES(&quot;andy&quot;,777.77); 准备项目 part04-ssm-integration 转成web项目 依赖导入 pom.xml 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.atguigu&lt;/groupId&gt; &lt;artifactId&gt;part04-ssm-integration&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;properties&gt; &lt;spring.version&gt;6.0.6&lt;/spring.version&gt; &lt;jakarta.annotation-api.version&gt;2.1.1&lt;/jakarta.annotation-api.version&gt; &lt;jakarta.jakartaee-web-api.version&gt;9.1.0&lt;/jakarta.jakartaee-web-api.version&gt; &lt;jackson-databind.version&gt;2.15.0&lt;/jackson-databind.version&gt; &lt;hibernate-validator.version&gt;8.0.0.Final&lt;/hibernate-validator.version&gt; &lt;mybatis.version&gt;3.5.11&lt;/mybatis.version&gt; &lt;mysql.version&gt;8.0.25&lt;/mysql.version&gt; &lt;pagehelper.version&gt;5.1.11&lt;/pagehelper.version&gt; &lt;druid.version&gt;1.2.8&lt;/druid.version&gt; &lt;mybatis-spring.version&gt;3.0.2&lt;/mybatis-spring.version&gt; &lt;jakarta.servlet.jsp.jstl-api.version&gt;3.0.0&lt;/jakarta.servlet.jsp.jstl-api.version&gt; &lt;logback.version&gt;1.2.3&lt;/logback.version&gt; &lt;lombok.version&gt;1.18.26&lt;/lombok.version&gt; &lt;maven.compiler.source&gt;17&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;17&lt;/maven.compiler.target&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;/properties&gt; &lt;!-- 需要依赖清单分析: spring ioc/di spring-context / 6.0.6 jakarta.annotation-api / 2.1.1 jsr250 aop spring-aspects / 6.0.6 tx spring-tx / 6.0.6 spring-jdbc / 6.0.6 springmvc spring-webmvc 6.0.6 jakarta.jakartaee-web-api 9.1.0 jackson-databind 2.15.0 hibernate-validator / hibernate-validator-annotation-processor 8.0.0.Final mybatis mybatis / 3.5.11 mysql / 8.0.25 pagehelper / 5.1.11 整合需要 加载spring容器 spring-web / 6.0.6 整合mybatis mybatis-spring x x 数据库连接池 druid / x lombok lombok / 1.18.26 logback logback/ 1.2.3 --&gt; &lt;dependencies&gt; &lt;!--spring pom.xml依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;jakarta.annotation&lt;/groupId&gt; &lt;artifactId&gt;jakarta.annotation-api&lt;/artifactId&gt; &lt;version&gt;$&#123;jakarta.annotation-api.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- springmvc spring-webmvc 6.0.6 jakarta.jakartaee-web-api 9.1.0 jackson-databind 2.15.0 hibernate-validator / hibernate-validator-annotation-processor 8.0.0.Final --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;jakarta.platform&lt;/groupId&gt; &lt;artifactId&gt;jakarta.jakartaee-web-api&lt;/artifactId&gt; &lt;version&gt;$&#123;jakarta.jakartaee-web-api.version&#125;&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- jsp需要依赖! jstl--&gt; &lt;dependency&gt; &lt;groupId&gt;jakarta.servlet.jsp.jstl&lt;/groupId&gt; &lt;artifactId&gt;jakarta.servlet.jsp.jstl-api&lt;/artifactId&gt; &lt;version&gt;$&#123;jakarta.servlet.jsp.jstl-api.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;$&#123;jackson-databind.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.hibernate.validator/hibernate-validator --&gt; &lt;dependency&gt; &lt;groupId&gt;org.hibernate.validator&lt;/groupId&gt; &lt;artifactId&gt;hibernate-validator&lt;/artifactId&gt; &lt;version&gt;$&#123;hibernate-validator.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.hibernate.validator/hibernate-validator-annotation-processor --&gt; &lt;dependency&gt; &lt;groupId&gt;org.hibernate.validator&lt;/groupId&gt; &lt;artifactId&gt;hibernate-validator-annotation-processor&lt;/artifactId&gt; &lt;version&gt;$&#123;hibernate-validator.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- mybatis mybatis / 3.5.11 mysql / 8.0.25 pagehelper / 5.1.11 --&gt; &lt;!-- mybatis依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;$&#123;mybatis.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- MySQL驱动 mybatis底层依赖jdbc驱动实现,本次不需要导入连接池,mybatis自带! --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;$&#123;mysql.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper&lt;/artifactId&gt; &lt;version&gt;$&#123;pagehelper.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 整合第三方特殊依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;$&#123;mybatis-spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 日志 ， 会自动传递slf4j门面--&gt; &lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-classic&lt;/artifactId&gt; &lt;version&gt;$&#123;logback.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;$&#123;lombok.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;$&#123;druid.version&#125;&lt;/version&gt; &lt;/dependency&gt; 12345678910114. 实体类添加 com.atguigu.pojo ```java @Data public class Employee &#123; private Integer empId; private String empName; private Double empSalary; &#125; logback配置 位置：resources&#x2F;logback.xml 123456789101112131415161718192021222324&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;configuration debug=&quot;true&quot;&gt; &lt;!-- 指定日志输出的位置，ConsoleAppender表示输出到控制台 --&gt; &lt;appender name=&quot;STDOUT&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt; &lt;encoder&gt; &lt;!-- 日志输出的格式 --&gt; &lt;!-- 按照顺序分别是：时间、日志级别、线程名称、打印日志的类、日志主体内容、换行 --&gt; &lt;pattern&gt;[%d&#123;HH:mm:ss.SSS&#125;] [%-5level] [%thread] [%logger] [%msg]%n&lt;/pattern&gt; &lt;charset&gt;UTF-8&lt;/charset&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;!-- 设置全局日志级别。日志级别按顺序分别是：TRACE、DEBUG、INFO、WARN、ERROR --&gt; &lt;!-- 指定任何一个日志级别都只打印当前级别和后面级别的日志。 --&gt; &lt;root level=&quot;DEBUG&quot;&gt; &lt;!-- 指定打印日志的appender，这里通过“STDOUT”引用了前面配置的appender --&gt; &lt;appender-ref ref=&quot;STDOUT&quot; /&gt; &lt;/root&gt; &lt;!-- 根据特殊需求指定局部日志级别，可也是包名或全类名。 --&gt; &lt;logger name=&quot;com.atguigu.mybatis&quot; level=&quot;DEBUG&quot; /&gt;&lt;/configuration&gt; 2.2 控制层配置编写(SpringMVC整合) 主要配置controller,springmvc相关组件配置&#x20; 位置：WebJavaConfig.java(命名随意) 123456789101112131415161718192021/** * projectName: com.atguigu.config * * 1.实现Springmvc组件声明标准化接口WebMvcConfigurer 提供了各种组件对应的方法 * 2.添加配置类注解@Configuration * 3.添加mvc复合功能开关@EnableWebMvc * 4.添加controller层扫描注解 * 5.开启默认处理器,支持静态资源处理 */@Configuration@EnableWebMvc@ComponentScan(&quot;com.atguigu.controller&quot;)public class WebJavaConfig implements WebMvcConfigurer &#123; //开启静态资源 @Override public void configureDefaultServletHandling(DefaultServletHandlerConfigurer configurer) &#123; configurer.enable(); &#125;&#125; 2.3 业务层配置编写(AOP &#x2F; TX整合） 主要配置service,注解aop和声明事务相关配置 位置：ServiceJavaConfig.java(命名随意) 1234567891011121314151617181920212223/** * projectName: com.atguigu.config * * 1. 声明@Configuration注解,代表配置类 * 2. 声明@EnableTransactionManagement注解,开启事务注解支持 * 3. 声明@EnableAspectJAutoProxy注解,开启aspect aop注解支持 * 4. 声明@ComponentScan(&quot;com.atguigu.service&quot;)注解,进行业务组件扫描 * 5. 声明transactionManager(DataSource dataSource)方法,指定具体的事务管理器 */@EnableTransactionManagement@EnableAspectJAutoProxy@Configuration@ComponentScan(&quot;com.atguigu.service&quot;)public class ServiceJavaConfig &#123; @Bean public DataSourceTransactionManager transactionManager(DataSource dataSource)&#123; DataSourceTransactionManager transactionManager = new DataSourceTransactionManager(); transactionManager.setDataSource(dataSource); return transactionManager; &#125; &#125; 2.4 持久层配置编写(MyBatis整合) 主要配置mapper代理对象，连接池和mybatis核心组件配置 mybatis整合思路 mybatis核心api使用回顾： 12345678910111213141516//1.读取外部配置文件InputStream ips = Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;);//2.创建sqlSessionFactorySqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(ips);//3.创建sqlSessionSqlSession sqlSession = sqlSessionFactory.openSession();//4.获取mapper代理对象EmpMapper empMapper = sqlSession.getMapper(EmpMapper.class);//5.数据库方法调用int rows = empMapper.deleteEmpById(1);System.out.println(&quot;rows = &quot; + rows);//6.提交和回滚sqlSession.commit();sqlSession.close(); mybatis核心api介绍回顾： SqlSessionFactoryBuilder 这个类可以被实例化、使用和丢弃，一旦创建了 SqlSessionFactory，就不再需要它了。&#x20;因此 SqlSessionFactoryBuilder 实例的最佳作用域是方法作用域（也就是局部方法变量）。 无需ioc容器管理！ SqlSessionFactory 一旦被创建就应该在应用的运行期间一直存在，没有任何理由丢弃它或重新创建另一个实例。 使用 SqlSessionFactory 的最佳实践是在应用运行期间不要重复创建多次，因此 SqlSessionFactory 的最佳作用域是应用作用域。 需要ioc容器管理！ SqlSession 每个线程都应该有它自己的 SqlSession 实例。SqlSession 的实例不是线程安全的，因此是不能被共享的，所以它的最佳的作用域是请求或方法作用域。 无需ioc容器管理！ Mapper映射器实例 映射器是一些绑定映射语句的接口。映射器接口的实例是从 SqlSession 中获得的。虽然从技术层面上来讲，任何映射器实例的最大作用域与请求它们的 SqlSession 相同。但方法作用域才是映射器实例的最合适的作用域。 从作用域的角度来说，映射器实例不应该交给ioc容器管理！ 但是从使用的角度来说，业务类（service）需要注入mapper接口，所以mapper应该交给ioc容器管理！ 总结 将SqlSessionFactory实例存储到IoC容器 将Mapper实例存储到IoC容器mybatis整合思路理解： mybatis的api实例化需要复杂的过程。 例如，自己实现sqlSessionFactory加入ioc容器： 12345678910@Beanpublic SqlSessionFactory sqlSessionFactory()&#123; //1.读取外部配置文件 InputStream ips = Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;); //2.创建sqlSessionFactory SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(ips); return sqlSessionFactory;&#125; 过程比较繁琐，为了提高整合效率，mybatis提供了提供封装SqlSessionFactory和Mapper实例化的逻辑的FactoryBean组件，我们只需要声明和指定少量的配置即可！ SqlSessionFactoryBean源码展示(mybatis提供)： 12345678910111213141516package org.mybatis.spring;public class SqlSessionFactoryBean implements FactoryBean&lt;SqlSessionFactory&gt;, InitializingBean, ApplicationListener&lt;ContextRefreshedEvent&gt; &#123; //封装了实例化流程 public SqlSessionFactory getObject() throws Exception &#123; if (this.sqlSessionFactory == null) &#123; //实例化对象逻辑 afterPropertiesSet(); &#125; //返回对象逻辑 return this.sqlSessionFactory; &#125; &#125; mybatis整合思路总结： 需要将SqlSessionFactory和Mapper实例加入到IoC容器 使用mybatis整合包提供的FactoryBean快速整合 准备外部配置文件 数据库连接信息位置：resources&#x2F;jdbc.properties 1234jdbc.user=rootjdbc.password=rootjdbc.url=jdbc:mysql:///mybatis-examplejdbc.driver=com.mysql.cj.jdbc.Driver 整合方式1 （保留mybatis-config.xml） 介绍 依然保留mybatis的外部配置文件（xml）, 但是数据库连接信息交给Druid连接池配置！ 缺点：依然需要mybatis-config.xml文件，进行xml文件解析，效率偏低！ mybatis配置文件 数据库信息以及mapper扫描包设置使用Java配置类处理！mybatis其他的功能（别名、settings、插件等信息）依然在mybatis-config.xml配置！ 1234567891011121314151617181920212223242526272829303132&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt; &lt;settings&gt; &lt;!-- 开启驼峰式映射--&gt; &lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;true&quot;/&gt; &lt;!-- 开启logback日志输出--&gt; &lt;setting name=&quot;logImpl&quot; value=&quot;SLF4J&quot;/&gt; &lt;!--开启resultMap自动映射 --&gt; &lt;setting name=&quot;autoMappingBehavior&quot; value=&quot;FULL&quot;/&gt; &lt;/settings&gt; &lt;typeAliases&gt; &lt;!-- 给实体类起别名 --&gt; &lt;package name=&quot;com.atguigu.pojo&quot;/&gt; &lt;/typeAliases&gt; &lt;plugins&gt; &lt;plugin interceptor=&quot;com.github.pagehelper.PageInterceptor&quot;&gt; &lt;!-- helperDialect：分页插件会自动检测当前的数据库链接，自动选择合适的分页方式。 你可以配置helperDialect属性来指定分页插件使用哪种方言。配置时，可以使用下面的缩写值： oracle,mysql,mariadb,sqlite,hsqldb,postgresql,db2,sqlserver,informix,h2,sqlserver2012,derby （完整内容看 PageAutoDialect） 特别注意：使用 SqlServer2012 数据库时， https://github.com/pagehelper/Mybatis-PageHelper/blob/master/wikis/zh/HowToUse.md#%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AE%E6%95%B0%E6%8D%AE%E5%BA%93%E6%96%B9%E8%A8%80 --&gt; &lt;property name=&quot;helperDialect&quot; value=&quot;mysql&quot;/&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/configuration&gt; mybatis和持久层配置类 持久层Mapper配置、数据库配置、Mybatis配置信息位置：MapperJavaConfig.java(命名随意) 123456789101112@Configuration@PropertySource(&quot;classpath:jdbc.properties&quot;)public class MapperJavaConfig &#123; @Value(&quot;$&#123;jdbc.user&#125;&quot;) private String user; @Value(&quot;$&#123;jdbc.password&#125;&quot;) private String password; @Value(&quot;$&#123;jdbc.url&#125;&quot;) private String url; @Value(&quot;$&#123;jdbc.driver&#125;&quot;) private String driver; //数据库连接池配置 @Bean public DataSource dataSource()&#123; DruidDataSource dataSource = new DruidDataSource(); dataSource.setUsername(user); dataSource.setPassword(password); dataSource.setUrl(url); dataSource.setDriverClassName(driver); return dataSource; &#125; /** * 配置SqlSessionFactoryBean,指定连接池对象和外部配置文件即可 * @param dataSource 需要注入连接池对象 * @return 工厂Bean */ @Bean public SqlSessionFactoryBean sqlSessionFactoryBean(DataSource dataSource)&#123; //实例化SqlSessionFactory工厂 SqlSessionFactoryBean sqlSessionFactoryBean = new SqlSessionFactoryBean(); //设置连接池 sqlSessionFactoryBean.setDataSource(dataSource); //设置配置文件 //包裹外部配置文件地址对象 Resource resource = new ClassPathResource(&quot;mybatis-config.xml&quot;); sqlSessionFactoryBean.setConfigLocation(resource); return sqlSessionFactoryBean; &#125; /** * 配置Mapper实例扫描工厂,配置 &lt;mapper &lt;package 对应接口和mapperxml文件所在的包 * @return */ @Bean public MapperScannerConfigurer mapperScannerConfigurer()&#123; MapperScannerConfigurer mapperScannerConfigurer = new MapperScannerConfigurer(); //设置mapper接口和xml文件所在的共同包 mapperScannerConfigurer.setBasePackage(&quot;com.atguigu.mapper&quot;); return mapperScannerConfigurer; &#125; } 123456789101112131415161718192021222324252627282930313233343536373839404142 问题： 当你在Spring配置类中添加了`sqlSessionFactoryBean`和`mapperScannerConfigurer`配置方法时，可能会导致`@Value`注解读取不到值为null的问题。这是因为`SqlSessionFactoryBean`和`MapperScannerConfigurer`是基于MyBatis框架的配置，它们的初始化顺序可能会导致属性注入的问题。 `SqlSessionFactoryBean`和`MapperScannerConfigurer`在配置类中通常是用来配置MyBatis相关的Bean，例如数据源、事务管理器、Mapper扫描等。这些配置类通常在`@Configuration`注解下定义，并且使用`@Value`注解来注入属性值。 当配置类被加载时，Spring容器会首先处理Bean的定义和初始化，其中包括`sqlSessionFactoryBean`和`mapperScannerConfigurer`的初始化。在这个过程中，如果`@Value`注解所在的Bean还没有被完全初始化，可能会导致注入的属性值为null。 解决方案： 分成两个配置类独立配置，互不影响，数据库提取一个配置类，mybatis提取一个配置类即可解决！4. 拆分配置 数据库配置类（DataSourceJavaConfig.java） ```java @Configuration @PropertySource(&quot;classpath:jdbc.properties&quot;) public class DataSourceJavaConfig &#123; @Value(&quot;$&#123;jdbc.user&#125;&quot;) private String user; @Value(&quot;$&#123;jdbc.password&#125;&quot;) private String password; @Value(&quot;$&#123;jdbc.url&#125;&quot;) private String url; @Value(&quot;$&#123;jdbc.driver&#125;&quot;) private String driver; //数据库连接池配置 @Bean public DataSource dataSource()&#123; DruidDataSource dataSource = new DruidDataSource(); dataSource.setUsername(user); dataSource.setPassword(password); dataSource.setUrl(url); dataSource.setDriverClassName(driver); return dataSource; &#125; &#125; mybatis配置类（MapperJavaConfig.java） 12345678910111213141516171819202122232425262728293031323334353637@Configurationpublic class MapperJavaConfig &#123; /** * 配置SqlSessionFactoryBean,指定连接池对象和外部配置文件即可 * @param dataSource 需要注入连接池对象 * @return 工厂Bean */ @Bean public SqlSessionFactoryBean sqlSessionFactoryBean(DataSource dataSource)&#123; //实例化SqlSessionFactory工厂 SqlSessionFactoryBean sqlSessionFactoryBean = new SqlSessionFactoryBean(); //设置连接池 sqlSessionFactoryBean.setDataSource(dataSource); //设置配置文件 //包裹外部配置文件地址对象 Resource resource = new ClassPathResource(&quot;mybatis-config.xml&quot;); sqlSessionFactoryBean.setConfigLocation(resource); return sqlSessionFactoryBean; &#125; /** * 配置Mapper实例扫描工厂,配置 &lt;mapper &lt;package 对应接口和mapperxml文件所在的包 * @return */ @Bean public MapperScannerConfigurer mapperScannerConfigurer()&#123; MapperScannerConfigurer mapperScannerConfigurer = new MapperScannerConfigurer(); //设置mapper接口和xml文件所在的共同包 mapperScannerConfigurer.setBasePackage(&quot;com.atguigu.mapper&quot;); return mapperScannerConfigurer; &#125; &#125; 整合方式2（完全配置类 去掉mybatis-config.xml） 介绍 不在保留mybatis的外部配置文件（xml）, 所有配置信息（settings、插件、别名等）全部在声明SqlSessionFactoryBean的代码中指定！数据库信息依然使用DruidDataSource实例替代！ 优势：全部配置类，避免了XML文件解析效率低问题！ mapper配置类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687/** * projectName: com.atguigu.config * * description: 持久层配置和Druid和Mybatis配置 使用一个配置文件 */@Configurationpublic class MapperJavaConfigNew &#123; /** * 配置SqlSessionFactoryBean,指定连接池对象和外部配置文件即可 * @param dataSource 需要注入连接池对象 * @return 工厂Bean */ @Bean public SqlSessionFactoryBean sqlSessionFactoryBean(DataSource dataSource)&#123; //实例化SqlSessionFactory工厂 SqlSessionFactoryBean sqlSessionFactoryBean = new SqlSessionFactoryBean(); //设置连接池 sqlSessionFactoryBean.setDataSource(dataSource); //TODO: 替代xml文件的java配置 /* &lt;settings&gt; &lt;!-- 开启驼峰式映射--&gt; &lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;true&quot;/&gt; &lt;!-- 开启logback日志输出--&gt; &lt;setting name=&quot;logImpl&quot; value=&quot;SLF4J&quot;/&gt; &lt;!--开启resultMap自动映射 --&gt; &lt;setting name=&quot;autoMappingBehavior&quot; value=&quot;FULL&quot;/&gt; &lt;/settings&gt; &lt;typeAliases&gt; &lt;!-- 给实体类起别名 --&gt; &lt;package name=&quot;com.atguigu.pojo&quot;/&gt; &lt;/typeAliases&gt; &lt;plugins&gt; &lt;plugin interceptor=&quot;com.github.pagehelper.PageInterceptor&quot;&gt; &lt;!-- helperDialect：分页插件会自动检测当前的数据库链接，自动选择合适的分页方式。 你可以配置helperDialect属性来指定分页插件使用哪种方言。配置时，可以使用下面的缩写值： oracle,mysql,mariadb,sqlite,hsqldb,postgresql,db2,sqlserver,informix,h2,sqlserver2012,derby （完整内容看 PageAutoDialect） 特别注意：使用 SqlServer2012 数据库时， https://github.com/pagehelper/Mybatis-PageHelper/blob/master/wikis/zh/HowToUse.md#%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AE%E6%95%B0%E6%8D%AE%E5%BA%93%E6%96%B9%E8%A8%80 --&gt; &lt;property name=&quot;helperDialect&quot; value=&quot;mysql&quot;/&gt; &lt;/plugin&gt; &lt;/plugins&gt; */ //settings [包裹到一个configuration对象,切记别倒错包] org.apache.ibatis.session.Configuration configuration = new org.apache.ibatis.session.Configuration(); configuration.setMapUnderscoreToCamelCase(true); configuration.setLogImpl(Slf4jImpl.class); configuration.setAutoMappingBehavior(AutoMappingBehavior.FULL); sqlSessionFactoryBean.setConfiguration(configuration); //typeAliases sqlSessionFactoryBean.setTypeAliasesPackage(&quot;com.atguigu.pojo&quot;); //分页插件配置 PageInterceptor pageInterceptor = new PageInterceptor(); Properties properties = new Properties(); properties.setProperty(&quot;helperDialect&quot;,&quot;mysql&quot;); pageInterceptor.setProperties(properties); sqlSessionFactoryBean.addPlugins(pageInterceptor); return sqlSessionFactoryBean; &#125; /** * 配置Mapper实例扫描工厂,配置 &lt;mapper &lt;package 对应接口和mapperxml文件所在的包 * @return */ @Bean public MapperScannerConfigurer mapperScannerConfigurer()&#123; MapperScannerConfigurer mapperScannerConfigurer = new MapperScannerConfigurer(); //设置mapper接口和xml文件所在的共同包 mapperScannerConfigurer.setBasePackage(&quot;com.atguigu.mapper&quot;); return mapperScannerConfigurer; &#125;&#125; 2.5 容器初始化配置类1234567891011121314151617181920public class MyWebAppInitializer extends AbstractAnnotationConfigDispatcherServletInitializer &#123; //指定root容器对应的配置类 @Override protected Class&lt;?&gt;[] getRootConfigClasses() &#123; return new Class&lt;?&gt;[] &#123;MapperJavaConfig.class, ServiceJavaConfig.class, DataSourceJavaConfig.class &#125;; &#125; //指定web容器对应的配置类 @Override protected Class&lt;?&gt;[] getServletConfigClasses() &#123; return new Class&lt;?&gt;[] &#123; WebJavaConfig.class &#125;; &#125; //指定dispatcherServlet处理路径，通常为 / @Override protected String[] getServletMappings() &#123; return new String[] &#123; &quot;/&quot; &#125;; &#125;&#125; 2.6 整合测试 需求 查询所有员工信息,返回对应json数据！ controller 12345678910111213141516@Slf4j@RestController@RequestMapping(&quot;/employee&quot;)public class EmployeeController &#123; @Autowired private EmployeeService employeeService; @GetMapping(&quot;list&quot;) public List&lt;Employee&gt; retList()&#123; List&lt;Employee&gt; employees = employeeService.findAll(); log.info(&quot;员工数据:&#123;&#125;&quot;,employees); return employees; &#125;&#125; service&#x20; 12345678910111213141516@Servicepublic class EmployeeServiceImpl implements EmployeeService &#123; @Autowired private EmployeeMapper employeeMapper; /** * 查询所有员工信息 */ @Override public List&lt;Employee&gt; findAll() &#123; List&lt;Employee&gt; employeeList = employeeMapper.queryAll(); return employeeList; &#125;&#125; mapper mapper接口 包：com.atguigu.mapper&#x20; 12345public interface EmployeeMapper &#123; List&lt;Employee&gt; queryAll();&#125; mapper XML 文件位置： resources&#x2F;mappers 12345678910111213&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;https://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;!-- namespace等于mapper接口类的全限定名,这样实现对应 --&gt;&lt;mapper namespace=&quot;com.atguigu.mapper.EmployeeMapper&quot;&gt; &lt;select id=&quot;queryAll&quot; resultType=&quot;employee&quot;&gt; &lt;!-- #&#123;empId&#125;代表动态传入的参数,并且进行赋值!后面详细讲解 --&gt; select emp_id empId,emp_name empName, emp_salary empSalary from t_emp &lt;/select&gt;&lt;/mapper&gt; 三、《任务列表案例》前端程序搭建和运行3.1 整合案例介绍和接口分析3.1.1 案例功能预览 3.1.2接口分析 学习计划分页查询12345678910111213141516171819202122232425262728/* 需求说明 查询全部数据页数据请求uri schedule/&#123;pageSize&#125;/&#123;currentPage&#125;请求方式 get 响应的json &#123; &quot;code&quot;:200, &quot;flag&quot;:true, &quot;data&quot;:&#123; //本页数据 data: [ &#123;id:1,title:&#x27;学习java&#x27;,completed:true&#125;, &#123;id:2,title:&#x27;学习html&#x27;,completed:true&#125;, &#123;id:3,title:&#x27;学习css&#x27;,completed:true&#125;, &#123;id:4,title:&#x27;学习js&#x27;,completed:true&#125;, &#123;id:5,title:&#x27;学习vue&#x27;,completed:true&#125; ], //分页参数 pageSize:5, // 每页数据条数 页大小 total:0 , // 总记录数 currentPage:1 // 当前页码 &#125; &#125;*/ 学习计划删除1234567891011121314/* 需求说明 根据id删除日程请求uri schedule/&#123;id&#125;请求方式 delete响应的json &#123; &quot;code&quot;:200, &quot;flag&quot;:true, &quot;data&quot;:null &#125;*/ 学习计划保存12345678910111213141516171819/* 需求说明 增加日程请求uri schedule请求方式 post请求体中的JSON &#123; title: &#x27;&#x27;, completed: false &#125;响应的json &#123; &quot;code&quot;:200, &quot;flag&quot;:true, &quot;data&quot;:null &#125;*/ 学习计划修改1234567891011121314151617181920/* 需求说明 根据id修改数据请求uri schedule请求方式 put请求体中的JSON &#123; id: 1, title: &#x27;&#x27;, completed: false &#125;响应的json &#123; &quot;code&quot;:200, &quot;flag&quot;:true, &quot;data&quot;:null &#125;*/ 3.2 前端工程导入3.2.1 前端环境搭建 &#x20;Node.js 是前端程序运行的服务器，类似Java程序运行的服务器Tomcat Npm 是前端依赖包管理工具，类似maven依赖管理工具软件 node安装 课程node版本：16.16.0 https://nodejs.org/download/release/v16.16.0/ node安装和测试： 打开官网 https://nodejs.org/en/ 下载对应操作系统的 LTS 版本。（16.16.0） node-v16.16.0-x64.msi 双击安装包进行安装，安装过程中遵循默认选项即可。安装完成后，可以在命令行终端输入 node -v 和 npm -v 查看 Node.js 和 npm 的版本号。 npm使用 （maven） NPM全称Node Package Manager，是Node.js包管理工具，是全球最大的模块生态系统，里面所有的模块都是开源免费的；也是Node.js的包管理工具，相当于后端的Maven 。 配置阿里镜像1npm config set registry https://registry.npmjs.org/ 更新npm版本 node16.16.0对应的npm版本过低！需要升级！ 1npm install -g npm@9.6.6 npm依赖下载命令1npm install 依赖名 / npm install 依赖名@版本 安装vscode&#x20; VSCodeUserSetup-x64-1.74.0.exe 3.2.2 导入前端程序vue3-demo2.rar 点击加载前端程序！ 3.3 启动测试12npm install //安装依赖npm run dev //运行测试 四、《任务列表案例》后端程序实现和测试4.1 准备工作 准备数据库脚本 123456789101112131415161718192021222324252627282930CREATE TABLE schedule ( id INT NOT NULL AUTO_INCREMENT, title VARCHAR(255) NOT NULL, completed BOOLEAN NOT NULL, PRIMARY KEY (id));INSERT INTO schedule (title, completed)VALUES (&#x27;学习java&#x27;, true), (&#x27;学习Python&#x27;, false), (&#x27;学习C++&#x27;, true), (&#x27;学习JavaScript&#x27;, false), (&#x27;学习HTML5&#x27;, true), (&#x27;学习CSS3&#x27;, false), (&#x27;学习Vue.js&#x27;, true), (&#x27;学习React&#x27;, false), (&#x27;学习Angular&#x27;, true), (&#x27;学习Node.js&#x27;, false), (&#x27;学习Express&#x27;, true), (&#x27;学习Koa&#x27;, false), (&#x27;学习MongoDB&#x27;, true), (&#x27;学习MySQL&#x27;, false), (&#x27;学习Redis&#x27;, true), (&#x27;学习Git&#x27;, false), (&#x27;学习Docker&#x27;, true), (&#x27;学习Kubernetes&#x27;, false), (&#x27;学习AWS&#x27;, true), (&#x27;学习Azure&#x27;, false); 准备pojo 包：com.atguigu.pojo 12345678910111213/** * projectName: com.atguigu.pojo * * description: 任务实体类 */@Datapublic class Schedule &#123; private Integer id; private String title; private Boolean completed;&#125; 准备 R 包：com.atguigu.utils 123456789101112** * projectName: com.atguigu.utils * * description: 返回结果类 */public class R &#123; private int code = 200; //200成功状态码 private boolean flag = true; //返回状态 private Object data; //返回具体数据 public static R ok(Object data)&#123; R r = new R(); r.data = data; return r; &#125; public static R fail(Object data)&#123; R r = new R(); r.code = 500; //错误码 r.flag = false; //错误状态 r.data = data; return r; &#125; public int getCode() &#123; return code; &#125; public void setCode(int code) &#123; this.code = code; &#125; public boolean isFlag() &#123; return flag; &#125; public void setFlag(boolean flag) &#123; this.flag = flag; &#125; public Object getData() &#123; return data; &#125; public void setData(Object data) &#123; this.data = data; &#125; } 12345678910111213144. 准备 PageBean 包：com.atguigu.utils ```java @Data @NoArgsConstructor @AllArgsConstructor public class PageBean&lt;T&gt; &#123; private int currentPage; // 当前页码 private int pageSize; // 每页显示的数据量 private long total; // 总数据条数 private List&lt;T&gt; data; // 当前页的数据集合 &#125; 4.2 功能实现 分页查询 controller 123456789101112131415161718/* @CrossOrigin 注释在带注释的控制器方法上启用跨源请求 */@CrossOrigin@RequestMapping(&quot;schedule&quot;)@RestControllerpublic class ScheduleController&#123; @Autowired private ScheduleService scheduleService; @GetMapping(&quot;/&#123;pageSize&#125;/&#123;currentPage&#125;&quot;) public R showList(@PathVariable(name = &quot;pageSize&quot;) int pageSize, @PathVariable(name = &quot;currentPage&quot;) int currentPage)&#123; PageBean&lt;Schedule&gt; pageBean = scheduleService.findByPage(pageSize,currentPage); return R.ok(pageBean); &#125;&#125; service 12345678910111213141516171819202122232425262728293031@Slf4j@Servicepublic class ScheduleServiceImpl implements ScheduleService &#123; @Autowired private ScheduleMapper scheduleMapper; /** * 分页数据查询,返回分页pageBean * * @param pageSize * @param currentPage * @return */ @Override public PageBean&lt;Schedule&gt; findByPage(int pageSize, int currentPage) &#123; //1.设置分页参数 PageHelper.startPage(currentPage,pageSize); //2.数据库查询 List&lt;Schedule&gt; list = scheduleMapper.queryPage(); //3.结果获取 PageInfo&lt;Schedule&gt; pageInfo = new PageInfo&lt;&gt;(list); //4.pageBean封装 PageBean&lt;Schedule&gt; pageBean = new PageBean&lt;&gt;(pageInfo.getPageNum(),pageInfo.getPageSize(),pageInfo.getTotal(),pageInfo.getList()); log.info(&quot;分页查询结果:&#123;&#125;&quot;,pageBean); return pageBean; &#125;&#125; mapper mapper接口 1234public interface ScheduleMapper &#123; List&lt;Schedule&gt; queryPage();&#125; mapperxml文件 1234567891011&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;https://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;!-- namespace等于mapper接口类的全限定名,这样实现对应 --&gt;&lt;mapper namespace=&quot;com.atguigu.mapper.ScheduleMapper&quot;&gt; &lt;select id=&quot;queryPage&quot; resultType=&quot;schedule&quot;&gt; select * from schedule &lt;/select&gt;&lt;/mapper&gt; 计划添加 controller 12345@PostMappingpublic R saveSchedule(@RequestBody Schedule schedule)&#123; scheduleService.saveSchedule(schedule); return R.ok(null);&#125; service 123456789/** * 保存学习计划 * * @param schedule */@Overridepublic void saveSchedule(Schedule schedule) &#123; scheduleMapper.insert(schedule);&#125; mapper mapper接口 1void insert(Schedule schedule); mapperxml文件 12345&lt;insert id=&quot;insert&quot;&gt; insert into schedule (title, completed) values (#&#123;title&#125;, #&#123;completed&#125;);&lt;/insert&gt; 计划删除 controller12345@DeleteMapping(&quot;/&#123;id&#125;&quot;)public R removeSchedule(@PathVariable Integer id)&#123; scheduleService.removeById(id); return R.ok(null);&#125; service123456789/** * 移除学习计划 * * @param id */@Overridepublic void removeById(Integer id) &#123; scheduleMapper.delete(id);&#125; mappermapper接口1void delete(Integer id); mapperxml文件123&lt;delete id=&quot;delete&quot;&gt; delete from schedule where id = #&#123;id&#125;&lt;/delete&gt; 计划修改 controller12345@PutMapping public R changeSchedule(@RequestBody Schedule schedule)&#123; scheduleService.updateSchedule(schedule); return R.ok(null);&#125; service123456789/** * 更新学习计划 * * @param schedule */@Overridepublic void updateSchedule(Schedule schedule) &#123; scheduleMapper.update(schedule);&#125; mappermapper接口1void update(Schedule schedule); mapperxml文件1234&lt;update id=&quot;update&quot;&gt; update schedule set title = #&#123;title&#125; , completed = #&#123;completed&#125; where id = #&#123;id&#125;&lt;/update&gt; 4.3 前后联调 后台项目根路径设计 启动测试即可","categories":[{"name":"SSM框架","slug":"SSM框架","permalink":"http://example.com/categories/SSM%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"ssm","slug":"ssm","permalink":"http://example.com/tags/ssm/"}]},{"title":"四、SpringMVC实战：构建高效表述层框架","slug":"SSM/四、SpringMVC实战：构建高效表述层框架/四、SpringMVC实战：构建高效表述层框架","date":"2022-09-29T23:55:54.000Z","updated":"2023-09-28T00:31:22.144Z","comments":true,"path":"2022/09/30/SSM/四、SpringMVC实战：构建高效表述层框架/四、SpringMVC实战：构建高效表述层框架/","link":"","permalink":"http://example.com/2022/09/30/SSM/%E5%9B%9B%E3%80%81SpringMVC%E5%AE%9E%E6%88%98%EF%BC%9A%E6%9E%84%E5%BB%BA%E9%AB%98%E6%95%88%E8%A1%A8%E8%BF%B0%E5%B1%82%E6%A1%86%E6%9E%B6/%E5%9B%9B%E3%80%81SpringMVC%E5%AE%9E%E6%88%98%EF%BC%9A%E6%9E%84%E5%BB%BA%E9%AB%98%E6%95%88%E8%A1%A8%E8%BF%B0%E5%B1%82%E6%A1%86%E6%9E%B6/","excerpt":"","text":"四、SpringMVC实战：构建高效表述层框架目录 一、SpringMVC简介和体验 1.1 介绍 1.2 主要作用 1.3 核心组件和调用流程理解 1.4 快速体验 二、SpringMVC接收数据 2.1 访问路径设置 2.2 接收参数（重点） 2.2.1 param 和 json参数比较 2.2.2 param参数接收 2.2.3 路径 参数接收 2.2.4 json参数接收 2.3 接收Cookie数据 2.4 接收请求头数据 2.5 原生Api对象操作 2.6 共享域对象操作 2.6.1 属性（共享）域作用回顾 2.6.2 Request级别属性（共享）域 2.6.3 Session级别属性（共享）域 2.6.4 Application级别属性（共享）域 三、SpringMVC响应数据 3.1 handler方法分析 3.2 页面跳转控制 3.2.1 快速返回模板视图 3.2.2 转发和重定向 3.3 返回JSON数据（重点） 3.3.1 前置准备 3.3.2 @ResponseBody 3.3.3 @RestController 3.4 返回静态资源处理 四、RESTFul风格设计和实战 4.1 RESTFul风格概述 4.1.1 RESTFul风格简介 4.1.2 RESTFul风格特点 4.1.3 RESTFul风格设计规范 4.1.4 RESTFul风格好处 4.2 RESTFul风格实战 4.2.1 需求分析 4.2.2 RESTFul风格接口设计 4.2.3 后台接口实现 五、SpringMVC其他扩展 5.1 全局异常处理机制 5.1.1 异常处理两种方式 5.1.2 基于注解异常声明异常处理 5.2 拦截器使用 5.2.1 拦截器概念 5.2.2 拦截器使用 5.3 参数校验 六、SpringMVC总结 一、SpringMVC简介和体验1.1 介绍https://docs.spring.io/spring-framework/reference/web/webmvc.html Spring Web MVC是基于Servlet API构建的原始Web框架，从一开始就包含在Spring Framework中。正式名称“Spring Web MVC”来自其源模块的名称（ spring-webmvc ），但它通常被称为“Spring MVC”。 在控制层框架历经Strust、WebWork、Strust2等诸多产品的历代更迭之后，目前业界普遍选择了SpringMVC作为Java EE项目表述层开发的首选方案。之所以能做到这一点，是因为SpringMVC具备如下显著优势： Spring 家族原生产品，与IOC容器等基础设施无缝对接 表述层各细分领域需要解决的问题全方位覆盖，提供全面解决方案 代码清新简洁，大幅度提升开发效率 内部组件化程度高，可插拔式组件即插即用，想要什么功能配置相应组件即可 性能卓著，尤其适合现代大型、超大型互联网项目要求 原生Servlet API开发代码片段 123456protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; String userName = request.getParameter(&quot;userName&quot;); System.out.println(&quot;userName=&quot;+userName);&#125; 基于SpringMVC开发代码片段 12345678@RequestMapping(&quot;/user/login&quot;)public String login(@RequestParam(&quot;userName&quot;) String userName,Sting password)&#123; log.debug(&quot;userName=&quot;+userName); //调用业务即可 return &quot;result&quot;;&#125; 1.2 主要作用 SSM框架构建起单体项目的技术栈需求！其中的SpringMVC负责表述层（控制层）实现简化！ SpringMVC的作用主要覆盖的是表述层，例如： 请求映射 数据输入 视图界面 请求分发 表单回显 会话控制 过滤拦截 异步交互 文件上传 文件下载 数据校验 类型转换 等等等 最终总结： 简化前端参数接收( 形参列表 ) 简化后端数据响应(返回值) 以及其他…… 1.3 核心组件和调用流程理解Spring MVC与许多其他Web框架一样，是围绕前端控制器模式设计的，其中中央 Servlet DispatcherServlet 做整体请求处理调度！ 除了DispatcherServletSpringMVC还会提供其他特殊的组件协作完成请求处理和响应呈现。 SpringMVC处理请求流程： SpringMVC涉及组件理解： DispatcherServlet : SpringMVC提供，我们需要使用web.xml配置使其生效，它是整个流程处理的核心，所有请求都经过它的处理和分发！[ CEO ] HandlerMapping : SpringMVC提供，我们需要进行IoC配置使其加入IoC容器方可生效，它内部缓存handler(controller方法)和handler访问路径数据，被DispatcherServlet调用，用于查找路径对应的handler！[秘书] HandlerAdapter : SpringMVC提供，我们需要进行IoC配置使其加入IoC容器方可生效，它可以处理请求参数和处理响应数据数据，每次DispatcherServlet都是通过handlerAdapter间接调用handler，他是handler和DispatcherServlet之间的适配器！[经理] Handler : handler又称处理器，他是Controller类内部的方法简称，是由我们自己定义，用来接收参数，向后调用业务，最终返回响应结果！[打工人] ViewResovler : SpringMVC提供，我们需要进行IoC配置使其加入IoC容器方可生效！视图解析器主要作用简化模版视图页面查找的，但是需要注意，前后端分离项目，后端只返回JSON数据，不返回页面，那就不需要视图解析器！所以，视图解析器，相对其他的组件不是必须的！[财务] 1.4 快速体验 体验场景需求 配置分析 DispatcherServlet，设置处理所有请求！ HandlerMapping,HandlerAdapter,Handler需要加入到IoC容器，供DS调用！ Handler自己声明（Controller）需要配置到HandlerMapping中供DS查找！ 准备项目 创建项目 springmvc-base-quick 注意：需要转成maven&#x2F;web程序！！ 导入依赖 123456789101112131415161718192021222324252627282930313233343536373839&lt;properties&gt; &lt;spring.version&gt;6.0.6&lt;/spring.version&gt; &lt;servlet.api&gt;9.1.0&lt;/servlet.api&gt; &lt;maven.compiler.source&gt;17&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;17&lt;/maven.compiler.target&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;&lt;/properties&gt;&lt;dependencies&gt; &lt;!-- springioc相关依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- web相关依赖 --&gt; &lt;!-- 在 pom.xml 中引入 Jakarta EE Web API 的依赖 --&gt; &lt;!-- 在 Spring Web MVC 6 中，Servlet API 迁移到了 Jakarta EE API，因此在配置 DispatcherServlet 时需要使用 Jakarta EE 提供的相应类库和命名空间。错误信息 “‘org.springframework.web.servlet.DispatcherServlet’ is not assignable to ‘javax.servlet.Servlet,jakarta.servlet.Servlet’” 表明你使用了旧版本的 Servlet API，没有更新到 Jakarta EE 规范。 --&gt; &lt;dependency&gt; &lt;groupId&gt;jakarta.platform&lt;/groupId&gt; &lt;artifactId&gt;jakarta.jakartaee-web-api&lt;/artifactId&gt; &lt;version&gt;$&#123;servlet.api&#125;&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- springwebmvc相关依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; Controller声明 123456789101112131415161718@Controllerpublic class HelloController &#123; //handlers /** * handler就是controller内部的具体方法 * @RequestMapping(&quot;/springmvc/hello&quot;) 就是用来向handlerMapping中注册的方法注解! * @ResponseBody 代表向浏览器直接返回数据! */ @RequestMapping(&quot;/springmvc/hello&quot;) @ResponseBody public String hello()&#123; System.out.println(&quot;HelloController.hello&quot;); return &quot;hello springmvc!!&quot;; &#125;&#125; Spring MVC核心组件配置类 声明springmvc涉及组件信息的配置类 123456789101112131415161718192021222324//TODO: SpringMVC对应组件的配置类 [声明SpringMVC需要的组件信息]//TODO: 导入handlerMapping和handlerAdapter的三种方式 //1.自动导入handlerMapping和handlerAdapter [推荐] //2.可以不添加,springmvc会检查是否配置handlerMapping和handlerAdapter,没有配置默认加载 //3.使用@Bean方式配置handlerMapper和handlerAdapter@EnableWebMvc @Configuration@ComponentScan(basePackages = &quot;com.atguigu.controller&quot;) //TODO: 进行controller扫//WebMvcConfigurer springMvc进行组件配置的规范,配置组件,提供各种方法! 前期可以实现public class SpringMvcConfig implements WebMvcConfigurer &#123; @Bean public HandlerMapping handlerMapping()&#123; return new RequestMappingHandlerMapping(); &#125; @Bean public HandlerAdapter handlerAdapter()&#123; return new RequestMappingHandlerAdapter(); &#125; &#125; SpringMVC环境搭建 对于使用基于 Java 的 Spring 配置的应用程序，建议这样做，如以下示例所示： 12345678910111213141516171819202122232425262728293031//TODO: SpringMVC提供的接口,是替代web.xml的方案,更方便实现完全注解方式ssm处理!//TODO: Springmvc框架会自动检查当前类的实现类,会自动加载 getRootConfigClasses / getServletConfigClasses 提供的配置类//TODO: getServletMappings 返回的地址 设置DispatherServlet对应处理的地址public class MyWebAppInitializer extends AbstractAnnotationConfigDispatcherServletInitializer &#123; /** * 指定service / mapper层的配置类 */ @Override protected Class&lt;?&gt;[] getRootConfigClasses() &#123; return null; &#125; /** * 指定springmvc的配置类 * @return */ @Override protected Class&lt;?&gt;[] getServletConfigClasses() &#123; return new Class&lt;?&gt;[] &#123; SpringMvcConfig.class &#125;; &#125; /** * 设置dispatcherServlet的处理路径! * 一般情况下为 / 代表处理所有请求! */ @Override protected String[] getServletMappings() &#123; return new String[] &#123; &quot;/&quot; &#125;; &#125;&#125; 启动测试 注意： tomcat应该是10+版本！方可支持 Jakarta EE API! 二、SpringMVC接收数据2.1 访问路径设置@RequestMapping注解的作用就是将请求的 URL 地址和处理请求的方式（handler方法）关联起来，建立映射关系。 SpringMVC 接收到指定的请求，就会来找到在映射关系中对应的方法来处理这个请求。 精准路径匹配 在@RequestMapping注解指定 URL 地址时，不使用任何通配符，按照请求地址进行精确匹配。 12345678910111213141516171819202122232425@Controllerpublic class UserController &#123; /** * 精准设置访问地址 /user/login */ @RequestMapping(value = &#123;&quot;/user/login&quot;&#125;) @ResponseBody public String login()&#123; System.out.println(&quot;UserController.login&quot;); return &quot;login success!!&quot;; &#125; /** * 精准设置访问地址 /user/register */ @RequestMapping(value = &#123;&quot;/user/register&quot;&#125;) @ResponseBody public String register()&#123; System.out.println(&quot;UserController.register&quot;); return &quot;register success!!&quot;; &#125; &#125; 模糊路径匹配 在@RequestMapping注解指定 URL 地址时，通过使用通配符，匹配多个类似的地址。 12345678910111213141516171819@Controllerpublic class ProductController &#123; /** * 路径设置为 /product/* * /* 为单层任意字符串 /product/a /product/aaa 可以访问此handler * /product/a/a 不可以 * 路径设置为 /product/** * /** 为任意层任意字符串 /product/a /product/aaa 可以访问此handler * /product/a/a 也可以访问 */ @RequestMapping(&quot;/product/*&quot;) @ResponseBody public String show()&#123; System.out.println(&quot;ProductController.show&quot;); return &quot;product show!&quot;; &#125;&#125; 12345单层匹配和多层匹配： /*：只能匹配URL地址中的一层，如果想准确匹配两层，那么就写“/*/*”以此类推。 /**：可以匹配URL地址中的多层。其中所谓的一层或多层是指一个URL地址字符串被“/”划分出来的各个层次这个知识点虽然对于@RequestMapping注解来说实用性不大，但是将来配置拦截器的时候也遵循这个规则。 类和方法级别区别 @RequestMapping 注解可以用于类级别和方法级别，它们之间的区别如下： 设置到类级别：@RequestMapping 注解可以设置在控制器类上，用于映射整个控制器的通用请求路径。这样，如果控制器中的多个方法都需要映射同一请求路径，就不需要在每个方法上都添加映射路径。 设置到方法级别：@RequestMapping 注解也可以单独设置在控制器方法上，用于更细粒度地映射请求路径和处理方法。当多个方法处理同一个路径的不同操作时，可以使用方法级别的 @RequestMapping 注解进行更精细的映射。12345678910111213//1.标记到handler方法@RequestMapping(&quot;/user/login&quot;)@RequestMapping(&quot;/user/register&quot;)@RequestMapping(&quot;/user/logout&quot;)//2.优化标记类+handler方法//类上@RequestMapping(&quot;/user&quot;)//handler方法上@RequestMapping(&quot;/login&quot;)@RequestMapping(&quot;/register&quot;)@RequestMapping(&quot;/logout&quot;) 附带请求方式限制 HTTP 协议定义了八种请求方式，在 SpringMVC 中封装到了下面这个枚举类： 123public enum RequestMethod &#123; GET, HEAD, POST, PUT, PATCH, DELETE, OPTIONS, TRACE&#125; 默认情况下：@RequestMapping(“&#x2F;logout”) 任何请求方式都可以访问！ 如果需要特定指定： 1234567891011121314151617181920212223242526@Controllerpublic class UserController &#123; /** * 精准设置访问地址 /user/login * method = RequestMethod.POST 可以指定单个或者多个请求方式! * 注意:违背请求方式会出现405异常! */ @RequestMapping(value = &#123;&quot;/user/login&quot;&#125; , method = RequestMethod.POST) @ResponseBody public String login()&#123; System.out.println(&quot;UserController.login&quot;); return &quot;login success!!&quot;; &#125; /** * 精准设置访问地址 /user/register */ @RequestMapping(value = &#123;&quot;/user/register&quot;&#125;,method = &#123;RequestMethod.POST,RequestMethod.GET&#125;) @ResponseBody public String register()&#123; System.out.println(&quot;UserController.register&quot;); return &quot;register success!!&quot;; &#125;&#125; 注意：违背请求方式，会出现405异常！！！ 进阶注解 还有 @RequestMapping 的 HTTP 方法特定快捷方式变体： @GetMapping @PostMapping @PutMapping @DeleteMapping @PatchMapping123@RequestMapping(value=&quot;/login&quot;,method=RequestMethod.GET)||@GetMapping(value=&quot;/login&quot;) 注意：进阶注解只能添加到handler方法上，无法添加到类上！ 常见配置问题 出现原因：多个 handler 方法映射了同一个地址，导致 SpringMVC 在接收到这个地址的请求时该找哪个 handler 方法处理。 There is already ‘demo03MappingMethodHandler’ bean method com.atguigu.mvc.handler.Demo03MappingMethodHandler#empGet() mapped. 2.2 接收参数（重点）2.2.1 param 和 json参数比较在 HTTP 请求中，我们可以选择不同的参数类型，如 param 类型和 JSON 类型。下面对这两种参数类型进行区别和对比： 参数编码： &#x20; param 类型的参数会被编码为 ASCII 码。例如，假设 name=john doe，则会被编码为 name=john%20doe。而 JSON 类型的参数会被编码为 UTF-8。 参数顺序： &#x20; param 类型的参数没有顺序限制。但是，JSON 类型的参数是有序的。JSON 采用键值对的形式进行传递，其中键值对是有序排列的。 数据类型： &#x20; param 类型的参数仅支持字符串类型、数值类型和布尔类型等简单数据类型。而 JSON 类型的参数则支持更复杂的数据类型，如数组、对象等。 嵌套性： &#x20; param 类型的参数不支持嵌套。但是，JSON 类型的参数支持嵌套，可以传递更为复杂的数据结构。 可读性： &#x20; param 类型的参数格式比 JSON 类型的参数更加简单、易读。但是，JSON 格式在传递嵌套数据结构时更加清晰易懂。 总的来说，param 类型的参数适用于单一的数据传递，而 JSON 类型的参数则更适用于更复杂的数据结构传递。根据具体的业务需求，需要选择合适的参数类型。在实际开发中，常见的做法是：在 GET 请求中采用 param 类型的参数，而在 POST 请求中采用 JSON 类型的参数传递。 2.2.2 param参数接收 直接接值 客户端请求 handler接收参数 只要形参数名和类型与传递参数相同，即可自动接收! 1234567891011121314151617181920@Controller@RequestMapping(&quot;param&quot;)public class ParamController &#123; /** * 前端请求: http://localhost:8080/param/value?name=xx&amp;age=18 * * 可以利用形参列表,直接接收前端传递的param参数! * 要求: 参数名 = 形参名 * 类型相同 * 出现乱码正常，json接收具体解决！！ * @return 返回前端数据 */ @GetMapping(value=&quot;/value&quot;) @ResponseBody public String setupForm(String name,int age)&#123; System.out.println(&quot;name = &quot; + name + &quot;, age = &quot; + age); return name + age; &#125;&#125; @RequestParam注解 可以使用 @RequestParam 注释将 Servlet 请求参数（即查询参数或表单数据）绑定到控制器中的方法参数。 @RequestParam使用场景： 指定绑定的请求参数名 要求请求参数必须传递 为请求参数提供默认值基本用法：12345678910111213 /** * 前端请求: http://localhost:8080/param/data?name=xx&amp;stuAge=18 * * 使用@RequestParam注解标记handler方法的形参 * 指定形参对应的请求参数@RequestParam(请求参数名称) */@GetMapping(value=&quot;/data&quot;)@ResponseBodypublic Object paramForm(@RequestParam(&quot;name&quot;) String name, @RequestParam(&quot;stuAge&quot;) int age)&#123; System.out.println(&quot;name = &quot; + name + &quot;, age = &quot; + age); return name+age;&#125; 默认情况下，使用此批注的方法参数是必需的，但您可以通过将 @RequestParam 批注的 required 标志设置为 false！ 如果没有没有设置非必须，也没有传递参数会出现： 将参数设置非必须，并且设置默认值： 12345678@GetMapping(value=&quot;/data&quot;)@ResponseBodypublic Object paramForm(@RequestParam(&quot;name&quot;) String name, @RequestParam(value = &quot;stuAge&quot;,required = false,defaultValue = &quot;18&quot;) int age)&#123; System.out.println(&quot;name = &quot; + name + &quot;, age = &quot; + age); return name+age;&#125; 特殊场景接值 一名多值 多选框，提交的数据的时候一个key对应多个值，我们可以使用集合进行接收！ 1234567891011/** * 前端请求: http://localhost:8080/param/mul?hbs=吃&amp;hbs=喝 * * 一名多值,可以使用集合接收即可!但是需要使用@RequestParam注解指定 */@GetMapping(value=&quot;/mul&quot;)@ResponseBodypublic Object mulForm(@RequestParam List&lt;String&gt; hbs)&#123; System.out.println(&quot;hbs = &quot; + hbs); return hbs;&#125; 实体接收 Spring MVC 是 Spring 框架提供的 Web 框架，它允许开发者使用实体对象来接收 HTTP 请求中的参数。通过这种方式，可以在方法内部直接使用对象的属性来访问请求参数，而不需要每个参数都写一遍。下面是一个使用实体对象接收参数的示例： 定义一个用于接收参数的实体类： 12345678public class User &#123; private String name; private int age = 18; // getter 和 setter 略&#125; 在控制器中，使用实体对象接收，示例代码如下： 123456789101112@Controller@RequestMapping(&quot;param&quot;)public class ParamController &#123; @RequestMapping(value = &quot;/user&quot;, method = RequestMethod.POST) @ResponseBody public String addUser(User user) &#123; // 在这里可以使用 user 对象的属性来接收请求参数 System.out.println(&quot;user = &quot; + user); return &quot;success&quot;; &#125;&#125; 在上述代码中，将请求参数name和age映射到实体类属性上！要求属性名必须等于参数名！否则无法映射！ 使用postman传递参数测试： 2.2.3 路径 参数接收路径传递参数是一种在 URL 路径中传递参数的方式。在 RESTful 的 Web 应用程序中，经常使用路径传递参数来表示资源的唯一标识符或更复杂的表示方式。而 Spring MVC 框架提供了 @PathVariable 注解来处理路径传递参数。 @PathVariable 注解允许将 URL 中的占位符映射到控制器方法中的参数。 例如，如果我们想将 /user/&#123;id&#125; 路径下的 &#123;id&#125; 映射到控制器方法的一个参数中，则可以使用 @PathVariable 注解来实现。 下面是一个使用 @PathVariable 注解处理路径传递参数的示例： 1234567891011121314 /** * 动态路径设计: /user/&#123;动态部分&#125;/&#123;动态部分&#125; 动态部分使用&#123;&#125;包含即可! &#123;&#125;内部动态标识! * 形参列表取值: @PathVariable Long id 如果形参名 = &#123;动态标识&#125; 自动赋值! * @PathVariable(&quot;动态标识&quot;) Long id 如果形参名 != &#123;动态标识&#125; 可以通过指定动态标识赋值! * * 访问测试: /param/user/1/root -&gt; id = 1 uname = root */@GetMapping(&quot;/user/&#123;id&#125;/&#123;name&#125;&quot;)@ResponseBodypublic String getUser(@PathVariable Long id, @PathVariable(&quot;name&quot;) String uname) &#123; System.out.println(&quot;id = &quot; + id + &quot;, uname = &quot; + uname); return &quot;user_detail&quot;;&#125; 2.2.4 json参数接收前端传递 JSON 数据时，Spring MVC 框架可以使用 @RequestBody 注解来将 JSON 数据转换为 Java 对象。@RequestBody 注解表示当前方法参数的值应该从请求体中获取，并且需要指定 value 属性来指示请求体应该映射到哪个参数上。其使用方式和示例代码如下： 前端发送 JSON 数据的示例：（使用postman测试） 12345&#123; &quot;name&quot;: &quot;张三&quot;, &quot;age&quot;: 18, &quot;gender&quot;: &quot;男&quot;&#125; 定义一个用于接收 JSON 数据的 Java 类，例如： 123456public class Person &#123; private String name; private int age; private String gender; // getter 和 setter 略&#125; 在控制器中，使用 @RequestBody 注解来接收 JSON 数据，并将其转换为 Java 对象，例如： 1234567@PostMapping(&quot;/person&quot;)@ResponseBodypublic String addPerson(@RequestBody Person person) &#123; // 在这里可以使用 person 对象来操作 JSON 数据中包含的属性 return &quot;success&quot;;&#125; 在上述代码中，@RequestBody 注解将请求体中的 JSON 数据映射到 Person 类型的 person 参数上，并将其作为一个对象来传递给 addPerson() 方法进行处理。 完善配置 测试： 问题： org.springframework.web.HttpMediaTypeNotSupportedException: Content-Type ‘application&#x2F;json;charset&#x3D;UTF-8’ is not supported] 原因： 不支持json数据类型处理 没有json类型处理的工具（jackson）解决：springmvc handlerAdpater配置json转化器,配置类需要明确：123456789101112//TODO: SpringMVC对应组件的配置类 [声明SpringMVC需要的组件信息]//TODO: 导入handlerMapping和handlerAdapter的三种方式 //1.自动导入handlerMapping和handlerAdapter [推荐] //2.可以不添加,springmvc会检查是否配置handlerMapping和handlerAdapter,没有配置默认加载 //3.使用@Bean方式配置handlerMapper和handlerAdapter@EnableWebMvc //json数据处理,必须使用此注解,因为他会加入json处理器@Configuration@ComponentScan(basePackages = &quot;com.atguigu.controller&quot;) //TODO: 进行controller扫描//WebMvcConfigurer springMvc进行组件配置的规范,配置组件,提供各种方法! 前期可以实现public class SpringMvcConfig implements WebMvcConfigurer &#123; } 1234567pom.xml 加入jackson依赖```xml&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.15.0&lt;/version&gt;&lt;/dependency&gt; @EnableWebMvc注解说明 @EnableWebMvc注解效果等同于在 XML 配置中，可以使用 &lt;mvc:annotation-driven&gt; 元素！我们来解析&lt;mvc:annotation-driven&gt;对应的解析工作！ 让我们来查看下&lt;mvc:annotation-driven&gt;具体的动作！ 先查看&lt;mvc:annotation-driven&gt;标签最终对应解析的Java类 查看解析类中具体的动作即可 打开源码：org.springframework.web.servlet.config.MvcNamespaceHandler 打开源码：org.springframework.web.servlet.config.AnnotationDrivenBeanDefinitionParser 123456789101112131415161718class AnnotationDrivenBeanDefinitionParser implements BeanDefinitionParser &#123; public static final String HANDLER_MAPPING_BEAN_NAME = RequestMappingHandlerMapping.class.getName(); public static final String HANDLER_ADAPTER_BEAN_NAME = RequestMappingHandlerAdapter.class.getName(); static &#123; ClassLoader classLoader = AnnotationDrivenBeanDefinitionParser.class.getClassLoader(); javaxValidationPresent = ClassUtils.isPresent(&quot;jakarta.validation.Validator&quot;, classLoader); romePresent = ClassUtils.isPresent(&quot;com.rometools.rome.feed.WireFeed&quot;, classLoader); jaxb2Present = ClassUtils.isPresent(&quot;jakarta.xml.bind.Binder&quot;, classLoader); jackson2Present = ClassUtils.isPresent(&quot;com.fasterxml.jackson.databind.ObjectMapper&quot;, classLoader) &amp;&amp; ClassUtils.isPresent(&quot;com.fasterxml.jackson.core.JsonGenerator&quot;, classLoader); jackson2XmlPresent = ClassUtils.isPresent(&quot;com.fasterxml.jackson.dataformat.xml.XmlMapper&quot;, classLoader); jackson2SmilePresent = ClassUtils.isPresent(&quot;com.fasterxml.jackson.dataformat.smile.SmileFactory&quot;, classLoader); jackson2CborPresent = ClassUtils.isPresent(&quot;com.fasterxml.jackson.dataformat.cbor.CBORFactory&quot;, classLoader); gsonPresent = ClassUtils.isPresent(&quot;com.google.gson.Gson&quot;, classLoader); &#125; @Override @Nullable public BeanDefinition parse(Element element, ParserContext context) &#123; //handlerMapping加入到ioc容器 readerContext.getRegistry().registerBeanDefinition(HANDLER_MAPPING_BEAN_NAME, handlerMappingDef); //添加jackson转化器 addRequestBodyAdvice(handlerAdapterDef); addResponseBodyAdvice(handlerAdapterDef); //handlerAdapter加入到ioc容器 readerContext.getRegistry().registerBeanDefinition(HANDLER_ADAPTER_BEAN_NAME, handlerAdapterDef); return null; &#125; //具体添加jackson转化对象方法 protected void addRequestBodyAdvice(RootBeanDefinition beanDef) &#123; if (jackson2Present) &#123; beanDef.getPropertyValues().add(&quot;requestBodyAdvice&quot;, new RootBeanDefinition(JsonViewRequestBodyAdvice.class)); &#125; &#125; protected void addResponseBodyAdvice(RootBeanDefinition beanDef) &#123; if (jackson2Present) &#123; beanDef.getPropertyValues().add(&quot;responseBodyAdvice&quot;, new RootBeanDefinition(JsonViewResponseBodyAdvice.class)); &#125; &#125; 123456789### 2.3 接收Cookie数据可以使用 `@CookieValue` 注释将 HTTP Cookie 的值绑定到控制器中的方法参数。考虑使用以下 cookie 的请求：```javaJSESSIONID=415A4AC178C59DACE0B2C9CA727CDD84 下面的示例演示如何获取 cookie 值： 1234@GetMapping(&quot;/demo&quot;)public void handle(@CookieValue(&quot;JSESSIONID&quot;) String cookie) &#123; //...&#125; 2.4 接收请求头数据可以使用 @RequestHeader 批注将请求标头绑定到控制器中的方法参数。 请考虑以下带有标头的请求： 123456Host localhost:8080Accept text/html,application/xhtml+xml,application/xml;q=0.9Accept-Language fr,en-gb;q=0.7,en;q=0.3Accept-Encoding gzip,deflateAccept-Charset ISO-8859-1,utf-8;q=0.7,*;q=0.7Keep-Alive 300 下面的示例获取 Accept-Encoding 和 Keep-Alive 标头的值： 123456@GetMapping(&quot;/demo&quot;)public void handle( @RequestHeader(&quot;Accept-Encoding&quot;) String encoding, @RequestHeader(&quot;Keep-Alive&quot;) long keepAlive) &#123; //...&#125; 2.5 原生Api对象操作https://docs.spring.io/spring-framework/reference/web/webmvc/mvc-controller/ann-methods/arguments.html 下表描述了支持的控制器方法参数 Controller method argument 控制器方法参数 Description jakarta.servlet.ServletRequest, jakarta.servlet.ServletResponse 请求&#x2F;响应对象 jakarta.servlet.http.HttpSession 强制存在会话。因此，这样的参数永远不会为 null 。 java.io.InputStream, java.io.Reader 用于访问由 Servlet API 公开的原始请求正文。 java.io.OutputStream, java.io.Writer 用于访问由 Servlet API 公开的原始响应正文。 @PathVariable 接收路径参数注解 @RequestParam 用于访问 Servlet 请求参数，包括多部分文件。参数值将转换为声明的方法参数类型。 @RequestHeader 用于访问请求标头。标头值将转换为声明的方法参数类型。 @CookieValue 用于访问Cookie。Cookie 值将转换为声明的方法参数类型。 @RequestBody 用于访问 HTTP 请求正文。正文内容通过使用 HttpMessageConverter 实现转换为声明的方法参数类型。 java.util.Map, org.springframework.ui.Model, org.springframework.ui.ModelMap 共享域对象，并在视图呈现过程中向模板公开。 Errors, BindingResult 验证和数据绑定中的错误信息获取对象！ 获取原生对象示例： 123456789101112/** * 如果想要获取请求或者响应对象,或者会话等,可以直接在形参列表传入,并且不分先后顺序! * 注意: 接收原生对象,并不影响参数接收! */@GetMapping(&quot;api&quot;)@ResponseBodypublic String api(HttpSession session , HttpServletRequest request, HttpServletResponse response)&#123; String method = request.getMethod(); System.out.println(&quot;method = &quot; + method); return &quot;api&quot;;&#125; 2.6 共享域对象操作2.6.1 属性（共享）域作用回顾在 JavaWeb 中，共享域指的是在 Servlet 中存储数据，以便在同一 Web 应用程序的多个组件中进行共享和访问。常见的共享域有四种：ServletContext、HttpSession、HttpServletRequest、PageContext。 ServletContext 共享域：ServletContext 对象可以在整个 Web 应用程序中共享数据，是最大的共享域。一般可以用于保存整个 Web 应用程序的全局配置信息，以及所有用户都共享的数据。在 ServletContext 中保存的数据是线程安全的。 HttpSession 共享域：HttpSession 对象可以在同一用户发出的多个请求之间共享数据，但只能在同一个会话中使用。比如，可以将用户登录状态保存在 HttpSession 中，让用户在多个页面间保持登录状态。 HttpServletRequest 共享域：HttpServletRequest 对象可以在同一个请求的多个处理器方法之间共享数据。比如，可以将请求的参数和属性存储在 HttpServletRequest 中，让处理器方法之间可以访问这些数据。 PageContext 共享域：PageContext 对象是在 JSP 页面Servlet 创建时自动创建的。它可以在 JSP 的各个作用域中共享数据，包括pageScope、requestScope、sessionScope、applicationScope 等作用域。 共享域的作用是提供了方便实用的方式在同一 Web 应用程序的多个组件之间传递数据，并且可以将数据保存在不同的共享域中，根据需要进行选择和使用。 2.6.2 Request级别属性（共享）域 使用 Model 类型的形参12345678910111213@RequestMapping(&quot;/attr/request/model&quot;)@ResponseBodypublic String testAttrRequestModel( // 在形参位置声明Model类型变量，用于存储模型数据 Model model) &#123; // 我们将数据存入模型，SpringMVC 会帮我们把模型数据存入请求域 // 存入请求域这个动作也被称为暴露到请求域 model.addAttribute(&quot;requestScopeMessageModel&quot;,&quot;i am very happy[model]&quot;); return &quot;target&quot;;&#125; 使用 ModelMap 类型的形参12345678910111213@RequestMapping(&quot;/attr/request/model/map&quot;)@ResponseBodypublic String testAttrRequestModelMap( // 在形参位置声明ModelMap类型变量，用于存储模型数据 ModelMap modelMap) &#123; // 我们将数据存入模型，SpringMVC 会帮我们把模型数据存入请求域 // 存入请求域这个动作也被称为暴露到请求域 modelMap.addAttribute(&quot;requestScopeMessageModelMap&quot;,&quot;i am very happy[model map]&quot;); return &quot;target&quot;;&#125; 使用 Map 类型的形参12345678910111213@RequestMapping(&quot;/attr/request/map&quot;)@ResponseBodypublic String testAttrRequestMap( // 在形参位置声明Map类型变量，用于存储模型数据 Map&lt;String, Object&gt; map) &#123; // 我们将数据存入模型，SpringMVC 会帮我们把模型数据存入请求域 // 存入请求域这个动作也被称为暴露到请求域 map.put(&quot;requestScopeMessageMap&quot;, &quot;i am very happy[map]&quot;); return &quot;target&quot;;&#125; 使用原生 request 对象1234567891011@RequestMapping(&quot;/attr/request/original&quot;)@ResponseBodypublic String testAttrOriginalRequest( // 拿到原生对象，就可以调用原生方法执行各种操作 HttpServletRequest request) &#123; request.setAttribute(&quot;requestScopeMessageOriginal&quot;, &quot;i am very happy[original]&quot;); return &quot;target&quot;;&#125; 使用 ModelAndView 对象123456789101112@RequestMapping(&quot;/attr/request/mav&quot;)public ModelAndView testAttrByModelAndView() &#123; // 1.创建ModelAndView对象 ModelAndView modelAndView = new ModelAndView(); // 2.存入模型数据 modelAndView.addObject(&quot;requestScopeMessageMAV&quot;, &quot;i am very happy[mav]&quot;); // 3.设置视图名称 modelAndView.setViewName(&quot;target&quot;); return modelAndView;&#125; 2.6.3 Session级别属性（共享）域123456@RequestMapping(&quot;/attr/session&quot;)@ResponseBodypublic String testAttrSession(HttpSession session) &#123; //直接对session对象操作,即对会话范围操作! return &quot;target&quot;;&#125; 2.6.4 Application级别属性（共享）域解释：springmvc会在初始化容器的时候，讲servletContext对象存储到ioc容器中！ 1234567891011@Autowiredprivate ServletContext servletContext;@RequestMapping(&quot;/attr/application&quot;)@ResponseBodypublic String attrApplication() &#123; servletContext.setAttribute(&quot;appScopeMsg&quot;, &quot;i am hungry...&quot;); return &quot;target&quot;;&#125; 三、SpringMVC响应数据3.1 handler方法分析理解handler方法的作用和组成： 123456789101112131415161718/** * TODO: 一个controller的方法是控制层的一个处理器,我们称为handler * TODO: handler需要使用@RequestMapping/@GetMapping系列,声明路径,在HandlerMapping中注册,供DS查找! * TODO: handler作用总结: * 1.接收请求参数(param,json,pathVariable,共享域等) * 2.调用业务逻辑 * 3.响应前端数据(页面（不讲解模版页面跳转）,json,转发和重定向等) * TODO: handler如何处理呢 * 1.接收参数: handler(形参列表: 主要的作用就是用来接收参数) * 2.调用业务: &#123; 方法体 可以向后调用业务方法 service.xx() &#125; * 3.响应数据: return 返回结果,可以快速响应前端数据 */@GetMappingpublic Object handler(简化请求参数接收)&#123; 调用业务方法 返回的结果 （页面跳转，返回数据（json）） return 简化响应前端数据;&#125; 总结： 请求数据接收，我们都是通过handler的形参列表 &#x20; 前端数据响应，我们都是通过handler的return关键字快速处理！ &#x20; springmvc简化了参数接收和响应！ 3.2 页面跳转控制3.2.1 快速返回模板视图 开发模式回顾 在 Web 开发中，有两种主要的开发模式：前后端分离和混合开发。 前后端分离模式：[重点] 指将前端的界面和后端的业务逻辑通过接口分离开发的一种方式。开发人员使用不同的技术栈和框架，前端开发人员主要负责页面的呈现和用户交互，后端开发人员主要负责业务逻辑和数据存储。前后端通信通过 API 接口完成，数据格式一般使用 JSON 或 XML。前后端分离模式可以提高开发效率，同时也有助于代码重用和维护。 混合开发模式： 指将前端和后端的代码集成在同一个项目中，共享相同的技术栈和框架。这种模式在小型项目中比较常见，可以减少学习成本和部署难度。但是，在大型项目中，这种模式会导致代码耦合性很高，维护和升级难度较大。 对于混合开发，我们就需要使用动态页面技术，动态展示Java的共享域数据！！ jsp技术了解 JSP（JavaServer Pages）是一种动态网页开发技术，它是由 Sun 公司提出的一种基于 Java 技术的 Web 页面制作技术，可以在 HTML 文件中嵌入 Java 代码，使得生成动态内容的编写更加简单。 JSP 最主要的作用是生成动态页面。它允许将 Java 代码嵌入到 HTML 页面中，以便使用 Java 进行数据库查询、处理表单数据和生成 HTML 等动态内容。另外，JSP 还可以与 Servlet 结合使用，实现更加复杂的 Web 应用程序开发。 JSP 的主要特点包括： 简单：JSP 通过将 Java 代码嵌入到 HTML 页面中，使得生成动态内容的编写更加简单。 高效：JSP 首次运行时会被转换为 Servlet，然后编译为字节码，从而可以启用 Just-in-Time（JIT）编译器，实现更高效的运行。 多样化：JSP 支持多种标准标签库，包括 JSTL（JavaServer Pages 标准标签库）、EL（表达式语言）等，可以帮助开发人员更加方便的处理常见的 Web 开发需求。总之，JSP 是一种简单高效、多样化的动态网页开发技术，它可以方便地生成动态页面和与 Servlet 结合使用，是 Java Web 开发中常用的技术之一。 准备jsp页面和依赖 pom.xml依赖 123456&lt;!-- jsp需要依赖! jstl--&gt;&lt;dependency&gt; &lt;groupId&gt;jakarta.servlet.jsp.jstl&lt;/groupId&gt; &lt;artifactId&gt;jakarta.servlet.jsp.jstl-api&lt;/artifactId&gt; &lt;version&gt;3.0.0&lt;/version&gt;&lt;/dependency&gt; jsp页面创建 建议位置：&#x2F;WEB-INF&#x2F;下，避免外部直接访问！ 位置：&#x2F;WEB-INF&#x2F;views&#x2F;home.jsp 1234567891011&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 可以获取共享域的数据,动态展示! jsp== 后台vue --&gt; $&#123;msg&#125; &lt;/body&gt;&lt;/html&gt; 快速响应模版页面 配置jsp视图解析器1234567891011121314@EnableWebMvc //json数据处理,必须使用此注解,因为他会加入json处理器@Configuration@ComponentScan(basePackages = &quot;com.atguigu.controller&quot;) //TODO: 进行controller扫描//WebMvcConfigurer springMvc进行组件配置的规范,配置组件,提供各种方法! 前期可以实现public class SpringMvcConfig implements WebMvcConfigurer &#123; //配置jsp对应的视图解析器 @Override public void configureViewResolvers(ViewResolverRegistry registry) &#123; //快速配置jsp模板语言对应的 registry.jsp(&quot;/WEB-INF/views/&quot;,&quot;.jsp&quot;); &#125;&#125; handler返回视图12345678910111213141516/** * 跳转到提交文件页面 /save/jump * * 如果要返回jsp页面! * 1.方法返回值改成字符串类型 * 2.返回逻辑视图名即可 * &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/views/&quot;/&gt; * + 逻辑视图名 + * &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt; */@GetMapping(&quot;jump&quot;)public String jumpJsp(Model model)&#123; System.out.println(&quot;FileController.jumpJsp&quot;); model.addAttribute(&quot;msg&quot;,&quot;request data!!&quot;); return &quot;home&quot;;&#125; 3.2.2 转发和重定向在 Spring MVC 中，Handler 方法返回值来实现快速转发，可以使用 redirect 或者 forward 关键字来实现重定向。 12345678910111213@RequestMapping(&quot;/redirect-demo&quot;)public String redirectDemo() &#123; // 重定向到 /demo 路径 return &quot;redirect:/demo&quot;;&#125;@RequestMapping(&quot;/forward-demo&quot;)public String forwardDemo() &#123; // 转发到 /demo 路径 return &quot;forward:/demo&quot;;&#125;//注意： 转发和重定向到项目下资源路径都是相同，都不需要添加项目根路径！填写项目下路径即可！ 总结： 将方法的返回值，设置String类型 转发使用forward关键字，重定向使用redirect关键字 关键字: &#x2F;路径 注意：如果是项目下的资源，转发和重定向都一样都是项目下路径！都不需要添加项目根路径！ 3.3 返回JSON数据（重点）3.3.1 前置准备导入jackson依赖 12345&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.15.0&lt;/version&gt;&lt;/dependency&gt; 添加json数据转化器 @EnableWebMvc&#x20; 123456789101112131415//TODO: SpringMVC对应组件的配置类 [声明SpringMVC需要的组件信息]//TODO: 导入handlerMapping和handlerAdapter的三种方式 //1.自动导入handlerMapping和handlerAdapter [推荐] //2.可以不添加,springmvc会检查是否配置handlerMapping和handlerAdapter,没有配置默认加载 //3.使用@Bean方式配置handlerMapper和handlerAdapter@EnableWebMvc //json数据处理,必须使用此注解,因为他会加入json处理器@Configuration@ComponentScan(basePackages = &quot;com.atguigu.controller&quot;) //TODO: 进行controller扫描//WebMvcConfigurer springMvc进行组件配置的规范,配置组件,提供各种方法! 前期可以实现public class SpringMvcConfig implements WebMvcConfigurer &#123;&#125; 3.3.2 @ResponseBody 方法上使用@ResponseBody 可以在方法上使用 @ResponseBody注解，用于将方法返回的对象序列化为 JSON 或 XML 格式的数据，并发送给客户端。在前后端分离的项目中使用！ 测试方法： 123456@GetMapping(&quot;/accounts/&#123;id&#125;&quot;)@ResponseBodypublic Object handle() &#123; // ... return obj;&#125; 具体来说，@ResponseBody 注解可以用来标识方法或者方法返回值，表示方法的返回值是要直接返回给客户端的数据，而不是由视图解析器来解析并渲染生成响应体（viewResolver没用）。 测试方法： 12345678910@RequestMapping(value = &quot;/user/detail&quot;, method = RequestMethod.POST)@ResponseBodypublic User getUser(@RequestBody User userParam) &#123; System.out.println(&quot;userParam = &quot; + userParam); User user = new User(); user.setAge(18); user.setName(&quot;John&quot;); //返回的对象,会使用jackson的序列化工具,转成json返回给前端! return user;&#125; 返回结果： 类上使用@ResponseBody 如果类中每个方法上都标记了 @ResponseBody 注解，那么这些注解就可以提取到类上。 1234@ResponseBody //responseBody可以添加到类上,代表默认类中的所有方法都生效!@Controller@RequestMapping(&quot;param&quot;)public class ParamController &#123; 3.3.3 @RestController类上的 @ResponseBody 注解可以和 @Controller 注解合并为 @RestController 注解。所以使用了 @RestController 注解就相当于给类中的每个方法都加了 @ResponseBody 注解。 RestController源码: 1234567891011121314151617@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documented@Controller@ResponseBodypublic @interface RestController &#123; /** * The value may indicate a suggestion for a logical component name, * to be turned into a Spring bean in case of an autodetected component. * @return the suggested component name, if any (or empty String otherwise) * @since 4.0.1 */ @AliasFor(annotation = Controller.class) String value() default &quot;&quot;; &#125; 3.4 返回静态资源处理 静态资源概念 资源本身已经是可以直接拿到浏览器上使用的程度了，不需要在服务器端做任何运算、处理。典型的静态资源包括： 纯HTML文件 图片 CSS文件 JavaScript文件 …… 静态资源访问和问题解决 web应用加入静态资源 手动构建确保编译 访问静态资源 问题分析 DispatcherServlet 的 url-pattern 配置的是“&#x2F;” url-pattern 配置“&#x2F;”表示整个 Web 应用范围内所有请求都由 SpringMVC 来处理 对 SpringMVC 来说，必须有对应的 @RequestMapping 才能找到处理请求的方法 现在 images&#x2F;mi.jpg 请求没有对应的 @RequestMapping 所以返回 404 问题解决 在 SpringMVC 配置配置类： 12345678910111213141516171819@EnableWebMvc //json数据处理,必须使用此注解,因为他会加入json处理器@Configuration@ComponentScan(basePackages = &quot;com.atguigu.controller&quot;) //TODO: 进行controller扫描//WebMvcConfigurer springMvc进行组件配置的规范,配置组件,提供各种方法! 前期可以实现public class SpringMvcConfig implements WebMvcConfigurer &#123; //配置jsp对应的视图解析器 @Override public void configureViewResolvers(ViewResolverRegistry registry) &#123; //快速配置jsp模板语言对应的 registry.jsp(&quot;/WEB-INF/views/&quot;,&quot;.jsp&quot;); &#125; //开启静态资源处理 &lt;mvc:default-servlet-handler/&gt; @Override public void configureDefaultServletHandling(DefaultServletHandlerConfigurer configurer) &#123; configurer.enable(); &#125;&#125; 再次测试访问图片： 新的问题：其他原本正常的handler请求访问不了了 handler无法访问 解决方案： 1@EnableWebMvc //json数据处理,必须使用此注解,因为他会加入json处理器 四、RESTFul风格设计和实战4.1 RESTFul风格概述4.1.1 RESTFul风格简介 RESTful（Representational State Transfer）是一种软件架构风格，用于设计网络应用程序和服务之间的通信。它是一种基于标准 HTTP 方法的简单和轻量级的通信协议，广泛应用于现代的Web服务开发。 通过遵循 RESTful 架构的设计原则，可以构建出易于理解、可扩展、松耦合和可重用的 Web 服务。RESTful API 的特点是简单、清晰，并且易于使用和理解，它们使用标准的 HTTP 方法和状态码进行通信，不需要额外的协议和中间件。 总而言之，RESTful 是一种基于 HTTP 和标准化的设计原则的软件架构风格，用于设计和实现可靠、可扩展和易于集成的 Web 服务和应用程序！ 学习RESTful设计原则可以帮助我们更好去设计HTTP协议的API接口！！ 4.1.2 RESTFul风格特点 每一个URI代表1种资源（URI 是名词）； 客户端使用GET、POST、PUT、DELETE 4个表示操作方式的动词对服务端资源进行操作：GET用来获取资源，POST用来新建资源（也可以用于更新资源），PUT用来更新资源，DELETE用来删除资源； 资源的表现形式是XML或者JSON； 客户端与服务端之间的交互在请求之间是无状态的，从客户端到服务端的每个请求都必须包含理解请求所必需的信息。 4.1.3 RESTFul风格设计规范 HTTP协议请求方式要求 REST 风格主张在项目设计、开发过程中，具体的操作符合HTTP协议定义的请求方式的语义。 操作 请求方式 查询操作 GET 保存操作 POST 删除操作 DELETE 更新操作 PUT URL路径风格要求 REST风格下每个资源都应该有一个唯一的标识符，例如一个 URI（统一资源标识符）或者一个 URL（统一资源定位符）。资源的标识符应该能明确地说明该资源的信息，同时也应该是可被理解和解释的！ 使用URL+请求方式确定具体的动作，他也是一种标准的HTTP协议请求！ 操作 传统风格 REST 风格 保存 &#x2F;CRUD&#x2F;saveEmp URL 地址：&#x2F;CRUD&#x2F;emp&#xA;请求方式：POST 删除 &#x2F;CRUD&#x2F;removeEmp?empId&#x3D;2 URL 地址：&#x2F;CRUD&#x2F;emp&#x2F;2&#xA;请求方式：DELETE 更新 &#x2F;CRUD&#x2F;updateEmp URL 地址：&#x2F;CRUD&#x2F;emp&#xA;请求方式：PUT 查询 &#x2F;CRUD&#x2F;editEmp?empId&#x3D;2 URL 地址：&#x2F;CRUD&#x2F;emp&#x2F;2&#xA;请求方式：GET 总结 根据接口的具体动作，选择具体的HTTP协议请求方式 路径设计从原来携带动标识，改成名词，对应资源的唯一标识即可！ 4.1.4 RESTFul风格好处 含蓄，安全 使用问号键值对的方式给服务器传递数据太明显，容易被人利用来对系统进行破坏。使用 REST 风格携带数据不再需要明显的暴露数据的名称。 风格统一 URL 地址整体格式统一，从前到后始终都使用斜杠划分各个单词，用简单一致的格式表达语义。 无状态 在调用一个接口（访问、操作资源）的时候，可以不用考虑上下文，不用考虑当前状态，极大的降低了系统设计的复杂度。 严谨，规范 严格按照 HTTP1.1 协议中定义的请求方式本身的语义进行操作。 简洁，优雅 过去做增删改查操作需要设计4个不同的URL，现在一个就够了。 操作 传统风格 REST 风格 保存 &#x2F;CRUD&#x2F;saveEmp URL 地址：&#x2F;CRUD&#x2F;emp&#xA;请求方式：POST 删除 &#x2F;CRUD&#x2F;removeEmp?empId&#x3D;2 URL 地址：&#x2F;CRUD&#x2F;emp&#x2F;2&#xA;请求方式：DELETE 更新 &#x2F;CRUD&#x2F;updateEmp URL 地址：&#x2F;CRUD&#x2F;emp&#xA;请求方式：PUT 查询 &#x2F;CRUD&#x2F;editEmp?empId&#x3D;2 URL 地址：&#x2F;CRUD&#x2F;emp&#x2F;2&#xA;请求方式：GET 丰富的语义 通过 URL 地址就可以知道资源之间的关系。它能够把一句话中的很多单词用斜杠连起来，反过来说就是可以在 URL 地址中用一句话来充分表达语义。 http://localhost:8080/shop http://localhost:8080/shop/product http://localhost:8080/shop/product/cellPhone http://localhost:8080/shop/product/cellPhone/iPhone 4.2 RESTFul风格实战4.2.1 需求分析 数据结构： User {id 唯一标识,name 用户名，age 用户年龄} 功能分析 用户数据分页展示功能（条件：page 页数 默认1，size 每页数量 默认 10） 保存用户功能 根据用户id查询用户详情功能 根据用户id更新用户数据功能 根据用户id删除用户数据功能 多条件模糊查询用户功能（条件：keyword 模糊关键字，page 页数 默认1，size 每页数量 默认 10） 4.2.2 RESTFul风格接口设计 接口设计 功能 接口和请求方式 请求参数 返回值 分页查询 GET &#x2F;user page&#x3D;1&amp;size&#x3D;10 { 响应数据 } 用户添加 POST &#x2F;user { user 数据 } {响应数据} 用户详情 GET &#x2F;user&#x2F;1 路径参数 {响应数据} 用户更新 PUT &#x2F;user { user 更新数据} {响应数据} 用户删除 DELETE &#x2F;user&#x2F;1 路径参数 {响应数据} 条件模糊 GET &#x2F;user&#x2F;search page&#x3D;1&amp;size&#x3D;10&amp;keywork&#x3D;关键字 {响应数据} 问题讨论 为什么查询用户详情，就使用路径传递参数，多条件模糊查询，就使用请求参数传递？ 误区：restful风格下，不是所有请求参数都是路径传递！可以使用其他方式传递！ 在 RESTful API 的设计中，路径和请求参数和请求体都是用来向服务器传递信息的方式。 对于查询用户详情，使用路径传递参数是因为这是一个单一资源的查询，即查询一条用户记录。使用路径参数可以明确指定所请求的资源，便于服务器定位并返回对应的资源，也符合 RESTful 风格的要求。 而对于多条件模糊查询，使用请求参数传递参数是因为这是一个资源集合的查询，即查询多条用户记录。使用请求参数可以通过组合不同参数来限制查询结果，路径参数的组合和排列可能会很多，不如使用请求参数更加灵活和简洁。此外，还有一些通用的原则可以遵循： 路径参数应该用于指定资源的唯一标识或者 ID，而请求参数应该用于指定查询条件或者操作参数。 请求参数应该限制在 10 个以内，过多的请求参数可能导致接口难以维护和使用。 对于敏感信息，最好使用 POST 和请求体来传递参数。 4.2.3 后台接口实现准备用户实体类： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package com.atguigu.pojo;/** * projectName: com.atguigu.pojo * 用户实体类 */public class User &#123; private Integer id; private String name; private Integer age; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Integer getAge() &#123; return age; &#125; public void setAge(Integer age) &#123; this.age = age; &#125; @Override public String toString() &#123; return &quot;User&#123;&quot; + &quot;id=&quot; + id + &quot;, name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, age=&quot; + age + &#x27;&#125;&#x27;; &#125;&#125; 准备用户Controller: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465/** * projectName: com.atguigu.controller * * description: 用户模块的控制器 */@RequestMapping(&quot;user&quot;)@RestControllerpublic class UserController &#123; /** * 模拟分页查询业务接口 */ @GetMapping public Object queryPage(@RequestParam(name = &quot;page&quot;,required = false,defaultValue = &quot;1&quot;)int page, @RequestParam(name = &quot;size&quot;,required = false,defaultValue = &quot;10&quot;)int size)&#123; System.out.println(&quot;page = &quot; + page + &quot;, size = &quot; + size); System.out.println(&quot;分页查询业务!&quot;); return &quot;&#123;&#x27;status&#x27;:&#x27;ok&#x27;&#125;&quot;; &#125; /** * 模拟用户保存业务接口 */ @PostMapping public Object saveUser(@RequestBody User user)&#123; System.out.println(&quot;user = &quot; + user); System.out.println(&quot;用户保存业务!&quot;); return &quot;&#123;&#x27;status&#x27;:&#x27;ok&#x27;&#125;&quot;; &#125; /** * 模拟用户详情业务接口 */ @PostMapping(&quot;/&#123;id&#125;&quot;) public Object detailUser(@PathVariable Integer id)&#123; System.out.println(&quot;id = &quot; + id); System.out.println(&quot;用户详情业务!&quot;); return &quot;&#123;&#x27;status&#x27;:&#x27;ok&#x27;&#125;&quot;; &#125; /** * 模拟用户更新业务接口 */ @PutMapping public Object updateUser(@RequestBody User user)&#123; System.out.println(&quot;user = &quot; + user); System.out.println(&quot;用户更新业务!&quot;); return &quot;&#123;&#x27;status&#x27;:&#x27;ok&#x27;&#125;&quot;; &#125; /** * 模拟条件分页查询业务接口 */ @GetMapping(&quot;search&quot;) public Object queryPage(@RequestParam(name = &quot;page&quot;,required = false,defaultValue = &quot;1&quot;)int page, @RequestParam(name = &quot;size&quot;,required = false,defaultValue = &quot;10&quot;)int size, @RequestParam(name = &quot;keyword&quot;,required= false)String keyword)&#123; System.out.println(&quot;page = &quot; + page + &quot;, size = &quot; + size + &quot;, keyword = &quot; + keyword); System.out.println(&quot;条件分页查询业务!&quot;); return &quot;&#123;&#x27;status&#x27;:&#x27;ok&#x27;&#125;&quot;; &#125;&#125; 五、SpringMVC其他扩展5.1 全局异常处理机制5.1.1 异常处理两种方式开发过程中是不可避免地会出现各种异常情况的，例如网络连接异常、数据格式异常、空指针异常等等。异常的出现可能导致程序的运行出现问题，甚至直接导致程序崩溃。因此，在开发过程中，合理处理异常、避免异常产生、以及对异常进行有效的调试是非常重要的。 对于异常的处理，一般分为两种方式： 编程式异常处理：是指在代码中显式地编写处理异常的逻辑。它通常涉及到对异常类型的检测及其处理，例如使用 try-catch 块来捕获异常，然后在 catch 块中编写特定的处理代码，或者在 finally 块中执行一些清理操作。在编程式异常处理中，开发人员需要显式地进行异常处理，异常处理代码混杂在业务代码中，导致代码可读性较差。 声明式异常处理：则是将异常处理的逻辑从具体的业务逻辑中分离出来，通过配置等方式进行统一的管理和处理。在声明式异常处理中，开发人员只需要为方法或类标注相应的注解（如 @Throws 或 @ExceptionHandler），就可以处理特定类型的异常。相较于编程式异常处理，声明式异常处理可以使代码更加简洁、易于维护和扩展。 站在宏观角度来看待声明式事务处理： 整个项目从架构这个层面设计的异常处理的统一机制和规范。 一个项目中会包含很多个模块，各个模块需要分工完成。如果张三负责的模块按照 A 方案处理异常，李四负责的模块按照 B 方案处理异常……各个模块处理异常的思路、代码、命名细节都不一样，那么就会让整个项目非常混乱。 使用声明式异常处理，可以统一项目处理异常思路，项目更加清晰明了！ 5.1.2 基于注解异常声明异常处理 声明异常处理控制器类 异常处理控制类，统一定义异常处理handler方法！ 123456789101112131415/** * projectName: com.atguigu.execptionhandler * * description: 全局异常处理器,内部可以定义异常处理Handler! *//** * @RestControllerAdvice = @ControllerAdvice + @ResponseBody * @ControllerAdvice 代表当前类的异常处理controller! */@RestControllerAdvicepublic class GlobalExceptionHandler &#123; &#125; 声明异常处理hander方法 异常处理handler方法和普通的handler方法参数接收和响应都一致！ 只不过异常处理handler方法要映射异常，发生对应的异常会调用！ 普通的handler方法要使用@RequestMapping注解映射路径，发生对应的路径调用！ 123456789101112131415161718192021222324252627282930313233343536373839/** * 异常处理handler * @ExceptionHandler(HttpMessageNotReadableException.class) * 该注解标记异常处理Handler,并且指定发生异常调用该方法! * * * @param e 获取异常对象! * @return 返回handler处理结果! */@ExceptionHandler(HttpMessageNotReadableException.class)public Object handlerJsonDateException(HttpMessageNotReadableException e)&#123; return null;&#125;/** * 当发生空指针异常会触发此方法! * @param e * @return */@ExceptionHandler(NullPointerException.class)public Object handlerNullException(NullPointerException e)&#123; return null;&#125;/** * 所有异常都会触发此方法!但是如果有具体的异常处理Handler! * 具体异常处理Handler优先级更高! * 例如: 发生NullPointerException异常! * 会触发handlerNullException方法,不会触发handlerException方法! * @param e * @return */@ExceptionHandler(Exception.class)public Object handlerException(Exception e)&#123; return null;&#125; 配置文件扫描控制器类配置 确保异常处理控制类被扫描 123&lt;!-- 扫描controller对应的包,将handler加入到ioc--&gt;@ComponentScan(basePackages = &#123;&quot;com.atguigu.controller&quot;,&quot;com.atguigu.exceptionhandler&quot;&#125;) 5.2 拦截器使用5.2.1 拦截器概念拦截器和过滤器解决问题 生活中 为了提高乘车效率，在乘客进入站台前统一检票 程序中 在程序中，使用拦截器在请求到达具体 handler 方法前，统一执行检测 拦截器 Springmvc VS 过滤器 javaWeb： 相似点 拦截：必须先把请求拦住，才能执行后续操作 过滤：拦截器或过滤器存在的意义就是对请求进行统一处理 放行：对请求执行了必要操作后，放请求过去，让它访问原本想要访问的资源 不同点 工作平台不同 过滤器工作在 Servlet 容器中 拦截器工作在 SpringMVC 的基础上 拦截的范围 过滤器：能够拦截到的最大范围是整个 Web 应用 拦截器：能够拦截到的最大范围是整个 SpringMVC 负责的请求 IOC 容器支持 过滤器：想得到 IOC 容器需要调用专门的工具方法，是间接的 拦截器：它自己就在 IOC 容器中，所以可以直接从 IOC 容器中装配组件，也就是可以直接得到 IOC 容器的支持 选择： 功能需要如果用 SpringMVC 的拦截器能够实现，就不使用过滤器。 5.2.2 拦截器使用 创建拦截器类 12345678910111213141516171819202122232425262728public class Process01Interceptor implements HandlerInterceptor &#123; // if( ! preHandler())&#123;return;&#125; // 在处理请求的目标 handler 方法前执行 @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; System.out.println(&quot;request = &quot; + request + &quot;, response = &quot; + response + &quot;, handler = &quot; + handler); System.out.println(&quot;Process01Interceptor.preHandle&quot;); // 返回true：放行 // 返回false：不放行 return true; &#125; // 在目标 handler 方法之后，handler报错不执行! @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; System.out.println(&quot;request = &quot; + request + &quot;, response = &quot; + response + &quot;, handler = &quot; + handler + &quot;, modelAndView = &quot; + modelAndView); System.out.println(&quot;Process01Interceptor.postHandle&quot;); &#125; // 渲染视图之后执行(最后),一定执行! @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; System.out.println(&quot;request = &quot; + request + &quot;, response = &quot; + response + &quot;, handler = &quot; + handler + &quot;, ex = &quot; + ex); System.out.println(&quot;Process01Interceptor.afterCompletion&quot;); &#125;&#125; 拦截器方法拦截位置： 修改配置类添加拦截器 1234567891011121314151617181920212223242526@EnableWebMvc //json数据处理,必须使用此注解,因为他会加入json处理器@Configuration@ComponentScan(basePackages = &#123;&quot;com.atguigu.controller&quot;,&quot;com.atguigu.exceptionhandler&quot;&#125;) //TODO: 进行controller扫描//WebMvcConfigurer springMvc进行组件配置的规范,配置组件,提供各种方法! 前期可以实现public class SpringMvcConfig implements WebMvcConfigurer &#123; //配置jsp对应的视图解析器 @Override public void configureViewResolvers(ViewResolverRegistry registry) &#123; //快速配置jsp模板语言对应的 registry.jsp(&quot;/WEB-INF/views/&quot;,&quot;.jsp&quot;); &#125; //开启静态资源处理 &lt;mvc:default-servlet-handler/&gt; @Override public void configureDefaultServletHandling(DefaultServletHandlerConfigurer configurer) &#123; configurer.enable(); &#125; //添加拦截器 @Override public void addInterceptors(InterceptorRegistry registry) &#123; //将拦截器添加到Springmvc环境,默认拦截所有Springmvc分发的请求 registry.addInterceptor(new Process01Interceptor()); &#125;&#125; 1234567893. 配置详解 1. 默认拦截全部 ```java @Override public void addInterceptors(InterceptorRegistry registry) &#123; //将拦截器添加到Springmvc环境,默认拦截所有Springmvc分发的请求 registry.addInterceptor(new Process01Interceptor()); &#125; 精准配置123456789101112@Overridepublic void addInterceptors(InterceptorRegistry registry) &#123; //将拦截器添加到Springmvc环境,默认拦截所有Springmvc分发的请求 registry.addInterceptor(new Process01Interceptor()); //精准匹配,设置拦截器处理指定请求 路径可以设置一个或者多个,为项目下路径即可 //addPathPatterns(&quot;/common/request/one&quot;) 添加拦截路径 //也支持 /* 和 /** 模糊路径。 * 任意一层字符串 ** 任意层 任意字符串 registry.addInterceptor(new Process01Interceptor()).addPathPatterns(&quot;/common/request/one&quot;,&quot;/common/request/tow&quot;);&#125; 排除配置12345678910111213141516171819//添加拦截器@Overridepublic void addInterceptors(InterceptorRegistry registry) &#123; //将拦截器添加到Springmvc环境,默认拦截所有Springmvc分发的请求 registry.addInterceptor(new Process01Interceptor()); //精准匹配,设置拦截器处理指定请求 路径可以设置一个或者多个,为项目下路径即可 //addPathPatterns(&quot;/common/request/one&quot;) 添加拦截路径 registry.addInterceptor(new Process01Interceptor()).addPathPatterns(&quot;/common/request/one&quot;,&quot;/common/request/tow&quot;); //排除匹配,排除应该在匹配的范围内排除 //addPathPatterns(&quot;/common/request/one&quot;) 添加拦截路径 //excludePathPatterns(&quot;/common/request/tow&quot;); 排除路径,排除应该在拦截的范围内 registry.addInterceptor(new Process01Interceptor()) .addPathPatterns(&quot;/common/request/one&quot;,&quot;/common/request/tow&quot;) .excludePathPatterns(&quot;/common/request/tow&quot;);&#125; 多个拦截器执行顺序 preHandle() 方法：SpringMVC 会把所有拦截器收集到一起，然后按照配置顺序调用各个 preHandle() 方法。 postHandle() 方法：SpringMVC 会把所有拦截器收集到一起，然后按照配置相反的顺序调用各个 postHandle() 方法。 afterCompletion() 方法：SpringMVC 会把所有拦截器收集到一起，然后按照配置相反的顺序调用各个 afterCompletion() 方法。 5.3 参数校验 在 Web 应用三层架构体系中，表述层负责接收浏览器提交的数据，业务逻辑层负责数据的处理。为了能够让业务逻辑层基于正确的数据进行处理，我们需要在表述层对数据进行检查，将错误的数据隔绝在业务逻辑层之外。 校验概述 JSR 303 是 Java 为 Bean 数据合法性校验提供的标准框架，它已经包含在 JavaEE 6.0 标准中。JSR 303 通过在 Bean 属性上标注类似于 @NotNull、@Max 等标准的注解指定校验规则，并通过标准的验证接口对Bean进行验证。 注解 规则 @Null 标注值必须为 null @NotNull 标注值不可为 null @AssertTrue 标注值必须为 true @AssertFalse 标注值必须为 false @Min(value) 标注值必须大于或等于 value @Max(value) 标注值必须小于或等于 value @DecimalMin(value) 标注值必须大于或等于 value @DecimalMax(value) 标注值必须小于或等于 value @Size(max,min) 标注值大小必须在 max 和 min 限定的范围内 @Digits(integer,fratction) 标注值值必须是一个数字，且必须在可接受的范围内 @Past 标注值只能用于日期型，且必须是过去的日期 @Future 标注值只能用于日期型，且必须是将来的日期 @Pattern(value) 标注值必须符合指定的正则表达式 JSR 303 只是一套标准，需要提供其实现才可以使用。Hibernate Validator 是 JSR 303 的一个参考实现，除支持所有标准的校验注解外，它还支持以下的扩展注解： 注解 规则 ————————————————————————————————————————————————————————————————————————————————————————————————————————————————- ——————– @Email 标注值必须是格式正确的 Email 地址 @Length 标注值字符串大小必须在指定的范围内 @NotEmpty 标注值字符串不能是空字符串 @Range 标注值必须在指定的范围内 Spring 4.0 版本已经拥有自己独立的数据校验框架，同时支持 JSR 303 标准的校验框架。Spring 在进行数据绑定时，可同时调用校验框架完成数据校验工作。在SpringMVC 中，可直接通过注解驱动 @EnableWebMvc 的方式进行数据校验。Spring 的 LocalValidatorFactoryBean 既实现了 Spring 的 Validator 接口，也实现了 JSR 303 的 Validator 接口。只要在Spring容器中定义了一个LocalValidatorFactoryBean，即可将其注入到需要数据校验的 Bean中。Spring本身并没有提供JSR 303的实现，所以必须将JSR 303的实现者的jar包放到类路径下。 配置 @EnableWebMvc后，SpringMVC 会默认装配好一个 LocalValidatorFactoryBean，通过在处理方法的入参上标注 @Validated 注解即可让 SpringMVC 在完成数据绑定后执行数据校验的工作。 操作演示 导入依赖 123456789101112131415161718192021&lt;!-- 校验注解 --&gt;&lt;dependency&gt; &lt;groupId&gt;jakarta.platform&lt;/groupId&gt; &lt;artifactId&gt;jakarta.jakartaee-web-api&lt;/artifactId&gt; &lt;version&gt;9.1.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt; &lt;!-- 校验注解实现--&gt; &lt;!-- https://mvnrepository.com/artifact/org.hibernate.validator/hibernate-validator --&gt;&lt;dependency&gt; &lt;groupId&gt;org.hibernate.validator&lt;/groupId&gt; &lt;artifactId&gt;hibernate-validator&lt;/artifactId&gt; &lt;version&gt;8.0.0.Final&lt;/version&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/org.hibernate.validator/hibernate-validator-annotation-processor --&gt;&lt;dependency&gt; &lt;groupId&gt;org.hibernate.validator&lt;/groupId&gt; &lt;artifactId&gt;hibernate-validator-annotation-processor&lt;/artifactId&gt; &lt;version&gt;8.0.0.Final&lt;/version&gt;&lt;/dependency&gt; 应用校验注解 123456789101112131415161718192021222324252627282930313233343536373839404142434445import jakarta.validation.constraints.Email;import jakarta.validation.constraints.Min;import org.hibernate.validator.constraints.Length;/** * projectName: com.atguigu.pojo */public class User &#123; //age 1 &lt;= age &lt; = 150 @Min(10) private int age; //name 3 &lt;= name.length &lt;= 6 @Length(min = 3,max = 10) private String name; //email 邮箱格式 @Email private String email; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getEmail() &#123; return email; &#125; public void setEmail(String email) &#123; this.email = email; &#125;&#125; handler标记和绑定错误收集 12345678910111213141516171819202122@RestController@RequestMapping(&quot;user&quot;)public class UserController &#123; /** * @Validated 代表应用校验注解! 必须添加! */ @PostMapping(&quot;save&quot;) public Object save(@Validated @RequestBody User user, //在实体类参数和 BindingResult 之间不能有任何其他参数, BindingResult可以接受错误信息,避免信息抛出! BindingResult result)&#123; //判断是否有信息绑定错误! 有可以自行处理! if (result.hasErrors())&#123; System.out.println(&quot;错误&quot;); String errorMsg = result.getFieldError().toString(); return errorMsg; &#125; //没有,正常处理业务即可 System.out.println(&quot;正常&quot;); return user; &#125;&#125; 测试效果 易混总结 @NotNull、@NotEmpty、@NotBlank 都是用于在数据校验中检查字段值是否为空的注解，但是它们的用法和校验规则有所不同。 @NotNull (包装类型不为null) @NotNull 注解是 JSR 303 规范中定义的注解，当被标注的字段值为 null 时，会认为校验失败而抛出异常。该注解不能用于字符串类型的校验，若要对字符串进行校验，应该使用 @NotBlank 或 @NotEmpty 注解。 @NotEmpty (集合类型长度大于0) @NotEmpty 注解同样是 JSR 303 规范中定义的注解，对于 CharSequence、Collection、Map 或者数组对象类型的属性进行校验，校验时会检查该属性是否为 Null 或者 size()&#x3D;&#x3D;0，如果是的话就会校验失败。但是对于其他类型的属性，该注解无效。需要注意的是只校验空格前后的字符串，如果该字符串中间只有空格，不会被认为是空字符串，校验不会失败。 @NotBlank （字符串，不为null，切不为” “字符串） @NotBlank 注解是 Hibernate Validator 附加的注解，对于字符串类型的属性进行校验，校验时会检查该属性是否为 Null 或 “” 或者只包含空格，如果是的话就会校验失败。需要注意的是，@NotBlank 注解只能用于字符串类型的校验。总之，这三种注解都是用于校验字段值是否为空的注解，但是其校验规则和用法有所不同。在进行数据校验时，需要根据具体情况选择合适的注解进行校验。 六、SpringMVC总结 核心点 掌握目标 springmvc框架 主要作用、核心组件、调用流程 简化参数接收 路径设计、参数接收、请求头接收、cookie接收 简化数据响应 模板页面、转发和重定向、JSON数据、静态资源 restful风格设计 主要作用、具体规范、请求方式和请求参数选择 功能扩展 全局异常处理、拦截器、参数校验注解","categories":[{"name":"SSM框架","slug":"SSM框架","permalink":"http://example.com/categories/SSM%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"ssm","slug":"ssm","permalink":"http://example.com/tags/ssm/"}]},{"title":"三、MyBatis实践：提高持久层数据处理效率","slug":"SSM/三、MyBatis实践：提高持久层数据处理效率/三、MyBatis实践：提高持久层数据处理效率","date":"2022-09-29T09:55:54.000Z","updated":"2023-09-28T00:31:34.403Z","comments":true,"path":"2022/09/29/SSM/三、MyBatis实践：提高持久层数据处理效率/三、MyBatis实践：提高持久层数据处理效率/","link":"","permalink":"http://example.com/2022/09/29/SSM/%E4%B8%89%E3%80%81MyBatis%E5%AE%9E%E8%B7%B5%EF%BC%9A%E6%8F%90%E9%AB%98%E6%8C%81%E4%B9%85%E5%B1%82%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E6%95%88%E7%8E%87/%E4%B8%89%E3%80%81MyBatis%E5%AE%9E%E8%B7%B5%EF%BC%9A%E6%8F%90%E9%AB%98%E6%8C%81%E4%B9%85%E5%B1%82%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E6%95%88%E7%8E%87/","excerpt":"","text":"三、MyBatis实践：提高持久层数据处理效率目录 一、Mybatis简介 1.1 简介 1.2 持久层框架对比 1.3 快速入门（基于Mybatis3方式） 二、MyBatis基本使用 2.1 向SQL语句传参 2.1.1 mybatis日志输出配置 2.1.2 #{}形式 2.1.3 ${}形式 2.2 数据输入 2.2.1 Mybatis总体机制概括 2.2.2 概念说明 2.2.3 单个简单类型参数 2.2.4 实体类类型参数 2.2.5 零散的简单类型数据 2.2.6 Map类型参数 2.3数据输出 2.3.1 输出概述 2.3.2 单个简单类型 2.3.3 返回实体类对象 2.3.4 返回Map类型 2.3.5 返回List类型 2.3.6 返回主键值 2.3.7 实体类属性和数据库字段对应关系 2.4 CRUD强化练习 2.5 mapperXML标签总结 三、MyBatis多表映射 3.1 多表映射概念 3.2 对一映射 3.3 对多映射 3.4 多表映射总结 3.4.1 多表映射优化 3.4.2 多表映射总结 四、MyBatis动态语句 4.1 动态语句需求和简介 4.2 if和where标签 4.3 set标签 4.4 trim标签(了解) 4.5 choose&#x2F;when&#x2F;otherwise标签 4.6 foreach标签 4.7 sql片段 五、MyBatis高级扩展 5.1 Mapper批量映射优化 5.2 插件和分页插件PageHelper 5.2.1 插件机制和PageHelper插件介绍 5.2.2 PageHelper插件使用 5.3 逆向工程和MybatisX插件 5.3.1 ORM思维介绍 5.3.2 逆向工程 5.3.3 逆向工程插件MyBatisX使用 六、MyBatis总结 一、Mybatis简介1.1 简介https://mybatis.org/mybatis-3/zh/index.html MyBatis最初是Apache的一个开源项目iBatis, 2010年6月这个项目由Apache Software Foundation迁移到了Google Code。随着开发团队转投Google Code旗下， iBatis3.x正式更名为MyBatis。代码于2013年11月迁移到Github。 MyBatis 是一款优秀的持久层框架，它支持自定义 SQL、存储过程以及高级映射。MyBatis 免除了几乎所有的 JDBC 代码以及设置参数和获取结果集的工作。MyBatis 可以通过简单的 XML 或注解来配置和映射原始类型、接口和 Java POJO（Plain Old Java Objects，普通老式 Java 对象）为数据库中的记录。 社区会持续更新开源项目，版本会不断变化，我们不必每个小版本都追，关注重大更新的大版本升级即可。 本课程使用：3.5.11版本 1.2 持久层框架对比 JDBC SQL 夹杂在Java代码中耦合度高，导致硬编码内伤 维护不易且实际开发需求中 SQL 有变化，频繁修改的情况多见 代码冗长，开发效率低 Hibernate 和 JPA 操作简便，开发效率高 程序中的长难复杂 SQL 需要绕过框架 内部自动生成的 SQL，不容易做特殊优化 基于全映射的全自动框架，大量字段的 POJO 进行部分映射时比较困难。 反射操作太多，导致数据库性能下降 MyBatis 轻量级，性能出色 SQL 和 Java 编码分开，功能边界清晰。Java代码专注业务、SQL语句专注数据 开发效率稍逊于 Hibernate，但是完全能够接收 开发效率：Hibernate&gt;Mybatis&gt;JDBC 运行效率：JDBC&gt;Mybatis&gt;Hibernate 1.3 快速入门（基于Mybatis3方式） 准备数据模型 1234567891011121314CREATE DATABASE `mybatis-example`;USE `mybatis-example`;CREATE TABLE `t_emp`( emp_id INT AUTO_INCREMENT, emp_name CHAR(100), emp_salary DOUBLE(10,5), PRIMARY KEY(emp_id));INSERT INTO `t_emp`(emp_name,emp_salary) VALUES(&quot;tom&quot;,200.33);INSERT INTO `t_emp`(emp_name,emp_salary) VALUES(&quot;jerry&quot;,666.66);INSERT INTO `t_emp`(emp_name,emp_salary) VALUES(&quot;andy&quot;,777.77); 项目搭建和准备 项目搭建 依赖导入 pom.xml 12345678910111213141516171819202122&lt;dependencies&gt; &lt;!-- mybatis依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.11&lt;/version&gt; &lt;/dependency&gt; &lt;!-- MySQL驱动 mybatis底层依赖jdbc驱动实现,本次不需要导入连接池,mybatis自带! --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.25&lt;/version&gt; &lt;/dependency&gt; &lt;!--junit5测试--&gt; &lt;dependency&gt; &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt; &lt;artifactId&gt;junit-jupiter-api&lt;/artifactId&gt; &lt;version&gt;5.3.1&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 实体类准备 12345678910public class Employee &#123; private Integer empId; private String empName; private Double empSalary; //getter | setter&#125; 准备Mapper接口和MapperXML文件 MyBatis 框架下，SQL语句编写位置发生改变，从原来的Java类，改成XML或者注解定义！ 推荐在XML文件中编写SQL语句，让用户能更专注于 SQL 代码，不用关注其他的JDBC代码。 如果拿它跟具有相同功能的 JDBC 代码进行对比，你会立即发现省掉了将近 95% 的代码！！ 一般编写SQL语句的文件命名：XxxMapper.xml Xxx一般取表名！！ Mybatis 中的 Mapper 接口相当于以前的 Dao。但是区别在于，Mapper 仅仅只是建接口即可，我们不需要提供实现类，具体的SQL写到对应的Mapper文件，该用法的思路如下图所示： 定义mapper接口 包：com.atguigu.mapper 12345678910111213141516171819package com.atguigu.mapper;import com.atguigu.pojo.Employee;/** * t_emp表对应数据库SQL语句映射接口! * 接口只规定方法,参数和返回值! * mapper.xml中编写具体SQL语句! */public interface EmployeeMapper &#123; /** * 根据员工id查询员工数据方法 * @param empId 员工id * @return 员工实体对象 */ Employee selectEmployee(Integer empId); &#125; 定义mapper xml 位置： resources&#x2F;mappers&#x2F;EmployeeMapper.xml 123456789101112131415161718&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;https://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;!-- namespace等于mapper接口类的全限定名,这样实现对应 --&gt;&lt;mapper namespace=&quot;com.atguigu.mapper.EmployeeMapper&quot;&gt; &lt;!-- 查询使用 select标签 id = 方法名 resultType = 返回值类型 标签内编写SQL语句 --&gt; &lt;select id=&quot;selectEmployee&quot; resultType=&quot;com.atguigu.pojo.Employee&quot;&gt; &lt;!-- #&#123;empId&#125;代表动态传入的参数,并且进行赋值!后面详细讲解 --&gt; select emp_id empId,emp_name empName, emp_salary empSalary from t_emp where emp_id = #&#123;empId&#125; &lt;/select&gt;&lt;/mapper&gt; 注意： 方法名和SQL的id一致 方法返回值和resultType一致 方法的参数和SQL的参数一致 接口的全类名和映射配置文件的名称空间一致 准备MyBatis配置文件 mybatis框架配置文件： 数据库连接信息，性能配置，mapper.xml配置等！ 习惯上命名为 mybatis-config.xml，这个文件名仅仅只是建议，并非强制要求。将来整合 Spring 之后，这个配置文件可以省略，所以大家操作时可以直接复制、粘贴。 1234567891011121314151617181920212223242526272829303132&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt; &lt;!-- environments表示配置Mybatis的开发环境，可以配置多个环境，在众多具体环境中，使用default属性指定实际运行时使用的环境。default属性的取值是environment标签的id属性的值。 --&gt; &lt;environments default=&quot;development&quot;&gt; &lt;!-- environment表示配置Mybatis的一个具体的环境 --&gt; &lt;environment id=&quot;development&quot;&gt; &lt;!-- Mybatis的内置的事务管理器 --&gt; &lt;transactionManager type=&quot;JDBC&quot;/&gt; &lt;!-- 配置数据源 --&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;!-- 建立数据库连接的具体信息 --&gt; &lt;property name=&quot;driver&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mybatis-example&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;root&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;!-- Mapper注册：指定Mybatis映射文件的具体位置 --&gt; &lt;!-- mapper标签：配置一个具体的Mapper映射文件 --&gt; &lt;!-- resource属性：指定Mapper映射文件的实际存储位置，这里需要使用一个以类路径根目录为基准的相对路径 --&gt; &lt;!-- 对Maven工程的目录结构来说，resources目录下的内容会直接放入类路径，所以这里我们可以以resources目录为基准 --&gt; &lt;mapper resource=&quot;mappers/EmployeeMapper.xml&quot;/&gt; &lt;/mappers&gt;&lt;/configuration&gt; 运行和测试 12345678910111213141516171819202122232425262728293031323334353637/** * projectName: com.atguigu.test * * description: 测试类 */public class MyBatisTest &#123; @Test public void testSelectEmployee() throws IOException &#123; // 1.创建SqlSessionFactory对象 // ①声明Mybatis全局配置文件的路径 String mybatisConfigFilePath = &quot;mybatis-config.xml&quot;; // ②以输入流的形式加载Mybatis配置文件 InputStream inputStream = Resources.getResourceAsStream(mybatisConfigFilePath); // ③基于读取Mybatis配置文件的输入流创建SqlSessionFactory对象 SqlSessionFactory sessionFactory = new SqlSessionFactoryBuilder().build(inputStream); // 2.使用SqlSessionFactory对象开启一个会话 SqlSession session = sessionFactory.openSession(); // 3.根据EmployeeMapper接口的Class对象获取Mapper接口类型的对象(动态代理技术) EmployeeMapper employeeMapper = session.getMapper(EmployeeMapper.class); // 4. 调用代理类方法既可以触发对应的SQL语句 Employee employee = employeeMapper.selectEmployee(1); System.out.println(&quot;employee = &quot; + employee); // 4.关闭SqlSession session.commit(); //提交事务 [DQL不需要,其他需要] session.close(); //关闭会话 &#125;&#125; 说明： SqlSession：代表Java程序和数据库之间的会话。（HttpSession是Java程序和浏览器之间的会话） SqlSessionFactory：是“生产”SqlSession的“工厂”。 工厂模式：如果创建某一个对象，使用的过程基本固定，那么我们就可以把创建这个对象的相关代码封装到一个“工厂类”中，以后都使用这个工厂类来“生产”我们需要的对象。 SqlSession和HttpSession区别 HttpSession：工作在Web服务器上，属于表述层。 代表浏览器和Web服务器之间的会话。 SqlSession：不依赖Web服务器，属于持久化层。 代表Java程序和数据库之间的会话。 二、MyBatis基本使用2.1 向SQL语句传参2.1.1 mybatis日志输出配置mybatis配置文件设计标签和顶层结构如下： configuration（配置） properties（属性） settings（设置） typeAliases（类型别名） typeHandlers（类型处理器） objectFactory（对象工厂） plugins（插件） environments（环境配置） environment（环境变量） transactionManager（事务管理器） dataSource（数据源） databaseIdProvider（数据库厂商标识） mappers（映射器） 我们可以在mybatis的配置文件使用settings标签设置，输出运过程SQL日志！ 通过查看日志，我们可以判定#{} 和 ${}的输出效果！ settings设置项： logImpl 指定 MyBatis 所用日志的具体实现，未指定时将自动查找。 SLF4J | LOG4J（3.5.9 起废弃） | LOG4J2 | JDK_LOGGING | COMMONS_LOGGING | STDOUT_LOGGING | NO_LOGGING 未设置 日志配置： 1234&lt;settings&gt; &lt;!-- SLF4J 选择slf4j输出！ --&gt; &lt;setting name=&quot;logImpl&quot; value=&quot;SLF4J&quot;/&gt;&lt;/settings&gt; 2.1.2 #{}形式Mybatis会将SQL语句中的#{}转换为问号占位符。 2.1.3 ${}形式${}形式传参，底层Mybatis做的是字符串拼接操作。 通常不会采用${}的方式传值。一个特定的适用场景是：通过Java程序动态生成数据库表，表名部分需要Java程序通过参数传入；而JDBC对于表名部分是不能使用问号占位符的，此时只能使用 结论：实际开发中，能用#{}实现的，肯定不用${}。 特殊情况： 动态的不是值，是列名或者关键字，需要使用${}拼接 1234//注解方式传入参数！！@Select(&quot;select * from user where $&#123;column&#125; = #&#123;value&#125;&quot;)User findByColumn(@Param(&quot;column&quot;) String column, @Param(&quot;value&quot;) String value); 2.2 数据输入2.2.1 Mybatis总体机制概括 2.2.2 概念说明这里数据输入具体是指上层方法（例如Service方法）调用Mapper接口时，数据传入的形式。 简单类型：只包含一个值的数据类型 基本数据类型：int、byte、short、double、…… 基本数据类型的包装类型：Integer、Character、Double、…… 字符串类型：String 复杂类型：包含多个值的数据类型 实体类类型：Employee、Department、…… 集合类型：List、Set、Map、…… 数组类型：int[]、String[]、…… 复合类型：List&lt;Employee&gt;、实体类中包含集合…… 2.2.3 单个简单类型参数Mapper接口中抽象方法的声明 1Employee selectEmployee(Integer empId); SQL语句 123&lt;select id=&quot;selectEmployee&quot; resultType=&quot;com.atguigu.mybatis.entity.Employee&quot;&gt; select emp_id empId,emp_name empName,emp_salary empSalary from t_emp where emp_id=#&#123;empId&#125;&lt;/select&gt; 单个简单类型参数，在#{}中可以随意命名，但是没有必要。通常还是使用和接口方法参数同名。 2.2.4 实体类类型参数Mapper接口中抽象方法的声明 1int insertEmployee(Employee employee); SQL语句 123&lt;insert id=&quot;insertEmployee&quot;&gt; insert into t_emp(emp_name,emp_salary) values(#&#123;empName&#125;,#&#123;empSalary&#125;)&lt;/insert&gt; 对应关系 结论 Mybatis会根据#{}中传入的数据，加工成getXxx()方法，通过反射在实体类对象中调用这个方法，从而获取到对应的数据。填充到#{}解析后的问号占位符这个位置。 2.2.5 零散的简单类型数据零散的多个简单类型参数，如果没有特殊处理，那么Mybatis无法识别自定义名称： Mapper接口中抽象方法的声明 1int updateEmployee(@Param(&quot;empId&quot;) Integer empId,@Param(&quot;empSalary&quot;) Double empSalary); SQL语句 123&lt;update id=&quot;updateEmployee&quot;&gt; update t_emp set emp_salary=#&#123;empSalary&#125; where emp_id=#&#123;empId&#125;&lt;/update&gt; 对应关系 2.2.6 Map类型参数Mapper接口中抽象方法的声明 1int updateEmployeeByMap(Map&lt;String, Object&gt; paramMap); SQL语句 12345&lt;update id=&quot;updateEmployeeByMap&quot;&gt; update t_emp set emp_salary=#&#123;empSalaryKey&#125; where emp_id=#&#123;empIdKey&#125;&lt;/update&gt; junit测试 123456789101112131415161718192021222324252627private SqlSession session;//junit5会在每一个@Test方法前执行@BeforeEach方法@BeforeEachpublic void init() throws IOException &#123; session = new SqlSessionFactoryBuilder() .build( Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;)) .openSession();&#125;@Testpublic void testUpdateEmpNameByMap() &#123; EmployeeMapper mapper = session.getMapper(EmployeeMapper.class); Map&lt;String, Object&gt; paramMap = new HashMap&lt;&gt;(); paramMap.put(&quot;empSalaryKey&quot;, 999.99); paramMap.put(&quot;empIdKey&quot;, 5); int result = mapper.updateEmployeeByMap(paramMap); log.info(&quot;result = &quot; + result);&#125;//junit5会在每一个@Test方法后执行@@AfterEach方法@AfterEachpublic void clear() &#123; session.commit(); session.close();&#125; 对应关系 #{}中写Map中的key 使用场景 有很多零散的参数需要传递，但是没有对应的实体类类型可以使用。使用@Param注解一个一个传入又太麻烦了。所以都封装到Map中。 2.3数据输出2.3.1 输出概述数据输出总体上有两种形式： 增删改操作返回的受影响行数：直接使用 int 或 long 类型接收即可 查询操作的查询结果 我们需要做的是，指定查询的输出数据类型即可！ 并且插入场景下，实现主键数据回显示！ 2.3.2 单个简单类型Mapper接口中的抽象方法 1int selectEmpCount(); SQL语句 123&lt;select id=&quot;selectEmpCount&quot; resultType=&quot;int&quot;&gt; select count(*) from t_emp&lt;/select&gt; Mybatis 内部给常用的数据类型设定了很多别名。 以 int 类型为例，可以写的名称有：int、integer、Integer、java.lang.Integer、Int、INT、INTEGER 等等。 junit测试 1234567891011@Testpublic void testEmpCount() &#123; EmployeeMapper employeeMapper = session.getMapper(EmployeeMapper.class); int count = employeeMapper.selectEmpCount(); log.info(&quot;count = &quot; + count);&#125; 细节解释： select标签，通过resultType指定查询返回值类型！ resultType &#x3D; “全限定符 ｜ 别名 ｜ 如果是返回集合类型，写范型类型即可” 别名问题： https://mybatis.org/mybatis-3/zh/configuration.html#typeAliases 类型别名可为 Java 类型设置一个缩写名字。 它仅用于 XML 配置，意在降低冗余的全限定类名书写。例如： 1234&lt;typeAliases&gt; &lt;typeAlias alias=&quot;Author&quot; type=&quot;domain.blog.Author&quot;/&gt; &lt;typeAlias alias=&quot;Blog&quot; type=&quot;domain.blog.Blog&quot;/&gt;&lt;/typeAliases&gt; 当这样配置时，Blog 可以用在任何使用 domain.blog.Blog 的地方。 也可以指定一个包名，MyBatis 会在包名下面搜索需要的 Java Bean，比如： 1&lt;typeAliases&gt; &lt;package name=&quot;domain.blog&quot;/&gt; &lt;/typeAliases&gt; 每一个在包 domain.blog 中的 Java Bean，在没有注解的情况下，会使用 Bean 的首字母小写的非限定类名来作为它的别名。 比如 domain.blog.Author 的别名为 author；若有注解，则别名为其注解值。见下面的例子： 1234@Alias(&quot;author&quot;)public class Author &#123; ...&#125; 下面是Mybatis为常见的 Java 类型内建的类型别名。它们都是不区分大小写的，注意，为了应对原始类型的命名重复，采取了特殊的命名风格。 别名 映射的类型 _byte byte _char (since 3.5.10) char _character (since 3.5.10) char _long long _short short _int int _integer int _double double _float float _boolean boolean string String byte Byte char (since 3.5.10) Character character (since 3.5.10) Character long Long short Short int Integer integer Integer double Double float Float boolean Boolean date Date decimal BigDecimal bigdecimal BigDecimal biginteger BigInteger object Object object[] Object[] map Map hashmap HashMap list List arraylist ArrayList collection Collection 2.3.3 返回实体类对象Mapper接口的抽象方法 12Employee selectEmployee(Integer empId); SQL语句 123456789&lt;!-- 编写具体的SQL语句，使用id属性唯一的标记一条SQL语句 --&gt;&lt;!-- resultType属性：指定封装查询结果的Java实体类的全类名 --&gt;&lt;select id=&quot;selectEmployee&quot; resultType=&quot;com.atguigu.mybatis.entity.Employee&quot;&gt; &lt;!-- Mybatis负责把SQL语句中的#&#123;&#125;部分替换成“?”占位符 --&gt; &lt;!-- 给每一个字段设置一个别名，让别名和Java实体类中属性名一致 --&gt; select emp_id empId,emp_name empName,emp_salary empSalary from t_emp where emp_id=#&#123;maomi&#125;&lt;/select&gt; 通过给数据库表字段加别名，让查询结果的每一列都和Java实体类中属性对应起来。 增加全局配置自动识别对应关系 在 Mybatis 全局配置文件中，做了下面的配置，select语句中可以不给字段设置别名 1234567891011&lt;!-- 在全局范围内对Mybatis进行配置 --&gt;&lt;settings&gt; &lt;!-- 具体配置 --&gt; &lt;!-- 从org.apache.ibatis.session.Configuration类中可以查看能使用的配置项 --&gt; &lt;!-- 将mapUnderscoreToCamelCase属性配置为true，表示开启自动映射驼峰式命名规则 --&gt; &lt;!-- 规则要求数据库表字段命名方式：单词_单词 --&gt; &lt;!-- 规则要求Java实体类属性名命名方式：首字母小写的驼峰式命名 --&gt; &lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;true&quot;/&gt;&lt;/settings&gt; 2.3.4 返回Map类型适用于SQL查询返回的各个字段综合起来并不和任何一个现有的实体类对应，没法封装到实体类对象中。能够封装成实体类类型的，就不使用Map类型。 Mapper接口的抽象方法 1Map&lt;String,Object&gt; selectEmpNameAndMaxSalary(); SQL语句 1234567891011&lt;!-- Map&lt;String,Object&gt; selectEmpNameAndMaxSalary(); --&gt;&lt;!-- 返回工资最高的员工的姓名和他的工资 --&gt;&lt;select id=&quot;selectEmpNameAndMaxSalary&quot; resultType=&quot;map&quot;&gt; SELECT emp_name 员工姓名, emp_salary 员工工资, (SELECT AVG(emp_salary) FROM t_emp) 部门平均工资 FROM t_emp WHERE emp_salary=( SELECT MAX(emp_salary) FROM t_emp )&lt;/select&gt; junit测试 12345678910111213141516171819@Testpublic void testQueryEmpNameAndSalary() &#123; EmployeeMapper employeeMapper = session.getMapper(EmployeeMapper.class); Map&lt;String, Object&gt; resultMap = employeeMapper.selectEmpNameAndMaxSalary(); Set&lt;Map.Entry&lt;String, Object&gt;&gt; entrySet = resultMap.entrySet(); for (Map.Entry&lt;String, Object&gt; entry : entrySet) &#123; String key = entry.getKey(); Object value = entry.getValue(); log.info(key + &quot;=&quot; + value); &#125;&#125; 2.3.5 返回List类型查询结果返回多个实体类对象，希望把多个实体类对象放在List集合中返回。此时不需要任何特殊处理，在resultType属性中还是设置实体类类型即可。 Mapper接口中抽象方法 1List&lt;Employee&gt; selectAll(); SQL语句 12345&lt;!-- List&lt;Employee&gt; selectAll(); --&gt;&lt;select id=&quot;selectAll&quot; resultType=&quot;com.atguigu.mybatis.entity.Employee&quot;&gt; select emp_id empId,emp_name empName,emp_salary empSalary from t_emp&lt;/select&gt; junit测试 12345678@Testpublic void testSelectAll() &#123; EmployeeMapper employeeMapper = session.getMapper(EmployeeMapper.class); List&lt;Employee&gt; employeeList = employeeMapper.selectAll(); for (Employee employee : employeeList) &#123; log.info(&quot;employee = &quot; + employee); &#125;&#125; 2.3.6 返回主键值 自增长类型主键 Mapper接口中的抽象方法 1int insertEmployee(Employee employee); SQL语句 1234567&lt;!-- int insertEmployee(Employee employee); --&gt;&lt;!-- useGeneratedKeys属性字面意思就是“使用生成的主键” --&gt;&lt;!-- keyProperty属性可以指定主键在实体类对象中对应的属性名，Mybatis会将拿到的主键值存入这个属性 --&gt;&lt;insert id=&quot;insertEmployee&quot; useGeneratedKeys=&quot;true&quot; keyProperty=&quot;empId&quot;&gt; insert into t_emp(emp_name,emp_salary) values(#&#123;empName&#125;,#&#123;empSalary&#125;)&lt;/insert&gt; junit测试 123456789@Testpublic void testSaveEmp() &#123; EmployeeMapper employeeMapper = session.getMapper(EmployeeMapper.class); Employee employee = new Employee(); employee.setEmpName(&quot;john&quot;); employee.setEmpSalary(666.66); employeeMapper.insertEmployee(employee); log.info(&quot;employee.getEmpId() = &quot; + employee.getEmpId());&#125; 注意 Mybatis是将自增主键的值设置到实体类对象中，而不是以Mapper接口方法返回值的形式返回。 非自增长类型主键 而对于不支持自增型主键的数据库（例如 Oracle）或者字符串类型主键，则可以使用 selectKey 子元素：selectKey 元素将会首先运行，id 会被设置，然后插入语句会被调用！ 使用 selectKey 帮助插入UUID作为字符串类型主键示例： 12345678910111213&lt;insert id=&quot;insertUser&quot; parameterType=&quot;User&quot;&gt; &lt;selectKey keyProperty=&quot;id&quot; resultType=&quot;java.lang.String&quot; order=&quot;BEFORE&quot;&gt; SELECT UUID() as id &lt;/selectKey&gt; INSERT INTO user (id, username, password) VALUES ( #&#123;id&#125;, #&#123;username&#125;, #&#123;password&#125; )&lt;/insert&gt; 在上例中，我们定义了一个 insertUser 的插入语句来将 User 对象插入到 user 表中。我们使用 selectKey 来查询 UUID 并设置到 id 字段中。 通过 keyProperty 属性来指定查询到的 UUID 赋值给对象中的 id 属性，而 resultType 属性指定了 UUID 的类型为 java.lang.String。 需要注意的是，我们将 selectKey 放在了插入语句的前面，这是因为 MySQL 在 insert 语句中只支持一个 select 子句，而 selectKey 中查询 UUID 的语句就是一个 select 子句，因此我们需要将其放在前面。 最后，在将 User 对象插入到 user 表中时，我们直接使用对象中的 id 属性来插入主键值。 使用这种方式，我们可以方便地插入 UUID 作为字符串类型主键。当然，还有其他插入方式可以使用，如使用Java代码生成UUID并在类中显式设置值等。需要根据具体应用场景和需求选择合适的插入方式。 2.3.7 实体类属性和数据库字段对应关系 别名对应 将字段的别名设置成和实体类属性一致。 123456789&lt;!-- 编写具体的SQL语句，使用id属性唯一的标记一条SQL语句 --&gt;&lt;!-- resultType属性：指定封装查询结果的Java实体类的全类名 --&gt;&lt;select id=&quot;selectEmployee&quot; resultType=&quot;com.atguigu.mybatis.entity.Employee&quot;&gt; &lt;!-- Mybatis负责把SQL语句中的#&#123;&#125;部分替换成“?”占位符 --&gt; &lt;!-- 给每一个字段设置一个别名，让别名和Java实体类中属性名一致 --&gt; select emp_id empId,emp_name empName,emp_salary empSalary from t_emp where emp_id=#&#123;maomi&#125;&lt;/select&gt; 关于实体类属性的约定：getXxx()方法、setXxx()方法把方法名中的get或set去掉，首字母小写。 全局配置自动识别驼峰式命名规则 在Mybatis全局配置文件加入如下配置： 1234567&lt;!-- 使用settings对Mybatis全局进行设置 --&gt;&lt;settings&gt; &lt;!-- 将xxx_xxx这样的列名自动映射到xxXxx这样驼峰式命名的属性名 --&gt; &lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;true&quot;/&gt;&lt;/settings&gt; SQL语句中可以不使用别名 123456&lt;!-- Employee selectEmployee(Integer empId); --&gt;&lt;select id=&quot;selectEmployee&quot; resultType=&quot;com.atguigu.mybatis.entity.Employee&quot;&gt; select emp_id,emp_name,emp_salary from t_emp where emp_id=#&#123;empId&#125;&lt;/select&gt; 使用resultMap 使用resultMap标签定义对应关系，再在后面的SQL语句中引用这个对应关系 1234567891011121314151617181920&lt;!-- 专门声明一个resultMap设定column到property之间的对应关系 --&gt;&lt;resultMap id=&quot;selectEmployeeByRMResultMap&quot; type=&quot;com.atguigu.mybatis.entity.Employee&quot;&gt; &lt;!-- 使用id标签设置主键列和主键属性之间的对应关系 --&gt; &lt;!-- column属性用于指定字段名；property属性用于指定Java实体类属性名 --&gt; &lt;id column=&quot;emp_id&quot; property=&quot;empId&quot;/&gt; &lt;!-- 使用result标签设置普通字段和Java实体类属性之间的关系 --&gt; &lt;result column=&quot;emp_name&quot; property=&quot;empName&quot;/&gt; &lt;result column=&quot;emp_salary&quot; property=&quot;empSalary&quot;/&gt;&lt;/resultMap&gt;&lt;!-- Employee selectEmployeeByRM(Integer empId); --&gt;&lt;select id=&quot;selectEmployeeByRM&quot; resultMap=&quot;selectEmployeeByRMResultMap&quot;&gt; select emp_id,emp_name,emp_salary from t_emp where emp_id=#&#123;empId&#125;&lt;/select&gt; 2.4 CRUD强化练习 准备数据库数据 首先，我们需要准备一张名为 user 的表。该表包含字段 id（主键）、username、password。创建SQL如下： 1234567CREATE TABLE `user` ( `id` INT(11) NOT NULL AUTO_INCREMENT, `username` VARCHAR(50) NOT NULL, `password` VARCHAR(50) NOT NULL, PRIMARY KEY (`id`)) ENGINE=INNODB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8; 实体类准备 接下来，我们需要定义一个实体类 User，来对应 user 表的一行数据。 123456@Data //lombokpublic class User &#123; private Integer id; private String username; private String password;&#125; Mapper接口定义 定义一个 Mapper 接口 UserMapper，并在其中添加 user 表的增、删、改、查方法。 123456789101112public interface UserMapper &#123; int insert(User user); int update(User user); int delete(Integer id); User selectById(Integer id); List&lt;User&gt; selectAll();&#125; MapperXML编写 在 resources &#x2F;mappers目录下创建一个名为 UserMapper.xml 的 XML 文件，包含与 Mapper 接口中相同的五个 SQL 语句，并在其中，将查询结果映射到 User 实体中。 1234567891011121314151617181920212223242526272829303132&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;https://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;!-- namespace等于mapper接口类的全限定名,这样实现对应 --&gt;&lt;mapper namespace=&quot;com.atguigu.mapper.UserMapper&quot;&gt; &lt;!-- 定义一个插入语句，并获取主键值 --&gt; &lt;insert id=&quot;insert&quot; useGeneratedKeys=&quot;true&quot; keyProperty=&quot;id&quot;&gt; INSERT INTO user(username, password) VALUES(#&#123;username&#125;, #&#123;password&#125;) &lt;/insert&gt; &lt;update id=&quot;update&quot;&gt; UPDATE user SET username=#&#123;username&#125;, password=#&#123;password&#125; WHERE id=#&#123;id&#125; &lt;/update&gt; &lt;delete id=&quot;delete&quot;&gt; DELETE FROM user WHERE id=#&#123;id&#125; &lt;/delete&gt; &lt;!-- resultType使用user别名，稍后需要配置！--&gt; &lt;select id=&quot;selectById&quot; resultType=&quot;user&quot;&gt; SELECT id, username, password FROM user WHERE id=#&#123;id&#125; &lt;/select&gt; &lt;!-- resultType返回值类型为集合，所以只写范型即可！ --&gt; &lt;select id=&quot;selectAll&quot; resultType=&quot;user&quot;&gt; SELECT id, username, password FROM user &lt;/select&gt; &lt;/mapper&gt; MyBatis配置文件 位置：resources: mybatis-config.xml&#x20; 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt; &lt;settings&gt; &lt;!-- 开启驼峰式映射--&gt; &lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;true&quot;/&gt; &lt;!-- 开启logback日志输出--&gt; &lt;setting name=&quot;logImpl&quot; value=&quot;SLF4J&quot;/&gt; &lt;/settings&gt; &lt;typeAliases&gt; &lt;!-- 给实体类起别名 --&gt; &lt;package name=&quot;com.atguigu.pojo&quot;/&gt; &lt;/typeAliases&gt; &lt;!-- environments表示配置Mybatis的开发环境，可以配置多个环境，在众多具体环境中，使用default属性指定实际运行时使用的环境。default属性的取值是environment标签的id属性的值。 --&gt; &lt;environments default=&quot;development&quot;&gt; &lt;!-- environment表示配置Mybatis的一个具体的环境 --&gt; &lt;environment id=&quot;development&quot;&gt; &lt;!-- Mybatis的内置的事务管理器 --&gt; &lt;transactionManager type=&quot;JDBC&quot;/&gt; &lt;!-- 配置数据源 --&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;!-- 建立数据库连接的具体信息 --&gt; &lt;property name=&quot;driver&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mybatis-example&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;root&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;!-- Mapper注册：指定Mybatis映射文件的具体位置 --&gt; &lt;!-- mapper标签：配置一个具体的Mapper映射文件 --&gt; &lt;!-- resource属性：指定Mapper映射文件的实际存储位置，这里需要使用一个以类路径根目录为基准的相对路径 --&gt; &lt;!-- 对Maven工程的目录结构来说，resources目录下的内容会直接放入类路径，所以这里我们可以以resources目录为基准 --&gt; &lt;mapper resource=&quot;mappers/UserMapper.xml&quot;/&gt; &lt;/mappers&gt;&lt;/configuration&gt; 效果测试 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081package com.atguigu.test;import com.atguigu.mapper.UserMapper;import com.atguigu.pojo.User;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import org.junit.jupiter.api.AfterEach;import org.junit.jupiter.api.BeforeEach;import org.junit.jupiter.api.Test;import java.io.IOException;import java.util.List;/** * projectName: com.atguigu.test */public class MyBatisTest &#123; private SqlSession session; // junit会在每一个@Test方法前执行@BeforeEach方法 @BeforeEach public void init() throws IOException &#123; session = new SqlSessionFactoryBuilder() .build( Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;)) .openSession(); &#125; @Test public void createTest() &#123; User user = new User(); user.setUsername(&quot;admin&quot;); user.setPassword(&quot;123456&quot;); UserMapper userMapper = session.getMapper(UserMapper.class); userMapper.insert(user); System.out.println(user); &#125; @Test public void updateTest() &#123; UserMapper userMapper = session.getMapper(UserMapper.class); User user = userMapper.selectById(1); user.setUsername(&quot;root&quot;); user.setPassword(&quot;111111&quot;); userMapper.update(user); user = userMapper.selectById(1); System.out.println(user); &#125; @Test public void deleteTest() &#123; UserMapper userMapper = session.getMapper(UserMapper.class); userMapper.delete(1); User user = userMapper.selectById(1); System.out.println(&quot;user = &quot; + user); &#125; @Test public void selectByIdTest() &#123; UserMapper userMapper = session.getMapper(UserMapper.class); User user = userMapper.selectById(1); System.out.println(&quot;user = &quot; + user); &#125; @Test public void selectAllTest() &#123; UserMapper userMapper = session.getMapper(UserMapper.class); List&lt;User&gt; userList = userMapper.selectAll(); System.out.println(&quot;userList = &quot; + userList); &#125; // junit会在每一个@Test方法后执行@@AfterEach方法 @AfterEach public void clear() &#123; session.commit(); session.close(); &#125;&#125; 2.5 mapperXML标签总结MyBatis 的真正强大在于它的语句映射，这是它的魔力所在。由于它的异常强大，映射器的 XML 文件就显得相对简单。如果拿它跟具有相同功能的 JDBC 代码进行对比，你会立即发现省掉了将近 95% 的代码。MyBatis 致力于减少使用成本，让用户能更专注于 SQL 代码。 SQL 映射文件只有很少的几个顶级元素（按照应被定义的顺序列出）： insert – 映射插入语句。 update – 映射更新语句。 delete – 映射删除语句。 select – 映射查询语句。 select标签： MyBatis 在查询和结果映射做了相当多的改进。一个简单查询的 select 元素是非常简单： 12&lt;select id=&quot;selectPerson&quot; resultType=&quot;hashmap&quot; resultMap=&quot;自定义结构&quot;&gt; SELECT * FROM PERSON WHERE ID = #&#123;id&#125; &lt;/select&gt; 这个语句名为 selectPerson，接受一个 int（或 Integer）类型的参数，并返回一个 HashMap 类型的对象，其中的键是列名，值便是结果行中的对应值。 注意参数符号：#{id} ${key} MyBatis 创建一个预处理语句（PreparedStatement）参数，在 JDBC 中，这样的一个参数在 SQL 中会由一个“?”来标识，并被传递到一个新的预处理语句中，就像这样： 1234// 近似的 JDBC 代码，非 MyBatis 代码...String selectPerson = &quot;SELECT * FROM PERSON WHERE ID=?&quot;;PreparedStatement ps = conn.prepareStatement(selectPerson);ps.setInt(1,id); select 元素允许你配置很多属性来配置每条语句的行为细节： 属性 描述 id 在命名空间中唯一的标识符，可以被用来引用这条语句。 resultType 期望从这条语句中返回结果的类全限定名或别名。 注意，如果返回的是集合，那应该设置为集合包含的类型，而不是集合本身的类型。 resultType 和 resultMap 之间只能同时使用一个。 resultMap 对外部 resultMap 的命名引用。结果映射是 MyBatis 最强大的特性，如果你对其理解透彻，许多复杂的映射问题都能迎刃而解。 resultType 和 resultMap 之间只能同时使用一个。 timeout 这个设置是在抛出异常之前，驱动程序等待数据库返回请求结果的秒数。默认值为未设置（unset）（依赖数据库驱动）。 statementType 可选 STATEMENT，PREPARED 或 CALLABLE。这会让 MyBatis 分别使用 Statement，PreparedStatement 或 CallableStatement，默认值：PREPARED。 insert, update 和 delete标签： 数据变更语句 insert，update 和 delete 的实现非常接近： 1234567891011121314151617&lt;insert id=&quot;insertAuthor&quot; statementType=&quot;PREPARED&quot; keyProperty=&quot;&quot; keyColumn=&quot;&quot; useGeneratedKeys=&quot;&quot; timeout=&quot;20&quot;&gt;&lt;update id=&quot;updateAuthor&quot; statementType=&quot;PREPARED&quot; timeout=&quot;20&quot;&gt;&lt;delete id=&quot;deleteAuthor&quot; statementType=&quot;PREPARED&quot; timeout=&quot;20&quot;&gt; 属性 描述 id 在命名空间中唯一的标识符，可以被用来引用这条语句。 timeout 这个设置是在抛出异常之前，驱动程序等待数据库返回请求结果的秒数。默认值为未设置（unset）（依赖数据库驱动）。 statementType 可选 STATEMENT，PREPARED 或 CALLABLE。这会让 MyBatis 分别使用 Statement，PreparedStatement 或 CallableStatement，默认值：PREPARED。 useGeneratedKeys （仅适用于 insert 和 update）这会令 MyBatis 使用 JDBC 的 getGeneratedKeys 方法来取出由数据库内部生成的主键（比如：像 MySQL 和 SQL Server 这样的关系型数据库管理系统的自动递增字段），默认值：false。 keyProperty （仅适用于 insert 和 update）指定能够唯一识别对象的属性，MyBatis 会使用 getGeneratedKeys 的返回值或 insert 语句的 selectKey 子元素设置它的值，默认值：未设置（unset）。如果生成列不止一个，可以用逗号分隔多个属性名称。 keyColumn （仅适用于 insert 和 update）设置生成键值在表中的列名，在某些数据库（像 PostgreSQL）中，当主键列不是表中的第一列的时候，是必须设置的。如果生成列不止一个，可以用逗号分隔多个属性名称。 三、MyBatis多表映射3.1 多表映射概念 多表查询结果映射思路 上面课程中，我全面讲解了单表的mybatis操作！但是开发中更多的是多表查询需求，这种情况我们如何让进行处理？ MyBatis 思想是：数据库不可能永远是你所想或所需的那个样子。 我们希望每个数据库都具备良好的第三范式或 BCNF 范式，可惜它们并不都是那样。 如果能有一种数据库映射模式，完美适配所有的应用程序查询需求，那就太好了，而 ResultMap 就是 MyBatis 就是完美答案。&#x20; 官方例子：我们如何映射下面这个语句？&#x20; 12345678910111213141516171819202122232425262728293031323334&lt;!-- 非常复杂的语句 --&gt;&lt;select id=&quot;selectBlogDetails&quot; resultMap=&quot;detailedBlogResultMap&quot;&gt; select B.id as blog_id, B.title as blog_title, B.author_id as blog_author_id, A.id as author_id, A.username as author_username, A.password as author_password, A.email as author_email, A.bio as author_bio, A.favourite_section as author_favourite_section, P.id as post_id, P.blog_id as post_blog_id, P.author_id as post_author_id, P.created_on as post_created_on, P.section as post_section, P.subject as post_subject, P.draft as draft, P.body as post_body, C.id as comment_id, C.post_id as comment_post_id, C.name as comment_name, C.comment as comment_text, T.id as tag_id, T.name as tag_name from Blog B left outer join Author A on B.author_id = A.id left outer join Post P on B.id = P.blog_id left outer join Comment C on P.id = C.post_id left outer join Post_Tag PT on PT.post_id = P.id left outer join Tag T on PT.tag_id = T.id where B.id = #&#123;id&#125;&lt;/select&gt; 你可能想把它映射到一个智能的对象模型，这个对象表示了一篇博客，它由某位作者所写，有很多的博文，每篇博文有零或多条的评论和标签。 我们先来看看下面这个完整的例子，它是一个非常复杂的结果映射（假设作者，博客，博文，评论和标签都是类型别名）。 虽然它看起来令人望而生畏，但其实非常简单。&#x20; 1234567891011121314151617181920212223242526&lt;!-- 非常复杂的结果映射 --&gt;&lt;resultMap id=&quot;detailedBlogResultMap&quot; type=&quot;Blog&quot;&gt; &lt;constructor&gt; &lt;idArg column=&quot;blog_id&quot; javaType=&quot;int&quot;/&gt; &lt;/constructor&gt; &lt;result property=&quot;title&quot; column=&quot;blog_title&quot;/&gt; &lt;association property=&quot;author&quot; javaType=&quot;Author&quot;&gt; &lt;id property=&quot;id&quot; column=&quot;author_id&quot;/&gt; &lt;result property=&quot;username&quot; column=&quot;author_username&quot;/&gt; &lt;result property=&quot;password&quot; column=&quot;author_password&quot;/&gt; &lt;result property=&quot;email&quot; column=&quot;author_email&quot;/&gt; &lt;result property=&quot;bio&quot; column=&quot;author_bio&quot;/&gt; &lt;result property=&quot;favouriteSection&quot; column=&quot;author_favourite_section&quot;/&gt; &lt;/association&gt; &lt;collection property=&quot;posts&quot; ofType=&quot;Post&quot;&gt; &lt;id property=&quot;id&quot; column=&quot;post_id&quot;/&gt; &lt;result property=&quot;subject&quot; column=&quot;post_subject&quot;/&gt; &lt;association property=&quot;author&quot; javaType=&quot;Author&quot;/&gt; &lt;collection property=&quot;comments&quot; ofType=&quot;Comment&quot;&gt; &lt;id property=&quot;id&quot; column=&quot;comment_id&quot;/&gt; &lt;/collection&gt; &lt;collection property=&quot;tags&quot; ofType=&quot;Tag&quot; &gt; &lt;id property=&quot;id&quot; column=&quot;tag_id&quot;/&gt; &lt;/collection&gt; &lt;/collection&gt;&lt;/resultMap&gt; 你现在可能看不懂，接下来我们要学习将多表查询结果使用ResultMap标签映射到实体类对象上！ 我们的学习目标： 多表查询语句使用 多表结果承接实体类设计 使用ResultMap完成多表结果映射 实体类设计方案 多表关系回顾：（双向查看） 一对一 夫妻关系，人和身份证号 一对多| 多对一 用户和用户的订单，锁和钥匙 多对多 老师和学生，部门和员工实体类设计关系(查询)：（单向查看） 对一 ： 夫妻一方对应另一方，订单对应用户都是对一关系 实体类设计：对一关系下，类中只要包含单个对方对象类型属性即可！ 例如： 123456789101112131415public class Customer &#123; private Integer customerId; private String customerName;&#125;public class Order &#123; private Integer orderId; private String orderName; private Customer customer;// 体现的是对一的关系&#125; 对多: 用户对应的订单，讲师对应的学生或者学生对应的讲师都是对多关系： 实体类设计：对多关系下，类中只要包含对方类型集合属性即可！ 12345678910111213141516public class Customer &#123; private Integer customerId; private String customerName; private List&lt;Order&gt; orderList;// 体现的是对多的关系&#125;public class Order &#123; private Integer orderId; private String orderName; private Customer customer;// 体现的是对一的关系 &#125;//查询客户和客户对应的订单集合 不要管! 多表结果实体类设计小技巧： 对一，属性中包含对方对象 对多，属性中包含对方对象集合 只有真实发生多表查询时，才需要设计和修改实体类，否则不提前设计和修改实体类！ 无论多少张表联查，实体类设计都是两两考虑! 在查询映射的时候，只需要关注本次查询相关的属性！例如：查询订单和对应的客户，就不要关注客户中的订单集合！ 多表映射案例准备 数据库： 123456789CREATE TABLE `t_customer` (`customer_id` INT NOT NULL AUTO_INCREMENT, `customer_name` CHAR(100), PRIMARY KEY (`customer_id`) );CREATE TABLE `t_order` ( `order_id` INT NOT NULL AUTO_INCREMENT, `order_name` CHAR(100), `customer_id` INT, PRIMARY KEY (`order_id`) ); INSERT INTO `t_customer` (`customer_name`) VALUES (&#x27;c01&#x27;);INSERT INTO `t_order` (`order_name`, `customer_id`) VALUES (&#x27;o1&#x27;, &#x27;1&#x27;);INSERT INTO `t_order` (`order_name`, `customer_id`) VALUES (&#x27;o2&#x27;, &#x27;1&#x27;);INSERT INTO `t_order` (`order_name`, `customer_id`) VALUES (&#x27;o3&#x27;, &#x27;1&#x27;); 实际开发时，一般在开发过程中，不给数据库表设置外键约束。原因是避免调试不方便。一般是功能开发完成，再加外键约束检查是否有bug。 实体类设计： 稍后会进行订单关联客户查询，也会进行客户关联订单查询，所以在这先练习设计 1234567891011121314151617@Datapublic class Customer &#123; private Integer customerId; private String customerName; private List&lt;Order&gt; orderList;// 体现的是对多的关系 &#125; @Datapublic class Order &#123; private Integer orderId; private String orderName; private Customer customer;// 体现的是对一的关系 &#125; 3.2 对一映射 需求说明 根据ID查询订单，以及订单关联的用户的信息！ OrderMapper接口 123public interface OrderMapper &#123; Order selectOrderWithCustomer(Integer orderId);&#125; OrderMapper.xml配置文件 123456789101112131415161718192021222324252627282930313233&lt;!-- 创建resultMap实现“对一”关联关系映射 --&gt;&lt;!-- id属性：通常设置为这个resultMap所服务的那条SQL语句的id加上“ResultMap” --&gt;&lt;!-- type属性：要设置为这个resultMap所服务的那条SQL语句最终要返回的类型 --&gt;&lt;resultMap id=&quot;selectOrderWithCustomerResultMap&quot; type=&quot;order&quot;&gt; &lt;!-- 先设置Order自身属性和字段的对应关系 --&gt; &lt;id column=&quot;order_id&quot; property=&quot;orderId&quot;/&gt; &lt;result column=&quot;order_name&quot; property=&quot;orderName&quot;/&gt; &lt;!-- 使用association标签配置“对一”关联关系 --&gt; &lt;!-- property属性：在Order类中对一的一端进行引用时使用的属性名 --&gt; &lt;!-- javaType属性：一的一端类的全类名 --&gt; &lt;association property=&quot;customer&quot; javaType=&quot;customer&quot;&gt; &lt;!-- 配置Customer类的属性和字段名之间的对应关系 --&gt; &lt;id column=&quot;customer_id&quot; property=&quot;customerId&quot;/&gt; &lt;result column=&quot;customer_name&quot; property=&quot;customerName&quot;/&gt; &lt;/association&gt;&lt;/resultMap&gt;&lt;!-- Order selectOrderWithCustomer(Integer orderId); --&gt;&lt;select id=&quot;selectOrderWithCustomer&quot; resultMap=&quot;selectOrderWithCustomerResultMap&quot;&gt; SELECT order_id,order_name,c.customer_id,customer_name FROM t_order o LEFT JOIN t_customer c ON o.customer_id=c.customer_id WHERE o.order_id=#&#123;orderId&#125;&lt;/select&gt; 对应关系可以参考下图： Mybatis全局注册Mapper文件 1234567&lt;!-- 注册Mapper配置文件：告诉Mybatis我们的Mapper配置文件的位置 --&gt;&lt;mappers&gt; &lt;!-- 在mapper标签的resource属性中指定Mapper配置文件以“类路径根目录”为基准的相对路径 --&gt; &lt;mapper resource=&quot;mappers/OrderMapper.xml&quot;/&gt;&lt;/mappers&gt; junit测试程序 12345678910111213141516171819202122232425262728293031@Slf4jpublic class MyBatisTest &#123; private SqlSession session; // junit会在每一个@Test方法前执行@BeforeEach方法 @BeforeEach public void init() throws IOException &#123; session = new SqlSessionFactoryBuilder() .build( Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;)) .openSession(); &#125; @Test public void testRelationshipToOne() &#123; OrderMapper orderMapper = session.getMapper(OrderMapper.class); // 查询Order对象，检查是否同时查询了关联的Customer对象 Order order = orderMapper.selectOrderWithCustomer(2); log.info(&quot;order = &quot; + order); &#125; // junit会在每一个@Test方法后执行@@AfterEach方法 @AfterEach public void clear() &#123; session.commit(); session.close(); &#125;&#125; 关键词 在“对一”关联关系中，我们的配置比较多，但是关键词就只有：association和javaType 3.3 对多映射 需求说明 查询客户和客户关联的订单信息！ CustomerMapper接口 12345public interface CustomerMapper &#123; Customer selectCustomerWithOrderList(Integer customerId);&#125; CustomerMapper.xml文件 1234567891011121314151617181920212223242526272829303132&lt;!-- 配置resultMap实现从Customer到OrderList的“对多”关联关系 --&gt;&lt;resultMap id=&quot;selectCustomerWithOrderListResultMap&quot; type=&quot;customer&quot;&gt; &lt;!-- 映射Customer本身的属性 --&gt; &lt;id column=&quot;customer_id&quot; property=&quot;customerId&quot;/&gt; &lt;result column=&quot;customer_name&quot; property=&quot;customerName&quot;/&gt; &lt;!-- collection标签：映射“对多”的关联关系 --&gt; &lt;!-- property属性：在Customer类中，关联“多”的一端的属性名 --&gt; &lt;!-- ofType属性：集合属性中元素的类型 --&gt; &lt;collection property=&quot;orderList&quot; ofType=&quot;order&quot;&gt; &lt;!-- 映射Order的属性 --&gt; &lt;id column=&quot;order_id&quot; property=&quot;orderId&quot;/&gt; &lt;result column=&quot;order_name&quot; property=&quot;orderName&quot;/&gt; &lt;/collection&gt;&lt;/resultMap&gt;&lt;!-- Customer selectCustomerWithOrderList(Integer customerId); --&gt;&lt;select id=&quot;selectCustomerWithOrderList&quot; resultMap=&quot;selectCustomerWithOrderListResultMap&quot;&gt; SELECT c.customer_id,c.customer_name,o.order_id,o.order_name FROM t_customer c LEFT JOIN t_order o ON c.customer_id=o.customer_id WHERE c.customer_id=#&#123;customerId&#125;&lt;/select&gt; 对应关系可以参考下图： Mybatis全局注册Mapper文件 123456&lt;!-- 注册Mapper配置文件：告诉Mybatis我们的Mapper配置文件的位置 --&gt;&lt;mappers&gt; &lt;!-- 在mapper标签的resource属性中指定Mapper配置文件以“类路径根目录”为基准的相对路径 --&gt; &lt;mapper resource=&quot;mappers/OrderMapper.xml&quot;/&gt; &lt;mapper resource=&quot;mappers/CustomerMapper.xml&quot;/&gt;&lt;/mappers&gt; junit测试程序 12345678910111213@Testpublic void testRelationshipToMulti() &#123; CustomerMapper customerMapper = session.getMapper(CustomerMapper.class); // 查询Customer对象同时将关联的Order集合查询出来 Customer customer = customerMapper.selectCustomerWithOrderList(1); log.info(&quot;customer.getCustomerId() = &quot; + customer.getCustomerId()); log.info(&quot;customer.getCustomerName() = &quot; + customer.getCustomerName()); List&lt;Order&gt; orderList = customer.getOrderList(); for (Order order : orderList) &#123; log.info(&quot;order = &quot; + order); &#125;&#125; 关键词 在“对多”关联关系中，同样有很多配置，但是提炼出来最关键的就是：“collection”和“ofType” 3.4 多表映射总结3.4.1 多表映射优化 setting属性 属性含义 可选值 默认值 autoMappingBehavior 指定 MyBatis 应如何自动映射列到字段或属性。 NONE 表示关闭自动映射；PARTIAL 只会自动映射没有定义嵌套结果映射的字段。 FULL 会自动映射任何复杂的结果集（无论是否嵌套）。 NONE, PARTIAL, FULL PARTIAL 我们可以将autoMappingBehavior设置为full,进行多表resultMap映射的时候，可以省略符合列和属性命名映射规则（列名&#x3D;属性名，或者开启驼峰映射也可以自定映射）的result标签！ 修改mybati-sconfig.xml: 12&lt;!--开启resultMap自动映射 --&gt;&lt;setting name=&quot;autoMappingBehavior&quot; value=&quot;FULL&quot;/&gt; 修改teacherMapper.xml 123456789&lt;resultMap id=&quot;teacherMap&quot; type=&quot;teacher&quot;&gt; &lt;id property=&quot;tId&quot; column=&quot;t_id&quot; /&gt; &lt;!-- 开启自动映射,并且开启驼峰式支持!可以省略 result!--&gt;&lt;!-- &lt;result property=&quot;tName&quot; column=&quot;t_name&quot; /&gt;--&gt; &lt;collection property=&quot;students&quot; ofType=&quot;student&quot; &gt; &lt;id property=&quot;sId&quot; column=&quot;s_id&quot; /&gt;&lt;!-- &lt;result property=&quot;sName&quot; column=&quot;s_name&quot; /&gt;--&gt; &lt;/collection&gt;&lt;/resultMap&gt; 3.4.2 多表映射总结 关联关系 配置项关键词 所在配置文件和具体位置 对一 association标签&#x2F;javaType属性&#x2F;property属性 Mapper配置文件中的resultMap标签内 对多 collection标签&#x2F;ofType属性&#x2F;property属性 Mapper配置文件中的resultMap标签内 四、MyBatis动态语句4.1 动态语句需求和简介经常遇到很多按照很多查询条件进行查询的情况，比如智联招聘的职位搜索等。其中经常出现很多条件不取值的情况，在后台应该如何完成最终的SQL语句呢？ 动态 SQL 是 MyBatis 的强大特性之一。如果你使用过 JDBC 或其它类似的框架，你应该能理解根据不同条件拼接 SQL 语句有多痛苦，例如拼接时要确保不能忘记添加必要的空格，还要注意去掉列表最后一个列名的逗号。利用动态 SQL，可以彻底摆脱这种痛苦。 使用动态 SQL 并非一件易事，但借助可用于任何 SQL 映射语句中的强大的动态 SQL 语言，MyBatis 显著地提升了这一特性的易用性。 如果你之前用过 JSTL 或任何基于类 XML 语言的文本处理器，你对动态 SQL 元素可能会感觉似曾相识。在 MyBatis 之前的版本中，需要花时间了解大量的元素。借助功能强大的基于 OGNL 的表达式，MyBatis 3 替换了之前的大部分元素，大大精简了元素种类，现在要学习的元素种类比原来的一半还要少。 4.2 if和where标签使用动态 SQL 最常见情景是根据条件包含 where &#x2F; if 子句的一部分。比如： 123456789101112131415161718192021&lt;!-- List&lt;Employee&gt; selectEmployeeByCondition(Employee employee); --&gt;&lt;select id=&quot;selectEmployeeByCondition&quot; resultType=&quot;employee&quot;&gt; select emp_id,emp_name,emp_salary from t_emp &lt;!-- where标签会自动去掉“标签体内前面多余的and/or” --&gt; &lt;where&gt; &lt;!-- 使用if标签，让我们可以有选择的加入SQL语句的片段。这个SQL语句片段是否要加入整个SQL语句，就看if标签判断的结果是否为true --&gt; &lt;!-- 在if标签的test属性中，可以访问实体类的属性，不可以访问数据库表的字段 --&gt; &lt;if test=&quot;empName != null&quot;&gt; &lt;!-- 在if标签内部，需要访问接口的参数时还是正常写#&#123;&#125; --&gt; or emp_name=#&#123;empName&#125; &lt;/if&gt; &lt;if test=&quot;empSalary &amp;gt; 2000&quot;&gt; or emp_salary&gt;#&#123;empSalary&#125; &lt;/if&gt; &lt;!-- 第一种情况：所有条件都满足 WHERE emp_name=? or emp_salary&gt;? 第二种情况：部分条件满足 WHERE emp_salary&gt;? 第三种情况：所有条件都不满足 没有where子句 --&gt; &lt;/where&gt;&lt;/select&gt; 4.3 set标签123456789101112131415161718192021&lt;!-- void updateEmployeeDynamic(Employee employee) --&gt;&lt;update id=&quot;updateEmployeeDynamic&quot;&gt; update t_emp &lt;!-- set emp_name=#&#123;empName&#125;,emp_salary=#&#123;empSalary&#125; --&gt; &lt;!-- 使用set标签动态管理set子句，并且动态去掉两端多余的逗号 --&gt; &lt;set&gt; &lt;if test=&quot;empName != null&quot;&gt; emp_name=#&#123;empName&#125;, &lt;/if&gt; &lt;if test=&quot;empSalary &amp;lt; 3000&quot;&gt; emp_salary=#&#123;empSalary&#125;, &lt;/if&gt; &lt;/set&gt; where emp_id=#&#123;empId&#125; &lt;!-- 第一种情况：所有条件都满足 SET emp_name=?, emp_salary=? 第二种情况：部分条件满足 SET emp_salary=? 第三种情况：所有条件都不满足 update t_emp where emp_id=? 没有set子句的update语句会导致SQL语法错误 --&gt;&lt;/update&gt; 4.4 trim标签(了解)使用trim标签控制条件部分两端是否包含某些字符 prefix属性：指定要动态添加的前缀 suffix属性：指定要动态添加的后缀 prefixOverrides属性：指定要动态去掉的前缀，使用“|”分隔有可能的多个值 suffixOverrides属性：指定要动态去掉的后缀，使用“|”分隔有可能的多个值 12345678910111213141516171819202122232425&lt;!-- List&lt;Employee&gt; selectEmployeeByConditionByTrim(Employee employee) --&gt;&lt;select id=&quot;selectEmployeeByConditionByTrim&quot; resultType=&quot;com.atguigu.mybatis.entity.Employee&quot;&gt; select emp_id,emp_name,emp_age,emp_salary,emp_gender from t_emp &lt;!-- prefix属性指定要动态添加的前缀 --&gt; &lt;!-- suffix属性指定要动态添加的后缀 --&gt; &lt;!-- prefixOverrides属性指定要动态去掉的前缀，使用“|”分隔有可能的多个值 --&gt; &lt;!-- suffixOverrides属性指定要动态去掉的后缀，使用“|”分隔有可能的多个值 --&gt; &lt;!-- 当前例子用where标签实现更简洁，但是trim标签更灵活，可以用在任何有需要的地方 --&gt; &lt;trim prefix=&quot;where&quot; suffixOverrides=&quot;and|or&quot;&gt; &lt;if test=&quot;empName != null&quot;&gt; emp_name=#&#123;empName&#125; and &lt;/if&gt; &lt;if test=&quot;empSalary &amp;gt; 3000&quot;&gt; emp_salary&gt;#&#123;empSalary&#125; and &lt;/if&gt; &lt;if test=&quot;empAge &amp;lt;= 20&quot;&gt; emp_age=#&#123;empAge&#125; or &lt;/if&gt; &lt;if test=&quot;empGender==&#x27;male&#x27;&quot;&gt; emp_gender=#&#123;empGender&#125; &lt;/if&gt; &lt;/trim&gt;&lt;/select&gt; 4.5 choose&#x2F;when&#x2F;otherwise标签在多个分支条件中，仅执行一个。 从上到下依次执行条件判断 遇到的第一个满足条件的分支会被采纳 被采纳分支后面的分支都将不被考虑 如果所有的when分支都不满足，那么就执行otherwise分支 12345678910111213141516&lt;!-- List&lt;Employee&gt; selectEmployeeByConditionByChoose(Employee employee) --&gt;&lt;select id=&quot;selectEmployeeByConditionByChoose&quot; resultType=&quot;com.atguigu.mybatis.entity.Employee&quot;&gt; select emp_id,emp_name,emp_salary from t_emp where &lt;choose&gt; &lt;when test=&quot;empName != null&quot;&gt;emp_name=#&#123;empName&#125;&lt;/when&gt; &lt;when test=&quot;empSalary &amp;lt; 3000&quot;&gt;emp_salary &amp;lt; 3000&lt;/when&gt; &lt;otherwise&gt;1=1&lt;/otherwise&gt; &lt;/choose&gt; &lt;!-- 第一种情况：第一个when满足条件 where emp_name=? 第二种情况：第二个when满足条件 where emp_salary &lt; 3000 第三种情况：两个when都不满足 where 1=1 执行了otherwise --&gt;&lt;/select&gt; 4.6 foreach标签基本用法 用批量插入举例 1234567891011121314&lt;!-- collection属性：要遍历的集合 item属性：遍历集合的过程中能得到每一个具体对象，在item属性中设置一个名字，将来通过这个名字引用遍历出来的对象 separator属性：指定当foreach标签的标签体重复拼接字符串时，各个标签体字符串之间的分隔符 open属性：指定整个循环把字符串拼好后，字符串整体的前面要添加的字符串 close属性：指定整个循环把字符串拼好后，字符串整体的后面要添加的字符串 index属性：这里起一个名字，便于后面引用 遍历List集合，这里能够得到List集合的索引值 遍历Map集合，这里能够得到Map集合的key --&gt;&lt;foreach collection=&quot;empList&quot; item=&quot;emp&quot; separator=&quot;,&quot; open=&quot;values&quot; index=&quot;myIndex&quot;&gt; &lt;!-- 在foreach标签内部如果需要引用遍历得到的具体的一个对象，需要使用item属性声明的名称 --&gt; (#&#123;emp.empName&#125;,#&#123;myIndex&#125;,#&#123;emp.empSalary&#125;,#&#123;emp.empGender&#125;)&lt;/foreach&gt; 批量更新时需要注意 上面批量插入的例子本质上是一条SQL语句，而实现批量更新则需要多条SQL语句拼起来，用分号分开。也就是一次性发送多条SQL语句让数据库执行。此时需要在数据库连接信息的URL地址中设置： 1atguigu.dev.url=jdbc:mysql:///mybatis-example?allowMultiQueries=true 对应的foreach标签如下： 123456&lt;!-- int updateEmployeeBatch(@Param(&quot;empList&quot;) List&lt;Employee&gt; empList) --&gt;&lt;update id=&quot;updateEmployeeBatch&quot;&gt; &lt;foreach collection=&quot;empList&quot; item=&quot;emp&quot; separator=&quot;;&quot;&gt; update t_emp set emp_name=#&#123;emp.empName&#125; where emp_id=#&#123;emp.empId&#125; &lt;/foreach&gt;&lt;/update&gt; 关于foreach标签的collection属性 如果没有给接口中List类型的参数使用@Param注解指定一个具体的名字，那么在collection属性中默认可以使用collection或list来引用这个list集合。这一点可以通过异常信息看出来： 1Parameter &#x27;empList&#x27; not found. Available parameters are [arg0, collection, list] 在实际开发中，为了避免隐晦的表达造成一定的误会，建议使用@Param注解明确声明变量的名称，然后在foreach标签的collection属性中按照@Param注解指定的名称来引用传入的参数。 4.7 sql片段抽取重复的SQL片段 1234&lt;!-- 使用sql标签抽取重复出现的SQL片段 --&gt;&lt;sql id=&quot;mySelectSql&quot;&gt; select emp_id,emp_name,emp_age,emp_salary,emp_gender from t_emp&lt;/sql&gt; 引用已抽取的SQL片段 12&lt;!-- 使用include标签引用声明的SQL片段 --&gt;&lt;include refid=&quot;mySelectSql&quot;/&gt; 五、MyBatis高级扩展5.1 Mapper批量映射优化 需求 Mapper 配置文件很多时，在全局配置文件中一个一个注册太麻烦，希望有一个办法能够一劳永逸。 配置方式 Mybatis 允许在指定 Mapper 映射文件时，只指定其所在的包： 123&lt;mappers&gt; &lt;package name=&quot;com.atguigu.mapper&quot;/&gt;&lt;/mappers&gt; 此时这个包下的所有 Mapper 配置文件将被自动加载、注册，比较方便。 资源创建要求 Mapper 接口和 Mapper 配置文件名称一致 Mapper 接口：EmployeeMapper.java Mapper 配置文件：EmployeeMapper.xml Mapper 配置文件放在 Mapper 接口所在的包内 可以将mapperxml文件放在mapper接口所在的包！ 可以在sources下创建mapper接口包一致的文件夹结构存放mapperxml文件 5.2 插件和分页插件PageHelper5.2.1 插件机制和PageHelper插件介绍MyBatis 对插件进行了标准化的设计，并提供了一套可扩展的插件机制。插件可以在用于语句执行过程中进行拦截，并允许通过自定义处理程序来拦截和修改 SQL 语句、映射语句的结果等。 具体来说，MyBatis 的插件机制包括以下三个组件： Interceptor（拦截器）：定义一个拦截方法 intercept，该方法在执行 SQL 语句、执行查询、查询结果的映射时会被调用。 Invocation（调用）：实际上是对被拦截的方法的封装，封装了 Object target、Method method 和 Object[] args 这三个字段。 InterceptorChain（拦截器链）：对所有的拦截器进行管理，包括将所有的 Interceptor 链接成一条链，并在执行 SQL 语句时按顺序调用。 插件的开发非常简单，只需要实现 Interceptor 接口，并使用注解 @Intercepts 来标注需要拦截的对象和方法，然后在 MyBatis 的配置文件中添加插件即可。 PageHelper 是 MyBatis 中比较著名的分页插件，它提供了多种分页方式（例如 MySQL 和 Oracle 分页方式），支持多种数据库，并且使用非常简单。下面就介绍一下 PageHelper 的使用方式。 https://github.com/pagehelper/Mybatis-PageHelper/blob/master/wikis/zh/HowToUse.md#如何配置数据库方言 5.2.2 PageHelper插件使用 pom.xml引入依赖 123456&lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper&lt;/artifactId&gt; &lt;version&gt;5.1.11&lt;/version&gt;&lt;/dependency&gt; mybatis-config.xml配置分页插件 在 MyBatis 的配置文件中添加 PageHelper 的插件： 123456&lt;plugins&gt; &lt;plugin interceptor=&quot;com.github.pagehelper.PageInterceptor&quot;&gt; &lt;property name=&quot;helperDialect&quot; value=&quot;mysql&quot;/&gt; &lt;/plugin&gt;&lt;/plugins&gt; 其中，com.github.pagehelper.PageInterceptor 是 PageHelper 插件的名称，dialect 属性用于指定数据库类型（支持多种数据库） 页插件使用 在查询方法中使用分页： 12345678910111213141516171819202122232425@Testpublic void testTeacherRelationshipToMulti() &#123; TeacherMapper teacherMapper = session.getMapper(TeacherMapper.class); PageHelper.startPage(1,2); // 查询Customer对象同时将关联的Order集合查询出来 List&lt;Teacher&gt; allTeachers = teacherMapper.findAllTeachers();// PageInfo&lt;Teacher&gt; pageInfo = new PageInfo&lt;&gt;(allTeachers); System.out.println(&quot;pageInfo = &quot; + pageInfo); long total = pageInfo.getTotal(); // 获取总记录数 System.out.println(&quot;total = &quot; + total); int pages = pageInfo.getPages(); // 获取总页数 System.out.println(&quot;pages = &quot; + pages); int pageNum = pageInfo.getPageNum(); // 获取当前页码 System.out.println(&quot;pageNum = &quot; + pageNum); int pageSize = pageInfo.getPageSize(); // 获取每页显示记录数 System.out.println(&quot;pageSize = &quot; + pageSize); List&lt;Teacher&gt; teachers = pageInfo.getList(); //获取查询页的数据集合 System.out.println(&quot;teachers = &quot; + teachers); teachers.forEach(System.out::println);&#125; 5.3 逆向工程和MybatisX插件5.3.1 ORM思维介绍ORM（Object-Relational Mapping，对象-关系映射）是一种将数据库和面向对象编程语言中的对象之间进行转换的技术。它将对象和关系数据库的概念进行映射，最后我们就可以通过方法调用进行数据库操作!! 最终: 让我们可以使用面向对象思维进行数据库操作！！！ ORM 框架通常有半自动和全自动两种方式。 半自动 ORM 通常需要程序员手动编写 SQL 语句或者配置文件，将实体类和数据表进行映射，还需要手动将查询的结果集转换成实体对象。 全自动 ORM 则是将实体类和数据表进行自动映射，使用 API 进行数据库操作时，ORM 框架会自动执行 SQL 语句并将查询结果转换成实体对象，程序员无需再手动编写 SQL 语句和转换代码。 下面是半自动和全自动 ORM 框架的区别： 映射方式：半自动 ORM 框架需要程序员手动指定实体类和数据表之间的映射关系，通常使用 XML 文件或注解方式来指定；全自动 ORM 框架则可以自动进行实体类和数据表的映射，无需手动干预。 查询方式：半自动 ORM 框架通常需要程序员手动编写 SQL 语句并将查询结果集转换成实体对象；全自动 ORM 框架可以自动组装 SQL 语句、执行查询操作，并将查询结果转换成实体对象。 性能：由于半自动 ORM 框架需要手动编写 SQL 语句，因此程序员必须对 SQL 语句和数据库的底层知识有一定的了解，才能编写高效的 SQL 语句；而全自动 ORM 框架通过自动优化生成的 SQL 语句来提高性能，程序员无需进行优化。 学习成本：半自动 ORM 框架需要程序员手动编写 SQL 语句和映射配置，要求程序员具备较高的数据库和 SQL 知识；全自动 ORM 框架可以自动生成 SQL 语句和映射配置，程序员无需了解过多的数据库和 SQL 知识。 常见的半自动 ORM 框架包括 MyBatis 等；常见的全自动 ORM 框架包括 Hibernate、Spring Data JPA、MyBatis-Plus 等。 5.3.2 逆向工程&#x20; MyBatis 的逆向工程是一种自动化生成持久层代码和映射文件的工具，它可以根据数据库表结构和设置的参数生成对应的实体类、Mapper.xml 文件、Mapper 接口等代码文件，简化了开发者手动生成的过程。逆向工程使开发者可以快速地构建起 DAO 层，并快速上手进行业务开发。&#x20; MyBatis 的逆向工程有两种方式：通过 MyBatis Generator 插件实现和通过 Maven 插件实现。无论是哪种方式，逆向工程一般需要指定一些配置参数，例如数据库连接 URL、用户名、密码、要生成的表名、生成的文件路径等等。&#x20; 总的来说，MyBatis 的逆向工程为程序员提供了一种方便快捷的方式，能够快速地生成持久层代码和映射文件，是半自动 ORM 思维像全自动发展的过程，提高程序员的开发效率。 注意：逆向工程只能生成单表crud的操作，多表查询依然需要我们自己编写！ 5.3.3 逆向工程插件MyBatisX使用&#x20; MyBatisX 是一个 MyBatis 的代码生成插件，可以通过简单的配置和操作快速生成 MyBatis Mapper、pojo 类和 Mapper.xml 文件。下面是使用 MyBatisX 插件实现逆向工程的步骤： 安装插件： 在 IntelliJ IDEA 中打开插件市场，搜索 MyBatisX 并安装。 使用 IntelliJ IDEA连接数据库 连接数据库 填写信息 展示库表 逆向工程使用 查看生成结果 逆向工程案例使用 正常使用即可，自动生成单表的crud方法！ 1234567891011121314151617181920212223242526package com.atguigu.mapper;import com.atguigu.pojo.User;/*** @author Jackiechan* @description 针对表【user】的数据库操作Mapper* @createDate 2023-06-02 16:55:32* @Entity com.atguigu.pojo.User*/public interface UserMapper &#123; int deleteByPrimaryKey(Long id); int insert(User record); int insertSelective(User record); User selectByPrimaryKey(Long id); int updateByPrimaryKeySelective(User record); int updateByPrimaryKey(User record);&#125; 六、MyBatis总结 核心点 掌握目标 mybatis基础 使用流程, 参数输入,#{} ${},参数输出 mybatis多表 实体类设计,resultMap多表结果映射 mybatis动态语句 Mybatis动态语句概念, where , if , foreach标签 mybatis扩展 Mapper批量处理,分页插件,逆向工程","categories":[{"name":"SSM框架","slug":"SSM框架","permalink":"http://example.com/categories/SSM%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"ssm","slug":"ssm","permalink":"http://example.com/tags/ssm/"}]},{"title":"二、SpringFramework实战指南","slug":"SSM/二、SpringFramework实战指南/二、SpringFramework实战指南","date":"2022-09-27T23:55:54.000Z","updated":"2023-09-28T00:25:50.767Z","comments":true,"path":"2022/09/28/SSM/二、SpringFramework实战指南/二、SpringFramework实战指南/","link":"","permalink":"http://example.com/2022/09/28/SSM/%E4%BA%8C%E3%80%81SpringFramework%E5%AE%9E%E6%88%98%E6%8C%87%E5%8D%97/%E4%BA%8C%E3%80%81SpringFramework%E5%AE%9E%E6%88%98%E6%8C%87%E5%8D%97/","excerpt":"","text":"二、SpringFramework实战指南目录 一、技术体系结构 1.1 总体技术体系 1.2 框架概念和理解 二、SpringFramework介绍 2.1 Spring 和 SpringFramework概念 2.2 SpringFramework主要功能模块 2.3 SpringFramework 主要优势 三、Spring IoC容器和核心概念 3.1 组件和组件管理概念 3.2 Spring IoC容器和容器实现 3.3 Spring IoC &#x2F; DI概念总结 四、Spring IoC实践和应用 4.1 Spring IoC &#x2F; DI 实现步骤 4.2 基于XML配置方式组件管理 4.2.1 实验一： 组件（Bean）信息声明配置（IoC） 4.2.2 实验二： 组件（Bean）依赖注入配置（DI） 4.2.3 实验三： IoC容器创建和使用 4.2.4 实验四： 高级特性：组件（Bean）作用域和周期方法配置 4.2.5 实验五： 高级特性：FactoryBean特性和使用 4.2.6 实验六： 基于XML方式整合三层架构组件 4.3 基于 注解 方式管理 Bean 4.3.1 实验一： Bean注解标记和扫描 (IoC) 4.3.2 实验二： 组件（Bean）作用域和周期方法注解 4.3.3 实验三： Bean属性赋值：引用类型自动装配 (DI) 4.3.4 实验四： Bean属性赋值：基本类型属性赋值 (DI) 4.3.5 实验五： 基于注解+XML方式整合三层架构组件 4.4 基于 配置类 方式管理 Bean 4.4.1 完全注解开发理解 4.4.2 实验一：配置类和扫描注解 4.4.3 实验二：@Bean定义组件 4.4.4 实验三：高级特性：@Bean注解细节 4.4.5 实验四：高级特性：@Import扩展 4.4.6 实验五：基于注解+配置类方式整合三层架构组件 4.5 三种配置方式总结 4.5.1 XML方式配置总结 4.5.2 XML+注解方式配置总结 4.5.3 完全注解方式配置总结 4.6 整合Spring5-Test5搭建测试环境 五、Spring AOP面向切面编程 5.1 场景设定和问题复现 5.2 解决技术代理模式 5.3 面向切面编程思维（AOP） 5.4 Spring AOP框架介绍和关系梳理 5.5 Spring AOP基于注解方式实现和细节 5.5.1 Spring AOP底层技术组成 5.5.2 初步实现 5.5.3 获取通知细节信息 5.5.4 切点表达式语法 5.5.5 重用（提取）切点表达式 5.5.6 环绕通知 5.5.7 切面优先级设置 5.5.8 CGLib动态代理生效 5.5.9 注解实现小结 5.6 Spring AOP基于XML方式实现(了解) 5.7 Spring AOP对获取Bean的影响理解 5.7.1 根据类型装配 bean 5.7.2 使用总结 六、Spring 声明式事务 6.1 声明式事务概念 6.1.1 编程式事务 6.1.2 声明式事务 6.1.3 Spring事务管理器 6.2 基于注解的声明式事务 6.2.1 准备工作 6.2.2 基本事务控制 6.2.3 事务属性：只读 6.2.4 事务属性：超时时间 6.2.5 事务属性：事务异常 6.2.6 事务属性：事务隔离级别 6.2.7 事务属性：事务传播行为 七、Spring核心掌握总结 一、技术体系结构1.1 总体技术体系 单一架构 一个项目，一个工程，导出为一个war包，在一个Tomcat上运行。也叫all in one。 单一架构，项目主要应用技术框架为：Spring , SpringMVC , Mybatis 分布式架构 一个项目（对应 IDEA 中的一个 project），拆分成很多个模块，每个模块是一个 IDEA 中的一个 module。每一个工程都是运行在自己的 Tomcat 上。模块之间可以互相调用。每一个模块内部可以看成是一个单一架构的应用。 分布式架构，项目主要应用技术框架：SpringBoot (SSM), SpringCloud , 中间件等 1.2 框架概念和理解框架( Framework )是一个集成了基本结构、规范、设计模式、编程语言和程序库等基础组件的软件系统，它可以用来构建更高级别的应用程序。框架的设计和实现旨在解决特定领域中的常见问题，帮助开发人员更高效、更稳定地实现软件开发目标。 框架的优点包括以下几点： 提高开发效率：框架提供了许多预先设计好了的组件和工具，能够帮助开发人员快速进行开发。相较于传统手写代码，在框架提供的规范化环境中，开发者可以更快地实现项目的各种要求。 降低开发成本：框架的提供标准化的编程语言、数据操作等代码片段，避免了重复开发的问题，降低了开发成本，提供深度优化的系统，降低了维护成本，增强了系统的可靠性。 提高应用程序的稳定性：框架通常经过了很长时间的开发和测试，其中的许多组件、代码片段和设计模式都得到了验证。重复利用这些组件有助于减少bug的出现，从而提高了应用程序的稳定性。 提供标准化的解决方案：框架通常是针对某个特定领域的，通过提供标准化的解决方案，可以为开发人员提供一种共同的语言和思想基础，有助于更好地沟通和协作。 框架的缺点包括以下几个方面： 学习成本高：框架通常具有特定的语言和编程范式。对于开发人员而言，需要花费时间学习其背后的架构、模式和逻辑，这对于新手而言可能会耗费较长时间。 可能存在局限性：虽然框架提高了开发效率并可以帮助开发人员解决常见问题，但是在某些情况下，特定的应用需求可能超出框架的范围，从而导致应用程序无法满足要求。开发人员可能需要更多的控制权和自由度，同时需要在框架和应用程序之间进行权衡取舍。 版本变更和兼容性问题：框架的版本发布和迭代通常会导致代码库的大规模变更，进而导致应用程序出现兼容性问题和漏洞。当框架变更时，需要考虑框架是否向下兼容，以及如何进行适当的测试、迁移和升级。 架构风险：框架涉及到很多抽象和概念，如果开发者没有足够的理解和掌握其架构，可能会导致系统出现设计和架构缺陷，从而影响系统的健康性和安全性。 站在文件结构的角度理解框架，可以将框架总结：框架 &#x3D; jar包+配置文件 莎士比亚说,”一千个观众眼中有一千个哈姆雷特” 即仁者见仁,智者见智.说每个人都会对作品有不同的理解，每个人对待任何事物都有自己的看法，同样的技术解决同样的问题会产生不同流程和风格的解决方案，而采用一种框架其实就是限制用户必须使用其规定的方案来实现，可以降低程序员之间沟通以及日后维护的成本！ 常用的单一架构JavaEE项目框架演进，从SSH、SSH2过渡到了SSM：SpringMVC、Spring、MyBatis。 总之，框架已经对基础的代码进行了封装并提供相应的API，开发者在使用框架是直接调用封装好的API可以省去很多代码编写，从而提高工作效率和开发速度。 二、SpringFramework介绍2.1 Spring 和 SpringFramework概念https://spring.io/projects 广义的 Spring：Spring 技术栈（全家桶） 广义上的 Spring 泛指以 Spring Framework 为基础的 Spring 技术栈。 经过十多年的发展，Spring 已经不再是一个单纯的应用框架，而是逐渐发展成为一个由多个不同子项目（模块）组成的成熟技术，例如 Spring Framework、Spring MVC、SpringBoot、Spring Cloud、Spring Data、Spring Security 等，其中 Spring Framework 是其他子项目的基础。 这些子项目涵盖了从企业级应用开发到云计算等各方面的内容，能够帮助开发人员解决软件发展过程中不断产生的各种实际问题，给开发人员带来了更好的开发体验。 狭义的 Spring：Spring Framework（基础框架） 狭义的 Spring 特指 Spring Framework，通常我们将它称为 Spring 框架。 Spring Framework（Spring框架）是一个开源的应用程序框架，由SpringSource公司开发，最初是为了解决企业级开发中各种常见问题而创建的。它提供了很多功能，例如：依赖注入（Dependency Injection）、面向切面编程（AOP）、声明式事务管理（TX）等。其主要目标是使企业级应用程序的开发变得更加简单和快速，并且Spring框架被广泛应用于Java企业开发领域。 Spring全家桶的其他框架都是以SpringFramework框架为基础！ 对比理解： QQ 和 腾讯 腾讯 &#x3D; Spring QQ &#x3D; SpringFramework 2.2 SpringFramework主要功能模块SpringFramework框架结构图： 功能模块 功能介绍 Core Container 核心容器，在 Spring 环境下使用任何功能都必须基于 IOC 容器。 AOP&amp;Aspects 面向切面编程 TX 声明式事务管理。 Spring MVC 提供了面向Web应用程序的集成功能。 2.3 SpringFramework 主要优势 丰富的生态系统：Spring 生态系统非常丰富，支持许多模块和库，如 Spring Boot、Spring Security、Spring Cloud 等等，可以帮助开发人员快速构建高可靠性的企业应用程序。 模块化的设计：框架组件之间的松散耦合和模块化设计使得 Spring Framework 具有良好的可重用性、可扩展性和可维护性。开发人员可以轻松地选择自己需要的模块，根据自己的需求进行开发。 简化 Java 开发：Spring Framework 简化了 Java 开发，提供了各种工具和 API，可以降低开发复杂度和学习成本。同时，Spring Framework 支持各种应用场景，包括 Web 应用程序、RESTful API、消息传递、批处理等等。 不断创新和发展：Spring Framework 开发团队一直在不断创新和发展，保持与最新技术的接轨，为开发人员提供更加先进和优秀的工具和框架。 因此，这些优点使得 Spring Framework 成为了一个稳定、可靠、且创新的框架，为企业级 Java 开发提供了一站式的解决方案。 Spring 使创建 Java 企业应用程序变得容易。它提供了在企业环境中采用 Java 语言所需的一切，支持 Groovy 和 Kotlin 作为 JVM 上的替代语言，并且可以根据应用程序的需求灵活地创建多种架构。从Spring Framework 6.0.6开始，Spring 需要 Java 17+。 三、Spring IoC容器和核心概念3.1 组件和组件管理概念 3.1.1 什么是组件? 回顾常规的三层架构处理请求流程： 整个项目就是由各种组件搭建而成的： 3.1.2 我们的期待 有人替我们创建组件的对象 有人帮我们保存组件的对象 有人帮助我们自动组装 有人替我们管理事务 有人协助我们整合其他框架 …… 3.1.3 Spring充当组件管理角色（IoC） 那么谁帮我们完成我们的期待，帮我们管理组件呢？ 当然是Spring 框架了！ 组件可以完全交给Spring 框架进行管理，Spring框架替代了程序员原有的new对象和对象属性赋值动作等！ Spring具体的组件管理动作包含： 组件对象实例化 组件属性属性赋值 组件对象之间引用 组件对象存活周期管理 ……我们只需要编写元数据（配置文件）告知Spring 管理哪些类组件和他们的关系即可！注意：组件是映射到应用程序中所有可重用组件的Java对象，应该是可复用的功能对象！ 组件一定是对象 对象不一定是组件综上所述，Spring 充当一个组件容器，创建、管理、存储组件，减少了我们的编码压力，让我们更加专注进行业务编写！ 3.1.4 组件交给Spring管理优势! 降低了组件之间的耦合性：Spring IoC容器通过依赖注入机制，将组件之间的依赖关系削弱，减少了程序组件之间的耦合性，使得组件更加松散地耦合。 提高了代码的可重用性和可维护性：将组件的实例化过程、依赖关系的管理等功能交给Spring IoC容器处理，使得组件代码更加模块化、可重用、更易于维护。 方便了配置和管理：Spring IoC容器通过XML文件或者注解，轻松的对组件进行配置和管理，使得组件的切换、替换等操作更加的方便和快捷。 交给Spring管理的对象（组件），方可享受Spring框架的其他功能（AOP,声明事务管理）等 3.2 Spring IoC容器和容器实现 3.2.1 普通和复杂容器 普通容器 生活中的普通容器 普通容器只能用来存储，没有更多功能。程序中的普通容器 数组 集合：List 集合：Set复杂容器生活中的复杂容器 政府管理我们的一生，生老病死都和政府有关。程序中的复杂容器Servlet 容器能够管理 Servlet(init,service,destroy)、Filter、Listener 这样的组件的一生，所以它是一个复杂容器。 名称 时机 次数 创建对象 默认情况：接收到第一次请求 &#xA;修改启动顺序后：Web应用启动过程中 一次 初始化操作 创建对象之后 一次 处理请求 接收到请求 多次 销毁操作 Web应用卸载之前 一次 我们即将要学习的 SpringIoC 容器也是一个复杂容器。它们不仅要负责创建组件的对象、存储组件的对象，还要负责调用组件的方法让它们工作，最终在特定情况下销毁组件。 总结：Spring管理组件的容器，就是一个复杂容器，不仅存储组件，也可以管理组件之间依赖关系，并且创建和销毁组件等！ 3.2.2 SpringIoC容器介绍 Spring IoC 容器，负责实例化、配置和组装 bean（组件）。容器通过读取配置元数据来获取有关要实例化、配置和组装组件的指令。配置元数据以 XML、Java 注解或 Java 代码形式表现。它允许表达组成应用程序的组件以及这些组件之间丰富的相互依赖关系。 上图显示了 Spring 容器工作原理的高级视图。应用程序类与配置元数据相结合，您拥有完全配置且可执行的系统或应用程序。 3.2.3 SpringIoC容器具体接口和实现类 SpringIoc容器接口：&#x20; BeanFactory 接口提供了一种高级配置机制，能够管理任何类型的对象，它是SpringIoC容器标准化超接口！ ApplicationContext 是 BeanFactory 的子接口。它扩展了以下功能： 更容易与 Spring 的 AOP 功能集成 消息资源处理（用于国际化） 特定于应用程序给予此接口实现，例如Web 应用程序的 WebApplicationContext简而言之， BeanFactory 提供了配置框架和基本功能，而 ApplicationContext 添加了更多特定于企业的功能。 ApplicationContext 是 BeanFactory 的完整超集！ApplicationContext容器实现类： 类型名 简介 ClassPathXmlApplicationContext 通过读取类路径下的 XML 格式的配置文件创建 IOC 容器对象 FileSystemXmlApplicationContext 通过文件系统路径读取 XML 格式的配置文件创建 IOC 容器对象 AnnotationConfigApplicationContext 通过读取Java配置类创建 IOC 容器对象 WebApplicationContext 专门为 Web 应用准备，基于 Web 环境创建 IOC 容器对象，并将对象引入存入 ServletContext 域中。 3.2.4 SpringIoC容器管理配置方式 Spring IoC 容器使用多种形式的配置元数据。此配置元数据表示您作为应用程序开发人员如何告诉 Spring 容器实例化、配置和组装应用程序中的对象。 Spring框架提供了多种配置方式：XML配置方式、注解方式和Java配置类方式 XML配置方式：是Spring框架最早的配置方式之一，通过在XML文件中定义Bean及其依赖关系、Bean的作用域等信息，让Spring IoC容器来管理Bean之间的依赖关系。该方式从Spring框架的第一版开始提供支持。 注解方式：从Spring 2.5版本开始提供支持，可以通过在Bean类上使用注解来代替XML配置文件中的配置信息。通过在Bean类上加上相应的注解（如@Component, @Service, @Autowired等），将Bean注册到Spring IoC容器中，这样Spring IoC容器就可以管理这些Bean之间的依赖关系。 Java配置类方式：从Spring 3.0版本开始提供支持，通过Java类来定义Bean、Bean之间的依赖关系和配置信息，从而代替XML配置文件的方式。Java配置类是一种使用Java编写配置信息的方式，通过@Configuration、@Bean等注解来实现Bean和依赖关系的配置。为了迎合当下开发环境，我们将以配置类+注解方式为主进行讲解！ 3.3 Spring IoC &#x2F; DI概念总结 IoC容器 Spring IoC 容器，负责实例化、配置和组装 bean（组件）核心容器。容器通过读取配置元数据来获取有关要实例化、配置和组装组件的指令。 IoC（Inversion of Control）控制反转 IoC 主要是针对对象的创建和调用控制而言的，也就是说，当应用程序需要使用一个对象时，不再是应用程序直接创建该对象，而是由 IoC 容器来创建和管理，即控制权由应用程序转移到 IoC 容器中，也就是“反转”了控制权。这种方式基本上是通过依赖查找的方式来实现的，即 IoC 容器维护着构成应用程序的对象，并负责创建这些对象。 DI (Dependency Injection) 依赖注入 DI 是指在组件之间传递依赖关系的过程中，将依赖关系在容器内部进行处理，这样就不必在应用程序代码中硬编码对象之间的依赖关系，实现了对象之间的解耦合。在 Spring 中，DI 是通过 XML 配置文件或注解的方式实现的。它提供了三种形式的依赖注入：构造函数注入、Setter 方法注入和接口注入。 四、Spring IoC实践和应用4.1 Spring IoC &#x2F; DI 实现步骤 我们总结下，组件交给Spring IoC容器管理，并且获取和使用的基本步骤！ 配置元数据（配置） 配置元数据，既是编写交给SpringIoC容器管理组件的信息，配置方式有三种。 基于 XML 的配置元数据的基本结构： &lt;bean id&#x3D;”…” [1] class&#x3D;”…” [2]&gt; &#x20;&#x20; &lt;!– collaborators and configuration for this bean go here –&gt;&#x20; &lt;&#x2F;bean&gt; 12345678910111213141516&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!-- 此处要添加一些约束，配置文件的标签并不是随意命名 --&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id=&quot;...&quot; [1] class=&quot;...&quot; [2]&gt; &lt;!-- collaborators and configuration for this bean go here --&gt; &lt;/bean&gt; &lt;bean id=&quot;...&quot; class=&quot;...&quot;&gt; &lt;!-- collaborators and configuration for this bean go here --&gt; &lt;/bean&gt; &lt;!-- more bean definitions go here --&gt;&lt;/beans&gt; Spring IoC 容器管理一个或多个组件。这些 组件是使用你提供给容器的配置元数据（例如，以 XML &lt;bean/&gt; 定义的形式）创建的。 &lt;bean &#x2F;&gt; 标签 &#x3D;&#x3D; 组件信息声明 id 属性是标识单个 Bean 定义的字符串。 class 属性定义 Bean 的类型并使用完全限定的类名。 实例化IoC容器 提供给 ApplicationContext 构造函数的位置路径是资源字符串地址，允许容器从各种外部资源（如本地文件系统、Java CLASSPATH 等）加载配置元数据。 我们应该选择一个合适的容器实现类，进行IoC容器的实例化工作： 123//实例化ioc容器,读取外部配置文件,最终会在容器内进行ioc和di动作ApplicationContext context = new ClassPathXmlApplicationContext(&quot;services.xml&quot;, &quot;daos.xml&quot;); 获取Bean（组件） ApplicationContext 是一个高级工厂的接口，能够维护不同 bean 及其依赖项的注册表。通过使用方法 T getBean(String name, Class&lt;T&gt; requiredType) ，您可以检索 bean 的实例。 允许读取 Bean 定义并访问它们，如以下示例所示： 123456//创建ioc容器对象，指定配置文件，ioc也开始实例组件对象ApplicationContext context = new ClassPathXmlApplicationContext(&quot;services.xml&quot;, &quot;daos.xml&quot;);//获取ioc容器的组件对象PetStoreService service = context.getBean(&quot;petStore&quot;, PetStoreService.class);//使用组件对象List&lt;String&gt; userList = service.getUsernameList(); 4.2 基于XML配置方式组件管理4.2.1 实验一： 组件（Bean）信息声明配置（IoC） 目标 Spring IoC 容器管理一个或多个 bean。这些 Bean 是使用您提供给容器的配置元数据创建的（例如，以 XML &lt;bean/&gt; 定义的形式）。 我们学习，如何通过定义XML配置文件，声明组件类信息，交给 Spring 的 IoC 容器进行组件管理！ 思路 准备项目 创建maven工程（spring-ioc-xml-01） 导入SpringIoC相关依赖 pom.xml 123456789101112131415&lt;dependencies&gt; &lt;!--spring context依赖--&gt; &lt;!--当你引入Spring Context依赖之后，表示将Spring的基础依赖引入了--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;6.0.6&lt;/version&gt; &lt;/dependency&gt; &lt;!--junit5测试--&gt; &lt;dependency&gt; &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt; &lt;artifactId&gt;junit-jupiter-api&lt;/artifactId&gt; &lt;version&gt;5.3.1&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 基于无参数构造函数 当通过构造函数方法创建一个 bean（组件对象） 时，所有普通类都可以由 Spring 使用并与之兼容。也就是说，正在开发的类不需要实现任何特定的接口或以特定的方式进行编码。只需指定 Bean 类信息就足够了。但是，默认情况下，我们需要一个默认（空）构造函数。 准备组件类1package com.atguigu.ioc; public class HappyComponent &#123; //默认包含无参数构造函数 public void doWork() &#123; System.out.println(&quot;HappyComponent.doWork&quot;); &#125; &#125; 1234567891011122. xml配置文件编写 创建携带spring约束的xml配置文件 ![](image/image_VcUvHx6Air.png) 编写配置文件： 文件：resources/spring-bean-01.xml ```java &lt;!-- 实验一 [重要]创建bean --&gt; &lt;bean id=&quot;happyComponent&quot; class=&quot;com.atguigu.ioc.HappyComponent&quot;/&gt; - bean标签：通过配置bean标签告诉IOC容器需要创建对象的组件信息 - id属性：bean的唯一标识,方便后期获取Bean！ - class属性：组件类的全限定符！ - 注意：要求当前组件类必须包含无参数构造函数！ 基于静态工厂方法实例化 除了使用构造函数实例化对象，还有一类是通过工厂模式实例化对象。接下来我们讲解如何定义使用静态工厂方法创建Bean的配置 ！ 准备组件类123public class ClientService &#123; private static ClientService clientService = new ClientService(); private ClientService() &#123;&#125; public static ClientService createInstance() &#123; return clientService; &#125; &#125; 12345672. xml配置文件编写 文件：resources/spring-bean-01.xml ```xml &lt;bean id=&quot;clientService&quot; class=&quot;examples.ClientService&quot; factory-method=&quot;createInstance&quot;/&gt; - class属性：指定工厂类的全限定符！ - factory-method: 指定静态工厂方法，注意，该方法必须是static方法。 基于实例工厂方法实例化 接下来我们讲解下如何定义使用实例工厂方法创建Bean的配置 ！ 准备组建类1public class DefaultServiceLocator &#123; private static ClientServiceImplclientService = new ClientServiceImpl(); public ClientService createClientServiceInstance() &#123; return clientService; &#125; &#125; 1234567891011122. xml配置文件编写 文件：resources/spring-bean-01.xml ```xml &lt;!-- 将工厂类进行ioc配置 --&gt; &lt;bean id=&quot;serviceLocator&quot; class=&quot;examples.DefaultServiceLocator&quot;&gt; &lt;/bean&gt; &lt;!-- 根据工厂对象的实例工厂方法进行实例化组件对象 --&gt; &lt;bean id=&quot;clientService&quot; factory-bean=&quot;serviceLocator&quot; factory-method=&quot;createClientServiceInstance&quot;/&gt; - factory-bean属性：指定当前容器中工厂Bean 的名称。 - factory-method: 指定实例工厂方法名。注意，实例方法必须是非static的！ 图解IoC配置流程 4.2.2 实验二： 组件（Bean）依赖注入配置（DI） 目标 通过配置文件,实现IoC容器中Bean之间的引用（依赖注入DI配置）。 主要涉及注入场景：基于构造函数的依赖注入和基于 Setter 的依赖注入。 思路 基于构造函数的依赖注入（单个构造参数） 介绍 基于构造函数的 DI 是通过容器调用具有多个参数的构造函数来完成的，每个参数表示一个依赖项。 下面的示例演示一个只能通过构造函数注入进行依赖项注入的类！ 准备组件类 12public class UserDao &#123;&#125; public class UserService { private UserDao userDao; public UserService(UserDao userDao) &#123; this.userDao = userDao; &#125; } 123456789101112133. 编写配置文件 文件：resources/spring-02.xml ```xml &lt;beans&gt; &lt;!-- 引用类bean声明 --&gt; &lt;bean id=&quot;userService&quot; class=&quot;x.y.UserService&quot;&gt; &lt;!-- 构造函数引用 --&gt; &lt;constructor-arg ref=&quot;userDao&quot;/&gt; &lt;/bean&gt; &lt;!-- 被引用类bean声明 --&gt; &lt;bean id=&quot;userDao&quot; class=&quot;x.y.UserDao&quot;/&gt; &lt;/beans&gt; constructor-arg标签：可以引用构造参数 ref引用其他bean的标识。 基于构造函数的依赖注入（多构造参数解析） 介绍 基于构造函数的 DI 是通过容器调用具有多个参数的构造函数来完成的，每个参数表示一个依赖项。 下面的示例演示通过构造函数注入多个参数，参数包含其他bean和基本数据类型！ 准备组件类 12public class UserDao &#123;&#125; public class UserService { private UserDao userDao; private int age; private String name; public UserService(int age , String name ,UserDao userDao) &#123; this.userDao = userDao; this.age = age; this.name = name; &#125; } 1234567891011121314151617181920212223242526272829303132333435363738394041423. 编写配置文件 ```xml &lt;!-- 场景1: 多参数，可以按照相应构造函数的顺序注入数据 --&gt; &lt;beans&gt; &lt;bean id=&quot;userService&quot; class=&quot;x.y.UserService&quot;&gt; &lt;!-- value直接注入基本类型值 --&gt; &lt;constructor-arg value=&quot;18&quot;/&gt; &lt;constructor-arg value=&quot;赵伟风&quot;/&gt; &lt;constructor-arg ref=&quot;userDao&quot;/&gt; &lt;/bean&gt; &lt;!-- 被引用类bean声明 --&gt; &lt;bean id=&quot;userDao&quot; class=&quot;x.y.UserDao&quot;/&gt; &lt;/beans&gt; &lt;!-- 场景2: 多参数，可以按照相应构造函数的名称注入数据 --&gt; &lt;beans&gt; &lt;bean id=&quot;userService&quot; class=&quot;x.y.UserService&quot;&gt; &lt;!-- value直接注入基本类型值 --&gt; &lt;constructor-arg name=&quot;name&quot; value=&quot;赵伟风&quot;/&gt; &lt;constructor-arg name=&quot;userDao&quot; ref=&quot;userDao&quot;/&gt; &lt;constructor-arg name=&quot;age&quot; value=&quot;18&quot;/&gt; &lt;/bean&gt; &lt;!-- 被引用类bean声明 --&gt; &lt;bean id=&quot;userDao&quot; class=&quot;x.y.UserDao&quot;/&gt; &lt;/beans&gt; &lt;!-- 场景2: 多参数，可以按照相应构造函数的角标注入数据 index从0开始 构造函数(0,1,2....) --&gt; &lt;beans&gt; &lt;bean id=&quot;userService&quot; class=&quot;x.y.UserService&quot;&gt; &lt;!-- value直接注入基本类型值 --&gt; &lt;constructor-arg index=&quot;1&quot; value=&quot;赵伟风&quot;/&gt; &lt;constructor-arg index=&quot;2&quot; ref=&quot;userDao&quot;/&gt; &lt;constructor-arg index=&quot;0&quot; value=&quot;18&quot;/&gt; &lt;/bean&gt; &lt;!-- 被引用类bean声明 --&gt; &lt;bean id=&quot;userDao&quot; class=&quot;x.y.UserDao&quot;/&gt; &lt;/beans&gt; constructor-arg标签：指定构造参数和对应的值 constructor-arg标签：name属性指定参数名、index属性指定参数角标、value属性指定普通属性值 基于Setter方法依赖注入 介绍 开发中，除了构造函数注入（DI）更多的使用的Setter方法进行注入！ 下面的示例演示一个只能使用纯 setter 注入进行依赖项注入的类。 准备组件类 1234567891011121314151617181920public Class MovieFinder&#123;&#125;public class SimpleMovieLister &#123; private MovieFinder movieFinder; private String movieName; public void setMovieFinder(MovieFinder movieFinder) &#123; this.movieFinder = movieFinder; &#125; public void setMovieName(String movieName)&#123; this.movieName = movieName; &#125; // business logic that actually uses the injected MovieFinder is omitted...&#125; 编写配置文件 1234567891011121314&lt;bean id=&quot;simpleMovieLister&quot; class=&quot;examples.SimpleMovieLister&quot;&gt; &lt;!-- setter方法，注入movieFinder对象的标识id name = 属性名 ref = 引用bean的id值 --&gt; &lt;property name=&quot;movieFinder&quot; ref=&quot;movieFinder&quot; /&gt; &lt;!-- setter方法，注入基本数据类型movieName name = 属性名 value= 基本类型值 --&gt; &lt;property name=&quot;movieName&quot; value=&quot;消失的她&quot;/&gt;&lt;/bean&gt;&lt;bean id=&quot;movieFinder&quot; class=&quot;examples.MovieFinder&quot;/&gt; property标签： 可以给setter方法对应的属性赋值 property 标签： name属性代表set方法标识、ref代表引用bean的标识id、value属性代表基本属性值 总结： 依赖注入（DI）包含引用类型和基本数据类型，同时注入的方式也有多种！主流的注入方式为setter方法注入和构造函数注入，两种注入语法都需要掌握！ 需要特别注意：引用其他bean，使用ref属性。直接注入基本类型值，使用value属性。 4.2.3 实验三： IoC容器创建和使用 介绍 上面的实验只是讲解了如何在XML格式的配置文件编写IoC和DI配置！ 如图： 想要配置文件中声明组件类信息真正的进行实例化成Bean对象和形成Bean之间的引用关系，我们需要声明IoC容器对象，读取配置文件，实例化组件和关系维护的过程都是在IoC容器中实现的！ 容器实例化 12345678910111213//方式1:实例化并且指定配置文件//参数：String...locations 传入一个或者多个配置文件ApplicationContext context = new ClassPathXmlApplicationContext(&quot;services.xml&quot;, &quot;daos.xml&quot;); //方式2:先实例化，再指定配置文件，最后刷新容器触发Bean实例化动作 [springmvc源码和contextLoadListener源码方式] ApplicationContext context = new ClassPathXmlApplicationContext(); //设置配置配置文件,方法参数为可变参数,可以设置一个或者多个配置iocContainer1.setConfigLocations(&quot;services.xml&quot;, &quot;daos.xml&quot;);//后配置的文件,需要调用refresh方法,触发刷新配置iocContainer1.refresh(); Bean对象读取 1234567891011121314151617181920//方式1: 根据id获取//没有指定类型,返回为Object,需要类型转化!HappyComponent happyComponent = (HappyComponent) iocContainer.getBean(&quot;bean的id标识&quot;); //使用组件对象 happyComponent.doWork();//方式2: 根据类型获取//根据类型获取,但是要求,同类型(当前类,或者之类,或者接口的实现类)只能有一个对象交给IoC容器管理//配置两个或者以上出现: org.springframework.beans.factory.NoUniqueBeanDefinitionException 问题HappyComponent happyComponent = iocContainer.getBean(HappyComponent.class);happyComponent.doWork();//方式3: 根据id和类型获取HappyComponent happyComponent = iocContainer.getBean(&quot;bean的id标识&quot;, HappyComponent.class);happyComponent.doWork();根据类型来获取bean时，在满足bean唯一性的前提下，其实只是看：『对象 instanceof 指定的类型』的返回结果，只要返回的是true就可以认定为和类型匹配，能够获取到。 4.2.4 实验四： 高级特性：组件（Bean）作用域和周期方法配置 组件周期方法配置 周期方法概念 我们可以在组件类中定义方法，然后当IoC容器实例化和销毁组件对象的时候进行调用！这两个方法我们成为生命周期方法！ 类似于Servlet的init&#x2F;destroy方法,我们可以在周期方法完成初始化和释放资源等工作。 周期方法声明 1234567891011121314public class BeanOne &#123; //周期方法要求： 方法命名随意，但是要求方法必须是 public void 无形参列表 public void init() &#123; // 初始化逻辑 &#125;&#125;public class BeanTwo &#123; public void cleanup() &#123; // 释放资源逻辑 &#125;&#125; 周期方法配置 1234&lt;beans&gt; &lt;bean id=&quot;beanOne&quot; class=&quot;examples.BeanOne&quot; init-method=&quot;init&quot; /&gt; &lt;bean id=&quot;beanTwo&quot; class=&quot;examples.BeanTwo&quot; destroy-method=&quot;cleanup&quot; /&gt;&lt;/beans&gt; 组件作用域配置 Bean作用域概念 &lt;bean 标签声明Bean，只是将Bean的信息配置给SpringIoC容器！ 在IoC容器中，这些&lt;bean标签对应的信息转成Spring内部 BeanDefinition 对象，BeanDefinition 对象内，包含定义的信息（id,class,属性等等）！ 这意味着，BeanDefinition与类概念一样，SpringIoC容器可以可以根据BeanDefinition对象反射创建多个Bean对象实例。 具体创建多少个Bean的实例对象，由Bean的作用域Scope属性指定！ 作用域可选值 取值 含义 创建对象的时机 默认值 singleton 在 IOC 容器中，这个 bean 的对象始终为单实例 IOC 容器初始化时 是 prototype 这个 bean 在 IOC 容器中有多个实例 获取 bean 时 否 如果是在WebApplicationContext环境下还会有另外两个作用域（但不常用）： 取值 含义 创建对象的时机 默认值 ——- ———- ——- — request 请求范围内有效的实例 每次请求 否 session 会话范围内有效的实例 每次会话 否 作用域配置 配置scope范围 123456789101112&lt;!--bean的作用域 准备两个引用关系的组件类即可！！--&gt;&lt;!-- scope属性：取值singleton（默认值），bean在IOC容器中只有一个实例，IOC容器初始化时创建对象 --&gt;&lt;!-- scope属性：取值prototype，bean在IOC容器中可以有多个实例，getBean()时创建对象 --&gt;&lt;bean id=&quot;happyMachine8&quot; scope=&quot;prototype&quot; class=&quot;com.atguigu.ioc.HappyMachine&quot;&gt; &lt;property name=&quot;machineName&quot; value=&quot;happyMachine&quot;/&gt;&lt;/bean&gt;&lt;bean id=&quot;happyComponent8&quot; scope=&quot;singleton&quot; class=&quot;com.atguigu.ioc.HappyComponent&quot;&gt; &lt;property name=&quot;componentName&quot; value=&quot;happyComponent&quot;/&gt;&lt;/bean&gt; 作用域测试 1234567891011121314@Testpublic void testExperiment08() &#123; ApplicationContext iocContainer = new ClassPathXmlApplicationContext(&quot;配置文件名&quot;); HappyMachine bean = iocContainer.getBean(HappyMachine.class); HappyMachine bean1 = iocContainer.getBean(HappyMachine.class); //多例对比 false System.out.println(bean == bean1); HappyComponent bean2 = iocContainer.getBean(HappyComponent.class); HappyComponent bean3 = iocContainer.getBean(HappyComponent.class); //单例对比 true System.out.println(bean2 == bean3);&#125; 4.2.5 实验五： 高级特性：FactoryBean特性和使用 FactoryBean简介 FactoryBean 接口是Spring IoC容器实例化逻辑的可插拔性点。 用于配置复杂的Bean对象，可以将创建过程存储在FactoryBean 的getObject方法！ FactoryBean&lt;T&gt; 接口提供三种方法： T getObject():&#x20; 返回此工厂创建的对象的实例。该返回值会被存储到IoC容器！ boolean isSingleton():&#x20; 如果此 FactoryBean 返回单例，则返回 true ，否则返回 false 。此方法的默认实现返回 true （注意，lombok插件使用，可能影响效果）。 Class&lt;?&gt; getObjectType(): 返回 getObject() 方法返回的对象类型，如果事先不知道类型，则返回 null 。 FactoryBean使用场景 代理类的创建 第三方框架整合 复杂对象实例化等 Factorybean应用 准备FactoryBean实现类1234567891011121314151617181920212223242526272829303132// 实现FactoryBean接口时需要指定泛型// 泛型类型就是当前工厂要生产的对象的类型public class HappyFactoryBean implements FactoryBean&lt;HappyMachine&gt; &#123; private String machineName; public String getMachineName() &#123; return machineName; &#125; public void setMachineName(String machineName) &#123; this.machineName = machineName; &#125; @Override public HappyMachine getObject() throws Exception &#123; // 方法内部模拟创建、设置一个对象的复杂过程 HappyMachine happyMachine = new HappyMachine(); happyMachine.setMachineName(this.machineName); return happyMachine; &#125; @Override public Class&lt;?&gt; getObjectType() &#123; // 返回要生产的对象的类型 return HappyMachine.class; &#125;&#125; 配置FactoryBean实现类123456&lt;!-- FactoryBean机制 --&gt;&lt;!-- 这个bean标签中class属性指定的是HappyFactoryBean，但是将来从这里获取的bean是HappyMachine对象 --&gt;&lt;bean id=&quot;happyMachine7&quot; class=&quot;com.atguigu.ioc.HappyFactoryBean&quot;&gt; &lt;!-- property标签仍然可以用来通过setXxx()方法给属性赋值 --&gt; &lt;property name=&quot;machineName&quot; value=&quot;iceCreamMachine&quot;/&gt;&lt;/bean&gt; 测试读取FactoryBean和FactoryBean.getObject对象12345678910111213@Testpublic void testExperiment07() &#123; ApplicationContext iocContainer = new ClassPathXmlApplicationContext(&quot;spring-bean-07.xml&quot;); //注意: 直接根据声明FactoryBean的id,获取的是getObject方法返回的对象 HappyMachine happyMachine = iocContainer.getBean(&quot;happyMachine7&quot;,HappyMachine.class); System.out.println(&quot;happyMachine = &quot; + happyMachine); //如果想要获取FactoryBean对象, 直接在id前添加&amp;符号即可! &amp;happyMachine7 这是一种固定的约束 Object bean = iocContainer.getBean(&quot;&amp;happyMachine7&quot;); System.out.println(&quot;bean = &quot; + bean);&#125; FactoryBean和BeanFactory区别 **FactoryBean **是 Spring 中一种特殊的 bean，可以在 getObject() 工厂方法自定义的逻辑创建Bean！是一种能够生产其他 Bean 的 Bean。FactoryBean 在容器启动时被创建，而在实际使用时则是通过调用 getObject() 方法来得到其所生产的 Bean。因此，FactoryBean 可以自定义任何所需的初始化逻辑，生产出一些定制化的 bean。 一般情况下，整合第三方框架，都是通过定义FactoryBean实现！！！ BeanFactory 是 Spring 框架的基础，其作为一个顶级接口定义了容器的基本行为，例如管理 bean 的生命周期、配置文件的加载和解析、bean 的装配和依赖注入等。BeanFactory 接口提供了访问 bean 的方式，例如 getBean() 方法获取指定的 bean 实例。它可以从不同的来源（例如 Mysql 数据库、XML 文件、Java 配置类等）获取 bean 定义，并将其转换为 bean 实例。同时，BeanFactory 还包含很多子类（例如，ApplicationContext 接口）提供了额外的强大功能。 总的来说，FactoryBean 和 BeanFactory 的区别主要在于前者是用于创建 bean 的接口，它提供了更加灵活的初始化定制功能，而后者是用于管理 bean 的框架基础接口，提供了基本的容器功能和 bean 生命周期管理。 4.2.6 实验六： 基于XML方式整合三层架构组件 需求分析 搭建一个三层架构案例，模拟查询全部学生（学生表）信息，持久层使用JdbcTemplate和Druid技术，使用XML方式进行组件管理！ 数据库准备 1234567891011121314151617181920212223create database studb;use studb;CREATE TABLE students ( id INT PRIMARY KEY, name VARCHAR(50) NOT NULL, gender VARCHAR(10) NOT NULL, age INT, class VARCHAR(50));INSERT INTO students (id, name, gender, age, class)VALUES (1, &#x27;张三&#x27;, &#x27;男&#x27;, 20, &#x27;高中一班&#x27;), (2, &#x27;李四&#x27;, &#x27;男&#x27;, 19, &#x27;高中二班&#x27;), (3, &#x27;王五&#x27;, &#x27;女&#x27;, 18, &#x27;高中一班&#x27;), (4, &#x27;赵六&#x27;, &#x27;女&#x27;, 20, &#x27;高中三班&#x27;), (5, &#x27;刘七&#x27;, &#x27;男&#x27;, 19, &#x27;高中二班&#x27;), (6, &#x27;陈八&#x27;, &#x27;女&#x27;, 18, &#x27;高中一班&#x27;), (7, &#x27;杨九&#x27;, &#x27;男&#x27;, 20, &#x27;高中三班&#x27;), (8, &#x27;吴十&#x27;, &#x27;男&#x27;, 19, &#x27;高中二班&#x27;); 项目准备 项目创建 spring-xml-practice-02 依赖导入 123456789101112131415161718192021222324252627282930&lt;dependencies&gt; &lt;!--spring context依赖--&gt; &lt;!--当你引入SpringContext依赖之后，表示将Spring的基础依赖引入了--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;6.0.6&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 数据库驱动和连接池--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.25&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.2.8&lt;/version&gt; &lt;/dependency&gt; &lt;!-- spring-jdbc --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;6.0.6&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 实体类准备 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960public class Student &#123; private Integer id; private String name; private String gender; private Integer age; private String classes; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getGender() &#123; return gender; &#125; public void setGender(String gender) &#123; this.gender = gender; &#125; public Integer getAge() &#123; return age; &#125; public void setAge(Integer age) &#123; this.age = age; &#125; public String getClasses() &#123; return classes; &#125; public void setClasses(String classes) &#123; this.classes = classes; &#125; @Override public String toString() &#123; return &quot;Student&#123;&quot; + &quot;id=&quot; + id + &quot;, name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, gender=&#x27;&quot; + gender + &#x27;\\&#x27;&#x27; + &quot;, age=&quot; + age + &quot;, classes=&#x27;&quot; + classes + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125;&#125; JdbcTemplate技术讲解 为了在特定领域帮助我们简化代码，Spring 封装了很多 『Template』形式的模板类。例如：RedisTemplate、RestTemplate 等等，包括我们今天要学习的 JdbcTemplate。jdbc.properties提取数据库连接信息 1234atguigu.url=jdbc:mysql://localhost:3306/studbatguigu.driver=com.mysql.cj.jdbc.Driveratguigu.username=rootatguigu.password=root springioc配置文件 123456&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;!-- 导入外部属性文件 --&gt; &lt;context:property-placeholder location=&quot;classpath:jdbc.properties&quot; /&gt; &lt;!-- 配置数据源 --&gt; &lt;bean id=&quot;druidDataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;atguigu.url&#125;&quot;/&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;$&#123;atguigu.driver&#125;&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;atguigu.username&#125;&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;atguigu.password&#125;&quot;/&gt; &lt;/bean&gt; &lt;!-- 配置 JdbcTemplate --&gt; &lt;bean id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt; &lt;!-- 装配数据源 --&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;druidDataSource&quot;/&gt; &lt;/bean&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788基于jdbcTemplate的CRUD使用```javapublic class JdbcTemplateTest &#123; /** * 使用jdbcTemplate进行DML动作 */ @Test public void testDML()&#123; ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;spring-ioc.xml&quot;); JdbcTemplate jdbcTemplate = applicationContext.getBean(JdbcTemplate.class); //TODO 执行插入一条学员数据 String sql = &quot;insert into students (id,name,gender,age,class) values (?,?,?,?,?);&quot;; /* 参数1: sql语句 参数2: 可变参数,占位符的值 */ int rows = jdbcTemplate.update(sql, 9,&quot;十一&quot;, &quot;男&quot;, 18, &quot;二年三班&quot;); System.out.println(&quot;rows = &quot; + rows); &#125; /** * 查询单条实体对象 * public class Student &#123; * private Integer id; * private String name; * private String gender; * private Integer age; * private String classes; */ @Test public void testDQLForPojo()&#123; String sql = &quot;select id , name , age , gender , class as classes from students where id = ? ;&quot;; ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;spring-ioc.xml&quot;); JdbcTemplate jdbcTemplate = applicationContext.getBean(JdbcTemplate.class); //根据id查询 Student student = jdbcTemplate.queryForObject(sql, (rs, rowNum) -&gt; &#123; //自己处理结果映射 Student stu = new Student(); stu.setId(rs.getInt(&quot;id&quot;)); stu.setName(rs.getString(&quot;name&quot;)); stu.setAge(rs.getInt(&quot;age&quot;)); stu.setGender(rs.getString(&quot;gender&quot;)); stu.setClasses(rs.getString(&quot;classes&quot;)); return stu; &#125;, 2); System.out.println(&quot;student = &quot; + student); &#125; /** * 查询实体类集合 */ @Test public void testDQLForListPojo()&#123; String sql = &quot;select id , name , age , gender , class as classes from students ;&quot;; ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;spring-ioc.xml&quot;); JdbcTemplate jdbcTemplate = applicationContext.getBean(JdbcTemplate.class); /* query可以返回集合! BeanPropertyRowMapper就是封装好RowMapper的实现,要求属性名和列名相同即可 */ List&lt;Student&gt; studentList = jdbcTemplate.query(sql, new BeanPropertyRowMapper&lt;&gt;(Student.class)); System.out.println(&quot;studentList = &quot; + studentList); &#125;&#125; 三层架构搭建和实现 持久层1234567891011121314151617181920212223242526272829303132333435363738//接口public interface StudentDao &#123; /** * 查询全部学生数据 * @return */ List&lt;Student&gt; queryAll();&#125;//实现类public class StudentDaoImpl implements StudentDao &#123; private JdbcTemplate jdbcTemplate; public void setJdbcTemplate(JdbcTemplate jdbcTemplate) &#123; this.jdbcTemplate = jdbcTemplate; &#125; /** * 查询全部学生数据 * @return */ @Override public List&lt;Student&gt; queryAll() &#123; String sql = &quot;select id , name , age , gender , class as classes from students ;&quot;; /* query可以返回集合! BeanPropertyRowMapper就是封装好RowMapper的实现,要求属性名和列名相同即可 */ List&lt;Student&gt; studentList = jdbcTemplate.query(sql, new BeanPropertyRowMapper&lt;&gt;(Student.class)); return studentList; &#125;&#125; 业务层123456789101112131415161718192021222324252627282930313233//接口public interface StudentService &#123; /** * 查询全部学员业务 * @return */ List&lt;Student&gt; findAll();&#125;//实现类public class StudentServiceImpl implements StudentService &#123; private StudentDao studentDao; public void setStudentDao(StudentDao studentDao) &#123; this.studentDao = studentDao; &#125; /** * 查询全部学员业务 * @return */ @Override public List&lt;Student&gt; findAll() &#123; List&lt;Student&gt; studentList = studentDao.queryAll(); return studentList; &#125;&#125; 表述层12345678910111213public class StudentController &#123; private StudentService studentService; public void setStudentService(StudentService studentService) &#123; this.studentService = studentService; &#125; public void findAll()&#123; List&lt;Student&gt; studentList = studentService.findAll(); System.out.println(&quot;studentList = &quot; + studentList); &#125;&#125; 三层架构IoC配置 12345&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;!-- 导入外部属性文件 --&gt; &lt;context:property-placeholder location=&quot;classpath:jdbc.properties&quot; /&gt; &lt;!-- 配置数据源 --&gt; &lt;bean id=&quot;druidDataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;atguigu.url&#125;&quot;/&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;$&#123;atguigu.driver&#125;&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;atguigu.username&#125;&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;atguigu.password&#125;&quot;/&gt; &lt;/bean&gt; &lt;!-- 配置 JdbcTemplate --&gt; &lt;bean id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt; &lt;!-- 装配数据源 --&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;druidDataSource&quot;/&gt; &lt;/bean&gt; &lt;bean id=&quot;studentDao&quot; class=&quot;com.atguigu.dao.impl.StudentDaoImpl&quot;&gt; &lt;property name=&quot;jdbcTemplate&quot; ref=&quot;jdbcTemplate&quot; /&gt; &lt;/bean&gt; &lt;bean id=&quot;studentService&quot; class=&quot;com.atguigu.service.impl.StudentServiceImpl&quot;&gt; &lt;property name=&quot;studentDao&quot; ref=&quot;studentDao&quot; /&gt; &lt;/bean&gt; &lt;bean id=&quot;studentController&quot; class=&quot;com.atguigu.controller.StudentController&quot;&gt; &lt;property name=&quot;studentService&quot; ref=&quot;studentService&quot; /&gt; &lt;/bean&gt; 1234567891011127. 运行测试 ```java public class ControllerTest &#123; @Test public void testRun()&#123; ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;spring-ioc.xml&quot;); StudentController studentController = applicationContext.getBean(StudentController.class); studentController.findAll(); &#125; &#125; XMLIoC方式问题总结 注入的属性必须添加setter方法、代码结构乱！ 配置文件和Java代码分离、编写不是很方便！ XML配置文件解析效率低 4.3 基于 注解 方式管理 Bean4.3.1 实验一： Bean注解标记和扫描 (IoC) 注解理解 和 XML 配置文件一样，注解本身并不能执行，注解本身仅仅只是做一个标记，具体的功能是框架检测到注解标记的位置，然后针对这个位置按照注解标记的功能来执行具体操作。 本质上：所有一切的操作都是 Java 代码来完成的，XML 和注解只是告诉框架中的 Java 代码如何执行。 举例：元旦联欢会要布置教室，蓝色的地方贴上元旦快乐四个字，红色的地方贴上拉花，黄色的地方贴上气球。 班长做了所有标记，同学们来完成具体工作。墙上的标记相当于我们在代码中使用的注解，后面同学们做的工作，相当于框架的具体操作。 扫描理解 Spring 为了知道程序员在哪些地方标记了什么注解，就需要通过扫描的方式，来进行检测。然后根据注解进行后续操作。 准备Spring项目和组件 准备项目pom.xml 12345678910111213141516&lt;dependencies&gt; &lt;!--spring context依赖--&gt; &lt;!--当你引入Spring Context依赖之后，表示将Spring的基础依赖引入了--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;6.0.6&lt;/version&gt; &lt;/dependency&gt; &lt;!--junit5测试--&gt; &lt;dependency&gt; &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt; &lt;artifactId&gt;junit-jupiter-api&lt;/artifactId&gt; &lt;version&gt;5.3.1&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 准备组件类 普通组件 12345678/** * projectName: com.atguigu.components * * description: 普通的组件 */public class CommonComponent &#123;&#125; Controller组件 12345678/** * projectName: com.atguigu.components * * description: controller类型组件 */public class XxxController &#123;&#125; Service组件 12345678/** * projectName: com.atguigu.components * * description: service类型组件 */public class XxxService &#123;&#125; Dao组件 12345678/** * projectName: com.atguigu.components * * description: dao类型组件 */public class XxxDao &#123;&#125; 组件添加标记注解 组件标记注解和区别 Spring 提供了以下多个注解，这些注解可以直接标注在 Java 类上，将它们定义成 Spring Bean。 注解 说明 @Component 该注解用于描述 Spring 中的 Bean，它是一个泛化的概念，仅仅表示容器中的一个组件（Bean），并且可以作用在应用的任何层次，例如 Service 层、Dao 层等。 使用时只需将该注解标注在相应类上即可。 @Repository 该注解用于将数据访问层（Dao 层）的类标识为 Spring 中的 Bean，其功能与 @Component 相同。 @Service 该注解通常作用在业务层（Service 层），用于将业务层的类标识为 Spring 中的 Bean，其功能与 @Component 相同。 @Controller 该注解通常作用在控制层（如SpringMVC 的 Controller），用于将控制层的类标识为 Spring 中的 Bean，其功能与 @Component 相同。 通过查看源码我们得知，@Controller、@Service、@Repository这三个注解只是在@Component注解的基础上起了三个新的名字。 对于Spring使用IOC容器管理这些组件来说没有区别，也就是语法层面没有区别。所以@Controller、@Service、@Repository这三个注解只是给开发人员看的，让我们能够便于分辨组件的作用。 注意：虽然它们本质上一样，但是为了代码的可读性、程序结构严谨！我们肯定不能随便胡乱标记。 使用注解标记 普通组件 123456789/** * projectName: com.atguigu.components * * description: 普通的组件 */@Componentpublic class CommonComponent &#123;&#125; Controller组件 123456789/** * projectName: com.atguigu.components * * description: controller类型组件 */@Controllerpublic class XxxController &#123;&#125; Service组件 123456789/** * projectName: com.atguigu.components * * description: service类型组件 */@Servicepublic class XxxService &#123;&#125; Dao组件 123456789/** * projectName: com.atguigu.components * * description: dao类型组件 */@Repositorypublic class XxxDao &#123;&#125; 配置文件确定扫描范围 情况1：基本扫描配置 12345678910111213&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;!-- 配置自动扫描的包 --&gt; &lt;!-- 1.包要精准,提高性能! 2.会扫描指定的包和子包内容 3.多个包可以使用,分割 例如: com.atguigu.controller,com.atguigu.service等 --&gt; &lt;context:component-scan base-package=&quot;com.atguigu.components&quot;/&gt; &lt;/beans&gt; 情况2：指定排除组件 12345678&lt;!-- 情况三：指定不扫描的组件 --&gt;&lt;context:component-scan base-package=&quot;com.atguigu.components&quot;&gt; &lt;!-- context:exclude-filter标签：指定排除规则 --&gt; &lt;!-- type属性：指定根据什么来进行排除，annotation取值表示根据注解来排除 --&gt; &lt;!-- expression属性：指定排除规则的表达式，对于注解来说指定全类名即可 --&gt; &lt;context:exclude-filter type=&quot;annotation&quot; expression=&quot;org.springframework.stereotype.Controller&quot;/&gt;&lt;/context:component-scan&gt; 情况3：指定扫描组件 12345678&lt;!-- 情况四：仅扫描指定的组件 --&gt;&lt;!-- 仅扫描 = 关闭默认规则 + 追加规则 --&gt;&lt;!-- use-default-filters属性：取值false表示关闭默认扫描规则 --&gt;&lt;context:component-scan base-package=&quot;com.atguigu.ioc.components&quot; use-default-filters=&quot;false&quot;&gt; &lt;!-- context:include-filter标签：指定在原有扫描规则的基础上追加的规则 --&gt; &lt;context:include-filter type=&quot;annotation&quot; expression=&quot;org.springframework.stereotype.Controller&quot;/&gt;&lt;/context:component-scan&gt; 组件BeanName问题 在我们使用 XML 方式管理 bean 的时候，每个 bean 都有一个唯一标识——id 属性的值，便于在其他地方引用。现在使用注解后，每个组件仍然应该有一个唯一标识。 默认情况： 类名首字母小写就是 bean 的 id。例如：SoldierController 类对应的 bean 的 id 就是 soldierController。 使用value属性指定： 123@Controller(value = &quot;tianDog&quot;)public class SoldierController &#123;&#125; 当注解中只设置一个属性时，value属性的属性名可以省略： 123@Service(&quot;smallDog&quot;)public class SoldierService &#123;&#125; 总结 注解方式IoC只是标记哪些类要被Spring管理 最终，我们还需要XML方式或者后面讲解Java配置类方式指定注解生效的包 现阶段配置方式为 注解 （标记）+ XML（扫描） 4.3.2 实验二： 组件（Bean）作用域和周期方法注解&#x20; 组件周期方法配置 周期方法概念 我们可以在组件类中定义方法，然后当IoC容器实例化和销毁组件对象的时候进行调用！这两个方法我们成为生命周期方法！ 类似于Servlet的init&#x2F;destroy方法,我们可以在周期方法完成初始化和释放资源等工作。 周期方法声明 12345678910111213141516public class BeanOne &#123; //周期方法要求： 方法命名随意，但是要求方法必须是 public void 无形参列表 @PostConstruct //注解制指定初始化方法 public void init() &#123; // 初始化逻辑 &#125;&#125;public class BeanTwo &#123; @PreDestroy //注解指定销毁方法 public void cleanup() &#123; // 释放资源逻辑 &#125;&#125; 组件作用域配置 Bean作用域概念 &lt;bean 标签声明Bean，只是将Bean的信息配置给SpringIoC容器！ 在IoC容器中，这些&lt;bean标签对应的信息转成Spring内部 BeanDefinition 对象，BeanDefinition 对象内，包含定义的信息（id,class,属性等等）！ 这意味着，BeanDefinition与类概念一样，SpringIoC容器可以可以根据BeanDefinition对象反射创建多个Bean对象实例。 具体创建多少个Bean的实例对象，由Bean的作用域Scope属性指定！ 作用域可选值 取值 含义 创建对象的时机 默认值 singleton 在 IOC 容器中，这个 bean 的对象始终为单实例 IOC 容器初始化时 是 prototype 这个 bean 在 IOC 容器中有多个实例 获取 bean 时 否 如果是在WebApplicationContext环境下还会有另外两个作用域（但不常用）： 取值 含义 创建对象的时机 默认值 ——- ———- ——- — request 请求范围内有效的实例 每次请求 否 session 会话范围内有效的实例 每次会话 否 作用域配置 12345678910@Scope(scopeName = ConfigurableBeanFactory.SCOPE_SINGLETON) //单例,默认值@Scope(scopeName = ConfigurableBeanFactory.SCOPE_PROTOTYPE) //多例 二选一public class BeanOne &#123; //周期方法要求： 方法命名随意，但是要求方法必须是 public void 无形参列表 @PostConstruct //注解制指定初始化方法 public void init() &#123; // 初始化逻辑 &#125;&#125; 4.3.3 实验三： Bean属性赋值：引用类型自动装配 (DI) 设定场景 SoldierController 需要 SoldierService SoldierService 需要 SoldierDao&#x20; 同时在各个组件中声明要调用的方法。 SoldierController中声明方法123456789101112import org.springframework.stereotype.Controller;@Controller(value = &quot;tianDog&quot;)public class SoldierController &#123; private SoldierService soldierService; public void getMessage() &#123; soldierService.getMessage(); &#125;&#125; SoldierService中声明方法123456789@Service(&quot;smallDog&quot;)public class SoldierService &#123; private SoldierDao soldierDao; public void getMessage() &#123; soldierDao.getMessage(); &#125;&#125; SoldierDao中声明方法12345678@Repositorypublic class SoldierDao &#123; public void getMessage() &#123; System.out.print(&quot;I am a soldier&quot;); &#125;&#125; 自动装配实现 前提 参与自动装配的组件（需要装配、被装配）全部都必须在IoC容器中。 注意：不区分IoC的方式！XML和注解都可以！ @Autowired注解 在成员变量上直接标记@Autowired注解即可，不需要提供setXxx()方法。以后我们在项目中的正式用法就是这样。 给Controller装配Service 1234567891011@Controller(value = &quot;tianDog&quot;)public class SoldierController &#123; @Autowired private SoldierService soldierService; public void getMessage() &#123; soldierService.getMessage(); &#125; &#125; 给Service装配Dao 12345678910@Service(&quot;smallDog&quot;)public class SoldierService &#123; @Autowired private SoldierDao soldierDao; public void getMessage() &#123; soldierDao.getMessage(); &#125;&#125; @Autowired注解细节 标记位置 成员变量 这是最主要的使用方式！ 与xml进行bean ref引用不同，他不需要有set方法！ 12345678910@Service(&quot;smallDog&quot;)public class SoldierService &#123; @Autowired private SoldierDao soldierDao; public void getMessage() &#123; soldierDao.getMessage(); &#125;&#125; 构造器 12345678910@Controller(value = &quot;tianDog&quot;)public class SoldierController &#123; private SoldierService soldierService; @Autowired public SoldierController(SoldierService soldierService) &#123; this.soldierService = soldierService; &#125; …… setXxx()方法 12345678910@Controller(value = &quot;tianDog&quot;)public class SoldierController &#123; private SoldierService soldierService; @Autowired public void setSoldierService(SoldierService soldierService) &#123; this.soldierService = soldierService; &#125; …… 工作流程 首先根据所需要的组件类型到 IOC 容器中查找 能够找到唯一的 bean：直接执行装配 如果完全找不到匹配这个类型的 bean：装配失败 和所需类型匹配的 bean 不止一个 没有 @Qualifier 注解：根据 @Autowired 标记位置成员变量的变量名作为 bean 的 id 进行匹配 能够找到：执行装配 找不到：装配失败 使用 @Qualifier 注解：根据 @Qualifier 注解中指定的名称作为 bean 的id进行匹配 能够找到：执行装配 找不到：装配失败 1234567@Controller(value = &quot;tianDog&quot;)public class SoldierController &#123; @Autowired @Qualifier(value = &quot;maomiService222&quot;) // 根据面向接口编程思想，使用接口类型引入Service组件 private ISoldierService soldierService; 佛系装配 给 @Autowired 注解设置 required &#x3D; false 属性表示：能装就装，装不上就不装。但是实际开发时，基本上所有需要装配组件的地方都是必须装配的，用不上这个属性 123456@Controller(value = &quot;tianDog&quot;)public class SoldierController &#123; // 给@Autowired注解设置required = false属性表示：能装就装，装不上就不装 @Autowired(required = false) private ISoldierService soldierService; 扩展JSR-250注解@Resource 理解JSR系列注解 JSR（Java Specification Requests）是Java平台标准化进程中的一种技术规范，而JSR注解是其中一部分重要的内容。按照JSR的分类以及注解语义的不同，可以将JSR注解分为不同的系列，主要有以下几个系列： JSR-175: 这个JSR是Java SE 5引入的，是Java注解最早的规范化版本，Java SE 5后的版本中都包含该JSR中定义的注解。主要包括以下几种标准注解： @Deprecated: 标识一个程序元素（如类、方法或字段）已过时，并且在将来的版本中可能会被删除。 @Override: 标识一个方法重写了父类中的方法。 @SuppressWarnings: 抑制编译时产生的警告消息。 @SafeVarargs: 标识一个有安全性警告的可变参数方法。 @FunctionalInterface: 标识一个接口只有一个抽象方法，可以作为lambda表达式的目标。 JSR-250: 这个JSR主要用于在Java EE 5中定义一些支持注解。该JSR主要定义了一些用于进行对象管理的注解，包括： @Resource: 标识一个需要注入的资源，是实现Java EE组件之间依赖关系的一种方式。 @PostConstruct: 标识一个方法作为初始化方法。 @PreDestroy: 标识一个方法作为销毁方法。 @Resource.AuthenticationType: 标识注入的资源的身份验证类型。 @Resource.AuthenticationType: 标识注入的资源的默认名称。 JSR-269: 这个JSR主要是Java SE 6中引入的一种支持编译时元数据处理的框架，即使用注解来处理Java源文件。该JSR定义了一些可以用注解标记的注解处理器，用于生成一些元数据，常用的注解有： @SupportedAnnotationTypes: 标识注解处理器所处理的注解类型。 @SupportedSourceVersion: 标识注解处理器支持的Java源码版本。 JSR-330: 该JSR主要为Java应用程序定义了一个依赖注入的标准，即Java依赖注入标准（javax.inject）。在此规范中定义了多种注解，包括： @Named: 标识一个被依赖注入的组件的名称。 @Inject: 标识一个需要被注入的依赖组件。 @Singleton: 标识一个组件的生命周期只有一个唯一的实例。 JSR-250: 这个JSR主要是Java EE 5中定义一些支持注解。该JSR包含了一些支持注解，可以用于对Java EE组件进行管理，包括： @RolesAllowed: 标识授权角色 @PermitAll: 标识一个活动无需进行身份验证。 @DenyAll: 标识不提供针对该方法的访问控制。 @DeclareRoles: 声明安全角色。但是你要理解JSR是Java提供的技术规范，也就是说，他只是规定了注解和注解的含义，JSR并不是直接提供特定的实现，而是提供标准和指导方针，由第三方框架（Spring）和库来实现和提供对应的功能。 JSR-250 @Resource注解 @Resource注解也可以完成属性注入。那它和@Autowired注解有什么区别？ @Resource注解是JDK扩展包中的，也就是说属于JDK的一部分。所以该注解是标准注解，更加具有通用性。(JSR-250标准中制定的注解类型。JSR是Java规范提案。) @Autowired注解是Spring框架自己的。 @Resource注解默认根据Bean名称装配，未指定name时，使用属性名作为name。通过name找不到的话会自动启动通过类型装配。 @Autowired注解默认根据类型装配，如果想根据名称装配，需要配合@Qualifier注解一起用。 @Resource注解用在属性上、setter方法上。 @Autowired注解用在属性上、setter方法上、构造方法上、构造方法参数上。@Resource注解属于JDK扩展包，所以不在JDK当中，需要额外引入以下依赖：【高于JDK11或低于JDK8需要引入以下依赖】12345&lt;dependency&gt; &lt;groupId&gt;jakarta.annotation&lt;/groupId&gt; &lt;artifactId&gt;jakarta.annotation-api&lt;/artifactId&gt; &lt;version&gt;2.1.1&lt;/version&gt;&lt;/dependency&gt; @Resource使用 123456789101112131415161718@Controllerpublic class XxxController &#123; /** * 1. 如果没有指定name,先根据属性名查找IoC中组件xxxService * 2. 如果没有指定name,并且属性名没有对应的组件,会根据属性类型查找 * 3. 可以指定name名称查找! @Resource(name=&#x27;test&#x27;) == @Autowired + @Qualifier(value=&#x27;test&#x27;) */ @Resource private XxxService xxxService; //@Resource(name = &quot;指定beanName&quot;) //private XxxService xxxService; public void show()&#123; System.out.println(&quot;XxxController.show&quot;); xxxService.show(); &#125;&#125; 4.3.4 实验四： Bean属性赋值：基本类型属性赋值 (DI)@Value 通常用于注入外部化属性 声明外部配置 application.properties 1catalog.name=MovieCatalog xml引入外部配置 12&lt;!-- 引入外部配置文件--&gt;&lt;context:property-placeholder location=&quot;application.properties&quot; /&gt; @Value注解读取配置 1234567891011121314151617181920212223242526272829package com.atguigu.components;import org.springframework.beans.factory.annotation.Value;import org.springframework.stereotype.Component;/** * projectName: com.atguigu.components * * description: 普通的组件 */@Componentpublic class CommonComponent &#123; /** * 情况1: $&#123;key&#125; 取外部配置key对应的值! * 情况2: $&#123;key:defaultValue&#125; 没有key,可以给与默认值 */ @Value(&quot;$&#123;catalog:hahaha&#125;&quot;) private String name; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125;&#125; catalog 4.3.5 实验五： 基于注解+XML方式整合三层架构组件 需求分析 搭建一个三层架构案例，模拟查询全部学生（学生表）信息，持久层使用JdbcTemplate和Druid技术，使用XML+注解方式进行组件管理！ 数据库准备 1234567891011121314151617181920212223create database studb;use studb;CREATE TABLE students ( id INT PRIMARY KEY, name VARCHAR(50) NOT NULL, gender VARCHAR(10) NOT NULL, age INT, class VARCHAR(50));INSERT INTO students (id, name, gender, age, class)VALUES (1, &#x27;张三&#x27;, &#x27;男&#x27;, 20, &#x27;高中一班&#x27;), (2, &#x27;李四&#x27;, &#x27;男&#x27;, 19, &#x27;高中二班&#x27;), (3, &#x27;王五&#x27;, &#x27;女&#x27;, 18, &#x27;高中一班&#x27;), (4, &#x27;赵六&#x27;, &#x27;女&#x27;, 20, &#x27;高中三班&#x27;), (5, &#x27;刘七&#x27;, &#x27;男&#x27;, 19, &#x27;高中二班&#x27;), (6, &#x27;陈八&#x27;, &#x27;女&#x27;, 18, &#x27;高中一班&#x27;), (7, &#x27;杨九&#x27;, &#x27;男&#x27;, 20, &#x27;高中三班&#x27;), (8, &#x27;吴十&#x27;, &#x27;男&#x27;, 19, &#x27;高中二班&#x27;); 项目准备 项目创建 spring-annotation-practice-04 依赖导入 123456789101112131415161718192021222324252627282930313233343536&lt;dependencies&gt; &lt;!--spring context依赖--&gt; &lt;!--当你引入SpringContext依赖之后，表示将Spring的基础依赖引入了--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;6.0.6&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 数据库驱动和连接池--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.25&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.2.8&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;jakarta.annotation&lt;/groupId&gt; &lt;artifactId&gt;jakarta.annotation-api&lt;/artifactId&gt; &lt;version&gt;2.1.1&lt;/version&gt; &lt;/dependency&gt; &lt;!-- spring-jdbc --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;6.0.6&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 实体类准备 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960public class Student &#123; private Integer id; private String name; private String gender; private Integer age; private String classes; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getGender() &#123; return gender; &#125; public void setGender(String gender) &#123; this.gender = gender; &#125; public Integer getAge() &#123; return age; &#125; public void setAge(Integer age) &#123; this.age = age; &#125; public String getClasses() &#123; return classes; &#125; public void setClasses(String classes) &#123; this.classes = classes; &#125; @Override public String toString() &#123; return &quot;Student&#123;&quot; + &quot;id=&quot; + id + &quot;, name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, gender=&#x27;&quot; + gender + &#x27;\\&#x27;&#x27; + &quot;, age=&quot; + age + &quot;, classes=&#x27;&quot; + classes + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125;&#125; 三层架构搭建和实现 持久层123456789101112131415161718192021222324252627282930313233343536//接口public interface StudentDao &#123; /** * 查询全部学生数据 * @return */ List&lt;Student&gt; queryAll();&#125;//实现类@Repositorypublic class StudentDaoImpl implements StudentDao &#123; @Autowired private JdbcTemplate jdbcTemplate; /** * 查询全部学生数据 * @return */ @Override public List&lt;Student&gt; queryAll() &#123; String sql = &quot;select id , name , age , gender , class as classes from students ;&quot;; /* query可以返回集合! BeanPropertyRowMapper就是封装好RowMapper的实现,要求属性名和列名相同即可 */ List&lt;Student&gt; studentList = jdbcTemplate.query(sql, new BeanPropertyRowMapper&lt;&gt;(Student.class)); return studentList; &#125;&#125; 业务层12345678910111213141516171819202122232425262728293031//接口public interface StudentService &#123; /** * 查询全部学员业务 * @return */ List&lt;Student&gt; findAll();&#125;//实现类@Servicepublic class StudentServiceImpl implements StudentService &#123; @Autowired private StudentDao studentDao; /** * 查询全部学员业务 * @return */ @Override public List&lt;Student&gt; findAll() &#123; List&lt;Student&gt; studentList = studentDao.queryAll(); return studentList; &#125;&#125; 表述层123456789101112@Controllerpublic class StudentController &#123; @Autowired private StudentService studentService; public void findAll()&#123; List&lt;Student&gt; studentList = studentService.findAll(); System.out.println(&quot;studentList = &quot; + studentList); &#125;&#125; 三层架构IoC配置 12345&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;!-- 导入外部属性文件 --&gt; &lt;context:property-placeholder location=&quot;classpath:jdbc.properties&quot; /&gt; &lt;!-- 配置数据源 --&gt; &lt;bean id=&quot;druidDataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;atguigu.url&#125;&quot;/&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;$&#123;atguigu.driver&#125;&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;atguigu.username&#125;&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;atguigu.password&#125;&quot;/&gt; &lt;/bean&gt; &lt;bean class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;druidDataSource&quot; /&gt; &lt;/bean&gt; &lt;!-- 扫描Ioc/DI注解 --&gt; &lt;context:component-scan base-package=&quot;com.atguigu.dao,com.atguigu.service,com.atguigu.controller&quot; /&gt; 1234567891011126. 运行测试 ```java public class ControllerTest &#123; @Test public void testRun()&#123; ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;spring-ioc.xml&quot;); StudentController studentController = applicationContext.getBean(StudentController.class); studentController.findAll(); &#125; &#125; 注解+XML IoC方式问题总结 自定义类可以使用注解方式，但是第三方依赖的类依然使用XML方式！ XML格式解析效率低！ 4.4 基于 配置类 方式管理 Bean4.4.1 完全注解开发理解Spring 完全注解配置（Fully Annotation-based Configuration）是指通过 Java配置类 代码来配置 Spring 应用程序，使用注解来替代原本在 XML 配置文件中的配置。相对于 XML 配置，完全注解配置具有更强的类型安全性和更好的可读性。 两种方式思维转化： 4.4.2 实验一：配置类和扫描注解xml+注解方式 配置文件application.xml 1234567891011121314151617&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;!-- 配置自动扫描的包 --&gt; &lt;!-- 1.包要精准,提高性能! 2.会扫描指定的包和子包内容 3.多个包可以使用,分割 例如: com.atguigu.controller,com.atguigu.service等 --&gt; &lt;context:component-scan base-package=&quot;com.atguigu.components&quot;/&gt; &lt;!-- 引入外部配置文件--&gt; &lt;context:property-placeholder location=&quot;application.properties&quot; /&gt;&lt;/beans&gt; 测试创建IoC容器 123// xml方式配置文件使用ClassPathXmlApplicationContext容器读取ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;application.xml&quot;); 配置类+注解方式（完全注解方式） 配置类 使用 @Configuration 注解将一个普通的类标记为 Spring 的配置类。 12345678910111213import org.springframework.context.annotation.ComponentScan;import org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.PropertySource;//标注当前类是配置类，替代application.xml @Configuration//使用注解读取外部配置，替代 &lt;context:property-placeholder标签@PropertySource(&quot;classpath:application.properties&quot;)//使用@ComponentScan注解,可以配置扫描包,替代&lt;context:component-scan标签@ComponentScan(basePackages = &#123;&quot;com.atguigu.components&quot;&#125;)public class MyConfiguration &#123; &#125; 测试创建IoC容器 123// AnnotationConfigApplicationContext 根据配置类创建 IOC 容器对象ApplicationContext iocContainerAnnotation = new AnnotationConfigApplicationContext(MyConfiguration.class); 可以使用 no-arg 构造函数实例化 AnnotationConfigApplicationContext ，然后使用 register() 方法对其进行配置。此方法在以编程方式生成 AnnotationConfigApplicationContext 时特别有用。以下示例演示如何执行此操作： 12345678// AnnotationConfigApplicationContext-IOC容器对象ApplicationContext iocContainerAnnotation = new AnnotationConfigApplicationContext();//外部设置配置类iocContainerAnnotation.register(MyConfiguration.class);//刷新后方可生效！！iocContainerAnnotation.refresh(); 总结： @Configuration指定一个类为配置类，可以添加配置注解，替代配置xml文件 @ComponentScan(basePackages &#x3D; {“包”,”包”}) 替代&lt;context:component-scan标签实现注解扫描 @PropertySource(“classpath:配置文件地址”) 替代 &lt;context:property-placeholder标签 配合IoC&#x2F;DI注解，可以进行完整注解开发！ 4.4.3 实验二：@Bean定义组件场景需求：将Druid连接池对象存储到IoC容器 需求分析：第三方jar包的类，添加到ioc容器，无法使用@Component等相关注解！因为源码jar包内容为只读模式！ xml方式实现： 12345678910111213141516171819&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;!-- 引入外部属性文件 --&gt; &lt;context:property-placeholder location=&quot;classpath:jdbc.properties&quot;/&gt; &lt;!-- 实验六 [重要]给bean的属性赋值：引入外部属性文件 --&gt; &lt;bean id=&quot;druidDataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot;/&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;$&#123;jdbc.driver&#125;&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.user&#125;&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;/&gt; &lt;/bean&gt;&lt;/beans&gt; 配置类方式实现： @Bean 注释用于指示方法实例化、配置和初始化要由 Spring IoC 容器管理的新对象。对于那些熟悉 Spring 的 &lt;beans/&gt; XML 配置的人来说， @Bean 注释与 &lt;bean/&gt; 元素起着相同的作用。 12345678910111213141516171819202122232425//标注当前类是配置类，替代application.xml @Configuration//引入jdbc.properties文件@PropertySource(&#123;&quot;classpath:application.properties&quot;,&quot;classpath:jdbc.properties&quot;&#125;)@ComponentScan(basePackages = &#123;&quot;com.atguigu.components&quot;&#125;)public class MyConfiguration &#123; //如果第三方类进行IoC管理,无法直接使用@Component相关注解 //解决方案: xml方式可以使用&lt;bean标签 //解决方案: 配置类方式,可以使用方法返回值+@Bean注解 @Bean public DataSource createDataSource(@Value(&quot;$&#123;jdbc.user&#125;&quot;) String username, @Value(&quot;$&#123;jdbc.password&#125;&quot;)String password, @Value(&quot;$&#123;jdbc.url&#125;&quot;)String url, @Value(&quot;$&#123;jdbc.driver&#125;&quot;)String driverClassName)&#123; //使用Java代码实例化 DruidDataSource dataSource = new DruidDataSource(); dataSource.setUsername(username); dataSource.setPassword(password); dataSource.setUrl(url); dataSource.setDriverClassName(driverClassName); //返回结果即可 return dataSource; &#125;&#125; 4.4.4 实验三：高级特性：@Bean注解细节 @Bean生成BeanName问题 @Bean注解源码： 123456789101112131415161718public @interface Bean &#123; //前两个注解可以指定Bean的标识 @AliasFor(&quot;name&quot;) String[] value() default &#123;&#125;; @AliasFor(&quot;value&quot;) String[] name() default &#123;&#125;; //autowireCandidate 属性来指示该 Bean 是否候选用于自动装配。 //autowireCandidate 属性默认值为 true，表示该 Bean 是一个默认的装配目标， //可被候选用于自动装配。如果将 autowireCandidate 属性设置为 false，则说明该 Bean 不是默认的装配目标，不会被候选用于自动装配。 boolean autowireCandidate() default true; //指定初始化方法 String initMethod() default &quot;&quot;; //指定销毁方法 String destroyMethod() default &quot;(inferred)&quot;;&#125; 指定@Bean的名称： 12345678@Configurationpublic class AppConfig &#123; @Bean(&quot;myThing&quot;) //指定名称 public Thing thing() &#123; return new Thing(); &#125;&#125; @Bean 注释注释方法。使用此方法在指定为方法返回值的类型的 ApplicationContext 中注册 Bean 定义。缺省情况下，Bean 名称与方法名称相同。下面的示例演示 @Bean 方法声明： 12345678@Configurationpublic class AppConfig &#123; @Bean public TransferServiceImpl transferService() &#123; return new TransferServiceImpl(); &#125;&#125; 前面的配置完全等同于下面的Spring XML： 123&lt;beans&gt; &lt;bean id=&quot;transferService&quot; class=&quot;com.acme.TransferServiceImpl&quot;/&gt;&lt;/beans&gt; @Bean 初始化和销毁方法指定 @Bean 注解支持指定任意初始化和销毁回调方法，非常类似于 Spring XML 在 bean 元素上的 init-method 和 destroy-method 属性，如以下示例所示： 123456789101112131415161718192021222324252627public class BeanOne &#123; public void init() &#123; // initialization logic &#125;&#125;public class BeanTwo &#123; public void cleanup() &#123; // destruction logic &#125;&#125;@Configurationpublic class AppConfig &#123; @Bean(initMethod = &quot;init&quot;) public BeanOne beanOne() &#123; return new BeanOne(); &#125; @Bean(destroyMethod = &quot;cleanup&quot;) public BeanTwo beanTwo() &#123; return new BeanTwo(); &#125;&#125; @Bean Scope作用域 可以指定使用 @Bean 注释定义的 bean 应具有特定范围。您可以使用在 Bean 作用域部分中指定的任何标准作用域。 默认作用域为 singleton ，但您可以使用 @Scope 注释覆盖此范围，如以下示例所示： 123456789@Configurationpublic class MyConfiguration &#123; @Bean @Scope(&quot;prototype&quot;) public Encryptor encryptor() &#123; // ... &#125;&#125; @Bean方法之间依赖 准备组件 123456789101112public class HappyMachine &#123; private String machineName; public String getMachineName() &#123; return machineName; &#125; public void setMachineName(String machineName) &#123; this.machineName = machineName; &#125;&#125; 1234567891011121314151617public class HappyComponent &#123; //引用新组件 private HappyMachine happyMachine; public HappyMachine getHappyMachine() &#123; return happyMachine; &#125; public void setHappyMachine(HappyMachine happyMachine) &#123; this.happyMachine = happyMachine; &#125; public void doWork() &#123; System.out.println(&quot;HappyComponent.doWork&quot;); &#125;&#125; Java配置类实现： 方案1： 直接调用方法返回 Bean 实例：在一个 @Bean 方法中直接调用其他 @Bean 方法来获取 Bean 实例，虽然是方法调用，也是通过IoC容器获取对应的Bean，例如： 1234567891011121314151617@Configurationpublic class JavaConfig &#123; @Bean public HappyMachine happyMachine()&#123; return new HappyMachine(); &#125; @Bean public HappyComponent happyComponent()&#123; HappyComponent happyComponent = new HappyComponent(); //直接调用方法即可! happyComponent.setHappyMachine(happyMachine()); return happyComponent; &#125;&#125; 方案2： 参数引用法：通过方法参数传递 Bean 实例的引用来解决 Bean 实例之间的依赖关系，例如： 123456789101112131415161718192021222324252627282930313233343536373839404142434445package com.atguigu.config;import com.atguigu.ioc.HappyComponent;import com.atguigu.ioc.HappyMachine;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;/** * projectName: com.atguigu.config * description: 配置HappyComponent和HappyMachine关系 */@Configurationpublic class JavaConfig &#123; @Bean public HappyMachine happyMachine()&#123; return new HappyMachine(); &#125; /** * 可以直接在形参列表接收IoC容器中的Bean! * 情况1: 直接指定类型即可 * 情况2: 如果有多个bean,(HappyMachine 名称 ) 形参名称等于要指定的bean名称! * 例如: * @Bean * public Foo foo1()&#123; * return new Foo(); * &#125; * @Bean * public Foo foo2()&#123; * return new Foo() * &#125; * @Bean * public Component component(Foo foo1 / foo2 通过此处指定引入的bean) */ @Bean public HappyComponent happyComponent(HappyMachine happyMachine)&#123; HappyComponent happyComponent = new HappyComponent(); //赋值 happyComponent.setHappyMachine(happyMachine); return happyComponent; &#125;&#125; 4.4.5 实验四：高级特性：@Import扩展@Import 注释允许从另一个配置类加载 @Bean 定义，如以下示例所示： 123456789101112131415161718@Configurationpublic class ConfigA &#123; @Bean public A a() &#123; return new A(); &#125;&#125;@Configuration@Import(ConfigA.class)public class ConfigB &#123; @Bean public B b() &#123; return new B(); &#125;&#125; 现在，在实例化上下文时不需要同时指定 ConfigA.class 和 ConfigB.class ，只需显式提供 ConfigB ，如以下示例所示： 1234567public static void main(String[] args) &#123; ApplicationContext ctx = new AnnotationConfigApplicationContext(ConfigB.class); // now both beans A and B will be available... A a = ctx.getBean(A.class); B b = ctx.getBean(B.class);&#125; 此方法简化了容器实例化，因为只需要处理一个类，而不是要求您在构造期间记住可能大量的 @Configuration 类。 4.4.6 实验五：基于注解+配置类方式整合三层架构组件 需求分析 搭建一个三层架构案例，模拟查询全部学生（学生表）信息，持久层使用JdbcTemplate和Druid技术，使用注解+配置类方式进行组件管理！ 数据库准备 1234567891011121314151617181920212223create database studb;use studb;CREATE TABLE students ( id INT PRIMARY KEY, name VARCHAR(50) NOT NULL, gender VARCHAR(10) NOT NULL, age INT, class VARCHAR(50));INSERT INTO students (id, name, gender, age, class)VALUES (1, &#x27;张三&#x27;, &#x27;男&#x27;, 20, &#x27;高中一班&#x27;), (2, &#x27;李四&#x27;, &#x27;男&#x27;, 19, &#x27;高中二班&#x27;), (3, &#x27;王五&#x27;, &#x27;女&#x27;, 18, &#x27;高中一班&#x27;), (4, &#x27;赵六&#x27;, &#x27;女&#x27;, 20, &#x27;高中三班&#x27;), (5, &#x27;刘七&#x27;, &#x27;男&#x27;, 19, &#x27;高中二班&#x27;), (6, &#x27;陈八&#x27;, &#x27;女&#x27;, 18, &#x27;高中一班&#x27;), (7, &#x27;杨九&#x27;, &#x27;男&#x27;, 20, &#x27;高中三班&#x27;), (8, &#x27;吴十&#x27;, &#x27;男&#x27;, 19, &#x27;高中二班&#x27;); 项目准备 项目创建 spring-java-practice-06 依赖导入 123456789101112131415161718192021222324252627282930313233343536&lt;dependencies&gt; &lt;!--spring context依赖--&gt; &lt;!--当你引入SpringContext依赖之后，表示将Spring的基础依赖引入了--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;6.0.6&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 数据库驱动和连接池--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.25&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.2.8&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;jakarta.annotation&lt;/groupId&gt; &lt;artifactId&gt;jakarta.annotation-api&lt;/artifactId&gt; &lt;version&gt;2.1.1&lt;/version&gt; &lt;/dependency&gt; &lt;!-- spring-jdbc --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;6.0.6&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 实体类准备 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960public class Student &#123; private Integer id; private String name; private String gender; private Integer age; private String classes; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getGender() &#123; return gender; &#125; public void setGender(String gender) &#123; this.gender = gender; &#125; public Integer getAge() &#123; return age; &#125; public void setAge(Integer age) &#123; this.age = age; &#125; public String getClasses() &#123; return classes; &#125; public void setClasses(String classes) &#123; this.classes = classes; &#125; @Override public String toString() &#123; return &quot;Student&#123;&quot; + &quot;id=&quot; + id + &quot;, name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, gender=&#x27;&quot; + gender + &#x27;\\&#x27;&#x27; + &quot;, age=&quot; + age + &quot;, classes=&#x27;&quot; + classes + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125;&#125; 三层架构搭建和实现 持久层123456789101112131415161718192021222324252627282930313233343536//接口public interface StudentDao &#123; /** * 查询全部学生数据 * @return */ List&lt;Student&gt; queryAll();&#125;//实现类@Repositorypublic class StudentDaoImpl implements StudentDao &#123; @Autowired private JdbcTemplate jdbcTemplate; /** * 查询全部学生数据 * @return */ @Override public List&lt;Student&gt; queryAll() &#123; String sql = &quot;select id , name , age , gender , class as classes from students ;&quot;; /* query可以返回集合! BeanPropertyRowMapper就是封装好RowMapper的实现,要求属性名和列名相同即可 */ List&lt;Student&gt; studentList = jdbcTemplate.query(sql, new BeanPropertyRowMapper&lt;&gt;(Student.class)); return studentList; &#125;&#125; 业务层12345678910111213141516171819202122232425262728293031//接口public interface StudentService &#123; /** * 查询全部学员业务 * @return */ List&lt;Student&gt; findAll();&#125;//实现类@Servicepublic class StudentServiceImpl implements StudentService &#123; @Autowired private StudentDao studentDao; /** * 查询全部学员业务 * @return */ @Override public List&lt;Student&gt; findAll() &#123; List&lt;Student&gt; studentList = studentDao.queryAll(); return studentList; &#125;&#125; 表述层123456789101112@Controllerpublic class StudentController &#123; @Autowired private StudentService studentService; public void findAll()&#123; List&lt;Student&gt; studentList = studentService.findAll(); System.out.println(&quot;studentList = &quot; + studentList); &#125;&#125; 三层架构IoC配置类 123456789101112131415161718192021222324252627282930313233@Configuration@ComponentScan(basePackages = &quot;com.atguigu&quot;)@PropertySource(&quot;classpath:jdbc.properties&quot;)public class JavaConfig &#123; @Value(&quot;$&#123;atguigu.url&#125;&quot;) private String url; @Value(&quot;$&#123;atguigu.driver&#125;&quot;) private String driver; @Value(&quot;$&#123;atguigu.username&#125;&quot;) private String username; @Value(&quot;$&#123;atguigu.password&#125;&quot;) private String password; @Bean(destroyMethod = &quot;close&quot;) public DruidDataSource dataSource()&#123; DruidDataSource dataSource = new DruidDataSource(); dataSource.setUrl(url); dataSource.setDriverClassName(driver); dataSource.setUsername(username); dataSource.setPassword(password); return dataSource; &#125; @Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE) @Bean public JdbcTemplate jdbcTemplate(DataSource dataSource)&#123; JdbcTemplate jdbcTemplate = new JdbcTemplate(); jdbcTemplate.setDataSource(dataSource); return jdbcTemplate; &#125;&#125; 运行测试 1234567891011121314public class ControllerTest &#123; @Test public void testRun()&#123; AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(JavaConfig.class); StudentController studentController = applicationContext.getBean(StudentController.class); studentController.findAll(); &#125;&#125; 注解+配置类 IoC方式总结 完全摒弃了XML配置文件 自定义类使用IoC和DI注解标记 第三方类使用配置类声明方法+@Bean方式处理 完全注解方式（配置类+注解）是现在主流配置方式 4.5 三种配置方式总结4.5.1 XML方式配置总结 所有内容写到xml格式配置文件中 声明bean通过&lt;bean标签 &lt;bean标签包含基本信息（id,class）和属性信息 &lt;property name value &#x2F; ref 引入外部的properties文件可以通过&lt;context:property-placeholder IoC具体容器实现选择ClassPathXmlApplicationContext对象 4.5.2 XML+注解方式配置总结 注解负责标记IoC的类和进行属性装配 xml文件依然需要，需要通过&lt;context:component-scan标签指定注解范围 标记IoC注解：@Component,@Service,@Controller,@Repository&#x20; 标记DI注解：@Autowired @Qualifier @Resource @Value IoC具体容器实现选择ClassPathXmlApplicationContext对象 4.5.3 完全注解方式配置总结 完全注解方式指的是去掉xml文件，使用配置类 + 注解实现 xml文件替换成使用@Configuration注解标记的类 标记IoC注解：@Component,@Service,@Controller,@Repository&#x20; 标记DI注解：@Autowired @Qualifier @Resource @Value &lt;context:component-scan标签指定注解范围使用@ComponentScan(basePackages &#x3D; {“com.atguigu.components”})替代 &lt;context:property-placeholder引入外部配置文件使用@PropertySource({“classpath:application.properties”,”classpath:jdbc.properties”})替代 &lt;bean 标签使用@Bean注解和方法实现 IoC具体容器实现选择AnnotationConfigApplicationContext对象 4.6 整合Spring5-Test5搭建测试环境 整合测试环境作用 好处1：不需要自己创建IOC容器对象了 好处2：任何需要的bean都可以在测试类中直接享受自动装配 导入相关依赖 123456789101112&lt;!--junit5测试--&gt;&lt;dependency&gt; &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt; &lt;artifactId&gt;junit-jupiter-api&lt;/artifactId&gt; &lt;version&gt;5.3.1&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;6.0.6&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt; 整合测试注解使用 123456789101112//@SpringJUnitConfig(locations = &#123;&quot;classpath:spring-context.xml&quot;&#125;) //指定配置文件xml@SpringJUnitConfig(value = &#123;BeanConfig.class&#125;) //指定配置类public class Junit5IntegrationTest &#123; @Autowired private User user; @Test public void testJunit5() &#123; System.out.println(user); &#125;&#125; 五、Spring AOP面向切面编程5.1 场景设定和问题复现 准备AOP项目 项目名：spring-aop-annotation pom.xml 123456789101112131415&lt;dependencies&gt; &lt;!--spring context依赖--&gt; &lt;!--当你引入Spring Context依赖之后，表示将Spring的基础依赖引入了--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;6.0.6&lt;/version&gt; &lt;/dependency&gt; &lt;!--junit5测试--&gt; &lt;dependency&gt; &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt; &lt;artifactId&gt;junit-jupiter-api&lt;/artifactId&gt; &lt;version&gt;5.3.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;6.0.6&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;jakarta.annotation&lt;/groupId&gt; &lt;artifactId&gt;jakarta.annotation-api&lt;/artifactId&gt; &lt;version&gt;2.1.1&lt;/version&gt; &lt;/dependency&gt; 123456789101112131415162. 声明接口 ```java /** * + - * / 运算的标准接口! */ public interface Calculator &#123; int add(int i, int j); int sub(int i, int j); int mul(int i, int j); int div(int i, int j); &#125; 接口实现 1package com.atguigu.proxy; &#x2F;** 实现计算接口,单纯添加 + - * &#x2F; 实现! 掺杂其他功能! *&#x2F; public class CalculatorPureImpl implements Calculator { @Override public int add(int i, int j) { int result = i + j; return result; } @Override public int sub(int i, int j) { int result = i - j; return result; } @Override public int mul(int i, int j) { int result = i * j; return result; } @Override public int div(int i, int j) { int result = i / j; return result; } } 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657584. 声明带日志接口实现 新需求： 需要在每个方法中，添加控制台输出，输出参数和输出计算后的返回值！ ![](http://heavy_code_industry.gitee.io/code_heavy_industry/assets/img/img002.f8e54219.png) ```java package com.atguigu.proxy; /** * 在每个方法中,输出传入的参数和计算后的返回结果! */ public class CalculatorLogImpl implements Calculator &#123; @Override public int add(int i, int j) &#123; System.out.println(&quot;参数是：&quot; + i + &quot;,&quot; + j); int result = i + j; System.out.println(&quot;方法内部 result = &quot; + result); return result; &#125; @Override public int sub(int i, int j) &#123; System.out.println(&quot;参数是：&quot; + i + &quot;,&quot; + j); int result = i - j; System.out.println(&quot;方法内部 result = &quot; + result); return result; &#125; @Override public int mul(int i, int j) &#123; System.out.println(&quot;参数是：&quot; + i + &quot;,&quot; + j); int result = i * j; System.out.println(&quot;方法内部 result = &quot; + result); return result; &#125; @Override public int div(int i, int j) &#123; System.out.println(&quot;参数是：&quot; + i + &quot;,&quot; + j); int result = i / j; System.out.println(&quot;方法内部 result = &quot; + result); return result; &#125; &#125; 代码问题分析 代码缺陷 对核心业务功能有干扰，导致程序员在开发核心业务功能时分散了精力 附加功能代码重复，分散在各个业务功能方法中！冗余，且不方便统一维护！ 解决思路 &#x20; 核心就是：解耦。我们需要把附加功能从业务功能代码中抽取出来。 &#x20; 将重复的代码统一提取，并且[[动态插入]]到每个业务方法！ 技术困难 解决问题的困难：提取重复附加功能代码到一个类中，可以实现 但是如何将代码插入到各个方法中，我们不会，我们需要引用新技术！！！ 5.2 解决技术代理模式 代理模式 二十三种设计模式中的一种，属于结构型模式。它的作用就是通过提供一个代理类，让我们在调用目标方法的时候，不再是直接对目标方法进行调用，而是通过代理类间接调用。让不属于目标方法核心逻辑的代码从目标方法中剥离出来——解耦。调用目标方法时先调用代理对象的方法，减少对目标方法的调用和打扰，同时让附加功能能够集中在一起也有利于统一维护。 无代理场景： 有代理场景： 生活中的代理： 广告商找大明星拍广告需要经过经纪人 合作伙伴找大老板谈合作要约见面时间需要经过秘书 房产中介是买卖双方的代理 太监是大臣和皇上之间的代理相关术语： 代理：将非核心逻辑剥离出来以后，封装这些非核心逻辑的类、对象、方法。(中介) 动词：指做代理这个动作，或这项工作 名词：扮演代理这个角色的类、对象、方法 目标：被代理“套用”了核心逻辑代码的类、对象、方法。(房东)代理在开发中实现的方式具体有两种：静态代理，[动态代理技术] 静态代理 主动创建代理类： 1234567891011121314151617181920212223public class CalculatorStaticProxy implements Calculator &#123; // 将被代理的目标对象声明为成员变量 private Calculator target; public CalculatorStaticProxy(Calculator target) &#123; this.target = target; &#125; @Override public int add(int i, int j) &#123; // 附加功能由代理类中的代理方法来实现 System.out.println(&quot;参数是：&quot; + i + &quot;,&quot; + j); // 通过目标对象来实现核心业务逻辑 int addResult = target.add(i, j); System.out.println(&quot;方法内部 result = &quot; + result); return addResult; &#125; …… 静态代理确实实现了解耦，但是由于代码都写死了，完全不具备任何的灵活性。就拿日志功能来说，将来其他地方也需要附加日志，那还得再声明更多个静态代理类，那就产生了大量重复的代码，日志功能还是分散的，没有统一管理。 提出进一步的需求：将日志功能集中到一个代理类中，将来有任何日志需求，都通过这一个代理类来实现。这就需要使用动态代理技术了。 动态代理 动态代理技术分类 JDK动态代理：JDK原生的实现方式，需要被代理的目标类必须实现接口！他会根据目标类的接口动态生成一个代理对象！代理对象和目标对象有相同的接口！（拜把子） cglib：通过继承被代理的目标类实现代理，所以不需要目标类实现接口！（认干爹）JDK动态代理技术实现（了解） 代理工程：基于jdk代理技术，生成代理对象 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class ProxyFactory &#123; private Object target; public ProxyFactory(Object target) &#123; this.target = target; &#125; public Object getProxy()&#123; /** * newProxyInstance()：创建一个代理实例 * 其中有三个参数： * 1、classLoader：加载动态生成的代理类的类加载器 * 2、interfaces：目标对象实现的所有接口的class对象所组成的数组 * 3、invocationHandler：设置代理对象实现目标对象方法的过程，即代理类中如何重写接口中的抽象方法 */ ClassLoader classLoader = target.getClass().getClassLoader(); Class&lt;?&gt;[] interfaces = target.getClass().getInterfaces(); InvocationHandler invocationHandler = new InvocationHandler() &#123; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; /** * proxy：代理对象 * method：代理对象需要实现的方法，即其中需要重写的方法 * args：method所对应方法的参数 */ Object result = null; try &#123; System.out.println(&quot;[动态代理][日志] &quot;+method.getName()+&quot;，参数：&quot;+ Arrays.toString(args)); result = method.invoke(target, args); System.out.println(&quot;[动态代理][日志] &quot;+method.getName()+&quot;，结果：&quot;+ result); &#125; catch (Exception e) &#123; e.printStackTrace(); System.out.println(&quot;[动态代理][日志] &quot;+method.getName()+&quot;，异常：&quot;+e.getMessage()); &#125; finally &#123; System.out.println(&quot;[动态代理][日志] &quot;+method.getName()+&quot;，方法执行完毕&quot;); &#125; return result; &#125; &#125;; return Proxy.newProxyInstance(classLoader, interfaces, invocationHandler); &#125;&#125; 测试代码： 1234567@Testpublic void testDynamicProxy()&#123; ProxyFactory factory = new ProxyFactory(new CalculatorLogImpl()); Calculator proxy = (Calculator) factory.getProxy(); proxy.div(1,0); //proxy.div(1,1);&#125; 代理总结 代理方式可以解决附加功能代码干扰核心代码和不方便统一维护的问题！ 他主要是将附加功能代码提取到代理中执行，不干扰目标核心代码！ 但是我们也发现，无论使用静态代理和动态代理(jdk,cglib)，程序员的工作都比较繁琐！ 需要自己编写代理工厂等！ 但是，提前剧透，我们在实际开发中，不需要编写代理代码，我们可以使用[Spring AOP]框架， 他会简化动态代理的实现！！！ 5.3 面向切面编程思维（AOP） 面向切面编程思想AOP AOP：Aspect Oriented Programming面向切面编程 AOP可以说是OOP（Object Oriented Programming，面向对象编程）的补充和完善。OOP引入封装、继承、多态等概念来建立一种对象层次结构，用于模拟公共行为的一个集合。不过OOP允许开发者定义纵向的关系，但并不适合定义横向的关系，例如日志功能。日志代码往往横向地散布在所有对象层次中，而与它对应的对象的核心功能毫无关系对于其他类型的代码，如安全性、异常处理和透明的持续性也都是如此，这种散布在各处的无关的代码被称为横切（cross cutting），在OOP设计中，它导致了大量代码的重复，而不利于各个模块的重用。 AOP技术恰恰相反，它利用一种称为”横切”的技术，剖解开封装的对象内部，并将那些影响了多个类的公共行为封装到一个可重用模块，并将其命名为”Aspect”，即切面。所谓”切面”，简单说就是那些与业务无关，却为业务模块所共同调用的逻辑或责任封装起来，便于减少系统的重复代码，降低模块之间的耦合度，并有利于未来的可操作性和可维护性。 使用AOP，可以在不修改原来代码的基础上添加新功能。 AOP思想主要的应用场景 AOP（面向切面编程）是一种编程范式，它通过将通用的横切关注点（如日志、事务、权限控制等）与业务逻辑分离，使得代码更加清晰、简洁、易于维护。AOP可以应用于各种场景，以下是一些常见的AOP应用场景： 日志记录：在系统中记录日志是非常重要的，可以使用AOP来实现日志记录的功能，可以在方法执行前、执行后或异常抛出时记录日志。 事务处理：在数据库操作中使用事务可以保证数据的一致性，可以使用AOP来实现事务处理的功能，可以在方法开始前开启事务，在方法执行完毕后提交或回滚事务。 安全控制：在系统中包含某些需要安全控制的操作，如登录、修改密码、授权等，可以使用AOP来实现安全控制的功能。可以在方法执行前进行权限判断，如果用户没有权限，则抛出异常或转向到错误页面，以防止未经授权的访问。 性能监控：在系统运行过程中，有时需要对某些方法的性能进行监控，以找到系统的瓶颈并进行优化。可以使用AOP来实现性能监控的功能，可以在方法执行前记录时间戳，在方法执行完毕后计算方法执行时间并输出到日志中。 异常处理：系统中可能出现各种异常情况，如空指针异常、数据库连接异常等，可以使用AOP来实现异常处理的功能，在方法执行过程中，如果出现异常，则进行异常处理（如记录日志、发送邮件等）。 缓存控制：在系统中有些数据可以缓存起来以提高访问速度，可以使用AOP来实现缓存控制的功能，可以在方法执行前查询缓存中是否有数据，如果有则返回，否则执行方法并将方法返回值存入缓存中。 动态代理：AOP的实现方式之一是通过动态代理，可以代理某个类的所有方法，用于实现各种功能。综上所述，AOP可以应用于各种场景，它的作用是将通用的横切关注点与业务逻辑分离，使得代码更加清晰、简洁、易于维护。 AOP术语名词介绍 1-横切关注点 从每个方法中抽取出来的同一类非核心业务。在同一个项目中，我们可以使用多个横切关注点对相关方法进行多个不同方面的增强。 这个概念不是语法层面天然存在的，而是根据附加功能的逻辑上的需要：有十个附加功能，就有十个横切关注点。 AOP把软件系统分为两个部分：核心关注点和横切关注点。业务处理的主要流程是核心关注点，与之关系不大的部分是横切关注点。横切关注点的一个特点是，他们经常发生在核心关注点的多处，而各处基本相似，比如权限认证、日志、事务、异常等。AOP的作用在于分离系统中的各种关注点，将核心关注点和横切关注点分离开来。 2-通知(增强) 每一个横切关注点上要做的事情都需要写一个方法来实现，这样的方法就叫通知方法。 前置通知：在被代理的目标方法前执行 返回通知：在被代理的目标方法成功结束后执行（寿终正寝） 异常通知：在被代理的目标方法异常结束后执行（死于非命） 后置通知：在被代理的目标方法最终结束后执行（盖棺定论） 环绕通知：使用try…catch…finally结构围绕整个被代理的目标方法，包括上面四种通知对应的所有位置3-连接点 joinpoint 这也是一个纯逻辑概念，不是语法定义的。 指那些被拦截到的点。在 Spring 中，可以被动态代理拦截目标类的方法 4-切入点 pointcut 定位连接点的方式，或者可以理解成被选中的连接点！ 是一个表达式，比如execution(* com.spring.service.impl..(..))。符合条件的每个方法都是一个具体的连接点。 5-切面 aspect 切入点和通知的结合。是一个类。 6-目标 target 被代理的目标对象。 7-代理 proxy 向目标对象应用通知之后创建的代理对象。 8-织入 weave 指把通知应用到目标上，生成代理对象的过程。可以在编译期织入，也可以在运行期织入，Spring采用后者。 5.4 Spring AOP框架介绍和关系梳理 AOP一种区别于OOP的编程思维，用来完善和解决OOP的非核心代码冗余和不方便统一维护问题！ 代理技术（动态代理|静态代理）是实现AOP思维编程的具体技术，但是自己使用动态代理实现代码比较繁琐！ Spring AOP框架，基于AOP编程思维，封装动态代理技术，简化动态代理技术实现的框架！SpringAOP内部帮助我们实现动态代理，我们只需写少量的配置，指定生效范围即可,即可完成面向切面思维编程的实现！ 5.5 Spring AOP基于注解方式实现和细节5.5.1 Spring AOP底层技术组成 动态代理（InvocationHandler）：JDK原生的实现方式，需要被代理的目标类必须实现接口。因为这个技术要求代理对象和目标对象实现同样的接口（兄弟两个拜把子模式）。 cglib：通过继承被代理的目标类（认干爹模式）实现代理，所以不需要目标类实现接口。 AspectJ：早期的AOP实现的框架，SpringAOP借用了AspectJ中的AOP注解。 5.5.2 初步实现 加入依赖123456789101112&lt;!-- spring-aspects会帮我们传递过来aspectjweaver --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;version&gt;6.0.6&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt; &lt;version&gt;6.0.6&lt;/version&gt;&lt;/dependency&gt; 准备接口1234567891011public interface Calculator &#123; int add(int i, int j); int sub(int i, int j); int mul(int i, int j); int div(int i, int j); &#125; 纯净实现类1package com.atguigu.proxy; &#x2F;** 实现计算接口,单纯添加 + - * &#x2F; 实现! 掺杂其他功能! *&#x2F; @Component public class CalculatorPureImpl implements Calculator { @Override public int add(int i, int j) { int result = i + j; return result; } @Override public int sub(int i, int j) { int result = i - j; return result; } @Override public int mul(int i, int j) { int result = i * j; return result; } @Override public int div(int i, int j) { int result = i / j; return result; } } 1234567891011121314151617181920212223242526272829303132333435364. 声明切面类 ```java package com.atguigu.advice; import org.aspectj.lang.annotation.*; import org.springframework.stereotype.Component; // @Aspect表示这个类是一个切面类 @Aspect // @Component注解保证这个切面类能够放入IOC容器 @Component public class LogAspect &#123; // @Before注解：声明当前方法是前置通知方法 // value属性：指定切入点表达式，由切入点表达式控制当前通知方法要作用在哪一个目标方法上 @Before(value = &quot;execution(public int com.atguigu.proxy.CalculatorPureImpl.add(int,int))&quot;) public void printLogBeforeCore() &#123; System.out.println(&quot;[AOP前置通知] 方法开始了&quot;); &#125; @AfterReturning(value = &quot;execution(public int com.atguigu.proxy.CalculatorPureImpl.add(int,int))&quot;) public void printLogAfterSuccess() &#123; System.out.println(&quot;[AOP返回通知] 方法成功返回了&quot;); &#125; @AfterThrowing(value = &quot;execution(public int com.atguigu.proxy.CalculatorPureImpl.add(int,int))&quot;) public void printLogAfterException() &#123; System.out.println(&quot;[AOP异常通知] 方法抛异常了&quot;); &#125; @After(value = &quot;execution(public int com.atguigu.proxy.CalculatorPureImpl.add(int,int))&quot;) public void printLogFinallyEnd() &#123; System.out.println(&quot;[AOP后置通知] 方法最终结束了&quot;); &#125; &#125; 开启aspectj注解支持 xml方式123456789101112&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt; &lt;!-- 进行包扫描--&gt; &lt;context:component-scan base-package=&quot;com.atguigu&quot; /&gt; &lt;!-- 开启aspectj框架注解支持--&gt; &lt;aop:aspectj-autoproxy /&gt;&lt;/beans&gt; 配置类方式1234567@Configuration@ComponentScan(basePackages = &quot;com.atguigu&quot;)//作用等于 &lt;aop:aspectj-autoproxy /&gt; 配置类上开启 Aspectj注解支持!@EnableAspectJAutoProxypublic class MyConfig &#123;&#125; 测试效果12345678910111213//@SpringJUnitConfig(locations = &quot;classpath:spring-aop.xml&quot;)@SpringJUnitConfig(value = &#123;MyConfig.class&#125;)public class AopTest &#123; @Autowired private Calculator calculator; @Test public void testCalculator()&#123; calculator.add(1,1); &#125;&#125; 输出结果：1234&quot;C:\\Program Files\\Java\\jdk-17\\bin\\java.exe&quot; -ea -Didea.test.cyclic.buffer.size=1048576 &quot;-javaagent:D:\\Program Files\\JetBrains\\IntelliJ IDEA 2022.3.2\\lib\\idea_rt.jar=65511:D:\\Program Files\\JetBrains\\IntelliJ IDEA 2022.3.2\\bin&quot; -Dfile.encoding=UTF-8 -classpath &quot;C:\\Users\\Jackiechan\\.m2\\repository\\org\\junit\\platform\\junit-platform-launcher\\1.3.1\\junit-platform-launcher-1.3.1.jar;C:\\Users\\Jackiechan\\.m2\\repository\\org\\apiguardian\\apiguardian-api\\1.0.0\\apiguardian-api-1.0.0.jar;C:\\Users\\Jackiechan\\.m2\\repository\\org\\junit\\platform\\junit-platform-engine\\1.3.1\\junit-platform-engine-1.3.1.jar;C:\\Users\\Jackiechan\\.m2\\repository\\org\\junit\\platform\\junit-platform-commons\\1.3.1\\junit-platform-commons-1.3.1.jar;C:\\Users\\Jackiechan\\.m2\\repository\\org\\opentest4j\\opentest4j\\1.1.1\\opentest4j-1.1.1.jar;C:\\Users\\Jackiechan\\.m2\\repository\\org\\junit\\jupiter\\junit-jupiter-engine\\5.3.1\\junit-jupiter-engine-5.3.1.jar;C:\\Users\\Jackiechan\\.m2\\repository\\org\\junit\\jupiter\\junit-jupiter-api\\5.3.1\\junit-jupiter-api-5.3.1.jar;D:\\Program Files\\JetBrains\\IntelliJ IDEA 2022.3.2\\lib\\idea_rt.jar;D:\\Program Files\\JetBrains\\IntelliJ IDEA 2022.3.2\\plugins\\junit\\lib\\junit5-rt.jar;D:\\Program Files\\JetBrains\\IntelliJ IDEA 2022.3.2\\plugins\\junit\\lib\\junit-rt.jar;D:\\javaprojects\\backend-engineering\\part01-spring\\spring-aop-annotation\\target\\test-classes;D:\\javaprojects\\backend-engineering\\part01-spring\\spring-aop-annotation\\target\\classes;D:\\repository\\org\\springframework\\spring-context\\6.0.6\\spring-context-6.0.6.jar;D:\\repository\\org\\springframework\\spring-beans\\6.0.6\\spring-beans-6.0.6.jar;D:\\repository\\org\\springframework\\spring-core\\6.0.6\\spring-core-6.0.6.jar;D:\\repository\\org\\springframework\\spring-jcl\\6.0.6\\spring-jcl-6.0.6.jar;D:\\repository\\org\\springframework\\spring-expression\\6.0.6\\spring-expression-6.0.6.jar;D:\\repository\\org\\junit\\jupiter\\junit-jupiter-api\\5.3.1\\junit-jupiter-api-5.3.1.jar;D:\\repository\\org\\apiguardian\\apiguardian-api\\1.0.0\\apiguardian-api-1.0.0.jar;D:\\repository\\org\\opentest4j\\opentest4j\\1.1.1\\opentest4j-1.1.1.jar;D:\\repository\\org\\junit\\platform\\junit-platform-commons\\1.3.1\\junit-platform-commons-1.3.1.jar;D:\\repository\\org\\springframework\\spring-test\\6.0.6\\spring-test-6.0.6.jar;D:\\repository\\jakarta\\annotation\\jakarta.annotation-api\\2.1.1\\jakarta.annotation-api-2.1.1.jar;D:\\repository\\mysql\\mysql-connector-java\\8.0.25\\mysql-connector-java-8.0.25.jar;D:\\repository\\com\\google\\protobuf\\protobuf-java\\3.11.4\\protobuf-java-3.11.4.jar;D:\\repository\\com\\alibaba\\druid\\1.2.8\\druid-1.2.8.jar;D:\\repository\\javax\\annotation\\javax.annotation-api\\1.3.2\\javax.annotation-api-1.3.2.jar;D:\\repository\\org\\springframework\\spring-aop\\6.0.6\\spring-aop-6.0.6.jar;D:\\repository\\org\\springframework\\spring-aspects\\6.0.6\\spring-aspects-6.0.6.jar;D:\\repository\\org\\aspectj\\aspectjweaver\\1.9.9.1\\aspectjweaver-1.9.9.1.jar&quot; com.intellij.rt.junit.JUnitStarter -ideVersion5 -junit5 com.atguigu.test.AopTest,testCalculator[AOP前置通知] 方法开始了[AOP返回通知] 方法成功返回了[AOP后置通知] 方法最终结束了 5.5.3 获取通知细节信息 JointPoint接口 需要获取方法签名、传入的实参等信息时，可以在通知方法声明JoinPoint类型的形参。 要点1：JoinPoint 接口通过 getSignature() 方法获取目标方法的签名（方法声明时的完整信息） 要点2：通过目标方法签名对象获取方法名 要点3：通过 JoinPoint 对象获取外界调用目标方法时传入的实参列表组成的数组1234567891011121314151617181920212223242526272829// @Before注解标记前置通知方法// value属性：切入点表达式，告诉Spring当前通知方法要套用到哪个目标方法上// 在前置通知方法形参位置声明一个JoinPoint类型的参数，Spring就会将这个对象传入// 根据JoinPoint对象就可以获取目标方法名称、实际参数列表@Before(value = &quot;execution(public int com.atguigu.aop.api.Calculator.add(int,int))&quot;)public void printLogBeforeCore(JoinPoint joinPoint) &#123; // 1.通过JoinPoint对象获取目标方法签名对象 // 方法的签名：一个方法的全部声明信息 Signature signature = joinPoint.getSignature(); // 2.通过方法的签名对象获取目标方法的详细信息 String methodName = signature.getName(); System.out.println(&quot;methodName = &quot; + methodName); int modifiers = signature.getModifiers(); System.out.println(&quot;modifiers = &quot; + modifiers); String declaringTypeName = signature.getDeclaringTypeName(); System.out.println(&quot;declaringTypeName = &quot; + declaringTypeName); // 3.通过JoinPoint对象获取外界调用目标方法时传入的实参列表 Object[] args = joinPoint.getArgs(); // 4.由于数组直接打印看不到具体数据，所以转换为List集合 List&lt;Object&gt; argList = Arrays.asList(args); System.out.println(&quot;[AOP前置通知] &quot; + methodName + &quot;方法开始了，参数列表：&quot; + argList);&#125; 方法返回值 在返回通知中，通过 @AfterReturning注解的returning属性获取目标方法的返回值！ 1234567891011121314// @AfterReturning注解标记返回通知方法// 在返回通知中获取目标方法返回值分两步：// 第一步：在@AfterReturning注解中通过returning属性设置一个名称// 第二步：使用returning属性设置的名称在通知方法中声明一个对应的形参@AfterReturning( value = &quot;execution(public int com.atguigu.aop.api.Calculator.add(int,int))&quot;, returning = &quot;targetMethodReturnValue&quot;)public void printLogAfterCoreSuccess(JoinPoint joinPoint, Object targetMethodReturnValue) &#123; String methodName = joinPoint.getSignature().getName(); System.out.println(&quot;[AOP返回通知] &quot;+methodName+&quot;方法成功结束了，返回值是：&quot; + targetMethodReturnValue);&#125; 异常对象捕捉 在异常通知中，通过@AfterThrowing注解的throwing属性获取目标方法抛出的异常对象 1234567891011121314// @AfterThrowing注解标记异常通知方法// 在异常通知中获取目标方法抛出的异常分两步：// 第一步：在@AfterThrowing注解中声明一个throwing属性设定形参名称// 第二步：使用throwing属性指定的名称在通知方法声明形参，Spring会将目标方法抛出的异常对象从这里传给我们@AfterThrowing( value = &quot;execution(public int com.atguigu.aop.api.Calculator.add(int,int))&quot;, throwing = &quot;targetMethodException&quot;)public void printLogAfterCoreException(JoinPoint joinPoint, Throwable targetMethodException) &#123; String methodName = joinPoint.getSignature().getName(); System.out.println(&quot;[AOP异常通知] &quot;+methodName+&quot;方法抛异常了，异常类型是：&quot; + targetMethodException.getClass().getName());&#125; 5.5.4 切点表达式语法 切点表达式作用 AOP切点表达式（Pointcut Expression）是一种用于指定切点的语言，它可以通过定义匹配规则，来选择需要被切入的目标对象。 切点表达式语法 切点表达式总结 语法细节 第一位：execution( ) 固定开头 第二位：方法访问修饰符 1public private 直接描述对应修饰符即可 第三位：方法返回值 12int String void 直接描述返回值类型 注意： 特殊情况 不考虑 访问修饰符和返回值 execution(* * ) 这是错误语法 execution( *) &#x3D;&#x3D; 你只要考虑返回值 或者 不考虑访问修饰符 相当于全部不考虑了 第四位：指定包的地址 12345固定的包: com.atguigu.api | service | dao单层的任意命名: com.atguigu.* = com.atguigu.api com.atguigu.dao * = 任意一层的任意命名任意层任意命名: com.. = com.atguigu.api.erdaye com.a.a.a.a.a.a.a ..任意层,任意命名 用在包上!注意: ..不能用作包开头 public int .. 错误语法 com..找到任何包下: *.. 第五位：指定类名称 12345固定名称: UserService任意类名: *部分任意: com..service.impl.*Impl任意包任意类: *..* 第六位：指定方法名称 12语法和类名一致任意访问修饰符,任意类的任意方法: * *..*.* 第七位：方法参数 12345678第七位: 方法的参数描述 具体值: (String,int) != (int,String) 没有参数 () 模糊值: 任意参数 有 或者 没有 (..) ..任意参数的意识 部分具体和模糊: 第一个参数是字符串的方法 (String..) 最后一个参数是字符串 (..String) 字符串开头,int结尾 (String..int) 包含int类型(..int..) 切点表达式案例 1234561.查询某包某类下，访问修饰符是公有，返回值是int的全部方法2.查询某包下类中第一个参数是String的方法3.查询全部包下，无参数的方法！4.查询com包下，以int参数类型结尾的方法5.查询指定包下，Service开头类的私有返回值int的无参数方法 5.5.5 重用（提取）切点表达式 重用切点表达式优点 123456789101112131415161718192021 // @Before注解：声明当前方法是前置通知方法// value属性：指定切入点表达式，由切入点表达式控制当前通知方法要作用在哪一个目标方法上@Before(value = &quot;execution(public int com.atguigu.proxy.CalculatorPureImpl.add(int,int))&quot;)public void printLogBeforeCore() &#123; System.out.println(&quot;[AOP前置通知] 方法开始了&quot;);&#125;@AfterReturning(value = &quot;execution(public int com.atguigu.proxy.CalculatorPureImpl.add(int,int))&quot;)public void printLogAfterSuccess() &#123; System.out.println(&quot;[AOP返回通知] 方法成功返回了&quot;);&#125;@AfterThrowing(value = &quot;execution(public int com.atguigu.proxy.CalculatorPureImpl.add(int,int))&quot;)public void printLogAfterException() &#123; System.out.println(&quot;[AOP异常通知] 方法抛异常了&quot;);&#125;@After(value = &quot;execution(public int com.atguigu.proxy.CalculatorPureImpl.add(int,int))&quot;)public void printLogFinallyEnd() &#123; System.out.println(&quot;[AOP后置通知] 方法最终结束了&quot;);&#125; 上面案例，是我们之前编写切点表达式的方式，发现， 所有增强方法的切点表达式相同！ 出现了冗余，如果需要切换也不方便统一维护！ 我们可以将切点提取，在增强上进行引用即可！ 同一类内部引用 提取 123// 切入点表达式重用@Pointcut(&quot;execution(public int com.atguigu.aop.api.Calculator.add(int,int)))&quot;)public void declarPointCut() &#123;&#125; 注意：提取切点注解使用@Pointcut(切点表达式) ， 需要添加到一个无参数无返回值方法上即可！ 引用 12@Before(value = &quot;declarPointCut()&quot;)public void printLogBeforeCoreOperation(JoinPoint joinPoint) &#123; 不同类中引用 不同类在引用切点，只需要添加类的全限定符+方法名即可！ 12@Before(value = &quot;com.atguigu.spring.aop.aspect.LogAspect.declarPointCut()&quot;)public Object roundAdvice(ProceedingJoinPoint joinPoint) &#123; 切点统一管理 建议：将切点表达式统一存储到一个类中进行集中管理和维护！ 123456789101112@Componentpublic class AtguiguPointCut &#123; @Pointcut(value = &quot;execution(public int *..Calculator.sub(int,int))&quot;) public void atguiguGlobalPointCut()&#123;&#125; @Pointcut(value = &quot;execution(public int *..Calculator.add(int,int))&quot;) public void atguiguSecondPointCut()&#123;&#125; @Pointcut(value = &quot;execution(* *..*Service.*(..))&quot;) public void transactionPointCut()&#123;&#125;&#125; 5.5.6 环绕通知环绕通知对应整个 try…catch…finally 结构，包括前面四种通知的所有功能。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546// 使用@Around注解标明环绕通知方法@Around(value = &quot;com.atguigu.aop.aspect.AtguiguPointCut.transactionPointCut()&quot;)public Object manageTransaction( // 通过在通知方法形参位置声明ProceedingJoinPoint类型的形参， // Spring会将这个类型的对象传给我们 ProceedingJoinPoint joinPoint) &#123; // 通过ProceedingJoinPoint对象获取外界调用目标方法时传入的实参数组 Object[] args = joinPoint.getArgs(); // 通过ProceedingJoinPoint对象获取目标方法的签名对象 Signature signature = joinPoint.getSignature(); // 通过签名对象获取目标方法的方法名 String methodName = signature.getName(); // 声明变量用来存储目标方法的返回值 Object targetMethodReturnValue = null; try &#123; // 在目标方法执行前：开启事务（模拟） log.debug(&quot;[AOP 环绕通知] 开启事务，方法名：&quot; + methodName + &quot;，参数列表：&quot; + Arrays.asList(args)); // 过ProceedingJoinPoint对象调用目标方法 // 目标方法的返回值一定要返回给外界调用者 targetMethodReturnValue = joinPoint.proceed(args); // 在目标方法成功返回后：提交事务（模拟） log.debug(&quot;[AOP 环绕通知] 提交事务，方法名：&quot; + methodName + &quot;，方法返回值：&quot; + targetMethodReturnValue); &#125;catch (Throwable e)&#123; // 在目标方法抛异常后：回滚事务（模拟） log.debug(&quot;[AOP 环绕通知] 回滚事务，方法名：&quot; + methodName + &quot;，异常：&quot; + e.getClass().getName()); &#125;finally &#123; // 在目标方法最终结束后：释放数据库连接 log.debug(&quot;[AOP 环绕通知] 释放数据库连接，方法名：&quot; + methodName); &#125; return targetMethodReturnValue;&#125; 5.5.7 切面优先级设置相同目标方法上同时存在多个切面时，切面的优先级控制切面的内外嵌套顺序。 优先级高的切面：外面 优先级低的切面：里面 使用 @Order 注解可以控制切面的优先级： @Order(较小的数)：优先级高 @Order(较大的数)：优先级低 实际意义 实际开发时，如果有多个切面嵌套的情况，要慎重考虑。例如：如果事务切面优先级高，那么在缓存中命中数据的情况下，事务切面的操作都浪费了。 此时应该将缓存切面的优先级提高，在事务操作之前先检查缓存中是否存在目标数据。 5.5.8 CGLib动态代理生效在目标类没有实现任何接口的情况下，Spring会自动使用cglib技术实现代理。为了证明这一点，我们做下面的测试： 1234567@Servicepublic class EmployeeService &#123; public void getEmpList() &#123; System.out.print(&quot;方法内部 com.atguigu.aop.imp.EmployeeService.getEmpList&quot;); &#125;&#125; 测试： 1234567@Autowiredprivate EmployeeService employeeService;@Testpublic void testNoInterfaceProxy() &#123; employeeService.getEmpList();&#125; 没有接口： 有接口： 使用总结： a. 如果目标类有接口,选择使用jdk动态代理 b. 如果目标类没有接口,选择cglib动态代理 c. 如果有接口,接口接值 d. 如果没有接口,类进行接值 5.5.9 注解实现小结 5.6 Spring AOP基于XML方式实现(了解) 准备工作 加入依赖 和基于注解的 AOP 时一样。 准备代码 把测试基于注解功能时的Java类复制到新module中，去除所有注解。 配置Spring配置文件 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;!-- 配置目标类的bean --&gt;&lt;bean id=&quot;calculatorPure&quot; class=&quot;com.atguigu.aop.imp.CalculatorPureImpl&quot;/&gt; &lt;!-- 配置切面类的bean --&gt;&lt;bean id=&quot;logAspect&quot; class=&quot;com.atguigu.aop.aspect.LogAspect&quot;/&gt; &lt;!-- 配置AOP --&gt;&lt;aop:config&gt; &lt;!-- 配置切入点表达式 --&gt; &lt;aop:pointcut id=&quot;logPointCut&quot; expression=&quot;execution(* *..*.*(..))&quot;/&gt; &lt;!-- aop:aspect标签：配置切面 --&gt; &lt;!-- ref属性：关联切面类的bean --&gt; &lt;aop:aspect ref=&quot;logAspect&quot;&gt; &lt;!-- aop:before标签：配置前置通知 --&gt; &lt;!-- method属性：指定前置通知的方法名 --&gt; &lt;!-- pointcut-ref属性：引用切入点表达式 --&gt; &lt;aop:before method=&quot;printLogBeforeCore&quot; pointcut-ref=&quot;logPointCut&quot;/&gt; &lt;!-- aop:after-returning标签：配置返回通知 --&gt; &lt;!-- returning属性：指定通知方法中用来接收目标方法返回值的参数名 --&gt; &lt;aop:after-returning method=&quot;printLogAfterCoreSuccess&quot; pointcut-ref=&quot;logPointCut&quot; returning=&quot;targetMethodReturnValue&quot;/&gt; &lt;!-- aop:after-throwing标签：配置异常通知 --&gt; &lt;!-- throwing属性：指定通知方法中用来接收目标方法抛出异常的异常对象的参数名 --&gt; &lt;aop:after-throwing method=&quot;printLogAfterCoreException&quot; pointcut-ref=&quot;logPointCut&quot; throwing=&quot;targetMethodException&quot;/&gt; &lt;!-- aop:after标签：配置后置通知 --&gt; &lt;aop:after method=&quot;printLogCoreFinallyEnd&quot; pointcut-ref=&quot;logPointCut&quot;/&gt; &lt;!-- aop:around标签：配置环绕通知 --&gt; &lt;!--&lt;aop:around method=&quot;……&quot; pointcut-ref=&quot;logPointCut&quot;/&gt;--&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt; 测试 123456789101112@SpringJUnitConfig(locations = &quot;classpath:spring-aop.xml&quot;)public class AopTest &#123; @Autowired private Calculator calculator; @Test public void testCalculator()&#123; System.out.println(calculator); calculator.add(1,1); &#125;&#125; 5.7 Spring AOP对获取Bean的影响理解5.7.1 根据类型装配 bean 情景一 bean 对应的类没有实现任何接口 根据 bean 本身的类型获取 bean 测试：IOC容器中同类型的 bean 只有一个 正常获取到 IOC 容器中的那个 bean 对象 测试：IOC 容器中同类型的 bean 有多个 会抛出 NoUniqueBeanDefinitionException 异常，表示 IOC 容器中这个类型的 bean 有多个 情景二 bean 对应的类实现了接口，这个接口也只有这一个实现类 测试：根据接口类型获取 bean 测试：根据类获取 bean 结论：上面两种情况其实都能够正常获取到 bean，而且是同一个对象 情景三 声明一个接口 接口有多个实现类 接口所有实现类都放入 IOC 容器 测试：根据接口类型获取 bean 会抛出 NoUniqueBeanDefinitionException 异常，表示 IOC 容器中这个类型的 bean 有多个 测试：根据类获取bean 正常 情景四 声明一个接口 接口有一个实现类 创建一个切面类，对上面接口的实现类应用通知 测试：根据接口类型获取bean 正常 测试：根据类获取bean 无法获取原因分析： 应用了切面后，真正放在IOC容器中的是代理类的对象 目标类并没有被放到IOC容器中，所以根据目标类的类型从IOC容器中是找不到的 情景五 声明一个类 创建一个切面类，对上面的类应用通知 测试：根据类获取 bean，能获取到debug查看实际类型： 5.7.2 使用总结对实现了接口的类应用切面 对没实现接口的类应用切面new 如果使用AOP技术，目标类有接口，必须使用接口类型接收IoC容器中代理组件！ 六、Spring 声明式事务6.1 声明式事务概念6.1.1 编程式事务编程式事务是指手动编写程序来管理事务，即通过编写代码的方式直接控制事务的提交和回滚。在 Java 中，通常使用事务管理器(如 Spring 中的 PlatformTransactionManager)来实现编程式事务。 编程式事务的主要优点是灵活性高，可以按照自己的需求来控制事务的粒度、模式等等。但是，编写大量的事务控制代码容易出现问题，对代码的可读性和可维护性有一定影响。 123456789101112131415161718192021Connection conn = ...; try &#123; // 开启事务：关闭事务的自动提交 conn.setAutoCommit(false); // 核心操作 // 业务代码 // 提交事务 conn.commit(); &#125;catch(Exception e)&#123; // 回滚事务 conn.rollBack(); &#125;finally&#123; // 释放数据库连接 conn.close(); &#125; 编程式的实现方式存在缺陷： 细节没有被屏蔽：具体操作过程中，所有细节都需要程序员自己来完成，比较繁琐。 代码复用性不高：如果没有有效抽取出来，每次实现功能都需要自己编写代码，代码就没有得到复用。 6.1.2 声明式事务声明式事务是指使用注解或 XML 配置的方式来控制事务的提交和回滚。 开发者只需要添加配置即可， 具体事务的实现由第三方框架实现，避免我们直接进行事务操作！ 使用声明式事务可以将事务的控制和业务逻辑分离开来，提高代码的可读性和可维护性。 区别： 编程式事务需要手动编写代码来管理事务 而声明式事务可以通过配置文件或注解来控制事务。 6.1.3 Spring事务管理器 Spring声明式事务对应依赖 spring-tx: 包含声明式事务实现的基本规范（事务管理器规范接口和事务增强等等） spring-jdbc: 包含DataSource方式事务管理器实现类DataSourceTransactionManager spring-orm: 包含其他持久层框架的事务管理器实现类例如：Hibernate&#x2F;Jpa等 Spring声明式事务对应事务管理器接口 我们现在要使用的事务管理器是org.springframework.jdbc.datasource.DataSourceTransactionManager，将来整合 JDBC方式、JdbcTemplate方式、Mybatis方式的事务实现！ DataSourceTransactionManager类中的主要方法： doBegin()：开启事务 doSuspend()：挂起事务 doResume()：恢复挂起的事务 doCommit()：提交事务 doRollback()：回滚事务 6.2 基于注解的声明式事务6.2.1 准备工作 准备项目 123456789101112131415&lt;dependencies&gt; &lt;!--spring context依赖--&gt; &lt;!--当你引入Spring Context依赖之后，表示将Spring的基础依赖引入了--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;6.0.6&lt;/version&gt; &lt;/dependency&gt; &lt;!--junit5测试--&gt; &lt;dependency&gt; &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt; &lt;artifactId&gt;junit-jupiter-api&lt;/artifactId&gt; &lt;version&gt;5.3.1&lt;/version&gt; &lt;/dependency&gt; org.springframework spring-test 6.0.6 test jakarta.annotation jakarta.annotation-api 2.1.1 mysql mysql-connector-java 8.0.25 com.alibaba druid 1.2.8 org.springframework spring-jdbc 6.0.6 org.springframework spring-tx 6.0.6 org.springframework spring-aop 6.0.6 org.springframework spring-aspects 6.0.6 123456782. 外部配置文件 jdbc.properties ```.properties atguigu.url=jdbc:mysql://localhost:3306/studb atguigu.driver=com.mysql.cj.jdbc.Driver atguigu.username=root atguigu.password=root spring配置文件 12345678910111213@Configuration@ComponentScan(&quot;com.atguigu&quot;)@PropertySource(&quot;classpath:jdbc.properties&quot;)public class JavaConfig &#123; @Value(&quot;$&#123;atguigu.driver&#125;&quot;) private String driver; @Value(&quot;$&#123;atguigu.url&#125;&quot;) private String url; @Value(&quot;$&#123;atguigu.username&#125;&quot;) private String username; @Value(&quot;$&#123;atguigu.password&#125;&quot;) private String password; //druid连接池 @Bean public DataSource dataSource()&#123; DruidDataSource dataSource = new DruidDataSource(); dataSource.setDriverClassName(driver); dataSource.setUrl(url); dataSource.setUsername(username); dataSource.setPassword(password); return dataSource; &#125; @Bean //jdbcTemplate public JdbcTemplate jdbcTemplate(DataSource dataSource)&#123; JdbcTemplate jdbcTemplate = new JdbcTemplate(); jdbcTemplate.setDataSource(dataSource); return jdbcTemplate; &#125; } 1234567891011121314151617181920214. 准备dao/service层 dao ```java @Repository public class StudentDao &#123; @Autowired private JdbcTemplate jdbcTemplate; public void updateNameById(String name,Integer id)&#123; String sql = &quot;update students set name = ? where id = ? ;&quot;; int rows = jdbcTemplate.update(sql, name, id); &#125; public void updateAgeById(Integer age,Integer id)&#123; String sql = &quot;update students set age = ? where id = ? ;&quot;; jdbcTemplate.update(sql,age,id); &#125; &#125; service 12345678910111213@Servicepublic class StudentService &#123; @Autowired private StudentDao studentDao; public void changeInfo()&#123; studentDao.updateAgeById(100,1); System.out.println(&quot;-----------&quot;); studentDao.updateNameById(&quot;test1&quot;,1); &#125;&#125; 测试环境搭建 1234567891011121314151617/** * projectName: com.atguigu.test * * description: */@SpringJUnitConfig(JavaConfig.class)public class TxTest &#123; @Autowired private StudentService studentService; @Test public void testTx()&#123; studentService.changeInfo(); &#125;&#125; 6.2.2 基本事务控制 配置事务管理器 数据库相关的配置 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758/** * projectName: com.atguigu.config * * description: 数据库和连接池配置类 */@Configuration@ComponenScan(&quot;com.atguigu&quot;)@PropertySource(value = &quot;classpath:jdbc.properties&quot;)@EnableTransactionManagementpublic class DataSourceConfig &#123; /** * 实例化dataSource加入到ioc容器 * @param url * @param driver * @param username * @param password * @return */ @Bean public DataSource dataSource(@Value(&quot;$&#123;atguigu.url&#125;&quot;)String url, @Value(&quot;$&#123;atguigu.driver&#125;&quot;)String driver, @Value(&quot;$&#123;atguigu.username&#125;&quot;)String username, @Value(&quot;$&#123;atguigu.password&#125;&quot;)String password)&#123; DruidDataSource dataSource = new DruidDataSource(); dataSource.setDriverClassName(driver); dataSource.setUrl(url); dataSource.setUsername(username); dataSource.setPassword(password); return dataSource; &#125; /** * 实例化JdbcTemplate对象,需要使用ioc中的DataSource * @param dataSource * @return */ @Bean public JdbcTemplate jdbcTemplate(DataSource dataSource)&#123; JdbcTemplate jdbcTemplate = new JdbcTemplate(); jdbcTemplate.setDataSource(dataSource); return jdbcTemplate; &#125; /** * 装配事务管理实现对象 * @param dataSource * @return */ @Bean public TransactionManager transactionManager(DataSource dataSource)&#123; return new DataSourceTransactionManager(dataSource); &#125;&#125; 使用声明事务注解@Transactional 12345678910111213141516171819/** * projectName: com.atguigu.service * */@Servicepublic class StudentService &#123; @Autowired private StudentDao studentDao; @Transactional public void changeInfo()&#123; studentDao.updateAgeById(100,1); System.out.println(&quot;-----------&quot;); int i = 1/0; studentDao.updateNameById(&quot;test1&quot;,1); &#125;&#125; 测试事务效果 123456789101112131415161718/** * projectName: com.atguigu.test * * description: *///@SpringJUnitConfig(locations = &quot;classpath:application.xml&quot;)@SpringJUnitConfig(classes = DataSourceConfig.class)public class TxTest &#123; @Autowired private StudentService studentService; @Test public void testTx()&#123; studentService.changeInfo(); &#125;&#125; 6.2.3 事务属性：只读 只读介绍 对一个查询操作来说，如果我们把它设置成只读，就能够明确告诉数据库，这个操作不涉及写操作。这样数据库就能够针对查询操作来进行优化。 设置方式 12// readOnly = true把当前事务设置为只读 默认是false!@Transactional(readOnly = true) 针对DML动作设置只读模式 会抛出下面异常： Caused by: java.sql.SQLException: Connection is read-only. Queries leading to data modification are not allowed @Transactional注解放在类上 生效原则 如果一个类中每一个方法上都使用了 @Transactional 注解，那么就可以将 @Transactional 注解提取到类上。反过来说：@Transactional 注解在类级别标记，会影响到类中的每一个方法。同时，类级别标记的 @Transactional 注解中设置的事务属性也会延续影响到方法执行时的事务属性。除非在方法上又设置了 @Transactional 注解。 对一个方法来说，离它最近的 @Transactional 注解中的事务属性设置生效。 用法举例 在类级别@Transactional注解中设置只读，这样类中所有的查询方法都不需要设置@Transactional注解了。因为对查询操作来说，其他属性通常不需要设置，所以使用公共设置即可。 然后在这个基础上，对增删改方法设置@Transactional注解 readOnly 属性为 false。 1234567891011121314151617@Service@Transactional(readOnly = true)public class EmpService &#123; // 为了便于核对数据库操作结果，不要修改同一条记录 @Transactional(readOnly = false) public void updateTwice(……) &#123; …… &#125; // readOnly = true把当前事务设置为只读 // @Transactional(readOnly = true) public String getEmpName(Integer empId) &#123; …… &#125; &#125; 6.2.4 事务属性：超时时间 需求 事务在执行过程中，有可能因为遇到某些问题，导致程序卡住，从而长时间占用数据库资源。而长时间占用资源，大概率是因为程序运行出现了问题（可能是Java程序或MySQL数据库或网络连接等等）。 此时这个很可能出问题的程序应该被回滚，撤销它已做的操作，事务结束，把资源让出来，让其他正常程序可以执行。 概括来说就是一句话：超时回滚，释放资源。 设置超时时间 12345678910111213141516171819202122@Servicepublic class StudentService &#123; @Autowired private StudentDao studentDao; /** * timeout设置事务超时时间,单位秒! 默认: -1 永不超时,不限制事务时间! */ @Transactional(readOnly = false,timeout = 3) public void changeInfo()&#123; studentDao.updateAgeById(100,1); //休眠4秒,等待方法超时! try &#123; Thread.sleep(4000); &#125; catch (InterruptedException e) &#123; throw new RuntimeException(e); &#125; studentDao.updateNameById(&quot;test1&quot;,1); &#125;&#125; 测试超时效果 执行抛出事务超时异常 12345678org.springframework.transaction.TransactionTimedOutException: Transaction timed out: deadline was Wed May 24 09:10:43 IRKT 2023 at org.springframework.transaction.support.ResourceHolderSupport.checkTransactionTimeout(ResourceHolderSupport.java:155) at org.springframework.transaction.support.ResourceHolderSupport.getTimeToLiveInMillis(ResourceHolderSupport.java:144) at org.springframework.transaction.support.ResourceHolderSupport.getTimeToLiveInSeconds(ResourceHolderSupport.java:128) at org.springframework.jdbc.datasource.DataSourceUtils.applyTimeout(DataSourceUtils.java:341) at org.springframework.jdbc.core.JdbcTemplate.applyStatementSettings(JdbcTemplate.java:1467) 6.2.5 事务属性：事务异常 默认情况 默认只针对运行时异常回滚，编译时异常不回滚。情景模拟代码如下： 12345678910111213141516171819@Servicepublic class StudentService &#123; @Autowired private StudentDao studentDao; /** * timeout设置事务超时时间,单位秒! 默认: -1 永不超时,不限制事务时间! * rollbackFor = 指定哪些异常才会回滚,默认是 RuntimeException and Error 异常方可回滚! * noRollbackFor = 指定哪些异常不会回滚, 默认没有指定,如果指定,应该在rollbackFor的范围内! */ @Transactional(readOnly = false,timeout = 3) public void changeInfo() throws FileNotFoundException &#123; studentDao.updateAgeById(100,1); //主动抛出一个检查异常,测试! 发现不会回滚,因为不在rollbackFor的默认范围内! new FileInputStream(&quot;xxxx&quot;); studentDao.updateNameById(&quot;test1&quot;,1); &#125;&#125; 设置回滚异常 rollbackFor属性：指定哪些异常类才会回滚,默认是 RuntimeException and Error 异常方可回滚! 123456789101112/** * timeout设置事务超时时间,单位秒! 默认: -1 永不超时,不限制事务时间! * rollbackFor = 指定哪些异常才会回滚,默认是 RuntimeException and Error 异常方可回滚! * noRollbackFor = 指定哪些异常不会回滚, 默认没有指定,如果指定,应该在rollbackFor的范围内! */@Transactional(readOnly = false,timeout = 3,rollbackFor = Exception.class)public void changeInfo() throws FileNotFoundException &#123; studentDao.updateAgeById(100,1); //主动抛出一个检查异常,测试! 发现不会回滚,因为不在rollbackFor的默认范围内! new FileInputStream(&quot;xxxx&quot;); studentDao.updateNameById(&quot;test1&quot;,1);&#125; 设置不回滚的异常 在默认设置和已有设置的基础上，再指定一个异常类型，碰到它不回滚。 noRollbackFor属性：指定哪些异常不会回滚, 默认没有指定,如果指定,应该在rollbackFor的范围内! 1234567891011121314151617181920@Servicepublic class StudentService &#123; @Autowired private StudentDao studentDao; /** * timeout设置事务超时时间,单位秒! 默认: -1 永不超时,不限制事务时间! * rollbackFor = 指定哪些异常才会回滚,默认是 RuntimeException and Error 异常方可回滚! * noRollbackFor = 指定哪些异常不会回滚, 默认没有指定,如果指定,应该在rollbackFor的范围内! */ @Transactional(readOnly = false,timeout = 3,rollbackFor = Exception.class,noRollbackFor = FileNotFoundException.class) public void changeInfo() throws FileNotFoundException &#123; studentDao.updateAgeById(100,1); //主动抛出一个检查异常,测试! 发现不会回滚,因为不在rollbackFor的默认范围内! new FileInputStream(&quot;xxxx&quot;); studentDao.updateNameById(&quot;test1&quot;,1); &#125;&#125; 6.2.6 事务属性：事务隔离级别 事务隔离级别 数据库事务的隔离级别是指在多个事务并发执行时，数据库系统为了保证数据一致性所遵循的规定。常见的隔离级别包括： 读未提交（Read Uncommitted）：事务可以读取未被提交的数据，容易产生脏读、不可重复读和幻读等问题。实现简单但不太安全，一般不用。 读已提交（Read Committed）：事务只能读取已经提交的数据，可以避免脏读问题，但可能引发不可重复读和幻读。 可重复读（Repeatable Read）：在一个事务中，相同的查询将返回相同的结果集，不管其他事务对数据做了什么修改。可以避免脏读和不可重复读，但仍有幻读的问题。 串行化（Serializable）：最高的隔离级别，完全禁止了并发，只允许一个事务执行完毕之后才能执行另一个事务。可以避免以上所有问题，但效率较低，不适用于高并发场景。不同的隔离级别适用于不同的场景，需要根据实际业务需求进行选择和调整。 事务隔离级别设置 123456789101112131415161718192021222324252627282930313233343536373839package com.atguigu.service;import com.atguigu.dao.StudentDao;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import org.springframework.transaction.annotation.Isolation;import org.springframework.transaction.annotation.Transactional;import java.io.FileInputStream;import java.io.FileNotFoundException;/** * projectName: com.atguigu.service */@Servicepublic class StudentService &#123; @Autowired private StudentDao studentDao; /** * timeout设置事务超时时间,单位秒! 默认: -1 永不超时,不限制事务时间! * rollbackFor = 指定哪些异常才会回滚,默认是 RuntimeException and Error 异常方可回滚! * noRollbackFor = 指定哪些异常不会回滚, 默认没有指定,如果指定,应该在rollbackFor的范围内! * isolation = 设置事务的隔离级别,mysql默认是repeatable read! */ @Transactional(readOnly = false, timeout = 3, rollbackFor = Exception.class, noRollbackFor = FileNotFoundException.class, isolation = Isolation.REPEATABLE_READ) public void changeInfo() throws FileNotFoundException &#123; studentDao.updateAgeById(100,1); //主动抛出一个检查异常,测试! 发现不会回滚,因为不在rollbackFor的默认范围内! new FileInputStream(&quot;xxxx&quot;); studentDao.updateNameById(&quot;test1&quot;,1); &#125;&#125; 6.2.7 事务属性：事务传播行为 事务传播行为要研究的问题 举例代码： 12345678910111213@Transactionalpublic void MethodA()&#123; // ... MethodB(); // ...&#125;//在被调用的子方法中设置传播行为，代表如何处理调用的事务！ 是加入，还是新事务等！@Transactional(propagation = Propagation.REQUIRES_NEW)public void MethodB()&#123; // ...&#125; propagation属性 @Transactional 注解通过 propagation 属性设置事务的传播行为。它的默认值是： 12Propagation propagation() default Propagation.REQUIRED; propagation 属性的可选值由 org.springframework.transaction.annotation.Propagation 枚举类提供： 名称 含义 REQUIRED &#xA;默认值 如果父方法有事务，就加入，如果没有就新建自己独立！ REQUIRES_NEW 不管父方法是否有事务，我都新建事务，都是独立的！ 测试 声明两个业务方法12345678910111213141516171819202122232425262728293031323334353637383940@Servicepublic class StudentService &#123; @Autowired private StudentDao studentDao; /** * timeout设置事务超时时间,单位秒! 默认: -1 永不超时,不限制事务时间! * rollbackFor = 指定哪些异常才会回滚,默认是 RuntimeException and Error 异常方可回滚! * noRollbackFor = 指定哪些异常不会回滚, 默认没有指定,如果指定,应该在rollbackFor的范围内! * isolation = 设置事务的隔离级别,mysql默认是repeatable read! */ @Transactional(readOnly = false, timeout = 3, rollbackFor = Exception.class, noRollbackFor = FileNotFoundException.class, isolation = Isolation.REPEATABLE_READ) public void changeInfo() throws FileNotFoundException &#123; studentDao.updateAgeById(100,1); //主动抛出一个检查异常,测试! 发现不会回滚,因为不在rollbackFor的默认范围内! new FileInputStream(&quot;xxxx&quot;); studentDao.updateNameById(&quot;test1&quot;,1); &#125; /** * 声明两个独立修改数据库的事务业务方法 */ @Transactional(propagation = Propagation.REQUIRED) public void changeAge()&#123; studentDao.updateAgeById(99,1); &#125; @Transactional(propagation = Propagation.REQUIRED) public void changeName()&#123; studentDao.updateNameById(&quot;test2&quot;,1); int i = 1/0; &#125;&#125; 声明一个整合业务方法12345678910111213@Servicepublic class TopService &#123; @Autowired private StudentService studentService; @Transactional public void topService()&#123; studentService.changeAge(); studentService.changeName(); &#125;&#125; 添加传播行为测试123456789101112131415@SpringJUnitConfig(classes = AppConfig.class)public class TxTest &#123; @Autowired private StudentService studentService; @Autowired private TopService topService; @Test public void testTx() throws FileNotFoundException &#123; topService.topService(); &#125;&#125; 注意： 在同一个类中，对于@Transactional注解的方法调用，事务传播行为不会生效。这是因为Spring框架中使用代理模式实现了事务机制，在同一个类中的方法调用并不经过代理，而是通过对象的方法调用，因此@Transactional注解的设置不会被代理捕获，也就不会产生任何事务传播行为的效果。 其他传播行为值（了解） Propagation.REQUIRED：如果当前存在事务，则加入当前事务，否则创建一个新事务。 Propagation.REQUIRES_NEW：创建一个新事务，并在新事务中执行。如果当前存在事务，则挂起当前事务，即使新事务抛出异常，也不会影响当前事务。 Propagation.NESTED：如果当前存在事务，则在该事务中嵌套一个新事务，如果没有事务，则与Propagation.REQUIRED一样。 Propagation.SUPPORTS：如果当前存在事务，则加入该事务，否则以非事务方式执行。 Propagation.NOT_SUPPORTED：以非事务方式执行，如果当前存在事务，挂起该事务。 Propagation.MANDATORY：必须在一个已有的事务中执行，否则抛出异常。 Propagation.NEVER：必须在没有事务的情况下执行，否则抛出异常。 七、Spring核心掌握总结 核心点 掌握目标 spring框架理解 spring家族和spring framework框架 spring核心功能 ioc&#x2F;di , aop , tx spring ioc &#x2F; di 组件管理、ioc容器、ioc&#x2F;di , 三种配置方式 spring aop aop和aop框架和代理技术、基于注解的aop配置 spring tx 声明式和编程式事务、动态事务管理器、事务注解、属性","categories":[{"name":"SSM框架","slug":"SSM框架","permalink":"http://example.com/categories/SSM%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"ssm","slug":"ssm","permalink":"http://example.com/tags/ssm/"}]},{"title":"第13章_泛型(Generic)","slug":"Java/尚硅谷_第13章_泛型/尚硅谷_宋红康_第13章_泛型","date":"2022-09-27T00:57:57.000Z","updated":"2023-10-07T11:57:44.547Z","comments":true,"path":"2022/09/27/Java/尚硅谷_第13章_泛型/尚硅谷_宋红康_第13章_泛型/","link":"","permalink":"http://example.com/2022/09/27/Java/%E5%B0%9A%E7%A1%85%E8%B0%B7_%E7%AC%AC13%E7%AB%A0_%E6%B3%9B%E5%9E%8B/%E5%B0%9A%E7%A1%85%E8%B0%B7_%E5%AE%8B%E7%BA%A2%E5%BA%B7_%E7%AC%AC13%E7%AB%A0_%E6%B3%9B%E5%9E%8B/","excerpt":"","text":"本章专题与脉络 1. 泛型概述1.1 生活中的例子 举例1：中药店，每个抽屉外面贴着标签 举例2：超市购物架上很多瓶子，每个瓶子装的是什么，有标签 举例3：家庭厨房中： Java中的泛型，就类似于上述场景中的标签。 1.2 泛型的引入在Java中，我们在声明方法时，当在完成方法功能时如果有未知的数据需要参与，这些未知的数据需要在调用方法时才能确定，那么我们把这样的数据通过形参表示。在方法体中，用这个形参名来代表那个未知的数据，而调用者在调用时，对应的传入实参就可以了。 受以上启发，JDK1.5设计了泛型的概念。泛型即为“类型参数”，这个类型参数在声明它的类、接口或方法中，代表未知的某种通用类型。 举例1： 集合类在设计阶段&#x2F;声明阶段不能确定这个容器到底实际存的是什么类型的对象，所以在JDK5.0之前只能把元素类型设计为Object，JDK5.0时Java引入了“参数化类型（Parameterized type）”的概念，允许我们在创建集合时指定集合元素的类型。比如：List&lt;String&gt;，这表明该List只能保存字符串类型的对象。 使用集合存储数据时，除了元素的类型不确定，其他部分是确定的（例如关于这个元素如何保存，如何管理等）。 举例2： java.lang.Comparable接口和java.util.Comparator接口，是用于比较对象大小的接口。这两个接口只是限定了当一个对象大于另一个对象时返回正整数，小于返回负整数，等于返回0，但是并不确定是什么类型的对象比较大小。JDK5.0之前只能用Object类型表示，使用时既麻烦又不安全，因此 JDK5.0 给它们增加了泛型。 其中&lt;T&gt;就是类型参数，即泛型。 所谓泛型，就是允许在定义类、接口时通过一个标识表示类中某个属性的类型或者是某个方法的返回值或参数的类型。这个类型参数将在使用时（例如，继承或实现这个接口、创建对象或调用方法时）确定（即传入实际的类型参数，也称为类型实参）。 2. 使用泛型举例自从JDK5.0引入泛型的概念之后，对之前核心类库中的API做了很大的修改，例如：JDK5.0改写了集合框架中的全部接口和类、java.lang.Comparable接口、java.util.Comparator接口、Class类等。为这些接口、类增加了泛型支持，从而可以在声明变量、创建对象时传入类型实参。 2.1 集合中使用泛型2.1.1 举例集合中没有使用泛型时： 集合中使用泛型时： Java泛型可以保证如果程序在编译时没有发出警告，运行时就不会产生ClassCastException异常。即，把不安全的因素在编译期间就排除了，而不是运行期；既然通过了编译，那么类型一定是符合要求的，就避免了类型转换。 同时，代码更加简洁、健壮。 把一个集合中的内容限制为一个特定的数据类型，这就是generic背后的核心思想。 举例： 1234567891011121314151617181920212223//泛型在List中的使用@Testpublic void test1()&#123; //举例：将学生成绩保存在ArrayList中 //标准写法： //ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); //jdk7的新特性：类型推断 ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(); list.add(56); //自动装箱 list.add(76); list.add(88); list.add(89); //当添加非Integer类型数据时，编译不通过 //list.add(&quot;Tom&quot;);//编译报错 Iterator&lt;Integer&gt; iterator = list.iterator(); while(iterator.hasNext())&#123; //不需要强转，直接可以获取添加时的元素的数据类型 Integer score = iterator.next(); System.out.println(score); &#125;&#125; 举例： 123456789101112131415161718192021222324252627282930313233343536//泛型在Map中的使用@Testpublic void test2()&#123; HashMap&lt;String,Integer&gt; map = new HashMap&lt;&gt;(); map.put(&quot;Tom&quot;,67); map.put(&quot;Jim&quot;,56); map.put(&quot;Rose&quot;,88); //编译不通过 // map.put(67,&quot;Jack&quot;); //遍历key集 Set&lt;String&gt; keySet = map.keySet(); for(String str:keySet)&#123; System.out.println(str); &#125; //遍历value集 Collection&lt;Integer&gt; values = map.values(); Iterator&lt;Integer&gt; iterator = values.iterator(); while(iterator.hasNext())&#123; Integer value = iterator.next(); System.out.println(value); &#125; //遍历entry集 Set&lt;Map.Entry&lt;String, Integer&gt;&gt; entrySet = map.entrySet(); Iterator&lt;Map.Entry&lt;String, Integer&gt;&gt; iterator1 = entrySet.iterator(); while(iterator1.hasNext())&#123; Map.Entry&lt;String, Integer&gt; entry = iterator1.next(); String key = entry.getKey(); Integer value = entry.getValue(); System.out.println(key + &quot;:&quot; + value); &#125;&#125; 2.1.2 练习练习1： 123456789（1）创建一个ArrayList集合对象，并指定泛型为&lt;Integer&gt;（2）添加5个[0,100)以内的整数到集合中（3）使用foreach遍历输出5个整数（4）使用集合的removeIf方法删除偶数，为Predicate接口指定泛型&lt;Ineteger&gt;（5）再使用Iterator迭代器输出剩下的元素，为Iterator接口指定泛型&lt;Integer&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445package com.atguigu.genericclass.use;import java.util.ArrayList;import java.util.Iterator;import java.util.Random;import java.util.function.Predicate;public class TestNumber &#123; public static void main(String[] args) &#123; ArrayList&lt;Integer&gt; coll = new ArrayList&lt;Integer&gt;(); Random random = new Random(); for (int i = 1; i &lt;= 5 ; i++) &#123; coll.add(random.nextInt(100)); &#125; System.out.println(&quot;coll中5个随机数是：&quot;); for (Integer integer : coll) &#123; System.out.println(integer); &#125; //方式1：使用集合的removeIf方法删除偶数 coll.removeIf(new Predicate&lt;Integer&gt;() &#123; @Override public boolean test(Integer integer) &#123; return integer % 2 == 0; &#125; &#125;); //方式2：调用Iterator接口的remove()方法 //Iterator&lt;Integer&gt; iterator1 = coll.iterator(); //while(coll.hasNext())&#123; // Integer i = coll.next(); // if(i % 2 == 0)&#123; // coll.remove(); // &#125; //&#125; System.out.println(&quot;coll中删除偶数后：&quot;); Iterator&lt;Integer&gt; iterator = coll.iterator(); while(iterator.hasNext())&#123; Integer number = iterator.next(); System.out.println(number); &#125; &#125;&#125; 练习2：编写一个简单的同学通迅录 需求说明： 查询所有通讯录的同学信息。 输入姓名，根据姓名查询指定同学信息。如果该姓名不存在，输出提示信息。 添加同学，姓名重复的不能添加。 根据学员姓名删除学员。 按姓名排序查询学员。 分析： 使用HashMap&lt;K,V&gt;存储同学信息，使用同学姓名做key，同学对象做value。 同学对象包含的属性有：姓名、年龄、住址、爱好等。 2.2 比较器中使用泛型2.2.1 举例123456789101112131415161718192021222324package com.atguigu.generic;public class Circle&#123; private double radius; public Circle(double radius) &#123; super(); this.radius = radius; &#125; public double getRadius() &#123; return radius; &#125; public void setRadius(double radius) &#123; this.radius = radius; &#125; @Override public String toString() &#123; return &quot;Circle [radius=&quot; + radius + &quot;]&quot;; &#125;&#125; 使用泛型之前： 12345678910111213141516171819202122package com.atguigu.generic;import java.util.Comparator;class CircleComparator implements Comparator&#123; @Override public int compare(Object o1, Object o2) &#123; //强制类型转换 Circle c1 = (Circle) o1; Circle c2 = (Circle) o2; return Double.compare(c1.getRadius(), c2.getRadius()); &#125;&#125;//测试：public class TestNoGeneric &#123; public static void main(String[] args) &#123; CircleComparator com = new CircleComparator(); System.out.println(com.compare(new Circle(1), new Circle(2))); System.out.println(com.compare(&quot;圆1&quot;, &quot;圆2&quot;));//运行时异常：ClassCastException &#125;&#125; 使用泛型之后： 123456789101112131415161718192021222324package com.atguigu.generic;import java.util.Comparator;class CircleComparator1 implements Comparator&lt;Circle&gt; &#123; @Override public int compare(Circle o1, Circle o2) &#123; //不再需要强制类型转换，代码更简洁 return Double.compare(o1.getRadius(), o2.getRadius()); &#125;&#125;//测试类public class TestHasGeneric &#123; public static void main(String[] args) &#123; CircleComparator1 com = new CircleComparator1(); System.out.println(com.compare(new Circle(1), new Circle(2))); //System.out.println(com.compare(&quot;圆1&quot;, &quot;圆2&quot;)); //编译错误，因为&quot;圆1&quot;, &quot;圆2&quot;不是Circle类型，是String类型，编译器提前报错， //而不是冒着风险在运行时再报错。 &#125;&#125; 2.2.2 练习（1）声明矩形类Rectangle，包含属性长和宽，属性私有化，提供有参构造、get&#x2F;set方法、重写toString方法，提供求面积和周长的方法。 （2）矩形类Rectangle实现java.lang.Comparable接口，并指定泛型为，重写int compareTo(T t)方法，按照矩形面积比较大小，面积相等的，按照周长比较大小。 （3）在测试类中，创建Rectangle数组，并创建5个矩形对象 （4）调用Arrays的sort方法，给矩形数组排序，并显示排序前后的结果。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package com.atguigu.genericclass.use;public class Rectangle implements Comparable&lt;Rectangle&gt;&#123; private double length; private double width; public Rectangle(double length, double width) &#123; this.length = length; this.width = width; &#125; public double getLength() &#123; return length; &#125; public void setLength(double length) &#123; this.length = length; &#125; public double getWidth() &#123; return width; &#125; public void setWidth(double width) &#123; this.width = width; &#125; //获取面积 public double area()&#123; return length * width; &#125; //获取周长 public double perimeter()&#123; return 2 * (length + width); &#125; @Override public String toString() &#123; return &quot;Rectangle&#123;&quot; + &quot;length=&quot; + length + &quot;, width=&quot; + width + &quot;,area =&quot; + area() + &quot;,perimeter = &quot; + perimeter() + &#x27;&#125;&#x27;; &#125; @Override public int compareTo(Rectangle o) &#123; int compare = Double.compare(area(), o.area()); return compare != 0 ? compare : Double.compare(perimeter(),o.perimeter()); &#125;&#125; 1234567891011121314151617181920212223242526package com.atguigu.genericclass.use;import java.util.Arrays;public class TestRectangle &#123; public static void main(String[] args) &#123; Rectangle[] arr = new Rectangle[4]; arr[0] = new Rectangle(6,2); arr[1] = new Rectangle(4,3); arr[2] = new Rectangle(12,1); arr[3] = new Rectangle(5,4); System.out.println(&quot;排序之前：&quot;); for (Rectangle rectangle : arr) &#123; System.out.println(rectangle); &#125; Arrays.sort(arr); System.out.println(&quot;排序之后：&quot;); for (Rectangle rectangle : arr) &#123; System.out.println(rectangle); &#125; &#125;&#125; 2.3 相关使用说明 在创建集合对象的时候，可以指明泛型的类型。 具体格式为：List list &#x3D; new ArrayList(); JDK7.0时，有新特性，可以简写为： List list &#x3D; new ArrayList&lt;&gt;(); &#x2F;&#x2F;类型推断 泛型，也称为泛型参数，即参数的类型，只能使用引用数据类型进行赋值。（不能使用基本数据类型，可以使用包装类替换） 集合声明时，声明泛型参数。在使用集合时，可以具体指明泛型的类型。一旦指明，类或接口内部，凡是使用泛型参数的位置，都指定为具体的参数类型。如果没有指明的话，看做是Object类型。 3. 自定义泛型结构3.1 泛型的基础说明1、&lt;类型&gt;这种语法形式就叫泛型。 &lt;类型&gt;的形式我们称为类型参数，这里的”类型”习惯上使用T表示，是Type的缩写。即：。 ：代表未知的数据类型，我们可以指定为，，等。 类比方法的参数的概念，我们把，称为类型形参，将称为类型实参，有助于我们理解泛型 这里的T，可以替换成K，V等任意字母。 2、在哪里可以声明类型变量&lt;T&gt; 声明类或接口时，在类名或接口名后面声明泛型类型，我们把这样的类或接口称为泛型类或泛型接口。 123456789101112【修饰符】 class 类名&lt;类型变量列表&gt; 【extends 父类】 【implements 接口们】&#123; &#125;【修饰符】 interface 接口名&lt;类型变量列表&gt; 【implements 接口们】&#123; &#125;//例如：public class ArrayList&lt;E&gt; public interface Map&lt;K,V&gt;&#123; ....&#125; 声明方法时，在【修饰符】与返回值类型之间声明类型变量，我们把声明了类型变量的方法，称为泛型方法。 12345678[修饰符] &lt;类型变量列表&gt; 返回值类型 方法名([形参列表])[throws 异常列表]&#123; //...&#125;//例如：java.util.Arrays类中的public static &lt;T&gt; List&lt;T&gt; asList(T... a)&#123; ....&#125; 3.2 自定义泛型类或泛型接口当我们在类或接口中定义某个成员时，该成员的相关类型是不确定的，而这个类型需要在使用这个类或接口时才可以确定，那么我们可以使用泛型类、泛型接口。 3.2.1 说明① 我们在声明完自定义泛型类以后，可以在类的内部（比如：属性、方法、构造器中）使用类的泛型。 ② 我们在创建自定义泛型类的对象时，可以指明泛型参数类型。一旦指明，内部凡是使用类的泛型参数的位置，都具体化为指定的类的泛型类型。 ③ 如果在创建自定义泛型类的对象时，没有指明泛型参数类型，那么泛型将被擦除，泛型对应的类型均按照Object处理，但不等价于Object。 经验：泛型要使用一路都用。要不用，一路都不要用。 ④ 泛型的指定中必须使用引用数据类型。不能使用基本数据类型，此时只能使用包装类替换。 ⑤ 除创建泛型类对象外，子类继承泛型类时、实现类实现泛型接口时，也可以确定泛型结构中的泛型参数。 如果我们在给泛型类提供子类时，子类也不确定泛型的类型，则可以继续使用泛型参数。 我们还可以在现有的父类的泛型参数的基础上，新增泛型参数。 3.2.2 注意① 泛型类可能有多个参数，此时应将多个参数一起放在尖括号内。比如：&lt;E1,E2,E3&gt; ② JDK7.0 开始，泛型的简化操作：ArrayList flist &#x3D; new ArrayList&lt;&gt;(); ③ 如果泛型结构是一个接口或抽象类，则不可创建泛型类的对象。 ④ 不能使用new E[]。但是可以：E[] elements &#x3D; (E[])new Object[capacity]; ​ 参考：ArrayList源码中声明：Object[] elementData，而非泛型参数类型数组。 ⑤ 在类&#x2F;接口上声明的泛型，在本类或本接口中即代表某种类型，但不可以在静态方法中使用类的泛型。 ⑥ 异常类不能是带泛型的。 3.2.2 举例举例1： 123456789101112131415161718192021222324252627282930class Person&lt;T&gt; &#123; // 使用T类型定义变量 private T info; // 使用T类型定义一般方法 public T getInfo() &#123; return info; &#125; public void setInfo(T info) &#123; this.info = info; &#125; // 使用T类型定义构造器 public Person() &#123; &#125; public Person(T info) &#123; this.info = info; &#125; // static的方法中不能声明泛型 //public static void show(T t) &#123; // //&#125; // 不能在try-catch中使用泛型定义 //public void test() &#123; //try &#123; // //&#125; catch (MyException&lt;T&gt; ex) &#123; // //&#125; //&#125;&#125; 举例2： 1234567891011121314151617class Father&lt;T1, T2&gt; &#123;&#125;// 子类不保留父类的泛型// 1)没有类型 擦除class Son1 extends Father &#123;// 等价于class Son extends Father&lt;Object,Object&gt;&#123;&#125;// 2)具体类型class Son2 extends Father&lt;Integer, String&gt; &#123;&#125;// 子类保留父类的泛型// 1)全部保留class Son3&lt;T1, T2&gt; extends Father&lt;T1, T2&gt; &#123;&#125;// 2)部分保留class Son4&lt;T2&gt; extends Father&lt;Integer, T2&gt; &#123;&#125; 举例3： 1234567891011121314151617class Father&lt;T1, T2&gt; &#123;&#125;// 子类不保留父类的泛型// 1)没有类型 擦除class Son&lt;A, B&gt; extends Father&#123;//等价于class Son extends Father&lt;Object,Object&gt;&#123;&#125;// 2)具体类型class Son2&lt;A, B&gt; extends Father&lt;Integer, String&gt; &#123;&#125;// 子类保留父类的泛型// 1)全部保留class Son3&lt;T1, T2, A, B&gt; extends Father&lt;T1, T2&gt; &#123;&#125;// 2)部分保留class Son4&lt;T2, A, B&gt; extends Father&lt;Integer, T2&gt; &#123;&#125; 3.2.3 练习练习1： 声明一个学生类，该学生包含姓名、成绩，而此时学生的成绩类型不确定，为什么呢，因为，语文老师希望成绩是“优秀”、“良好”、“及格”、“不及格”，数学老师希望成绩是89.5, 65.0，英语老师希望成绩是’A’,’B’,’C’,’D’,’E’。那么我们在设计这个学生类时，就可以使用泛型。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package com.atguigu.genericclass.define;class Student&lt;T&gt;&#123; private String name; private T score; public Student() &#123; super(); &#125; public Student(String name, T score) &#123; super(); this.name = name; this.score = score; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public T getScore() &#123; return score; &#125; public void setScore(T score) &#123; this.score = score; &#125; @Override public String toString() &#123; return &quot;姓名：&quot; + name + &quot;, 成绩：&quot; + score; &#125;&#125;public class TestStudent &#123; public static void main(String[] args) &#123; //语文老师使用时： Student&lt;String&gt; stu1 = new Student&lt;String&gt;(&quot;张三&quot;, &quot;良好&quot;); //数学老师使用时： //Student&lt;double&gt; stu2 = new Student&lt;double&gt;(&quot;张三&quot;, 90.5);//错误，必须是引用数据类型 Student&lt;Double&gt; stu2 = new Student&lt;Double&gt;(&quot;张三&quot;, 90.5); //英语老师使用时： Student&lt;Character&gt; stu3 = new Student&lt;Character&gt;(&quot;张三&quot;, &#x27;C&#x27;); //错误的指定 //Student&lt;Object&gt; stu = new Student&lt;String&gt;();//错误的 &#125;&#125; 练习2： 123456789101112131415定义个泛型类 DAO&lt;T&gt;，在其中定义一个Map 成员变量，Map 的键为 String 类型，值为 T 类型。分别创建以下方法：public void save(String id,T entity)： 保存 T 类型的对象到 Map 成员变量中public T get(String id)：从 map 中获取 id 对应的对象public void update(String id,T entity)：替换 map 中key为id的内容,改为 entity 对象public List&lt;T&gt; list()：返回 map 中存放的所有 T 对象public void delete(String id)：删除指定 id 对象定义一个 User 类：该类包含：private成员变量（int类型） id，age；（String 类型）name。定义一个测试类：创建 DAO 类的对象， 分别调用其 save、get、update、list、delete 方法来操作 User 对象，使用 Junit 单元测试类进行测试。 代码实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/** * @author 尚硅谷-宋红康 * @create 8:45 */public class DAO&lt;T&gt; &#123; private Map&lt;String,T&gt; map ; &#123; map = new HashMap&lt;String,T&gt;(); &#125; //保存 T 类型的对象到 Map 成员变量中 public void save(String id,T entity)&#123; if(!map.containsKey(id))&#123; map.put(id,entity); &#125; &#125; //从 map 中获取 id 对应的对象 public T get(String id)&#123; return map.get(id); &#125; //替换 map 中key为id的内容,改为 entity 对象 public void update(String id,T entity)&#123; if(map.containsKey(id))&#123; map.put(id,entity); &#125; &#125; //返回 map 中存放的所有 T 对象 public List&lt;T&gt; list()&#123; //错误的：// Collection&lt;T&gt; values = map.values();// System.out.println(values.getClass());// return (List&lt;T&gt;) values; //正确的方式1：// ArrayList&lt;T&gt; list = new ArrayList&lt;&gt;();// Collection&lt;T&gt; values = map.values();// list.addAll(values);// return list; //正确的方式2： Collection&lt;T&gt; values = map.values(); ArrayList&lt;T&gt; list = new ArrayList&lt;&gt;(values); return list; &#125; //删除指定 id 对象 public void delete(String id)&#123; map.remove(id); &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071package com.atguigu02.selfdefine.exer1;import java.util.Objects;/** * 定义一个 User 类： * 该类包含：private成员变量（int类型） id，age；（String 类型）name。 * * @author 尚硅谷-宋红康 * @create 9:02 */public class User &#123; private int id; private int age; private String name; public User() &#123; &#125; public User(int id, int age, String name) &#123; this.id = id; this.age = age; this.name = name; &#125; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; @Override public String toString() &#123; return &quot;User&#123;&quot; + &quot;id=&quot; + id + &quot;, age=&quot; + age + &quot;, name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125; @Override public boolean equals(Object o) &#123; if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; User user = (User) o; return id == user.id &amp;&amp; age == user.age &amp;&amp; Objects.equals(name, user.name); &#125; @Override public int hashCode() &#123; return Objects.hash(id, age, name); &#125;&#125; 1234567891011121314151617181920212223242526package com.atguigu02.selfdefine.exer1;import java.util.List;/** * @author 尚硅谷-宋红康 * @create 9:04 */public class DAOTest &#123; public static void main(String[] args) &#123; DAO&lt;User&gt; dao = new DAO&lt;&gt;(); dao.save(&quot;1001&quot;,new User(1,34,&quot;曹操&quot;)); dao.save(&quot;1002&quot;,new User(2,33,&quot;刘备&quot;)); dao.save(&quot;1003&quot;,new User(3,24,&quot;孙权&quot;)); dao.update(&quot;1002&quot;,new User(2,23,&quot;刘禅&quot;)); dao.delete(&quot;1003&quot;); List&lt;User&gt; list = dao.list(); for(User u : list)&#123; System.out.println(u); &#125; &#125;&#125; 3.3 自定义泛型方法如果我们定义类、接口时没有使用&lt;泛型参数&gt;，但是某个方法形参类型不确定时，这个方法可以单独定义&lt;泛型参数&gt;。 3.3.1 说明 泛型方法的格式： 123[访问权限] &lt;泛型&gt; 返回值类型 方法名([泛型标识 参数名称]) [抛出的异常]&#123; &#125; 方法，也可以被泛型化，与其所在的类是否是泛型类没有关系。 泛型方法中的泛型参数在方法被调用时确定。 泛型方法可以根据需要，声明为static的。 3.3.2 举例举例1： 12345678910public class DAO &#123; public &lt;E&gt; E get(int id, E e) &#123; E result = null; return result; &#125;&#125; 举例2： 12345678910111213141516171819202122public static &lt;T&gt; void fromArrayToCollection(T[] a, Collection&lt;T&gt; c) &#123; for (T o : a) &#123; c.add(o); &#125;&#125;public static void main(String[] args) &#123; Object[] ao = new Object[100]; Collection&lt;Object&gt; co = new ArrayList&lt;Object&gt;(); fromArrayToCollection(ao, co); String[] sa = new String[20]; Collection&lt;String&gt; cs = new ArrayList&lt;&gt;(); fromArrayToCollection(sa, cs); Collection&lt;Double&gt; cd = new ArrayList&lt;&gt;(); // 下面代码中T是Double类，但sa是String类型，编译错误。 // fromArrayToCollection(sa, cd); // 下面代码中T是Object类型，sa是String类型，可以赋值成功。 fromArrayToCollection(sa, co);&#125; 举例3： 123456789101112131415161718192021222324252627class MyArrays &#123; public static &lt;T&gt; void sort(T[] arr)&#123; for (int i = 1; i &lt; arr.length; i++) &#123; for (int j = 0; j &lt; arr.length-i; j++) &#123; if(((Comparable&lt;T&gt;)arr[j]).compareTo(arr[j+1])&gt;0)&#123; T temp = arr[j]; arr[j] = arr[j+1]; arr[j+1] = temp; &#125; &#125; &#125; &#125;&#125;public class MyArraysTest &#123; public static void main(String[] args) &#123; int[] arr = &#123;3,2,5,1,4&#125;;// MyArrays.sort(arr);//错误的，因为int[]不是对象数组 String[] strings = &#123;&quot;hello&quot;,&quot;java&quot;,&quot;song&quot;&#125;; MyArrays.sort(strings); System.out.println(Arrays.toString(strings)); Circle[] circles = &#123;new Circle(2.0),new Circle(1.2),new Circle(3.0)&#125;; MyArrays.sort(circles); //编译通过，运行报错，因为Circle没有实现Comparable接口 &#125;&#125; 3.3.3 练习练习1: 泛型方法 编写一个泛型方法，实现任意引用类型数组指定位置元素交换。 public static void method1( E[] e,int a,int b) 1234567891011121314151617181920212223/** * @author 尚硅谷-宋红康 * @create 9:11 */public class Exer01 &#123; //编写一个泛型方法，实现任意引用类型数组指定位置元素交换。 public static &lt;E&gt; void method( E[] arr,int a,int b)&#123; E temp = arr[a]; arr[a] = arr[b]; arr[b] = temp; &#125; @Test public void testMethod()&#123; Integer[] arr = new Integer[]&#123;10,20,30,40&#125;; method(arr,2,3); for(Integer i : arr)&#123; System.out.println(i); &#125; &#125;&#125; 练习2: 泛型方法 编写一个泛型方法，接收一个任意引用类型的数组，并反转数组中的所有元素 public static void method2( E[] e) 123456789101112131415161718192021222324/** * @author 尚硅谷-宋红康 * @create 9:11 */public class Exer01 &#123; //编写一个泛型方法，接收一个任意引用类型的数组，并反转数组中的所有元素 public static &lt;E&gt; void method1( E[] arr)&#123; for(int min = 0,max = arr.length - 1;min &lt; max; min++,max--)&#123; E temp = arr[min]; arr[min] = arr[max]; arr[max] = temp; &#125; &#125; @Test public void testMethod1()&#123; Integer[] arr = new Integer[]&#123;10,20,30,40&#125;; method1(arr); for(Integer i : arr)&#123; System.out.println(i); &#125; &#125;&#125; 4. 泛型在继承上的体现如果B是A的一个子类型（子类或者子接口），而G是具有泛型声明的类或接口，G并不是G的子类型！ 比如：String是Object的子类，但是List并不是List的子类。 12345678910111213public void testGenericAndSubClass() &#123; Person[] persons = null; Man[] mans = null; //Person[] 是 Man[] 的父类 persons = mans; Person p = mans[0]; // 在泛型的集合上 List&lt;Person&gt; personList = null; List&lt;Man&gt; manList = null; //personList = manList;(报错)&#125; 思考：对比如下两段代码有何不同： 片段1： 123456public void printCollection(Collection c) &#123; Iterator i = c.iterator(); for (int k = 0; k &lt; c.size(); k++) &#123; System.out.println(i.next()); &#125;&#125; 片段2： 12345public void printCollection(Collection&lt;Object&gt; c) &#123; for (Object e : c) &#123; System.out.println(e); &#125;&#125; 5. 通配符的使用当我们声明一个变量&#x2F;形参时，这个变量&#x2F;形参的类型是一个泛型类或泛型接口，例如：Comparator类型，但是我们仍然无法确定这个泛型类或泛型接口的类型变量的具体类型，此时我们考虑使用类型通配符 ? 。 5.1 通配符的理解使用类型通配符：？ 比如：List&lt;?&gt;，Map&lt;?,?&gt; ​ List&lt;?&gt;是List&lt;String&gt;、List&lt;Object&gt;等各种泛型List的父类。 5.2 通配符的读与写写操作： 将任意元素加入到其中不是类型安全的： 123Collection&lt;?&gt; c = new ArrayList&lt;String&gt;();c.add(new Object()); // 编译时错误 因为我们不知道c的元素类型，我们不能向其中添加对象。add方法有类型参数E作为集合的元素类型。我们传给add的任何参数都必须是一个未知类型的子类。因为我们不知道那是什么类型，所以我们无法传任何东西进去。 唯一可以插入的元素是null，因为它是所有引用类型的默认值。 读操作： 另一方面，读取List&lt;?&gt;的对象list中的元素时，永远是安全的，因为不管 list 的真实类型是什么，它包含的都是Object。 举例1： 1234567public class TestWildcard &#123; public static void m4(Collection&lt;?&gt; coll)&#123; for (Object o : coll) &#123; System.out.println(o); &#125; &#125;&#125; 举例2： 123456789101112131415161718192021public static void main(String[] args) &#123; List&lt;?&gt; list = null; list = new ArrayList&lt;String&gt;(); list = new ArrayList&lt;Double&gt;(); // list.add(3);//编译不通过 list.add(null); List&lt;String&gt; l1 = new ArrayList&lt;String&gt;(); List&lt;Integer&gt; l2 = new ArrayList&lt;Integer&gt;(); l1.add(&quot;尚硅谷&quot;); l2.add(15); read(l1); read(l2);&#125;public static void read(List&lt;?&gt; list) &#123; for (Object o : list) &#123; System.out.println(o); &#125;&#125; 5.3 使用注意点注意点1：编译错误：不能用在泛型方法声明上，返回值类型前面&lt;&gt;不能使用? 12public static &lt;?&gt; void test(ArrayList&lt;?&gt; list)&#123;&#125; 注意点2：编译错误：不能用在泛型类的声明上 12class GenericTypeClass&lt;?&gt;&#123;&#125; 注意点3：编译错误：不能用在创建对象上，右边属于创建集合对象 1ArrayList&lt;?&gt; list2 = new ArrayList&lt;?&gt;(); 5.4 有限制的通配符 &lt;?&gt; 允许所有泛型的引用调用 通配符指定上限：&lt;? extends 类/接口 &gt; 使用时指定的类型必须是继承某个类，或者实现某个接口，即&lt;&#x3D; 通配符指定下限：&lt;? super 类/接口 &gt; 使用时指定的类型必须是操作的类或接口，或者是操作的类的父类或接口的父接口，即&gt;&#x3D; 说明： 12345678&lt;? extends Number&gt; //(无穷小 , Number]//只允许泛型为Number及Number子类的引用调用&lt;? super Number&gt; //[Number , 无穷大)//只允许泛型为Number及Number父类的引用调用&lt;? extends Comparable&gt;//只允许泛型为实现Comparable接口的实现类的引用调用 举例1 123456789101112131415161718class Creature&#123;&#125;class Person extends Creature&#123;&#125;class Man extends Person&#123;&#125;class PersonTest &#123; public static &lt;T extends Person&gt; void test(T t)&#123; System.out.println(t); &#125; public static void main(String[] args) &#123; test(new Person()); test(new Man()); //The method test(T) in the type PersonTest is not //applicable for the arguments (Creature) test(new Creature()); &#125;&#125; 举例2： 123456789101112131415161718192021public static void main(String[] args) &#123; Collection&lt;Integer&gt; list1 = new ArrayList&lt;Integer&gt;(); Collection&lt;String&gt; list2 = new ArrayList&lt;String&gt;(); Collection&lt;Number&gt; list3 = new ArrayList&lt;Number&gt;(); Collection&lt;Object&gt; list4 = new ArrayList&lt;Object&gt;(); getElement1(list1); getElement1(list2);//报错 getElement1(list3); getElement1(list4);//报错 getElement2(list1);//报错 getElement2(list2);//报错 getElement2(list3); getElement2(list4); &#125;// 泛型的上限：此时的泛型?，必须是Number类型或者Number类型的子类public static void getElement1(Collection&lt;? extends Number&gt; coll)&#123;&#125;// 泛型的下限：此时的泛型?，必须是Number类型或者Number类型的父类public static void getElement2(Collection&lt;? super Number&gt; coll)&#123;&#125; 举例3： 123456789101112131415161718public static void printCollection1(Collection&lt;? extends Person&gt; coll) &#123; //Iterator只能用Iterator&lt;?&gt;或Iterator&lt;? extends Person&gt;.why? Iterator&lt;?&gt; iterator = coll.iterator(); while (iterator.hasNext()) &#123; Person per = iterator.next(); System.out.println(per); &#125;&#125;public static void printCollection2(Collection&lt;? super Person&gt; coll) &#123; //Iterator只能用Iterator&lt;?&gt;或Iterator&lt;? super Person&gt;.why? Iterator&lt;?&gt; iterator = coll.iterator(); while (iterator.hasNext()) &#123; Object obj = iterator.next(); System.out.println(obj); &#125;&#125; 举例4: 12345678910111213141516171819202122232425262728293031323334353637383940@Testpublic void test1()&#123; //List&lt;Object&gt; list1 = null; List&lt;Person&gt; list2 = new ArrayList&lt;Person&gt;(); //List&lt;Student&gt; list3 = null; List&lt;? extends Person&gt; list4 = null; list2.add(new Person()); list4 = list2; //读取：可以读 Person p1 = list4.get(0); //写入：除了null之外，不能写入 list4.add(null); // list4.add(new Person()); // list4.add(new Student());&#125;@Testpublic void test2()&#123; //List&lt;Object&gt; list1 = null; List&lt;Person&gt; list2 = new ArrayList&lt;Person&gt;(); //List&lt;Student&gt; list3 = null; List&lt;? super Person&gt; list5 = null; list2.add(new Person()); list5 = list2; //读取：可以实现 Object obj = list5.get(0); //写入:可以写入Person及Person子类的对象 list5.add(new Person()); list5.add(new Student());&#125; 5.5 泛型应用举例举例1：泛型嵌套 12345678910111213141516171819public static void main(String[] args) &#123; HashMap&lt;String, ArrayList&lt;Citizen&gt;&gt; map = new HashMap&lt;String, ArrayList&lt;Citizen&gt;&gt;(); ArrayList&lt;Citizen&gt; list = new ArrayList&lt;Citizen&gt;(); list.add(new Citizen(&quot;赵又廷&quot;)); list.add(new Citizen(&quot;高圆圆&quot;)); list.add(new Citizen(&quot;瑞亚&quot;)); map.put(&quot;赵又廷&quot;, list); Set&lt;Entry&lt;String, ArrayList&lt;Citizen&gt;&gt;&gt; entrySet = map.entrySet(); Iterator&lt;Entry&lt;String, ArrayList&lt;Citizen&gt;&gt;&gt; iterator = entrySet.iterator(); while (iterator.hasNext()) &#123; Entry&lt;String, ArrayList&lt;Citizen&gt;&gt; entry = iterator.next(); String key = entry.getKey(); ArrayList&lt;Citizen&gt; value = entry.getValue(); System.out.println(&quot;户主：&quot; + key); System.out.println(&quot;家庭成员：&quot; + value); &#125;&#125; 举例2：个人信息设计 用户在设计类的时候往往会使用类的关联关系，例如，一个人中可以定义一个信息的属性，但是一个人可能有各种各样的信息（如联系方式、基本信息等），所以此信息属性的类型就可以通过泛型进行声明，然后只要设计相应的信息类即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596interface Info&#123; // 只有此接口的子类才是表示人的信息&#125;class Contact implements Info&#123; // 表示联系方式 private String address ; // 联系地址 private String telephone ; // 联系方式 private String zipcode ; // 邮政编码 public Contact(String address,String telephone,String zipcode)&#123; this.address = address; this.telephone = telephone; this.zipcode = zipcode; &#125; public void setAddress(String address)&#123; this.address = address ; &#125; public void setTelephone(String telephone)&#123; this.telephone = telephone ; &#125; public void setZipcode(String zipcode)&#123; this.zipcode = zipcode; &#125; public String getAddress()&#123; return this.address ; &#125; public String getTelephone()&#123; return this.telephone ; &#125; public String getZipcode()&#123; return this.zipcode; &#125; @Override public String toString() &#123; return &quot;Contact [address=&quot; + address + &quot;, telephone=&quot; + telephone + &quot;, zipcode=&quot; + zipcode + &quot;]&quot;; &#125;&#125;class Introduction implements Info&#123; private String name ; // 姓名 private String sex ; // 性别 private int age ; // 年龄 public Introduction(String name,String sex,int age)&#123; this.name = name; this.sex = sex; this.age = age; &#125; public void setName(String name)&#123; this.name = name ; &#125; public void setSex(String sex)&#123; this.sex = sex ; &#125; public void setAge(int age)&#123; this.age = age ; &#125; public String getName()&#123; return this.name ; &#125; public String getSex()&#123; return this.sex ; &#125; public int getAge()&#123; return this.age ; &#125; @Override public String toString() &#123; return &quot;Introduction [name=&quot; + name + &quot;, sex=&quot; + sex + &quot;, age=&quot; + age + &quot;]&quot;; &#125;&#125;class Person&lt;T extends Info&gt;&#123; private T info ; public Person(T info)&#123; // 通过构造器设置信息属性内容 this.info = info; &#125; public void setInfo(T info)&#123; this.info = info ; &#125; public T getInfo()&#123; return info ; &#125; @Override public String toString() &#123; return &quot;Person [info=&quot; + info + &quot;]&quot;; &#125; &#125;public class GenericPerson&#123; public static void main(String args[])&#123; Person&lt;Contact&gt; per = null ; // 声明Person对象 per = new Person&lt;Contact&gt;(new Contact(&quot;北京市&quot;,&quot;01088888888&quot;,&quot;102206&quot;)) ; System.out.println(per); Person&lt;Introduction&gt; per2 = null ; // 声明Person对象 per2 = new Person&lt;Introduction&gt;(new Introduction(&quot;李雷&quot;,&quot;男&quot;,24)); System.out.println(per2) ; &#125;&#125;","categories":[{"name":"java基础","slug":"java基础","permalink":"http://example.com/categories/java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"java","slug":"java","permalink":"http://example.com/tags/java/"}]},{"title":"第12章_集合框架","slug":"Java/尚硅谷_第12章_集合框架/尚硅谷_宋红康_第12章_集合框架","date":"2022-09-27T00:57:56.000Z","updated":"2023-10-07T11:56:34.778Z","comments":true,"path":"2022/09/27/Java/尚硅谷_第12章_集合框架/尚硅谷_宋红康_第12章_集合框架/","link":"","permalink":"http://example.com/2022/09/27/Java/%E5%B0%9A%E7%A1%85%E8%B0%B7_%E7%AC%AC12%E7%AB%A0_%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/%E5%B0%9A%E7%A1%85%E8%B0%B7_%E5%AE%8B%E7%BA%A2%E5%BA%B7_%E7%AC%AC12%E7%AB%A0_%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/","excerpt":"","text":"本章专题与脉络 1. 集合框架概述1.1 生活中的容器 1.2 数组的特点与弊端 一方面，面向对象语言对事物的体现都是以对象的形式，为了方便对多个对象的操作，就要对对象进行存储。 另一方面，使用数组存储对象方面具有一些弊端，而Java 集合就像一种容器，可以动态地把多个对象的引用放入容器中。 数组在内存存储方面的特点： 数组初始化以后，长度就确定了。 数组中的添加的元素是依次紧密排列的，有序的，可以重复的。 数组声明的类型，就决定了进行元素初始化时的类型。不是此类型的变量，就不能添加。 可以存储基本数据类型值，也可以存储引用数据类型的变量 数组在存储数据方面的弊端： 数组初始化以后，长度就不可变了，不便于扩展 数组中提供的属性和方法少，不便于进行添加、删除、插入、获取元素个数等操作，且效率不高。 数组存储数据的特点单一，只能存储有序的、可以重复的数据 Java 集合框架中的类可以用于存储多个对象，还可用于保存具有映射关系的关联数组。 1.3 Java集合框架体系Java 集合可分为 Collection 和 Map 两大体系： Collection接口：用于存储一个一个的数据，也称单列数据集合。 List子接口：用来存储有序的、可以重复的数据（主要用来替换数组，”动态”数组） 实现类：ArrayList(主要实现类)、LinkedList、Vector Set子接口：用来存储无序的、不可重复的数据（类似于高中讲的”集合”） 实现类：HashSet(主要实现类)、LinkedHashSet、TreeSet Map接口：用于存储具有映射关系“key-value对”的集合，即一对一对的数据，也称双列数据集合。(类似于高中的函数、映射。(x1,y1),(x2,y2) —&gt; y &#x3D; f(x) ) HashMap(主要实现类)、LinkedHashMap、TreeMap、Hashtable、Properties JDK提供的集合API位于java.util包内 图示：集合框架全图 简图1：Collection接口继承树 简图2：Map接口继承树 1.4 集合的使用场景 2. Collection接口及方法 JDK不提供此接口的任何直接实现，而是提供更具体的子接口（如：Set和List）去实现。 Collection 接口是 List和Set接口的父接口，该接口里定义的方法既可用于操作 Set 集合，也可用于操作 List 集合。方法如下： 2.1 添加（1）add(E obj)：添加元素对象到当前集合中（2）addAll(Collection other)：添加other集合中的所有元素对象到当前集合中，即this &#x3D; this ∪ other 注意：add和addAll的区别 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package com.atguigu.collection;import org.junit.Test;import java.util.ArrayList;import java.util.Collection;public class TestCollectionAdd &#123; @Test public void testAdd()&#123; //ArrayList是Collection的子接口List的实现类之一。 Collection coll = new ArrayList(); coll.add(&quot;小李广&quot;); coll.add(&quot;扫地僧&quot;); coll.add(&quot;石破天&quot;); System.out.println(coll); &#125; @Test public void testAddAll()&#123; Collection c1 = new ArrayList(); c1.add(1); c1.add(2); System.out.println(&quot;c1集合元素的个数：&quot; + c1.size());//2 System.out.println(&quot;c1 = &quot; + c1); Collection c2 = new ArrayList(); c2.add(1); c2.add(2); System.out.println(&quot;c2集合元素的个数：&quot; + c2.size());//2 System.out.println(&quot;c2 = &quot; + c2); Collection other = new ArrayList(); other.add(1); other.add(2); other.add(3); System.out.println(&quot;other集合元素的个数：&quot; + other.size());//3 System.out.println(&quot;other = &quot; + other); System.out.println(); c1.addAll(other); System.out.println(&quot;c1集合元素的个数：&quot; + c1.size());//5 System.out.println(&quot;c1.addAll(other) = &quot; + c1); c2.add(other); System.out.println(&quot;c2集合元素的个数：&quot; + c2.size());//3 System.out.println(&quot;c2.add(other) = &quot; + c2); &#125;&#125; 注意：coll.addAll(other);与coll.add(other); 2.2 判断（3）int size()：获取当前集合中实际存储的元素个数（4）boolean isEmpty()：判断当前集合是否为空集合（5）boolean contains(Object obj)：判断当前集合中是否存在一个与obj对象equals返回true的元素（6）boolean containsAll(Collection coll)：判断coll集合中的元素是否在当前集合中都存在。即coll集合是否是当前集合的“子集”（7）boolean equals(Object obj)：判断当前集合与obj是否相等 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879package com.atguigu.collection;import org.junit.Test;import java.util.ArrayList;import java.util.Arrays;import java.util.Collection;public class TestCollectionContains &#123; @Test public void test01() &#123; Collection coll = new ArrayList(); System.out.println(&quot;coll在添加元素之前，isEmpty = &quot; + coll.isEmpty()); coll.add(&quot;小李广&quot;); coll.add(&quot;扫地僧&quot;); coll.add(&quot;石破天&quot;); coll.add(&quot;佛地魔&quot;); System.out.println(&quot;coll的元素个数&quot; + coll.size()); System.out.println(&quot;coll在添加元素之后，isEmpty = &quot; + coll.isEmpty()); &#125; @Test public void test02() &#123; Collection coll = new ArrayList(); coll.add(&quot;小李广&quot;); coll.add(&quot;扫地僧&quot;); coll.add(&quot;石破天&quot;); coll.add(&quot;佛地魔&quot;); System.out.println(&quot;coll = &quot; + coll); System.out.println(&quot;coll是否包含“小李广” = &quot; + coll.contains(&quot;小李广&quot;)); System.out.println(&quot;coll是否包含“宋红康” = &quot; + coll.contains(&quot;宋红康&quot;)); Collection other = new ArrayList(); other.add(&quot;小李广&quot;); other.add(&quot;扫地僧&quot;); other.add(&quot;尚硅谷&quot;); System.out.println(&quot;other = &quot; + other); System.out.println(&quot;coll.containsAll(other) = &quot; + coll.containsAll(other)); &#125; @Test public void test03()&#123; Collection c1 = new ArrayList(); c1.add(1); c1.add(2); System.out.println(&quot;c1集合元素的个数：&quot; + c1.size());//2 System.out.println(&quot;c1 = &quot; + c1); Collection c2 = new ArrayList(); c2.add(1); c2.add(2); System.out.println(&quot;c2集合元素的个数：&quot; + c2.size());//2 System.out.println(&quot;c2 = &quot; + c2); Collection other = new ArrayList(); other.add(1); other.add(2); other.add(3); System.out.println(&quot;other集合元素的个数：&quot; + other.size());//3 System.out.println(&quot;other = &quot; + other); System.out.println(); c1.addAll(other); System.out.println(&quot;c1集合元素的个数：&quot; + c1.size());//5 System.out.println(&quot;c1.addAll(other) = &quot; + c1); System.out.println(&quot;c1.contains(other) = &quot; + c1.contains(other)); System.out.println(&quot;c1.containsAll(other) = &quot; + c1.containsAll(other)); System.out.println(); c2.add(other); System.out.println(&quot;c2集合元素的个数：&quot; + c2.size()); System.out.println(&quot;c2.add(other) = &quot; + c2); System.out.println(&quot;c2.contains(other) = &quot; + c2.contains(other)); System.out.println(&quot;c2.containsAll(other) = &quot; + c2.containsAll(other)); &#125;&#125; 2.3 删除（8）void clear()：清空集合元素（9） boolean remove(Object obj) ：从当前集合中删除第一个找到的与obj对象equals返回true的元素。（10）boolean removeAll(Collection coll)：从当前集合中删除所有与coll集合中相同的元素。即this &#x3D; this - this ∩ coll（11）boolean retainAll(Collection coll)：从当前集合中删除两个集合中不同的元素，使得当前集合仅保留与coll集合中的元素相同的元素，即当前集合中仅保留两个集合的交集，即this &#x3D; this ∩ coll； 注意几种删除方法的区别 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566package com.atguigu.collection;import org.junit.Test;import java.util.ArrayList;import java.util.Collection;import java.util.function.Predicate;public class TestCollectionRemove &#123; @Test public void test01()&#123; Collection coll = new ArrayList(); coll.add(&quot;小李广&quot;); coll.add(&quot;扫地僧&quot;); coll.add(&quot;石破天&quot;); coll.add(&quot;佛地魔&quot;); System.out.println(&quot;coll = &quot; + coll); coll.remove(&quot;小李广&quot;); System.out.println(&quot;删除元素\\&quot;小李广\\&quot;之后coll = &quot; + coll); coll.clear(); System.out.println(&quot;coll清空之后，coll = &quot; + coll); &#125; @Test public void test02() &#123; Collection coll = new ArrayList(); coll.add(&quot;小李广&quot;); coll.add(&quot;扫地僧&quot;); coll.add(&quot;石破天&quot;); coll.add(&quot;佛地魔&quot;); System.out.println(&quot;coll = &quot; + coll); Collection other = new ArrayList(); other.add(&quot;小李广&quot;); other.add(&quot;扫地僧&quot;); other.add(&quot;尚硅谷&quot;); System.out.println(&quot;other = &quot; + other); coll.removeAll(other); System.out.println(&quot;coll.removeAll(other)之后，coll = &quot; + coll); System.out.println(&quot;coll.removeAll(other)之后，other = &quot; + other); &#125; @Test public void test03() &#123; Collection coll = new ArrayList(); coll.add(&quot;小李广&quot;); coll.add(&quot;扫地僧&quot;); coll.add(&quot;石破天&quot;); coll.add(&quot;佛地魔&quot;); System.out.println(&quot;coll = &quot; + coll); Collection other = new ArrayList(); other.add(&quot;小李广&quot;); other.add(&quot;扫地僧&quot;); other.add(&quot;尚硅谷&quot;); System.out.println(&quot;other = &quot; + other); coll.retainAll(other); System.out.println(&quot;coll.retainAll(other)之后，coll = &quot; + coll); System.out.println(&quot;coll.retainAll(other)之后，other = &quot; + other); &#125;&#125; 2.4 其它（12）Object[] toArray()：返回包含当前集合中所有元素的数组（13）hashCode()：获取集合对象的哈希值（14）iterator()：返回迭代器对象，用于集合遍历 12345678910111213141516171819public class TestCollectionContains &#123; @Test public void test01() &#123; Collection coll = new ArrayList(); coll.add(&quot;小李广&quot;); coll.add(&quot;扫地僧&quot;); coll.add(&quot;石破天&quot;); coll.add(&quot;佛地魔&quot;); //集合转换为数组：集合的toArray()方法 Object[] objects = coll.toArray(); System.out.println(&quot;用数组返回coll中所有元素：&quot; + Arrays.toString(objects)); //对应的，数组转换为集合：调用Arrays的asList(Object ...objs) Object[] arr1 = new Object[]&#123;123,&quot;AA&quot;,&quot;CC&quot;&#125;; Collection list = Arrays.asList(arr1); System.out.println(list); &#125;&#125; 3. Iterator(迭代器)接口3.1 Iterator接口 在程序开发中，经常需要遍历集合中的所有元素。针对这种需求，JDK专门提供了一个接口java.util.Iterator。Iterator接口也是Java集合中的一员，但它与Collection、Map接口有所不同。 Collection接口与Map接口主要用于存储元素 Iterator，被称为迭代器接口，本身并不提供存储对象的能力，主要用于遍历Collection中的元素 Collection接口继承了java.lang.Iterable接口，该接口有一个iterator()方法，那么所有实现了Collection接口的集合类都有一个iterator()方法，用以返回一个实现了Iterator接口的对象。 public Iterator iterator(): 获取集合对应的迭代器，用来遍历集合中的元素的。 集合对象每次调用iterator()方法都得到一个全新的迭代器对象，默认游标都在集合的第一个元素之前。 Iterator接口的常用方法如下： public E next():返回迭代的下一个元素。 public boolean hasNext():如果仍有元素可以迭代，则返回 true。 注意：在调用it.next()方法之前必须要调用it.hasNext()进行检测。若不调用，且下一条记录无效，直接调用it.next()会抛出NoSuchElementException异常。 举例： 12345678910111213141516171819202122232425262728293031323334353637package com.atguigu.iterator;import org.junit.Test;import java.util.ArrayList;import java.util.Collection;import java.util.Iterator;public class TestIterator &#123; @Test public void test01()&#123; Collection coll = new ArrayList(); coll.add(&quot;小李广&quot;); coll.add(&quot;扫地僧&quot;); coll.add(&quot;石破天&quot;); Iterator iterator = coll.iterator(); System.out.println(iterator.next()); System.out.println(iterator.next()); System.out.println(iterator.next()); System.out.println(iterator.next()); //报NoSuchElementException异常 &#125; @Test public void test02()&#123; Collection coll = new ArrayList(); coll.add(&quot;小李广&quot;); coll.add(&quot;扫地僧&quot;); coll.add(&quot;石破天&quot;); Iterator iterator = coll.iterator();//获取迭代器对象 while(iterator.hasNext()) &#123;//判断是否还有元素可迭代 System.out.println(iterator.next());//取出下一个元素 &#125; &#125;&#125; 3.2 迭代器的执行原理Iterator迭代器对象在遍历集合时，内部采用指针的方式来跟踪集合中的元素，接下来通过一个图例来演示Iterator对象迭代元素的过程： 使用Iterator迭代器删除元素：java.util.Iterator迭代器中有一个方法：void remove() ; 1234567Iterator iter = coll.iterator();//回到起点while(iter.hasNext())&#123; Object obj = iter.next(); if(obj.equals(&quot;Tom&quot;))&#123; iter.remove(); &#125;&#125; 注意： Iterator可以删除集合的元素，但是遍历过程中通过迭代器对象的remove方法，不是集合对象的remove方法。 如果还未调用next()或在上一次调用 next() 方法之后已经调用了 remove() 方法，再调用remove()都会报IllegalStateException。 Collection已经有remove(xx)方法了，为什么Iterator迭代器还要提供删除方法呢？因为迭代器的remove()可以按指定的条件进行删除。 例如：要删除以下集合元素中的偶数 123456789101112131415161718192021222324252627282930package com.atguigu.iterator;import org.junit.Test;import java.util.ArrayList;import java.util.Collection;import java.util.Iterator;public class TestIteratorRemove &#123; @Test public void test01()&#123; Collection coll = new ArrayList(); coll.add(1); coll.add(2); coll.add(3); coll.add(4); coll.add(5); coll.add(6); Iterator iterator = coll.iterator(); while(iterator.hasNext())&#123; Integer element = (Integer) iterator.next(); if(element % 2 == 0)&#123; iterator.remove(); &#125; &#125; System.out.println(coll); &#125;&#125; 在JDK8.0时，Collection接口有了removeIf 方法，即可以根据条件删除。（第18章中再讲） 12345678910111213141516171819202122232425262728package com.atguigu.collection;import org.junit.Test;import java.util.ArrayList;import java.util.Collection;import java.util.function.Predicate;public class TestCollectionRemoveIf &#123; @Test public void test01()&#123; Collection coll = new ArrayList(); coll.add(&quot;小李广&quot;); coll.add(&quot;扫地僧&quot;); coll.add(&quot;石破天&quot;); coll.add(&quot;佛地魔&quot;); System.out.println(&quot;coll = &quot; + coll); coll.removeIf(new Predicate() &#123; @Override public boolean test(Object o) &#123; String str = (String) o; return str.contains(&quot;地&quot;); &#125; &#125;); System.out.println(&quot;删除包含\\&quot;地\\&quot;字的元素之后coll = &quot; + coll); &#125;&#125; 3.3 foreach循环 foreach循环（也称增强for循环）是 JDK5.0 中定义的一个高级for循环，专门用来遍历数组和集合的。 foreach循环的语法格式： 1234for(元素的数据类型 局部变量 : Collection集合或数组)&#123; //操作局部变量的输出操作&#125;//这里局部变量就是一个临时变量，自己命名就可以 举例： 1234567891011121314151617181920212223242526272829303132package com.atguigu.iterator;import org.junit.Test;import java.util.ArrayList;import java.util.Collection;public class TestForeach &#123; @Test public void test01()&#123; Collection coll = new ArrayList(); coll.add(&quot;小李广&quot;); coll.add(&quot;扫地僧&quot;); coll.add(&quot;石破天&quot;); //foreach循环其实就是使用Iterator迭代器来完成元素的遍历的。 for (Object o : coll) &#123; System.out.println(o); &#125; &#125; @Test public void test02()&#123; int[] nums = &#123;1,2,3,4,5&#125;; for (int num : nums) &#123; System.out.println(num); &#125; System.out.println(&quot;-----------------&quot;); String[] names = &#123;&quot;张三&quot;,&quot;李四&quot;,&quot;王五&quot;&#125;; for (String name : names) &#123; System.out.println(name); &#125; &#125;&#125; 对于集合的遍历，增强for的内部原理其实是个Iterator迭代器。如下图。 它用于遍历Collection和数组。通常只进行遍历元素，不要在遍历的过程中对集合元素进行增删操作。 练习：判断输出结果为何？ 12345678910111213public class ForTest &#123; public static void main(String[] args) &#123; String[] str = new String[5]; for (String myStr : str) &#123; myStr = &quot;atguigu&quot;; System.out.println(myStr); &#125; for (int i = 0; i &lt; str.length; i++) &#123; System.out.println(str[i]); &#125; &#125;&#125; 4. Collection子接口1：List4.1 List接口特点 鉴于Java中数组用来存储数据的局限性，我们通常使用java.util.List替代数组 List集合类中元素有序、且可重复，集合中的每个元素都有其对应的顺序索引。 举例：List集合存储数据，就像银行门口客服，给每一个来办理业务的客户分配序号：第一个来的是“张三”，客服给他分配的是0；第二个来的是“李四”，客服给他分配的1；以此类推，最后一个序号应该是“总人数-1”。 JDK API中List接口的实现类常用的有：ArrayList、LinkedList和Vector。 4.2 List接口方法List除了从Collection集合继承的方法外，List 集合里添加了一些根据索引来操作集合元素的方法。 插入元素 void add(int index, Object ele):在index位置插入ele元素 boolean addAll(int index, Collection eles):从index位置开始将eles中的所有元素添加进来 获取元素 Object get(int index):获取指定index位置的元素 List subList(int fromIndex, int toIndex):返回从fromIndex到toIndex位置的子集合 获取元素索引 int indexOf(Object obj):返回obj在集合中首次出现的位置 int lastIndexOf(Object obj):返回obj在当前集合中末次出现的位置 删除和替换元素 Object remove(int index):移除指定index位置的元素，并返回此元素 Object set(int index, Object ele):设置指定index位置的元素为ele 举例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.atguigu.list;import java.util.ArrayList;import java.util.List;public class TestListMethod &#123; public static void main(String[] args) &#123; // 创建List集合对象 List&lt;String&gt; list = new ArrayList&lt;String&gt;(); // 往 尾部添加 指定元素 list.add(&quot;图图&quot;); list.add(&quot;小美&quot;); list.add(&quot;不高兴&quot;); System.out.println(list); // add(int index,String s) 往指定位置添加 list.add(1,&quot;没头脑&quot;); System.out.println(list); // String remove(int index) 删除指定位置元素 返回被删除元素 // 删除索引位置为2的元素 System.out.println(&quot;删除索引位置为2的元素&quot;); System.out.println(list.remove(2)); System.out.println(list); // String set(int index,String s) // 在指定位置 进行 元素替代（改） // 修改指定位置元素 list.set(0, &quot;三毛&quot;); System.out.println(list); // String get(int index) 获取指定位置元素 // 跟size() 方法一起用 来 遍历的 for(int i = 0;i&lt;list.size();i++)&#123; System.out.println(list.get(i)); &#125; //还可以使用增强for for (String string : list) &#123; System.out.println(string); &#125; &#125;&#125; 注意：在JavaSE中List名称的类型有两个，一个是java.util.List集合接口，一个是java.awt.List图形界面的组件，别导错包了。 4.3 List接口主要实现类：ArrayList ArrayList 是 List 接口的主要实现类 本质上，ArrayList是对象引用的一个”变长”数组 Arrays.asList(…) 方法返回的 List 集合，既不是 ArrayList 实例，也不是 Vector 实例。 Arrays.asList(…) 返回值是一个固定长度的 List 集合 4.4 List的实现类之二：LinkedList 对于频繁的插入或删除元素的操作，建议使用LinkedList类，效率较高。这是由底层采用链表（双向链表）结构存储数据决定的。 特有方法： void addFirst(Object obj) void addLast(Object obj) Object getFirst() Object getLast() Object removeFirst() Object removeLast() 4.5 List的实现类之三：Vector Vector 是一个古老的集合，JDK1.0就有了。大多数操作与ArrayList相同，区别之处在于Vector是线程安全的。 在各种List中，最好把ArrayList作为默认选择。当插入、删除频繁时，使用LinkedList；Vector总是比ArrayList慢，所以尽量避免使用。 特有方法： void addElement(Object obj) void insertElementAt(Object obj,int index) void setElementAt(Object obj,int index) void removeElement(Object obj) void removeAllElements() 4.6 练习面试题： 1234567891011121314@Testpublic void testListRemove() &#123; List list = new ArrayList(); list.add(1); list.add(2); list.add(3); updateList(list); System.out.println(list);//[1,2]&#125;private static void updateList(List list) &#123; list.remove(2); &#125; 练习1： 定义学生类，属性为姓名、年龄，提供必要的getter、setter方法，构造器，toString()，equals()方法。 使用ArrayList集合，保存录入的多个学生对象。 循环录入的方式，1：继续录入，0：结束录入。 录入结束后，用foreach遍历集合。 代码实现，效果如图所示： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778package com.atguigu.test01;import java.util.ArrayList;import java.util.Scanner;public class StudentTest &#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); ArrayList stuList = new ArrayList(); for (;;) &#123; System.out.println(&quot;选择（录入 1 ；结束 0）&quot;); int x = scanner.nextInt();//根据x的值，判断是否需要继续循环 if (x == 1) &#123; System.out.println(&quot;姓名&quot;); String name = scanner.next(); System.out.println(&quot;年龄&quot;); int age = scanner.nextInt(); Student stu = new Student(age, name); stuList.add(stu); &#125; else if (x == 0) &#123; break; &#125; else &#123; System.out.println(&quot;输入有误，请重新输入&quot;); &#125; &#125; for (Object stu : stuList) &#123; System.out.println(stu); &#125; &#125;&#125;public class Student &#123; private int age; private String name; public Student() &#123; &#125; public Student(int age, String name) &#123; super(); this.age = age; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; @Override public String toString() &#123; return &quot;Student [age=&quot; + age + &quot;, name=&quot; + name + &quot;]&quot;; &#125;&#125; 练习2： ​ 1、请定义方法public static int listTest(Collection list,String s)统计集合中指定元素出现的次数 ​ 2、创建集合，集合存放随机生成的30个小写字母 ​ 3、用listTest统计，a、b、c、x元素的出现次数 ​ 4、效果如下 12345678910111213141516171819202122232425262728293031package com.atguigu.test02;import java.util.ArrayList;import java.util.Collection;import java.util.Random;public class Test02 &#123; public static void main(String[] args) &#123; Collection list = new ArrayList(); Random rand = new Random(); for (int i = 0; i &lt; 30; i++) &#123; list.add((char)(rand.nextInt(26)+97)+&quot;&quot;); &#125; System.out.println(list); System.out.println(&quot;a:&quot;+listTest(list, &quot;a&quot;)); System.out.println(&quot;b:&quot;+listTest(list, &quot;b&quot;)); System.out.println(&quot;c:&quot;+listTest(list, &quot;c&quot;)); System.out.println(&quot;x:&quot;+listTest(list, &quot;x&quot;)); &#125; public static int listTest(Collection list, String string) &#123; int count = 0; for (Object object : list) &#123; if(string.equals(object))&#123; count++; &#125; &#125; return count; &#125;&#125; 练习3：KTV点歌系统 描述 分别使用ArrayList和LinkedList集合，编写一个**KTV点歌系统**的程序。在程序中： 指令1代表添加歌曲 指令2代表将所选歌曲置顶 指令3代表将所选歌曲提前一位 指令4代表退出该系统 要求根据用户输入的指令和歌曲名展现歌曲列表。例如输入指令1，输入歌曲名”爱你一万年”，则输出“当前歌曲列表：[爱你一万年]”。 提示 为了指引用户操作，首先要将各个指令所表示的含义打印到控制台 12345System.out.println(&quot;-------------欢迎来到点歌系统------------&quot;);System.out.println(&quot;1.添加歌曲至列表&quot;);System.out.println(&quot;2.将歌曲置顶&quot;);System.out.println(&quot;3.将歌曲前移一位&quot;);System.out.println(&quot;4.退出&quot;); 程序中需要创建一个集合作为歌曲列表，并向其添加一部分歌曲 通过ArrayList或LinkedList集合定义的方法操作歌曲列表 代码 使用ArrayList集合模拟点歌系统的实现代码，如下所示： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495/** * @author 尚硅谷-宋红康 * @create 20:26 */public class KTVByArrayList &#123; private static ArrayList musicList = new ArrayList();// 创建歌曲列表 private static Scanner sc = new Scanner(System.in); public static void main(String[] args) &#123; addMusicList();// 添加一部分歌曲至歌曲列表 boolean flag = true; while (flag) &#123; System.out.println(&quot;当前歌曲列表：&quot; + musicList); System.out.println(&quot;-------------欢迎来到点歌系统------------&quot;); System.out.println(&quot;1.添加歌曲至列表&quot;); System.out.println(&quot;2.将歌曲置顶&quot;); System.out.println(&quot;3.将歌曲前移一位&quot;); System.out.println(&quot;4.退出&quot;); System.out.print(&quot;请输入操作序号：&quot;); int key = sc.nextInt();// //接收键盘输入的功能选项序号 // 执行序号对应的功能 switch (key) &#123; case 1:// 添加歌曲至列表 addMusic(); break; case 2:// 将歌曲置顶 setTop(); break; case 3:// 将歌曲前移一位 setBefore(); break; case 4:// 退出 System.out.println(&quot;----------------退出---------------&quot;); System.out.println(&quot;您已退出系统&quot;); flag = false; break; default: System.out.println(&quot;----------------------------------&quot;); System.out.println(&quot;功能选择有误，请输入正确的功能序号!&quot;); break; &#125; &#125; &#125; // 初始时添加歌曲名称 private static void addMusicList() &#123; musicList.add(&quot;本草纲目&quot;); musicList.add(&quot;你是我的眼&quot;); musicList.add(&quot;老男孩&quot;); musicList.add(&quot;白月光与朱砂痣&quot;); musicList.add(&quot;不谓侠&quot;); musicList.add(&quot;爱你&quot;); &#125; // 执行添加歌曲 private static void addMusic() &#123; System.out.print(&quot;请输入要添加的歌曲名称：&quot;); String musicName = sc.next();// 获取键盘输入内容 musicList.add(musicName);// 添加歌曲到列表的最后 System.out.println(&quot;已添加歌曲：&quot; + musicName); &#125; // 执行将歌曲置顶 private static void setTop() &#123; System.out.print(&quot;请输入要置顶的歌曲名称：&quot;); String musicName = sc.next();// 获取键盘输入内容 int musicIndex = musicList.indexOf(musicName);// 查找指定歌曲位置 if (musicIndex &lt; 0) &#123;// 判断输入歌曲是否存在 System.out.println(&quot;当前列表中没有输入的歌曲！&quot;); &#125;else if(musicIndex == 0)&#123; System.out.println(&quot;当前歌曲默认已置顶！&quot;); &#125;else &#123; musicList.remove(musicName);// 移除指定的歌曲 musicList.add(0, musicName);// 将指定的歌曲放到第一位 System.out.println(&quot;已将歌曲《&quot; + musicName + &quot;》置顶&quot;); &#125; &#125; // 执行将歌曲置前一位 private static void setBefore() &#123; System.out.print(&quot;请输入要置前的歌曲名称：&quot;); String musicName = sc.next();// 获取键盘输入内容 int musicIndex = musicList.indexOf(musicName);// 查找指定歌曲位置 if (musicIndex &lt; 0) &#123;// 判断输入歌曲是否存在 System.out.println(&quot;当前列表中没有输入的歌曲！&quot;); &#125; else if (musicIndex == 0) &#123;// 判断歌曲是否已在第一位 System.out.println(&quot;当前歌曲已在最顶部！&quot;); &#125; else &#123; musicList.remove(musicName);// 移除指定的歌曲 musicList.add(musicIndex - 1, musicName);// 将指定的歌曲放到前一位 System.out.println(&quot;已将歌曲《&quot; + musicName + &quot;》置前一位&quot;); &#125; &#125;&#125; 5. Collection子接口2：Set5.1 Set接口概述 Set接口是Collection的子接口，Set接口相较于Collection接口没有提供额外的方法 Set 集合不允许包含相同的元素，如果试把两个相同的元素加入同一个 Set 集合中，则添加操作失败。 Set集合支持的遍历方式和Collection集合一样：foreach和Iterator。 Set的常用实现类有：HashSet、TreeSet、LinkedHashSet。 5.2 Set主要实现类：HashSet5.2.1 HashSet概述 HashSet 是 Set 接口的主要实现类，大多数时候使用 Set 集合时都使用这个实现类。 HashSet 按 Hash 算法来存储集合中的元素，因此具有很好的存储、查找、删除性能。 HashSet 具有以下特点： 不能保证元素的排列顺序 HashSet 不是线程安全的 集合元素可以是 null HashSet 集合判断两个元素相等的标准：两个对象通过 hashCode() 方法得到的哈希值相等，并且两个对象的 equals() 方法返回值为true。 对于存放在Set容器中的对象，对应的类一定要重写hashCode()和equals(Object obj)方法，以实现对象相等规则。即：“相等的对象必须具有相等的散列码”。 HashSet集合中元素的无序性，不等同于随机性。这里的无序性与元素的添加位置有关。具体来说：我们在添加每一个元素到数组中时，具体的存储位置是由元素的hashCode()调用后返回的hash值决定的。导致在数组中每个元素不是依次紧密存放的，表现出一定的无序性。 5.2.2 HashSet中添加元素的过程： 第1步：当向 HashSet 集合中存入一个元素时，HashSet 会调用该对象的 hashCode() 方法得到该对象的 hashCode值，然后根据 hashCode值，通过某个散列函数决定该对象在 HashSet 底层数组中的存储位置。 第2步：如果要在数组中存储的位置上没有元素，则直接添加成功。 第3步：如果要在数组中存储的位置上有元素，则继续比较： 如果两个元素的hashCode值不相等，则添加成功； 如果两个元素的hashCode()值相等，则会继续调用equals()方法： 如果equals()方法结果为false，则添加成功。 如果equals()方法结果为true，则添加失败。 第2步添加成功，元素会保存在底层数组中。 第3步两种添加成功的操作，由于该底层数组的位置已经有元素了，则会通过链表的方式继续链接，存储。 举例： 123456789101112131415161718192021222324252627282930313233343536373839package com.atguigu.set;import java.util.Objects;public class MyDate &#123; private int year; private int month; private int day; public MyDate(int year, int month, int day) &#123; this.year = year; this.month = month; this.day = day; &#125; @Override public boolean equals(Object o) &#123; if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; MyDate myDate = (MyDate) o; return year == myDate.year &amp;&amp; month == myDate.month &amp;&amp; day == myDate.day; &#125; @Override public int hashCode() &#123; return Objects.hash(year, month, day); &#125; @Override public String toString() &#123; return &quot;MyDate&#123;&quot; + &quot;year=&quot; + year + &quot;, month=&quot; + month + &quot;, day=&quot; + day + &#x27;&#125;&#x27;; &#125;&#125; 1234567891011121314151617181920212223242526272829303132package com.atguigu.set;import org.junit.Test;import java.util.HashSet;public class TestHashSet &#123; @Test public void test01()&#123; HashSet set = new HashSet(); set.add(&quot;张三&quot;); set.add(&quot;张三&quot;); set.add(&quot;李四&quot;); set.add(&quot;王五&quot;); set.add(&quot;王五&quot;); set.add(&quot;赵六&quot;); System.out.println(&quot;set = &quot; + set);//不允许重复，无序 &#125; @Test public void test02()&#123; HashSet set = new HashSet(); set.add(new MyDate(2021,1,1)); set.add(new MyDate(2021,1,1)); set.add(new MyDate(2022,2,4)); set.add(new MyDate(2022,2,4)); System.out.println(&quot;set = &quot; + set);//不允许重复，无序 &#125;&#125; 5.2.3 重写 hashCode() 方法的基本原则 在程序运行时，同一个对象多次调用 hashCode() 方法应该返回相同的值。 当两个对象的 equals() 方法比较返回 true 时，这两个对象的 hashCode() 方法的返回值也应相等。 对象中用作 equals() 方法比较的 Field，都应该用来计算 hashCode 值。 注意：如果两个元素的 equals() 方法返回 true，但它们的 hashCode() 返回值不相等，hashSet 将会把它们存储在不同的位置，但依然可以添加成功。 5.2.4 重写equals()方法的基本原则 重写equals方法的时候一般都需要同时复写hashCode方法。通常参与计算hashCode的对象的属性也应该参与到equals()中进行计算。 推荐：开发中直接调用Eclipse&#x2F;IDEA里的快捷键自动重写equals()和hashCode()方法即可。 为什么用Eclipse&#x2F;IDEA复写hashCode方法，有31这个数字？ 1234567首先，选择系数的时候要选择尽量大的系数。因为如果计算出来的hash地址越大，所谓的“冲突”就越少，查找起来效率也会提高。（减少冲突）其次，31只占用5bits,相乘造成数据溢出的概率较小。再次，31可以 由i*31== (i&lt;&lt;5)-1来表示,现在很多虚拟机里面都有做相关优化。（提高算法效率）最后，31是一个素数，素数作用就是如果我用一个数字来乘以这个素数，那么最终出来的结果只能被素数本身和被乘数还有1来整除！(减少冲突) 5.2.5 练习练习1：在List内去除重复数字值，要求尽量简单 123456789101112131415161718public static List duplicateList(List list) &#123; HashSet set = new HashSet(); set.addAll(list); return new ArrayList(set);&#125;public static void main(String[] args) &#123; List list = new ArrayList(); list.add(new Integer(1)); list.add(new Integer(2)); list.add(new Integer(2)); list.add(new Integer(4)); list.add(new Integer(4)); List list2 = duplicateList(list); for (Object integer : list2) &#123; System.out.println(integer); &#125;&#125; 练习2：获取随机数 编写一个程序，获取10个1至20的随机数，要求随机数不能重复。并把最终的随机数输出到控制台。 12345678910111213141516171819202122/** * * @Description * @author 尚硅谷-宋红康 * @date 2022年5月7日上午12:43:01 * */public class RandomValueTest &#123; public static void main(String[] args) &#123; HashSet hs = new HashSet(); // 创建集合对象 Random r = new Random(); while (hs.size() &lt; 10) &#123; int num = r.nextInt(20) + 1; // 生成1到20的随机数 hs.add(num); &#125; for (Integer integer : hs) &#123; // 遍历集合 System.out.println(integer); // 打印每一个元素 &#125; &#125;&#125; 练习3：去重 使用Scanner从键盘读取一行输入，去掉其中重复字符，打印出不同的那些字符。比如：aaaabbbcccddd 1234567891011121314151617181920212223242526/** * * @Description * @author 尚硅谷-宋红康 * @date 2022年5月7日上午12:44:01 * */public class DistinctTest &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); // 创建键盘录入对象 System.out.println(&quot;请输入一行字符串:&quot;); String line = sc.nextLine(); // 将键盘录入的字符串存储在line中 char[] arr = line.toCharArray(); // 将字符串转换成字符数组 HashSet hs = new HashSet(); // 创建HashSet集合对象 for (Object c : arr) &#123; // 遍历字符数组 hs.add(c); // 将字符数组中的字符添加到集合中 &#125; for (Object ch : hs) &#123; // 遍历集合 System.out.print(ch); &#125; &#125;&#125; 练习4：面试题 123456789101112131415161718HashSet set = new HashSet();Person p1 = new Person(1001,&quot;AA&quot;);Person p2 = new Person(1002,&quot;BB&quot;);set.add(p1);set.add(p2);p1.name = &quot;CC&quot;;set.remove(p1);System.out.println(set);set.add(new Person(1001,&quot;CC&quot;));System.out.println(set);set.add(new Person(1001,&quot;AA&quot;));System.out.println(set);//其中Person类中重写了hashCode()和equal()方法 5.3 Set实现类之二：LinkedHashSet LinkedHashSet 是 HashSet 的子类，不允许集合元素重复。 LinkedHashSet 根据元素的 hashCode 值来决定元素的存储位置，但它同时使用双向链表维护元素的次序，这使得元素看起来是以添加顺序保存的。 LinkedHashSet插入性能略低于 HashSet，但在迭代访问 Set 里的全部元素时有很好的性能。 举例： 1234567891011121314151617181920package com.atguigu.set;import org.junit.Test;import java.util.LinkedHashSet;public class TestLinkedHashSet &#123; @Test public void test01()&#123; LinkedHashSet set = new LinkedHashSet(); set.add(&quot;张三&quot;); set.add(&quot;张三&quot;); set.add(&quot;李四&quot;); set.add(&quot;王五&quot;); set.add(&quot;王五&quot;); set.add(&quot;赵六&quot;); System.out.println(&quot;set = &quot; + set);//不允许重复，体现添加顺序 &#125;&#125; 5.4 Set实现类之三：TreeSet5.4.1 TreeSet概述 TreeSet 是 SortedSet 接口的实现类，TreeSet 可以按照添加的元素的指定的属性的大小顺序进行遍历。 TreeSet底层使用红黑树结构存储数据 新增的方法如下： (了解) Comparator comparator() Object first() Object last() Object lower(Object e) Object higher(Object e) SortedSet subSet(fromElement, toElement) SortedSet headSet(toElement) SortedSet tailSet(fromElement) TreeSet特点：不允许重复、实现排序（自然排序或定制排序） TreeSet 两种排序方法：自然排序和定制排序。默认情况下，TreeSet 采用自然排序。 自然排序：TreeSet 会调用集合元素的 compareTo(Object obj) 方法来比较元素之间的大小关系，然后将集合元素按升序(默认情况)排列。 如果试图把一个对象添加到 TreeSet 时，则该对象的类必须实现 Comparable 接口。 实现 Comparable 的类必须实现 compareTo(Object obj) 方法，两个对象即通过 compareTo(Object obj) 方法的返回值来比较大小。 定制排序：如果元素所属的类没有实现Comparable接口，或不希望按照升序(默认情况)的方式排列元素或希望按照其它属性大小进行排序，则考虑使用定制排序。定制排序，通过Comparator接口来实现。需要重写compare(T o1,T o2)方法。 利用int compare(T o1,T o2)方法，比较o1和o2的大小：如果方法返回正整数，则表示o1大于o2；如果返回0，表示相等；返回负整数，表示o1小于o2。 要实现定制排序，需要将实现Comparator接口的实例作为形参传递给TreeSet的构造器。 因为只有相同类的两个实例才会比较大小，所以向 TreeSet 中添加的应该是同一个类的对象。 对于 TreeSet 集合而言，它判断两个对象是否相等的唯一标准是：两个对象通过 compareTo(Object obj) 或compare(Object o1,Object o2)方法比较返回值。返回值为0，则认为两个对象相等。 5.4.2 举例举例1： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package com.atguigu.set;import org.junit.Test;import java.util.Iterator;import java.util.TreeSet;/** * @author 尚硅谷-宋红康 * @create 14:22 */public class TreeSetTest &#123; /* * 自然排序：针对String类的对象 * */ @Test public void test1()&#123; TreeSet set = new TreeSet(); set.add(&quot;MM&quot;); set.add(&quot;CC&quot;); set.add(&quot;AA&quot;); set.add(&quot;DD&quot;); set.add(&quot;ZZ&quot;); //set.add(123); //报ClassCastException的异常 Iterator iterator = set.iterator(); while(iterator.hasNext())&#123; System.out.println(iterator.next()); &#125; &#125; /* * 自然排序：针对User类的对象 * */ @Test public void test2()&#123; TreeSet set = new TreeSet(); set.add(new User(&quot;Tom&quot;,12)); set.add(new User(&quot;Rose&quot;,23)); set.add(new User(&quot;Jerry&quot;,2)); set.add(new User(&quot;Eric&quot;,18)); set.add(new User(&quot;Tommy&quot;,44)); set.add(new User(&quot;Jim&quot;,23)); set.add(new User(&quot;Maria&quot;,18)); //set.add(&quot;Tom&quot;); Iterator iterator = set.iterator(); while(iterator.hasNext())&#123; System.out.println(iterator.next()); &#125; System.out.println(set.contains(new User(&quot;Jack&quot;, 23))); //true &#125;&#125; 其中，User类定义如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243/** * @author 尚硅谷-宋红康 * @create 14:22 */public class User implements Comparable&#123; String name; int age; public User() &#123; &#125; public User(String name, int age) &#123; this.name = name; this.age = age; &#125; @Override public String toString() &#123; return &quot;User&#123;&quot; + &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, age=&quot; + age + &#x27;&#125;&#x27;; &#125; /* 举例：按照age从小到大的顺序排列，如果age相同，则按照name从大到小的顺序排列 * */ public int compareTo(Object o) &#123; if(this == o)&#123; return 0; &#125; if(o instanceof User)&#123; User user = (User)o; int value = this.age - user.age; if(value != 0)&#123; return value; &#125; return -this.name.compareTo(user.name); &#125; throw new RuntimeException(&quot;输入的类型不匹配&quot;); &#125;&#125; 举例2： 12345678910111213141516171819202122232425262728293031323334/* * 定制排序 * */@Testpublic void test3()&#123; //按照User的姓名的从小到大的顺序排列 Comparator comparator = new Comparator() &#123; @Override public int compare(Object o1, Object o2) &#123; if(o1 instanceof User &amp;&amp; o2 instanceof User)&#123; User u1 = (User)o1; User u2 = (User)o2; return u1.name.compareTo(u2.name); &#125; throw new RuntimeException(&quot;输入的类型不匹配&quot;); &#125; &#125;; TreeSet set = new TreeSet(comparator); set.add(new User(&quot;Tom&quot;,12)); set.add(new User(&quot;Rose&quot;,23)); set.add(new User(&quot;Jerry&quot;,2)); set.add(new User(&quot;Eric&quot;,18)); set.add(new User(&quot;Tommy&quot;,44)); set.add(new User(&quot;Jim&quot;,23)); set.add(new User(&quot;Maria&quot;,18)); //set.add(new User(&quot;Maria&quot;,28)); Iterator iterator = set.iterator(); while(iterator.hasNext())&#123; System.out.println(iterator.next()); &#125;&#125; 5.4.3 练习练习1：在一个List集合中存储了多个无大小顺序并且有重复的字符串，定义一个方法，让其有序(从小到大排序)，并且不能去除重复元素。 提示：考查ArrayList、TreeSet 1234567891011121314151617181920212223242526272829303132333435363738394041/** * * @Description * @author 尚硅谷-宋红康 * @date 2022年4月7日上午12:50:46 * */public class SortTest &#123; public static void main(String[] args) &#123; ArrayList list = new ArrayList(); list.add(&quot;ccc&quot;); list.add(&quot;ccc&quot;); list.add(&quot;aaa&quot;); list.add(&quot;aaa&quot;); list.add(&quot;bbb&quot;); list.add(&quot;ddd&quot;); list.add(&quot;ddd&quot;); sort(list); System.out.println(list); &#125; /* * 对集合中的元素排序,并保留重复 */ public static void sort(List list) &#123; TreeSet ts = new TreeSet(new Comparator() &#123; @Override public int compare(Object o1, Object o2) &#123; // 重写compare方法 String s1 = (String)o1; String s2 = (String)o2; int num = s1.compareTo(s2); // 比较内容 return num == 0 ? 1 : num; // 如果内容一样返回一个不为0的数字即可 &#125; &#125;); ts.addAll(list); // 将list集合中的所有元素添加到ts中 list.clear(); // 清空list list.addAll(ts); // 将ts中排序并保留重复的结果在添加到list中 &#125;&#125; 练习2：TreeSet的自然排序和定制排序 定义一个Employee类。该类包含：private成员变量name,age,birthday，其中 birthday 为 MyDate 类的对象；并为每一个属性定义 getter, setter 方法；并重写 toString 方法输出 name, age, birthday MyDate类包含:private成员变量year,month,day；并为每一个属性定义 getter, setter 方法； 创建该类的 5 个对象，并把这些对象放入 TreeSet 集合中（下一章：TreeSet 需使用泛型来定义） 分别按以下两种方式对集合中的元素进行排序，并遍历输出： 1). 使Employee 实现 Comparable 接口，并按 name 排序2). 创建 TreeSet 时传入 Comparator对象，按生日日期的先后排序。 代码实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869public class MyDate implements Comparable&#123; private int year; private int month; private int day; public MyDate() &#123; &#125; public MyDate(int year, int month, int day) &#123; this.year = year; this.month = month; this.day = day; &#125; public int getYear() &#123; return year; &#125; public void setYear(int year) &#123; this.year = year; &#125; public int getMonth() &#123; return month; &#125; public void setMonth(int month) &#123; this.month = month; &#125; public int getDay() &#123; return day; &#125; public void setDay(int day) &#123; this.day = day; &#125; @Override public String toString() &#123;// return &quot;MyDate&#123;&quot; +// &quot;year=&quot; + year +// &quot;, month=&quot; + month +// &quot;, day=&quot; + day +// &#x27;&#125;&#x27;; return year + &quot;年&quot; + month + &quot;月&quot; + day + &quot;日&quot;; &#125; @Override public int compareTo(Object o) &#123; if(this == o)&#123; return 0; &#125; if(o instanceof MyDate)&#123; MyDate myDate = (MyDate) o; int yearDistance = this.getYear() - myDate.getYear(); if(yearDistance != 0)&#123; return yearDistance; &#125; int monthDistance = this.getMonth() - myDate.getMonth(); if(monthDistance != 0)&#123; return monthDistance; &#125; return this.getDay() - myDate.getDay(); &#125; throw new RuntimeException(&quot;输入的类型不匹配&quot;); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960public class Employee implements Comparable&#123; private String name; private int age; private MyDate birthday; public Employee() &#123; &#125; public Employee(String name, int age, MyDate birthday) &#123; this.name = name; this.age = age; this.birthday = birthday; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public MyDate getBirthday() &#123; return birthday; &#125; public void setBirthday(MyDate birthday) &#123; this.birthday = birthday; &#125; @Override public String toString() &#123; return &quot;Employee&#123;&quot; + &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, age=&#x27;&quot; + age + &#x27;\\&#x27;&#x27; + &quot;, birthday=&quot; + birthday + &#x27;&#125;&#x27;; &#125; @Override public int compareTo(Object o) &#123; if(o == this)&#123; return 0; &#125; if(o instanceof Employee)&#123; Employee emp = (Employee) o; return this.name.compareTo(emp.name); &#125; throw new RuntimeException(&quot;传入的类型不匹配&quot;); &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586public class EmployeeTest &#123; /* 自然排序： 创建该类的 5 个对象，并把这些对象放入 TreeSet 集合中 * 需求1：使Employee 实现 Comparable 接口，并按 name 排序 * */ @Test public void test1()&#123; TreeSet set = new TreeSet(); Employee e1 = new Employee(&quot;Tom&quot;,23,new MyDate(1999,7,9)); Employee e2 = new Employee(&quot;Rose&quot;,43,new MyDate(1999,7,19)); Employee e3 = new Employee(&quot;Jack&quot;,54,new MyDate(1998,12,21)); Employee e4 = new Employee(&quot;Jerry&quot;,12,new MyDate(2002,4,21)); Employee e5 = new Employee(&quot;Tony&quot;,22,new MyDate(2001,9,12)); set.add(e1); set.add(e2); set.add(e3); set.add(e4); set.add(e5); //遍历 Iterator iterator = set.iterator(); while(iterator.hasNext())&#123; System.out.println(iterator.next()); &#125; &#125; /* * 定制排序： * 创建 TreeSet 时传入 Comparator对象，按生日日期的先后排序。 * */ @Test public void test2()&#123; Comparator comparator = new Comparator() &#123; @Override public int compare(Object o1, Object o2) &#123; if(o1 instanceof Employee &amp;&amp; o2 instanceof Employee)&#123; Employee e1 = (Employee) o1; Employee e2 = (Employee) o2; //对比两个employee的生日的大小 MyDate birth1 = e1.getBirthday(); MyDate birth2 = e2.getBirthday(); //方式1：// int yearDistance = birth1.getYear() - birth2.getYear();// if(yearDistance != 0)&#123;// return yearDistance;// &#125;// int monthDistance = birth1.getMonth() - birth2.getMonth();// if(monthDistance != 0)&#123;// return monthDistance;// &#125;//// return birth1.getDay() - birth2.getDay(); //方式2： return birth1.compareTo(birth2); &#125; throw new RuntimeException(&quot;输入的类型不匹配&quot;); &#125; &#125;; TreeSet set = new TreeSet(comparator); Employee e1 = new Employee(&quot;Tom&quot;,23,new MyDate(1999,7,9)); Employee e2 = new Employee(&quot;Rose&quot;,43,new MyDate(1999,7,19)); Employee e3 = new Employee(&quot;Jack&quot;,54,new MyDate(1998,12,21)); Employee e4 = new Employee(&quot;Jerry&quot;,12,new MyDate(2002,4,21)); Employee e5 = new Employee(&quot;Tony&quot;,22,new MyDate(2001,9,12)); set.add(e1); set.add(e2); set.add(e3); set.add(e4); set.add(e5); //遍历 Iterator iterator = set.iterator(); while(iterator.hasNext())&#123; System.out.println(iterator.next()); &#125; &#125;&#125; 6. Map接口现实生活与开发中，我们常会看到这样的一类集合：用户ID与账户信息、学生姓名与考试成绩、IP地址与主机名等，这种一一对应的关系，就称作映射。Java提供了专门的集合框架用来存储这种映射关系的对象，即java.util.Map接口。 6.1 Map接口概述 Map与Collection并列存在。用于保存具有映射关系的数据：key-value Collection集合称为单列集合，元素是孤立存在的（理解为单身）。 Map集合称为双列集合，元素是成对存在的(理解为夫妻)。 Map 中的 key 和 value 都可以是任何引用类型的数据。但常用String类作为Map的“键”。 Map接口的常用实现类：HashMap、LinkedHashMap、TreeMap和&#96;&#96;Properties。其中，HashMap是 Map 接口使用频率最高&#96;的实现类。 6.2 Map中key-value特点这里主要以HashMap为例说明。HashMap中存储的key、value的特点如下： Map 中的 key用Set来存放，不允许重复，即同一个 Map 对象所对应的类，须重写hashCode()和equals()方法 key 和 value 之间存在单向一对一关系，即通过指定的 key 总能找到唯一的、确定的 value，不同key对应的value可以重复。value所在的类要重写equals()方法。 key和value构成一个entry。所有的entry彼此之间是无序的、不可重复的。 6.2 Map接口的常用方法 添加、修改操作： Object put(Object key,Object value)：将指定key-value添加到(或修改)当前map对象中 void putAll(Map m):将m中的所有key-value对存放到当前map中 删除操作： Object remove(Object key)：移除指定key的key-value对，并返回value void clear()：清空当前map中的所有数据 元素查询的操作： Object get(Object key)：获取指定key对应的value boolean containsKey(Object key)：是否包含指定的key boolean containsValue(Object value)：是否包含指定的value int size()：返回map中key-value对的个数 boolean isEmpty()：判断当前map是否为空 boolean equals(Object obj)：判断当前map和参数对象obj是否相等 元视图操作的方法： Set keySet()：返回所有key构成的Set集合 Collection values()：返回所有value构成的Collection集合 Set entrySet()：返回所有key-value对构成的Set集合 举例： 1234567891011121314151617181920212223242526package com.atguigu.map;import java.util.HashMap;public class TestMapMethod &#123; public static void main(String[] args) &#123; //创建 map对象 HashMap map = new HashMap(); //添加元素到集合 map.put(&quot;黄晓明&quot;, &quot;杨颖&quot;); map.put(&quot;李晨&quot;, &quot;李小璐&quot;); map.put(&quot;李晨&quot;, &quot;范冰冰&quot;); map.put(&quot;邓超&quot;, &quot;孙俪&quot;); System.out.println(map); //删除指定的key-value System.out.println(map.remove(&quot;黄晓明&quot;)); System.out.println(map); //查询指定key对应的value System.out.println(map.get(&quot;邓超&quot;)); System.out.println(map.get(&quot;黄晓明&quot;)); &#125;&#125; 举例： 123456789101112131415161718192021222324252627public static void main(String[] args) &#123; HashMap map = new HashMap(); map.put(&quot;许仙&quot;, &quot;白娘子&quot;); map.put(&quot;董永&quot;, &quot;七仙女&quot;); map.put(&quot;牛郎&quot;, &quot;织女&quot;); map.put(&quot;许仙&quot;, &quot;小青&quot;); System.out.println(&quot;所有的key:&quot;); Set keySet = map.keySet(); for (Object key : keySet) &#123; System.out.println(key); &#125; System.out.println(&quot;所有的value:&quot;); Collection values = map.values(); for (Object value : values) &#123; System.out.println(value); &#125; System.out.println(&quot;所有的映射关系:&quot;); Set entrySet = map.entrySet(); for (Object mapping : entrySet) &#123; //System.out.println(entry); Map.Entry entry = (Map.Entry) mapping; System.out.println(entry.getKey() + &quot;-&gt;&quot; + entry.getValue()); &#125;&#125; 6.3 Map的主要实现类：HashMap6.3.1 HashMap概述 HashMap是 Map 接口使用频率最高的实现类。 HashMap是线程不安全的。允许添加 null 键和 null 值。 存储数据采用的哈希表结构，底层使用一维数组+单向链表+红黑树进行key-value数据的存储。与HashSet一样，元素的存取顺序不能保证一致。 HashMap 判断两个key相等的标准是：两个 key 的hashCode值相等，通过 equals() 方法返回 true。 HashMap 判断两个value相等的标准是：两个 value 通过 equals() 方法返回 true。 6.3.2 练习练习1：添加你喜欢的歌手以及你喜欢他唱过的歌曲 例如： 12345678910111213141516171819202122232425262728293031323334353637383940//方式1/** * @author 尚硅谷-宋红康 * @create 9:03 */public class SingerTest1 &#123; public static void main(String[] args) &#123; //创建一个HashMap用于保存歌手和其歌曲集 HashMap singers = new HashMap(); //声明一组key,value String singer1 = &quot;周杰伦&quot;; ArrayList songs1 = new ArrayList(); songs1.add(&quot;双节棍&quot;); songs1.add(&quot;本草纲目&quot;); songs1.add(&quot;夜曲&quot;); songs1.add(&quot;稻香&quot;); //添加到map中 singers.put(singer1,songs1); //声明一组key,value String singer2 = &quot;陈奕迅&quot;; List songs2 = Arrays.asList(&quot;浮夸&quot;, &quot;十年&quot;, &quot;红玫瑰&quot;, &quot;好久不见&quot;, &quot;孤勇者&quot;); //添加到map中 singers.put(singer2,songs2); //遍历map Set entrySet = singers.entrySet(); for(Object obj : entrySet)&#123; Map.Entry entry = (Map.Entry)obj; String singer = (String) entry.getKey(); List songs = (List) entry.getValue(); System.out.println(&quot;歌手：&quot; + singer); System.out.println(&quot;歌曲有：&quot; + songs); &#125; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124//方式2：改为HashSet实现public class SingerTest2 &#123; @Test public void test1() &#123; Singer singer1 = new Singer(&quot;周杰伦&quot;); Singer singer2 = new Singer(&quot;陈奕迅&quot;); Song song1 = new Song(&quot;双节棍&quot;); Song song2 = new Song(&quot;本草纲目&quot;); Song song3 = new Song(&quot;夜曲&quot;); Song song4 = new Song(&quot;浮夸&quot;); Song song5 = new Song(&quot;十年&quot;); Song song6 = new Song(&quot;孤勇者&quot;); HashSet h1 = new HashSet();// 放歌手一的歌曲 h1.add(song1); h1.add(song2); h1.add(song3); HashSet h2 = new HashSet();// 放歌手二的歌曲 h2.add(song4); h2.add(song5); h2.add(song6); HashMap hashMap = new HashMap();// 放歌手和他对应的歌曲 hashMap.put(singer1, h1); hashMap.put(singer2, h2); for (Object obj : hashMap.keySet()) &#123; System.out.println(obj + &quot;=&quot; + hashMap.get(obj)); &#125; &#125;&#125;//歌曲public class Song implements Comparable&#123; private String songName;//歌名 public Song() &#123; super(); &#125; public Song(String songName) &#123; super(); this.songName = songName; &#125; public String getSongName() &#123; return songName; &#125; public void setSongName(String songName) &#123; this.songName = songName; &#125; @Override public String toString() &#123; return &quot;《&quot; + songName + &quot;》&quot;; &#125; @Override public int compareTo(Object o) &#123; if(o == this)&#123; return 0; &#125; if(o instanceof Song)&#123; Song song = (Song)o; return songName.compareTo(song.getSongName()); &#125; return 0; &#125; &#125;//歌手public class Singer implements Comparable&#123; private String name; private Song song; public Singer() &#123; super(); &#125; public Singer(String name) &#123; super(); this.name = name; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Song getSong() &#123; return song; &#125; public void setSong(Song song) &#123; this.song = song; &#125; @Override public String toString() &#123; return name; &#125; @Override public int compareTo(Object o) &#123; if(o == this)&#123; return 0; &#125; if(o instanceof Singer)&#123; Singer singer = (Singer)o; return name.compareTo(singer.getName()); &#125; return 0; &#125;&#125; 练习2：二级联动 将省份和城市的名称保存在集合中，当用户选择省份以后，二级联动，显示对应省份的地级市供用户选择。 效果演示： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/** * * @Description * @author 尚硅谷-宋红康 Email:shkstart@126.com * @version * @date 2021年5月7日上午12:26:59 * */class CityMap&#123; public static Map model = new HashMap(); static &#123; model.put(&quot;北京&quot;, new String[] &#123;&quot;北京&quot;&#125;); model.put(&quot;上海&quot;, new String[] &#123;&quot;上海&quot;&#125;); model.put(&quot;天津&quot;, new String[] &#123;&quot;天津&quot;&#125;); model.put(&quot;重庆&quot;, new String[] &#123;&quot;重庆&quot;&#125;); model.put(&quot;黑龙江&quot;, new String[] &#123;&quot;哈尔滨&quot;,&quot;齐齐哈尔&quot;,&quot;牡丹江&quot;,&quot;大庆&quot;,&quot;伊春&quot;,&quot;双鸭山&quot;,&quot;绥化&quot;&#125;); model.put(&quot;吉林&quot;, new String[] &#123;&quot;长春&quot;,&quot;延边&quot;,&quot;吉林&quot;,&quot;白山&quot;,&quot;白城&quot;,&quot;四平&quot;,&quot;松原&quot;&#125;); model.put(&quot;河北&quot;, new String[] &#123;&quot;石家庄&quot;,&quot;张家口&quot;,&quot;邯郸&quot;,&quot;邢台&quot;,&quot;唐山&quot;,&quot;保定&quot;,&quot;秦皇岛&quot;&#125;); &#125; &#125;public class ProvinceTest &#123; public static void main(String[] args) &#123; Set keySet = CityMap.model.keySet(); for(Object s : keySet) &#123; System.out.print(s + &quot;\\t&quot;); &#125; System.out.println(); System.out.println(&quot;请选择你所在的省份：&quot;); Scanner scan = new Scanner(System.in); String province = scan.next(); String[] citys = (String[])CityMap.model.get(province); for(String city : citys) &#123; System.out.print(city + &quot;\\t&quot;); &#125; System.out.println(); System.out.println(&quot;请选择你所在的城市：&quot;); String city = scan.next(); System.out.println(&quot;信息登记完毕&quot;); &#125; &#125; 练习3：WordCount统计 需求：统计字符串中每个字符出现的次数 String str &#x3D; “aaaabbbcccccccccc”; 提示： char[] arr &#x3D; str.toCharArray(); &#x2F;&#x2F;将字符串转换成字符数组 HashMap hm &#x3D; new HashMap(); &#x2F;&#x2F;创建双列集合存储键和值，键放字符，值放次数 12345678910111213141516171819202122232425262728/** * * @author 尚硅谷-宋红康 * @date 2022年5月7日上午12:26:59 * */public class WordCountTest &#123; public static void main(String[] args) &#123; String str = &quot;aaaabbbcccccccccc&quot;; char[] arr = str.toCharArray(); // 将字符串转换成字符数组 HashMap map = new HashMap(); // 创建双列集合存储键和值 for (char c : arr) &#123; // 遍历字符数组 if (!map.containsKey(c)) &#123; // 如果不包含这个键 map.put(c, 1); // 就将键和值为1添加 &#125; else &#123; // 如果包含这个键 map.put(c, (int)map.get(c) + 1); // 就将键和值再加1添加进来 &#125; &#125; for (Object key : map.keySet()) &#123; // 遍历双列集合 System.out.println(key + &quot;=&quot; + map.get(key)); &#125; &#125;&#125; 6.4 Map实现类之二：LinkedHashMap LinkedHashMap 是 HashMap 的子类 存储数据采用的哈希表结构+链表结构，在HashMap存储结构的基础上，使用了一对双向链表来记录添加元素的先后顺序，可以保证遍历元素时，与添加的顺序一致。 通过哈希表结构可以保证键的唯一、不重复，需要键所在类重写hashCode()方法、equals()方法。 123456789101112131415161718192021public class TestLinkedHashMap &#123; public static void main(String[] args) &#123; LinkedHashMap map = new LinkedHashMap(); map.put(&quot;王五&quot;, 13000.0); map.put(&quot;张三&quot;, 10000.0); //key相同，新的value会覆盖原来的value //因为String重写了hashCode和equals方法 map.put(&quot;张三&quot;, 12000.0); map.put(&quot;李四&quot;, 14000.0); //HashMap支持key和value为null值 String name = null; Double salary = null; map.put(name, salary); Set entrySet = map.entrySet(); for (Object obj : entrySet) &#123; Map.Entry entry = (Map.Entry)obj; System.out.println(entry); &#125; &#125;&#125; 6.5 Map实现类之三：TreeMap TreeMap存储 key-value 对时，需要根据 key-value 对进行排序。TreeMap 可以保证所有的 key-value 对处于有序状态。 TreeSet底层使用红黑树结构存储数据 TreeMap 的 Key 的排序： 自然排序：TreeMap 的所有的 Key 必须实现 Comparable 接口，而且所有的 Key 应该是同一个类的对象，否则将会抛出 ClasssCastException 定制排序：创建 TreeMap 时，构造器传入一个 Comparator 对象，该对象负责对 TreeMap 中的所有 key 进行排序。此时不需要 Map 的 Key 实现 Comparable 接口 TreeMap判断两个key相等的标准：两个key通过compareTo()方法或者compare()方法返回0。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100/** * @author 尚硅谷-宋红康 * @create 1:23 */public class TestTreeMap &#123; /* * 自然排序举例 * */ @Test public void test1()&#123; TreeMap map = new TreeMap(); map.put(&quot;CC&quot;,45); map.put(&quot;MM&quot;,78); map.put(&quot;DD&quot;,56); map.put(&quot;GG&quot;,89); map.put(&quot;JJ&quot;,99); Set entrySet = map.entrySet(); for(Object entry : entrySet)&#123; System.out.println(entry); &#125; &#125; /* * 定制排序 * * */ @Test public void test2()&#123; //按照User的姓名的从小到大的顺序排列 TreeMap map = new TreeMap(new Comparator() &#123; @Override public int compare(Object o1, Object o2) &#123; if(o1 instanceof User &amp;&amp; o2 instanceof User)&#123; User u1 = (User)o1; User u2 = (User)o2; return u1.name.compareTo(u2.name); &#125; throw new RuntimeException(&quot;输入的类型不匹配&quot;); &#125; &#125;); map.put(new User(&quot;Tom&quot;,12),67); map.put(new User(&quot;Rose&quot;,23),&quot;87&quot;); map.put(new User(&quot;Jerry&quot;,2),88); map.put(new User(&quot;Eric&quot;,18),45); map.put(new User(&quot;Tommy&quot;,44),77); map.put(new User(&quot;Jim&quot;,23),88); map.put(new User(&quot;Maria&quot;,18),34); Set entrySet = map.entrySet(); for(Object entry : entrySet)&#123; System.out.println(entry); &#125; &#125;&#125;class User implements Comparable&#123; String name; int age; public User(String name, int age) &#123; this.name = name; this.age = age; &#125; public User() &#123; &#125; @Override public String toString() &#123; return &quot;User&#123;&quot; + &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, age=&quot; + age + &#x27;&#125;&#x27;; &#125; /* 举例：按照age从小到大的顺序排列，如果age相同，则按照name从大到小的顺序排列 * */ @Override public int compareTo(Object o) &#123; if(this == o)&#123; return 0; &#125; if(o instanceof User)&#123; User user = (User)o; int value = this.age - user.age; if(value != 0)&#123; return value; &#125; return -this.name.compareTo(user.name); &#125; throw new RuntimeException(&quot;输入的类型不匹配&quot;); &#125;&#125; 6.6 Map实现类之四：Hashtable Hashtable是Map接口的古老实现类，JDK1.0就提供了。不同于HashMap，Hashtable是线程安全的。 Hashtable实现原理和HashMap相同，功能相同。底层都使用哈希表结构（数组+单向链表），查询速度快。 与HashMap一样，Hashtable 也不能保证其中 Key-Value 对的顺序 Hashtable判断两个key相等、两个value相等的标准，与HashMap一致。 与HashMap不同，Hashtable 不允许使用 null 作为 key 或 value。 面试题：Hashtable和HashMap的区别 12345678910HashMap:底层是一个哈希表（jdk7:数组+链表;jdk8:数组+链表+红黑树）,是一个线程不安全的集合,执行效率高Hashtable:底层也是一个哈希表（数组+链表）,是一个线程安全的集合,执行效率低HashMap集合:可以存储null的键、null的值Hashtable集合,不能存储null的键、null的值Hashtable和Vector集合一样,在jdk1.2版本之后被更先进的集合(HashMap,ArrayList)取代了。所以HashMap是Map的主要实现类，Hashtable是Map的古老实现类。Hashtable的子类Properties（配置文件）依然活跃在历史舞台Properties集合是一个唯一和IO流相结合的集合 6.7 Map实现类之五：Properties Properties 类是 Hashtable 的子类，该对象用于处理属性文件 由于属性文件里的 key、value 都是字符串类型，所以 Properties 中要求 key 和 value 都是字符串类型 存取数据时，建议使用setProperty(String key,String value)方法和getProperty(String key)方法 123456789101112131415161718192021@Testpublic void test01() &#123; Properties properties = System.getProperties(); String fileEncoding = properties.getProperty(&quot;file.encoding&quot;);//当前源文件字符编码 System.out.println(&quot;fileEncoding = &quot; + fileEncoding);&#125;@Testpublic void test02() &#123; Properties properties = new Properties(); properties.setProperty(&quot;user&quot;,&quot;songhk&quot;); properties.setProperty(&quot;password&quot;,&quot;123456&quot;); System.out.println(properties);&#125;@Testpublic void test03() throws IOException &#123; Properties pros = new Properties(); pros.load(new FileInputStream(&quot;jdbc.properties&quot;)); String user = pros.getProperty(&quot;user&quot;); System.out.println(user);&#125; 7. Collections工具类参考操作数组的工具类：Arrays，Collections 是一个操作 Set、List 和 Map 等集合的工具类。 7.1 常用方法Collections 中提供了一系列静态的方法对集合元素进行排序、查询和修改等操作，还提供了对集合对象设置不可变、对集合对象实现同步控制等方法（均为static方法）： 排序操作： reverse(List)：反转 List 中元素的顺序 shuffle(List)：对 List 集合元素进行随机排序 sort(List)：根据元素的自然顺序对指定 List 集合元素按升序排序 sort(List，Comparator)：根据指定的 Comparator 产生的顺序对 List 集合元素进行排序 swap(List，int， int)：将指定 list 集合中的 i 处元素和 j 处元素进行交换 查找 Object max(Collection)：根据元素的自然顺序，返回给定集合中的最大元素 Object max(Collection，Comparator)：根据 Comparator 指定的顺序，返回给定集合中的最大元素 Object min(Collection)：根据元素的自然顺序，返回给定集合中的最小元素 Object min(Collection，Comparator)：根据 Comparator 指定的顺序，返回给定集合中的最小元素 int binarySearch(List list,T key)在List集合中查找某个元素的下标，但是List的元素必须是T或T的子类对象，而且必须是可比较大小的，即支持自然排序的。而且集合也事先必须是有序的，否则结果不确定。 int binarySearch(List list,T key,Comparator c)在List集合中查找某个元素的下标，但是List的元素必须是T或T的子类对象，而且集合也事先必须是按照c比较器规则进行排序过的，否则结果不确定。 int frequency(Collection c，Object o)：返回指定集合中指定元素的出现次数 复制、替换 void copy(List dest,List src)：将src中的内容复制到dest中 boolean replaceAll(List list，Object oldVal，Object newVal)：使用新值替换 List 对象的所有旧值 提供了多个unmodifiableXxx()方法，该方法返回指定 Xxx的不可修改的视图。 添加 boolean addAll(Collection c,T… elements)将所有指定元素添加到指定 collection 中。 同步 Collections 类中提供了多个 synchronizedXxx() 方法，该方法可使将指定集合包装成线程同步的集合，从而可以解决多线程并发访问集合时的线程安全问题： 7.2 举例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168package com.atguigu.collections;import org.junit.Test;import java.text.Collator;import java.util.*;public class TestCollections &#123; @Test public void test01()&#123; /* public static &lt;T&gt; boolean addAll(Collection&lt;? super T&gt; c,T... elements) 将所有指定元素添加到指定 collection 中。Collection的集合的元素类型必须&gt;=T类型 */ Collection&lt;Object&gt; coll = new ArrayList&lt;&gt;(); Collections.addAll(coll, &quot;hello&quot;,&quot;java&quot;); Collections.addAll(coll, 1,2,3,4); Collection&lt;String&gt; coll2 = new ArrayList&lt;&gt;(); Collections.addAll(coll2, &quot;hello&quot;,&quot;java&quot;); //Collections.addAll(coll2, 1,2,3,4);//String和Integer之间没有父子类关系 &#125; @Test public void test02()&#123;/* * public static &lt;T extends Object &amp; Comparable&lt;? super T&gt;&gt; T max(Collection&lt;? extends T&gt; coll) * 在coll集合中找出最大的元素，集合中的对象必须是T或T的子类对象，而且支持自然排序* * public static &lt;T&gt; T max(Collection&lt;? extends T&gt; coll,Comparator&lt;? super T&gt; comp)* 在coll集合中找出最大的元素，集合中的对象必须是T或T的子类对象，按照比较器comp找出最大者**/ List&lt;Man&gt; list = new ArrayList&lt;&gt;(); list.add(new Man(&quot;张三&quot;,23)); list.add(new Man(&quot;李四&quot;,24)); list.add(new Man(&quot;王五&quot;,25)); /* * Man max = Collections.max(list);//要求Man实现Comparable接口，或者父类实现 * System.out.println(max); */ Man max = Collections.max(list, new Comparator&lt;Man&gt;() &#123; @Override public int compare(Man o1, Man o2) &#123; return o2.getAge()-o2.getAge(); &#125; &#125;); System.out.println(max); &#125; @Test public void test03()&#123; /* * public static void reverse(List&lt;?&gt; list) * 反转指定列表List中元素的顺序。 */ List&lt;String&gt; list = new ArrayList&lt;&gt;(); Collections.addAll(list,&quot;hello&quot;,&quot;java&quot;,&quot;world&quot;); System.out.println(list); Collections.reverse(list); System.out.println(list); &#125; @Test public void test04()&#123; /* * public static void shuffle(List&lt;?&gt; list) * List 集合元素进行随机排序，类似洗牌，打乱顺序 */ List&lt;String&gt; list = new ArrayList&lt;&gt;(); Collections.addAll(list,&quot;hello&quot;,&quot;java&quot;,&quot;world&quot;); Collections.shuffle(list); System.out.println(list); &#125; @Test public void test05() &#123; /* * public static &lt;T extends Comparable&lt;? super T&gt;&gt; void sort(List&lt;T&gt; list) * 根据元素的自然顺序对指定 List 集合元素按升序排序 * * public static &lt;T&gt; void sort(List&lt;T&gt; list,Comparator&lt;? super T&gt; c) * 根据指定的 Comparator 产生的顺序对 List 集合元素进行排序 */ List&lt;Man&gt; list = new ArrayList&lt;&gt;(); list.add(new Man(&quot;张三&quot;,23)); list.add(new Man(&quot;李四&quot;,24)); list.add(new Man(&quot;王五&quot;,25)); Collections.sort(list); System.out.println(list); Collections.sort(list, new Comparator&lt;Man&gt;() &#123; @Override public int compare(Man o1, Man o2) &#123; return Collator.getInstance(Locale.CHINA).compare(o1.getName(),o2.getName()); &#125; &#125;); System.out.println(list); &#125; @Test public void test06()&#123; /* * public static void swap(List&lt;?&gt; list,int i,int j) * 将指定 list 集合中的 i 处元素和 j 处元素进行交换 */ List&lt;String&gt; list = new ArrayList&lt;&gt;(); Collections.addAll(list,&quot;hello&quot;,&quot;java&quot;,&quot;world&quot;); Collections.swap(list,0,2); System.out.println(list); &#125; @Test public void test07()&#123; /* * public static int frequency(Collection&lt;?&gt; c,Object o) * 返回指定集合中指定元素的出现次数 */ List&lt;String&gt; list = new ArrayList&lt;&gt;(); Collections.addAll(list,&quot;hello&quot;,&quot;java&quot;,&quot;world&quot;,&quot;hello&quot;,&quot;hello&quot;); int count = Collections.frequency(list, &quot;hello&quot;); System.out.println(&quot;count = &quot; + count); &#125; @Test public void test08()&#123; /* * public static &lt;T&gt; void copy(List&lt;? super T&gt; dest,List&lt;? extends T&gt; src) * 将src中的内容复制到dest中 */ List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); for(int i=1; i&lt;=5; i++)&#123;//1-5 list.add(i); &#125; List&lt;Integer&gt; list2 = new ArrayList&lt;&gt;(); for(int i=11; i&lt;=13; i++)&#123;//11-13 list2.add(i); &#125; Collections.copy(list, list2); System.out.println(list); List&lt;Integer&gt; list3 = new ArrayList&lt;&gt;(); for(int i=11; i&lt;=20; i++)&#123;//11-20 list3.add(i); &#125; //java.lang.IndexOutOfBoundsException: Source does not fit in dest //Collections.copy(list, list3); //System.out.println(list); &#125; @Test public void test09()&#123; /* * public static &lt;T&gt; boolean replaceAll(List&lt;T&gt; list，T oldVal，T newVal) * 使用新值替换 List 对象的所有旧值 */ List&lt;String&gt; list = new ArrayList&lt;&gt;(); Collections.addAll(list,&quot;hello&quot;,&quot;java&quot;,&quot;world&quot;,&quot;hello&quot;,&quot;hello&quot;); Collections.replaceAll(list, &quot;hello&quot;,&quot;song&quot;); System.out.println(list); &#125;&#125; 7.3 练习练习1： 请从键盘随机输入10个整数保存到List中，并按倒序、从大到小的顺序显示出来 练习2：模拟斗地主洗牌和发牌，牌没有排序 效果演示： 提示： 12345String[] num = &#123;&quot;A&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;,&quot;5&quot;,&quot;6&quot;,&quot;7&quot;,&quot;8&quot;,&quot;9&quot;,&quot;10&quot;,&quot;J&quot;,&quot;Q&quot;,&quot;K&quot;&#125;;String[] color = &#123;&quot;方片&quot;,&quot;梅花&quot;,&quot;红桃&quot;,&quot;黑桃&quot;&#125;;ArrayList&lt;String&gt; poker = new ArrayList&lt;&gt;(); 代码示例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/** * * @author 尚硅谷-宋红康 * @date 2022年5月7日上午12:26:59 * */public class PokerTest &#123; public static void main(String[] args) &#123; String[] num = &#123;&quot;A&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;,&quot;5&quot;,&quot;6&quot;,&quot;7&quot;,&quot;8&quot;,&quot;9&quot;,&quot;10&quot;,&quot;J&quot;,&quot;Q&quot;,&quot;K&quot;&#125;; String[] color = &#123;&quot;方片&quot;,&quot;梅花&quot;,&quot;红桃&quot;,&quot;黑桃&quot;&#125;; ArrayList poker = new ArrayList(); //1. 生成54张扑克牌 for (String s1 : color) &#123; for (String s2 : num) &#123; poker.add(s1.concat(&quot; &quot; + s2)); &#125; &#125; poker.add(&quot;小王&quot;); poker.add(&quot;大王&quot;); //2. 洗牌 Collections.shuffle(poker); //3. 发牌 ArrayList tomCards = new ArrayList(); ArrayList jerryCards = new ArrayList(); ArrayList meCards = new ArrayList(); ArrayList lastCards = new ArrayList(); for (int i = 0; i &lt; poker.size(); i++) &#123; if(i &gt;= poker.size() - 3)&#123; lastCards.add(poker.get(i)); &#125;else if(i % 3 == 0)&#123; tomCards.add(poker.get(i)); &#125;else if(i % 3 == 1)&#123; jerryCards.add(poker.get(i)); &#125;else &#123; meCards.add(poker.get(i)); &#125; &#125; //4. 看牌 System.out.println(&quot;Tom:\\n&quot; + tomCards); System.out.println(&quot;Jerry:\\n&quot; + jerryCards); System.out.println(&quot;me:\\n&quot; + meCards); System.out.println(&quot;底牌:\\n&quot; + lastCards); &#125;&#125; 练习3：模拟斗地主洗牌和发牌并对牌进行排序的代码实现。 提示：考查HashMap、TreeSet、ArrayList、Collections 代码示例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960/** * @author 尚硅谷-宋红康 * @create 0:23 */public class PokerTest1 &#123; public static void main(String[] args) &#123; String[] num = &#123;&quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;, &quot;7&quot;, &quot;8&quot;, &quot;9&quot;, &quot;10&quot;, &quot;J&quot;, &quot;Q&quot;, &quot;K&quot;, &quot;A&quot;, &quot;2&quot;&#125;; String[] color = &#123;&quot;方片&quot;, &quot;梅花&quot;, &quot;红桃&quot;, &quot;黑桃&quot;&#125;; HashMap map = new HashMap(); // 存储索引和扑克牌 ArrayList list = new ArrayList(); // 存储索引 int index = 0; // 索引的开始值 for (String s1 : num) &#123; for (String s2 : color) &#123; map.put(index, s2.concat(s1)); // 将索引和扑克牌添加到HashMap中 list.add(index); // 将索引添加到ArrayList集合中 index++; &#125; &#125; map.put(index, &quot;小王&quot;); list.add(index); index++; map.put(index, &quot;大王&quot;); list.add(index); // 洗牌 Collections.shuffle(list); // 发牌 TreeSet Tom = new TreeSet(); TreeSet Jerry = new TreeSet(); TreeSet me = new TreeSet(); TreeSet lastCards = new TreeSet(); for (int i = 0; i &lt; list.size(); i++) &#123; if (i &gt;= list.size() - 3) &#123; lastCards.add(list.get(i)); // 将list集合中的索引添加到TreeSet集合中会自动排序 &#125; else if (i % 3 == 0) &#123; Tom.add(list.get(i)); &#125; else if (i % 3 == 1) &#123; Jerry.add(list.get(i)); &#125; else &#123; me.add(list.get(i)); &#125; &#125; // 看牌 lookPoker(&quot;Tom&quot;, Tom, map); lookPoker(&quot;Jerry&quot;, Jerry, map); lookPoker(&quot;康师傅&quot;, me, map); lookPoker(&quot;底牌&quot;, lastCards, map); &#125; public static void lookPoker(String name, TreeSet ts, HashMap map) &#123; System.out.println(name + &quot;的牌是:&quot;); for (Object index : ts) &#123; System.out.print(map.get(index) + &quot; &quot;); &#125; System.out.println(); &#125;&#125;","categories":[{"name":"java基础","slug":"java基础","permalink":"http://example.com/categories/java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"java","slug":"java","permalink":"http://example.com/tags/java/"}]},{"title":"第11章_常用类和基础API","slug":"Java/尚硅谷_第11章_常用类和基础API/尚硅谷_宋红康_第11章_常用类和基础API","date":"2022-09-27T00:57:54.000Z","updated":"2023-10-07T11:55:10.620Z","comments":true,"path":"2022/09/27/Java/尚硅谷_第11章_常用类和基础API/尚硅谷_宋红康_第11章_常用类和基础API/","link":"","permalink":"http://example.com/2022/09/27/Java/%E5%B0%9A%E7%A1%85%E8%B0%B7_%E7%AC%AC11%E7%AB%A0_%E5%B8%B8%E7%94%A8%E7%B1%BB%E5%92%8C%E5%9F%BA%E7%A1%80API/%E5%B0%9A%E7%A1%85%E8%B0%B7_%E5%AE%8B%E7%BA%A2%E5%BA%B7_%E7%AC%AC11%E7%AB%A0_%E5%B8%B8%E7%94%A8%E7%B1%BB%E5%92%8C%E5%9F%BA%E7%A1%80API/","excerpt":"","text":"本章专题与脉络 1. 字符串相关类之不可变字符序列：String1.1 String的特性 java.lang.String 类代表字符串。Java程序中所有的字符串文字（例如&quot;hello&quot; ）都可以看作是实现此类的实例。 字符串是常量，用双引号引起来表示。它们的值在创建之后不能更改。 字符串String类型本身是final声明的，意味着我们不能继承String。 String对象的字符内容是存储在一个字符数组value[]中的。&quot;abc&quot; 等效于 char[] data=&#123;&#39;h&#39;,&#39;e&#39;,&#39;l&#39;,&#39;l&#39;,&#39;o&#39;&#125;。 123456789//jdk8中的String源码：public final class String implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123; /** The value is used for character storage. */ private final char value[]; //String对象的字符内容是存储在此数组中 /** Cache the hash code for the string */ private int hash; // Default to 0 private意味着外面无法直接获取字符数组，而且String没有提供value的get和set方法。 final意味着字符数组的引用不可改变，而且String也没有提供方法来修改value数组某个元素值 因此字符串的字符数组内容也不可变的，即String代表着不可变的字符序列。即，一旦对字符串进行修改，就会产生新对象。 JDK9只有，底层使用byte[]数组。 12345678public final class String implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123; @Stable private final byte[] value;&#125;//官方说明：... that most String objects contain only Latin-1 characters. Such characters require only one byte of storage, hence half of the space in the internal char arrays of such String objects is going unused.//细节：... The new String class will store characters encoded either as ISO-8859-1/Latin-1 (one byte per character), or as UTF-16 (two bytes per character), based upon the contents of the string. The encoding flag will indicate which encoding is used. Java 语言提供对字符串串联符号（”+”）以及将其他对象转换为字符串的特殊支持（toString()方法）。 1.2 String的内存结构1.2.1 概述因为字符串对象设计为不可变，那么所以字符串有常量池来保存很多常量对象。 JDK6中，字符串常量池在方法区。JDK7开始，就移到堆空间，直到目前JDK17版本。 举例内存结构分配： 1.2.2 练习类型1：拼接1234String s1 = &quot;hello&quot;;String s2 = &quot;hello&quot;;System.out.println(s1 == s2);// 内存中只有一个&quot;hello&quot;对象被创建，同时被s1和s2共享。 对应内存结构为：（以下内存结构以JDK6为例绘制）： 进一步： 123456789Person p1 = new Person();p1.name = “Tom&quot;;Person p2 = new Person();p2.name = “Tom&quot;;System.out.println(p1.name.equals( p2.name)); //System.out.println(p1.name == p2.name); //System.out.println(p1.name == &quot;Tom&quot;); // 1.2.3 练习类型2：newString str1 &#x3D; “abc”; 与 String str2 &#x3D; new String(“abc”);的区别？ str2 首先指向堆中的一个字符串对象，然后堆中字符串的value数组指向常量池中常量对象的value数组。 字符串常量存储在字符串常量池，目的是共享。 字符串非常量对象存储在堆中。 练习： 123456789String s1 = &quot;javaEE&quot;;String s2 = &quot;javaEE&quot;;String s3 = new String(&quot;javaEE&quot;);String s4 = new String(&quot;javaEE&quot;);System.out.println(s1 == s2);//trueSystem.out.println(s1 == s3);//falseSystem.out.println(s1 == s4);//falseSystem.out.println(s3 == s4);//false 练习：String str2 &#x3D; new String(“hello”); 在内存中创建了几个对象？ 1两个 1.2.4 练习类型3：intern() String s1 &#x3D; “a”; 说明：在字符串常量池中创建了一个字面量为”a”的字符串。 s1 &#x3D; s1 + “b”; 说明：实际上原来的“a”字符串对象已经丢弃了，现在在堆空间中产生了一个字符串s1+”b”（也就是”ab”)。如果多次执行这些改变串内容的操作，会导致大量副本字符串对象存留在内存中，降低效率。如果这样的操作放到循环中，会极大影响程序的性能。 String s2 &#x3D; “ab”; 说明：直接在字符串常量池中创建一个字面量为”ab”的字符串。 String s3 &#x3D; “a” + “b”; 说明：s3指向字符串常量池中已经创建的”ab”的字符串。 String s4 &#x3D; s1.intern(); 说明：堆空间的s1对象在调用intern()之后，会将常量池中已经存在的”ab”字符串赋值给s4。 练习： 1234567891011String s1 = &quot;hello&quot;;String s2 = &quot;world&quot;;String s3 = &quot;hello&quot; + &quot;world&quot;;String s4 = s1 + &quot;world&quot;;String s5 = s1 + s2;String s6 = (s1 + s2).intern();System.out.println(s3 == s4);System.out.println(s3 == s5);System.out.println(s4 == s5);System.out.println(s3 == s6); 结论： （1）常量+常量：结果是常量池。且常量池中不会存在相同内容的常量。 （2）常量与变量 或 变量与变量：结果在堆中 （3）拼接后调用intern方法：返回值在常量池中 练习： 123456789101112131415161718192021222324252627282930313233343536373839404142@Testpublic void test01()&#123; String s1 = &quot;hello&quot;; String s2 = &quot;world&quot;; String s3 = &quot;helloworld&quot;; String s4 = s1 + &quot;world&quot;;//s4字符串内容也helloworld，s1是变量，&quot;world&quot;常量，变量 + 常量的结果在堆中 String s5 = s1 + s2;//s5字符串内容也helloworld，s1和s2都是变量，变量 + 变量的结果在堆中 String s6 = &quot;hello&quot; + &quot;world&quot;;//常量+ 常量 结果在常量池中，因为编译期间就可以确定结果 System.out.println(s3 == s4);//false System.out.println(s3 == s5);//false System.out.println(s3 == s6);//true&#125;@Testpublic void test02()&#123; final String s1 = &quot;hello&quot;; final String s2 = &quot;world&quot;; String s3 = &quot;helloworld&quot;; String s4 = s1 + &quot;world&quot;;//s4字符串内容也helloworld，s1是常量，&quot;world&quot;常量，常量+常量结果在常量池中 String s5 = s1 + s2;//s5字符串内容也helloworld，s1和s2都是常量，常量+ 常量 结果在常量池中 String s6 = &quot;hello&quot; + &quot;world&quot;;//常量+ 常量 结果在常量池中，因为编译期间就可以确定结果 System.out.println(s3 == s4);//true System.out.println(s3 == s5);//true System.out.println(s3 == s6);//true&#125;@Testpublic void test01()&#123; String s1 = &quot;hello&quot;; String s2 = &quot;world&quot;; String s3 = &quot;helloworld&quot;; String s4 = (s1 + &quot;world&quot;).intern();//把拼接的结果放到常量池中 String s5 = (s1 + s2).intern(); System.out.println(s3 == s4);//true System.out.println(s3 == s5);//true&#125; 练习：下列程序运行的结果： 12345678910111213public class TestString &#123; public static void main(String[] args) &#123; String str = &quot;hello&quot;; String str2 = &quot;world&quot;; String str3 =&quot;helloworld&quot;; String str4 = &quot;hello&quot;.concat(&quot;world&quot;); String str5 = &quot;hello&quot;+&quot;world&quot;; System.out.println(str3 == str4);//false System.out.println(str3 == str5);//true &#125;&#125; concat方法拼接，哪怕是两个常量对象拼接，结果也是在堆。 练习：下列程序运行的结果： 1234567891011121314151617public class StringTest &#123; String str = new String(&quot;good&quot;); char[] ch = &#123; &#x27;t&#x27;, &#x27;e&#x27;, &#x27;s&#x27;, &#x27;t&#x27; &#125;; public void change(String str, char ch[]) &#123; str = &quot;test ok&quot;; ch[0] = &#x27;b&#x27;; &#125; public static void main(String[] args) &#123; StringTest ex = new StringTest(); ex.change(ex.str, ex.ch); System.out.print(ex.str + &quot; and &quot;);// System.out.println(ex.ch); &#125;&#125; 1.3 String的常用API-11.3.1 构造器 public String() ：初始化新创建的 String对象，以使其表示空字符序列。 String(String original)： 初始化一个新创建的 String 对象，使其表示一个与参数相同的字符序列；换句话说，新创建的字符串是该参数字符串的副本。 public String(char[] value) ：通过当前参数中的字符数组来构造新的String。 public String(char[] value,int offset, int count) ：通过字符数组的一部分来构造新的String。 public String(byte[] bytes) ：通过使用平台的默认字符集解码当前参数中的字节数组来构造新的String。 public String(byte[] bytes,String charsetName) ：通过使用指定的字符集解码当前参数中的字节数组来构造新的String。 举例： 123456789101112131415161718//字面量定义方式：字符串常量对象String str = &quot;hello&quot;;//构造器定义方式：无参构造String str1 = new String();//构造器定义方式：创建&quot;hello&quot;字符串常量的副本String str2 = new String(&quot;hello&quot;);//构造器定义方式：通过字符数组构造char chars[] = &#123;&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;,&#x27;d&#x27;,&#x27;e&#x27;&#125;; String str3 = new String(chars);String str4 = new String(chars,0,3);//构造器定义方式：通过字节数组构造byte bytes[] = &#123;97, 98, 99 &#125;; String str5 = new String(bytes);String str6 = new String(bytes,&quot;GBK&quot;); 1234567891011public static void main(String[] args) &#123; char[] data = &#123;&#x27;h&#x27;,&#x27;e&#x27;,&#x27;l&#x27;,&#x27;l&#x27;,&#x27;o&#x27;,&#x27;j&#x27;,&#x27;a&#x27;,&#x27;v&#x27;,&#x27;a&#x27;&#125;; String s1 = String.copyValueOf(data); String s2 = String.copyValueOf(data,0,5); int num = 123456; String s3 = String.valueOf(num); System.out.println(s1); System.out.println(s2); System.out.println(s3);&#125; 1.3.2 String与其他结构间的转换字符串 –&gt; 基本数据类型、包装类： Integer包装类的public static int parseInt(String s)：可以将由“数字”字符组成的字符串转换为整型。 类似地，使用java.lang包中的Byte、Short、Long、Float、Double类调相应的类方法可以将由“数字”字符组成的字符串，转化为相应的基本数据类型。 基本数据类型、包装类 –&gt; 字符串： 调用String类的public String valueOf(int n)可将int型转换为字符串 相应的valueOf(byte b)、valueOf(long l)、valueOf(float f)、valueOf(double d)、valueOf(boolean b)可由参数的相应类型到字符串的转换。 字符数组 –&gt; 字符串： String 类的构造器：String(char[]) 和 String(char[]，int offset，int length) 分别用字符数组中的全部字符和部分字符创建字符串对象。 字符串 –&gt; 字符数组： public char[] toCharArray()：将字符串中的全部字符存放在一个字符数组中的方法。 public void getChars(int srcBegin, int srcEnd, char[] dst, int dstBegin)：提供了将指定索引范围内的字符串存放到数组中的方法。 字符串 –&gt; 字节数组：（编码） public byte[] getBytes() ：使用平台的默认字符集将此 String 编码为 byte 序列，并将结果存储到一个新的 byte 数组中。 public byte[] getBytes(String charsetName) ：使用指定的字符集将此 String 编码到 byte 序列，并将结果存储到新的 byte 数组。 字节数组 –&gt; 字符串：（解码） String(byte[])：通过使用平台的默认字符集解码指定的 byte 数组，构造一个新的 String。 String(byte[]，int offset，int length) ：用指定的字节数组的一部分，即从数组起始位置offset开始取length个字节构造一个字符串对象。 String(byte[], String charsetName ) 或 new String(byte[], int, int,String charsetName )：解码，按照指定的编码方式进行解码。 代码示例： 123456789101112131415@Testpublic void test01() throws Exception &#123; String str = &quot;中国&quot;; System.out.println(str.getBytes(&quot;ISO8859-1&quot;).length);// 2 // ISO8859-1把所有的字符都当做一个byte处理，处理不了多个字节 System.out.println(str.getBytes(&quot;GBK&quot;).length);// 4 每一个中文都是对应2个字节 System.out.println(str.getBytes(&quot;UTF-8&quot;).length);// 6 常规的中文都是3个字节 /* * 不乱码：（1）保证编码与解码的字符集名称一样（2）不缺字节 */ System.out.println(new String(str.getBytes(&quot;ISO8859-1&quot;), &quot;ISO8859-1&quot;));// 乱码 System.out.println(new String(str.getBytes(&quot;GBK&quot;), &quot;GBK&quot;));// 中国 System.out.println(new String(str.getBytes(&quot;UTF-8&quot;), &quot;UTF-8&quot;));// 中国&#125; 1.4 String的常用API-2String 类包括的方法可用于检查序列的单个字符、比较字符串、搜索字符串、提取子字符串、创建字符串副本并将所有字符全部转换为大写或小写。 1.4.1 系列1：常用方法（1）boolean isEmpty()：字符串是否为空（2）int length()：返回字符串的长度（3）String concat(xx)：拼接（4）boolean equals(Object obj)：比较字符串是否相等，区分大小写（5）boolean equalsIgnoreCase(Object obj)：比较字符串是否相等，不区分大小写（6）int compareTo(String other)：比较字符串大小，区分大小写，按照Unicode编码值比较大小（7）int compareToIgnoreCase(String other)：比较字符串大小，不区分大小写（8）String toLowerCase()：将字符串中大写字母转为小写（9）String toUpperCase()：将字符串中小写字母转为大写（10）String trim()：去掉字符串前后空白符（11）public String intern()：结果在常量池中共享 1234567891011121314151617181920212223242526272829303132333435363738394041424344@Testpublic void test01()&#123; //将用户输入的单词全部转为小写，如果用户没有输入单词，重新输入 Scanner input = new Scanner(System.in); String word; while(true)&#123; System.out.print(&quot;请输入单词：&quot;); word = input.nextLine(); if(word.trim().length()!=0)&#123; word = word.toLowerCase(); break; &#125; &#125; System.out.println(word);&#125;@Testpublic void test02()&#123; //随机生成验证码，验证码由0-9，A-Z,a-z的字符组成 char[] array = new char[26*2+10]; for (int i = 0; i &lt; 10; i++) &#123; array[i] = (char)(&#x27;0&#x27; + i); &#125; for (int i = 10,j=0; i &lt; 10+26; i++,j++) &#123; array[i] = (char)(&#x27;A&#x27; + j); &#125; for (int i = 10+26,j=0; i &lt; array.length; i++,j++) &#123; array[i] = (char)(&#x27;a&#x27; + j); &#125; String code = &quot;&quot;; Random rand = new Random(); for (int i = 0; i &lt; 4; i++) &#123; code += array[rand.nextInt(array.length)]; &#125; System.out.println(&quot;验证码：&quot; + code); //将用户输入的单词全部转为小写，如果用户没有输入单词，重新输入 Scanner input = new Scanner(System.in); System.out.print(&quot;请输入验证码：&quot;); String inputCode = input.nextLine(); if(!code.equalsIgnoreCase(inputCode))&#123; System.out.println(&quot;验证码输入不正确&quot;); &#125;&#125; 1.4.2 系列2：查找（11）boolean contains(xx)：是否包含xx（12）int indexOf(xx)：从前往后找当前字符串中xx，即如果有返回第一次出现的下标，要是没有返回-1（13）int indexOf(String str, int fromIndex)：返回指定子字符串在此字符串中第一次出现处的索引，从指定的索引开始（14）int lastIndexOf(xx)：从后往前找当前字符串中xx，即如果有返回最后一次出现的下标，要是没有返回-1（15）int lastIndexOf(String str, int fromIndex)：返回指定子字符串在此字符串中最后一次出现处的索引，从指定的索引开始反向搜索。 1234567@Testpublic void test01()&#123; String str = &quot;尚硅谷是一家靠谱的培训机构，尚硅谷可以说是IT培训的小清华，JavaEE是尚硅谷的当家学科，尚硅谷的大数据培训是行业独角兽。尚硅谷的前端和UI专业一样独领风骚。&quot;; System.out.println(&quot;是否包含清华：&quot; + str.contains(&quot;清华&quot;)); System.out.println(&quot;培训出现的第一次下标：&quot; + str.indexOf(&quot;培训&quot;)); System.out.println(&quot;培训出现的最后一次下标：&quot; + str.lastIndexOf(&quot;培训&quot;));&#125; 1.4.3 系列3：字符串截取（16）String substring(int beginIndex) ：返回一个新的字符串，它是此字符串的从beginIndex开始截取到最后的一个子字符串。（17）String substring(int beginIndex, int endIndex) ：返回一个新字符串，它是此字符串从beginIndex开始截取到endIndex(不包含)的一个子字符串。 1234567891011121314151617@Testpublic void test01()&#123; String str = &quot;helloworldjavaatguigu&quot;; String sub1 = str.substring(5); String sub2 = str.substring(5,10); System.out.println(sub1); System.out.println(sub2);&#125;@Testpublic void test02()&#123; String fileName = &quot;快速学习Java的秘诀.dat&quot;; //截取文件名 System.out.println(&quot;文件名：&quot; + fileName.substring(0,fileName.lastIndexOf(&quot;.&quot;))); //截取后缀名 System.out.println(&quot;后缀名：&quot; + fileName.substring(fileName.lastIndexOf(&quot;.&quot;)));&#125; 1.4.4 系列4：和字符&#x2F;字符数组相关（18）char charAt(index)：返回[index]位置的字符（19）char[] toCharArray()： 将此字符串转换为一个新的字符数组返回（20）static String valueOf(char[] data) ：返回指定数组中表示该字符序列的 String（21）static String valueOf(char[] data, int offset, int count) ： 返回指定数组中表示该字符序列的 String（22）static String copyValueOf(char[] data)： 返回指定数组中表示该字符序列的 String（23）static String copyValueOf(char[] data, int offset, int count)：返回指定数组中表示该字符序列的 String 1234567891011121314151617181920212223242526272829@Testpublic void test01()&#123; //将字符串中的字符按照大小顺序排列 String str = &quot;helloworldjavaatguigu&quot;; char[] array = str.toCharArray(); Arrays.sort(array); str = new String(array); System.out.println(str);&#125;@Testpublic void test02()&#123; //将首字母转为大写 String str = &quot;jack&quot;; str = Character.toUpperCase(str.charAt(0))+str.substring(1); System.out.println(str);&#125;@Testpublic void test03()&#123; char[] data = &#123;&#x27;h&#x27;,&#x27;e&#x27;,&#x27;l&#x27;,&#x27;l&#x27;,&#x27;o&#x27;,&#x27;j&#x27;,&#x27;a&#x27;,&#x27;v&#x27;,&#x27;a&#x27;&#125;; String s1 = String.copyValueOf(data); String s2 = String.copyValueOf(data,0,5); int num = 123456; String s3 = String.valueOf(num); System.out.println(s1); System.out.println(s2); System.out.println(s3);&#125; 1.4.5 系列5：开头与结尾（24）boolean startsWith(xx)：测试此字符串是否以指定的前缀开始（25）boolean startsWith(String prefix, int toffset)：测试此字符串从指定索引开始的子字符串是否以指定前缀开始（26）boolean endsWith(xx)：测试此字符串是否以指定的后缀结束 1234567891011121314151617@Testpublic void test1()&#123; String name = &quot;张三&quot;; System.out.println(name.startsWith(&quot;张&quot;));&#125;@Testpublic void test2()&#123; String file = &quot;Hello.txt&quot;; if(file.endsWith(&quot;.java&quot;))&#123; System.out.println(&quot;Java源文件&quot;); &#125;else if(file.endsWith(&quot;.class&quot;))&#123; System.out.println(&quot;Java字节码文件&quot;); &#125;else&#123; System.out.println(&quot;其他文件&quot;); &#125;&#125; 1.4.6 系列6：替换（27）String replace(char oldChar, char newChar)：返回一个新的字符串，它是通过用 newChar 替换此字符串中出现的所有 oldChar 得到的。 不支持正则。（28）String replace(CharSequence target, CharSequence replacement)：使用指定的字面值替换序列替换此字符串所有匹配字面值目标序列的子字符串。（29）String replaceAll(String regex, String replacement)：使用给定的 replacement 替换此字符串所有匹配给定的正则表达式的子字符串。（30）String replaceFirst(String regex, String replacement)：使用给定的 replacement 替换此字符串匹配给定的正则表达式的第一个子字符串。 12345678910111213@Testpublic void test1()&#123; String str1 = &quot;hello244world.java;887&quot;; //把其中的非字母去掉 str1 = str1.replaceAll(&quot;[^a-zA-Z]&quot;, &quot;&quot;); System.out.println(str1); String str2 = &quot;12hello34world5java7891mysql456&quot;; //把字符串中的数字替换成,，如果结果中开头和结尾有，的话去掉 String string = str2.replaceAll(&quot;\\\\d+&quot;, &quot;,&quot;).replaceAll(&quot;^,|,$&quot;, &quot;&quot;); System.out.println(string);&#125; 1.5 常见算法题目题目1：模拟一个trim方法，去除字符串两端的空格。 12345678910111213141516171819202122232425262728public String myTrim(String str) &#123; if (str != null) &#123; int start = 0;// 用于记录从前往后首次索引位置不是空格的位置的索引 int end = str.length() - 1;// 用于记录从后往前首次索引位置不是空格的位置的索引 while (start &lt; end &amp;&amp; str.charAt(start) == &#x27; &#x27;) &#123; start++; &#125; while (start &lt; end &amp;&amp; str.charAt(end) == &#x27; &#x27;) &#123; end--; &#125; if (str.charAt(start) == &#x27; &#x27;) &#123; return &quot;&quot;; &#125; return str.substring(start, end + 1); &#125; return null;&#125;@Testpublic void testMyTrim() &#123; String str = &quot; a &quot;; // str = &quot; &quot;; String newStr = myTrim(str); System.out.println(&quot;---&quot; + newStr + &quot;---&quot;);&#125; 题目2：将一个字符串进行反转。将字符串中指定部分进行反转。比如“abcdefg”反转为”abfedcg” 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758// 方式一：public String reverse1(String str, int start, int end) &#123;// start:2,end:5 if (str != null) &#123; // 1. char[] charArray = str.toCharArray(); // 2. for (int i = start, j = end; i &lt; j; i++, j--) &#123; char temp = charArray[i]; charArray[i] = charArray[j]; charArray[j] = temp; &#125; // 3. return new String(charArray); &#125; return null;&#125;// 方式二：public String reverse2(String str, int start, int end) &#123; // 1. String newStr = str.substring(0, start);// ab // 2. for (int i = end; i &gt;= start; i--) &#123; newStr += str.charAt(i); &#125; // abfedc // 3. newStr += str.substring(end + 1); return newStr;&#125;// 方式三：推荐 （相较于方式二做的改进）public String reverse3(String str, int start, int end) &#123;// ArrayList list = new ArrayList(80); // 1. StringBuffer s = new StringBuffer(str.length()); // 2. s.append(str.substring(0, start));// ab // 3. for (int i = end; i &gt;= start; i--) &#123; s.append(str.charAt(i)); &#125; // 4. s.append(str.substring(end + 1)); // 5. return s.toString();&#125;@Testpublic void testReverse() &#123; String str = &quot;abcdefg&quot;; String str1 = reverse3(str, 2, 5); System.out.println(str1);// abfedcg&#125; 题目3：获取一个字符串在另一个字符串中出现的次数。 比如：获取“ ab”在 “abkkcadkabkebfkabkskab” 中出现的次数 123456789101112131415161718192021222324252627282930// 第3题// 判断str2在str1中出现的次数public int getCount(String mainStr, String subStr) &#123; if (mainStr.length() &gt;= subStr.length()) &#123; int count = 0; int index = 0; // while((index = mainStr.indexOf(subStr)) != -1)&#123; // count++; // mainStr = mainStr.substring(index + subStr.length()); // &#125; // 改进： while ((index = mainStr.indexOf(subStr, index)) != -1) &#123; index += subStr.length(); count++; &#125; return count; &#125; else &#123; return 0; &#125;&#125;@Testpublic void testGetCount() &#123; String str1 = &quot;cdabkkcadkabkebfkabkskab&quot;; String str2 = &quot;ab&quot;; int count = getCount(str1, str2); System.out.println(count);&#125; 题目4：获取两个字符串中最大相同子串。比如： str1 &#x3D; “abcwerthelloyuiodef“;str2 &#x3D; “cvhellobnm” 提示：将短的那个串进行长度依次递减的子串与较长的串比较。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384 // 第4题 // 如果只存在一个最大长度的相同子串 public String getMaxSameSubString(String str1, String str2) &#123; if (str1 != null &amp;&amp; str2 != null) &#123; String maxStr = (str1.length() &gt; str2.length()) ? str1 : str2; String minStr = (str1.length() &gt; str2.length()) ? str2 : str1; int len = minStr.length(); for (int i = 0; i &lt; len; i++) &#123;// 0 1 2 3 4 此层循环决定要去几个字符 for (int x = 0, y = len - i; y &lt;= len; x++, y++) &#123; if (maxStr.contains(minStr.substring(x, y))) &#123; return minStr.substring(x, y); &#125; &#125; &#125; &#125; return null; &#125; // 如果存在多个长度相同的最大相同子串 // 此时先返回String[]，后面可以用集合中的ArrayList替换，较方便 public String[] getMaxSameSubString1(String str1, String str2) &#123; if (str1 != null &amp;&amp; str2 != null) &#123; StringBuffer sBuffer = new StringBuffer(); String maxString = (str1.length() &gt; str2.length()) ? str1 : str2; String minString = (str1.length() &gt; str2.length()) ? str2 : str1; int len = minString.length(); for (int i = 0; i &lt; len; i++) &#123; for (int x = 0, y = len - i; y &lt;= len; x++, y++) &#123; String subString = minString.substring(x, y); if (maxString.contains(subString)) &#123; sBuffer.append(subString + &quot;,&quot;); &#125; &#125; System.out.println(sBuffer); if (sBuffer.length() != 0) &#123; break; &#125; &#125; String[] split = sBuffer.toString().replaceAll(&quot;,$&quot;, &quot;&quot;).split(&quot;\\\\,&quot;); return split; &#125; return null; &#125; // 如果存在多个长度相同的最大相同子串：使用ArrayList// public List&lt;String&gt; getMaxSameSubString1(String str1, String str2) &#123;// if (str1 != null &amp;&amp; str2 != null) &#123;// List&lt;String&gt; list = new ArrayList&lt;String&gt;();// String maxString = (str1.length() &gt; str2.length()) ? str1 : str2;// String minString = (str1.length() &gt; str2.length()) ? str2 : str1;//// int len = minString.length();// for (int i = 0; i &lt; len; i++) &#123;// for (int x = 0, y = len - i; y &lt;= len; x++, y++) &#123;// String subString = minString.substring(x, y);// if (maxString.contains(subString)) &#123;// list.add(subString);// &#125;// &#125;// if (list.size() != 0) &#123;// break;// &#125;// &#125;// return list;// &#125;//// return null;// &#125; @Test public void testGetMaxSameSubString() &#123; String str1 = &quot;abcwerthelloyuiodef&quot;; String str2 = &quot;cvhellobnmiodef&quot;; String[] strs = getMaxSameSubString1(str1, str2); System.out.println(Arrays.toString(strs)); &#125; 题目5：对字符串中字符进行自然顺序排序。提示：1）字符串变成字符数组。2）对数组排序，选择，冒泡，Arrays.sort();3）将排序后的数组变成字符串。 12345678910// 第5题@Testpublic void testSort() &#123; String str = &quot;abcwerthelloyuiodef&quot;; char[] arr = str.toCharArray(); Arrays.sort(arr); String newStr = new String(arr); System.out.println(newStr);&#125; 2. 字符串相关类之可变字符序列：StringBuffer、StringBuilder因为String对象是不可变对象，虽然可以共享常量对象，但是对于频繁字符串的修改和拼接操作，效率极低，空间消耗也比较高。因此，JDK又在java.lang包提供了可变字符序列StringBuffer和StringBuilder类型。 2.1 StringBuffer与StringBuilder的理解 java.lang.StringBuffer代表可变的字符序列，JDK1.0中声明，可以对字符串内容进行增删，此时不会产生新的对象。比如： 12345//情况1:String s = new String(&quot;我喜欢学习&quot;); //情况2：StringBuffer buffer = new StringBuffer(&quot;我喜欢学习&quot;); buffer.append(&quot;数学&quot;); 继承结构： StringBuilder 和 StringBuffer 非常类似，均代表可变的字符序列，而且提供相关功能的方法也一样。 区分String、StringBuffer、StringBuilder String:不可变的字符序列； 底层使用char[]数组存储(JDK8.0中) StringBuffer:可变的字符序列；线程安全（方法有synchronized修饰），效率低；底层使用char[]数组存储 (JDK8.0中) StringBuilder:可变的字符序列； jdk1.5引入，线程不安全的，效率高；底层使用char[]数组存储(JDK8.0中) 2.2 StringBuilder、StringBuffer的APIStringBuilder、StringBuffer的API是完全一致的，并且很多方法与String相同。 1、常用API （1）StringBuffer append(xx)：提供了很多的append()方法，用于进行字符串追加的方式拼接（2）StringBuffer delete(int start, int end)：删除[start,end)之间字符（3）StringBuffer deleteCharAt(int index)：删除[index]位置字符（4）StringBuffer replace(int start, int end, String str)：替换[start,end)范围的字符序列为str（5）void setCharAt(int index, char c)：替换[index]位置字符（6）char charAt(int index)：查找指定index位置上的字符（7）StringBuffer insert(int index, xx)：在[index]位置插入xx（8）int length()：返回存储的字符数据的长度（9）StringBuffer reverse()：反转 当append和insert时，如果原来value数组长度不够，可扩容。 如上(1)(2)(3)(4)(9)这些方法支持方法链操作。原理： 2、其它API （1）int indexOf(String str)：在当前字符序列中查询str的第一次出现下标（2）int indexOf(String str, int fromIndex)：在当前字符序列[fromIndex,最后]中查询str的第一次出现下标（3）int lastIndexOf(String str)：在当前字符序列中查询str的最后一次出现下标（4）int lastIndexOf(String str, int fromIndex)：在当前字符序列[fromIndex,最后]中查询str的最后一次出现下标（5）String substring(int start)：截取当前字符序列[start,最后]（6）String substring(int start, int end)：截取当前字符序列[start,end)（7）String toString()：返回此序列中数据的字符串表示形式（8）void setLength(int newLength) ：设置当前字符序列长度为newLength 12345678910111213141516171819202122232425262728293031323334353637383940414243@Testpublic void test1()&#123; StringBuilder s = new StringBuilder(); s.append(&quot;hello&quot;).append(true).append(&#x27;a&#x27;).append(12).append(&quot;atguigu&quot;); System.out.println(s); System.out.println(s.length());&#125;@Testpublic void test2()&#123; StringBuilder s = new StringBuilder(&quot;helloworld&quot;); s.insert(5, &quot;java&quot;); s.insert(5, &quot;chailinyan&quot;); System.out.println(s);&#125;@Testpublic void test3()&#123; StringBuilder s = new StringBuilder(&quot;helloworld&quot;); s.delete(1, 3); s.deleteCharAt(4); System.out.println(s);&#125;@Testpublic void test4()&#123; StringBuilder s = new StringBuilder(&quot;helloworld&quot;); s.reverse(); System.out.println(s);&#125;@Testpublic void test5()&#123; StringBuilder s = new StringBuilder(&quot;helloworld&quot;); s.setCharAt(2, &#x27;a&#x27;); System.out.println(s);&#125;@Testpublic void test6()&#123; StringBuilder s = new StringBuilder(&quot;helloworld&quot;); s.setLength(30); System.out.println(s);&#125; 2.3 效率测试1234567891011121314151617181920212223242526272829//初始设置long startTime = 0L;long endTime = 0L;String text = &quot;&quot;;StringBuffer buffer = new StringBuffer(&quot;&quot;);StringBuilder builder = new StringBuilder(&quot;&quot;);//开始对比startTime = System.currentTimeMillis();for (int i = 0; i &lt; 20000; i++) &#123; buffer.append(String.valueOf(i));&#125;endTime = System.currentTimeMillis();System.out.println(&quot;StringBuffer的执行时间：&quot; + (endTime - startTime));startTime = System.currentTimeMillis();for (int i = 0; i &lt; 20000; i++) &#123; builder.append(String.valueOf(i));&#125;endTime = System.currentTimeMillis();System.out.println(&quot;StringBuilder的执行时间：&quot; + (endTime - startTime));startTime = System.currentTimeMillis();for (int i = 0; i &lt; 20000; i++) &#123; text = text + i;&#125;endTime = System.currentTimeMillis();System.out.println(&quot;String的执行时间：&quot; + (endTime - startTime)); 2.4 练习笔试题：程序输出： 1234567891011String str = null;StringBuffer sb = new StringBuffer();sb.append(str);System.out.println(sb.length());//System.out.println(sb);//StringBuffer sb1 = new StringBuffer(str);System.out.println(sb1);// 3. JDK8之前：日期时间API3.1 java.lang.System类的方法 System类提供的public static long currentTimeMillis()：用来返回当前时间与1970年1月1日0时0分0秒之间以毫秒为单位的时间差。 此方法适于计算时间差。 计算世界时间的主要标准有： UTC(Coordinated Universal Time) GMT(Greenwich Mean Time) CST(Central Standard Time) 在国际无线电通信场合，为了统一起见，使用一个统一的时间，称为通用协调时(UTC, Universal Time Coordinated)。UTC与格林尼治平均时(GMT, Greenwich Mean Time)一样，都与英国伦敦的本地时相同。这里，UTC与GMT含义完全相同。 3.2 java.util.Date表示特定的瞬间，精确到毫秒。 构造器： Date()：使用无参构造器创建的对象可以获取本地当前时间。 Date(long 毫秒数)：把该毫秒值换算成日期时间对象 常用方法 getTime(): 返回自 1970 年 1 月 1 日 00:00:00 GMT 以来此 Date 对象表示的毫秒数。 toString(): 把此 Date 对象转换为以下形式的 String： dow mon dd hh:mm:ss zzz yyyy 其中： dow 是一周中的某一天 (Sun, Mon, Tue, Wed, Thu, Fri, Sat)，zzz是时间标准。 其它很多方法都过时了。 举例： 123456789101112131415161718192021222324252627282930313233@Testpublic void test1()&#123; Date d = new Date(); System.out.println(d);&#125;@Testpublic void test2()&#123; long time = System.currentTimeMillis(); System.out.println(time);//1559806982971 //当前系统时间距离1970-1-1 0:0:0 0毫秒的时间差，毫秒为单位&#125;@Testpublic void test3()&#123; Date d = new Date(); long time = d.getTime(); System.out.println(time);//1559807047979&#125;@Testpublic void test4()&#123; long time = 1559807047979L; Date d = new Date(time); System.out.println(d);&#125;@Testpublic void test5()&#123; long time = Long.MAX_VALUE; Date d = new Date(time); System.out.println(d);&#125; 3.3 java.text.SimpleDateFormat java.text.SimpleDateFormat类是一个不与语言环境有关的方式来格式化和解析日期的具体类。 可以进行格式化：日期 –&gt; 文本 可以进行解析：文本 –&gt; 日期 构造器： SimpleDateFormat() ：默认的模式和语言环境创建对象 public SimpleDateFormat(String pattern)：该构造方法可以用参数pattern指定的格式创建一个对象 格式化： public String format(Date date)：方法格式化时间对象date 解析： public Date parse(String source)：从给定字符串的开始解析文本，以生成一个日期。 123456789101112131415161718//格式化@Testpublic void test1()&#123; Date d = new Date(); SimpleDateFormat sf = new SimpleDateFormat(&quot;yyyy年MM月dd日 HH时mm分ss秒 SSS毫秒 E Z&quot;); //把Date日期转成字符串，按照指定的格式转 String str = sf.format(d); System.out.println(str);&#125;//解析@Testpublic void test2() throws ParseException&#123; String str = &quot;2022年06月06日 16时03分14秒 545毫秒 星期四 +0800&quot;; SimpleDateFormat sf = new SimpleDateFormat(&quot;yyyy年MM月dd日 HH时mm分ss秒 SSS毫秒 E Z&quot;); Date d = sf.parse(str); System.out.println(d);&#125; 3.4 java.util.Calendar(日历) Date类的API大部分被废弃了，替换为Calendar。 Calendar 类是一个抽象类，主用用于完成日期字段之间相互操作的功能。 获取Calendar实例的方法 使用Calendar.getInstance()方法 调用它的子类GregorianCalendar（公历）的构造器。 一个Calendar的实例是系统时间的抽象表示，可以修改或获取 YEAR、MONTH、DAY_OF_WEEK、HOUR_OF_DAY 、MINUTE、SECOND等 日历字段对应的时间值。 public int get(int field)：返回给定日历字段的值 public void set(int field,int value) ：将给定的日历字段设置为指定的值 public void add(int field,int amount)：根据日历的规则，为给定的日历字段添加或者减去指定的时间量 public final Date getTime()：将Calendar转成Date对象 public final void setTime(Date date)：使用指定的Date对象重置Calendar的时间 常用字段 注意： 获取月份时：一月是0，二月是1，以此类推，12月是11 获取星期时：周日是1，周二是2 ， 。。。。周六是7 示例代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import org.junit.Test;import java.util.Calendar;import java.util.TimeZone;public class TestCalendar &#123; @Test public void test1()&#123; Calendar c = Calendar.getInstance(); System.out.println(c); int year = c.get(Calendar.YEAR); int month = c.get(Calendar.MONTH)+1; int day = c.get(Calendar.DATE); int hour = c.get(Calendar.HOUR_OF_DAY); int minute = c.get(Calendar.MINUTE); System.out.println(year + &quot;-&quot; + month + &quot;-&quot; + day + &quot; &quot; + hour + &quot;:&quot; + minute); &#125; @Test public void test2()&#123; TimeZone t = TimeZone.getTimeZone(&quot;America/Los_Angeles&quot;); Calendar c = Calendar.getInstance(t); int year = c.get(Calendar.YEAR); int month = c.get(Calendar.MONTH)+1; int day = c.get(Calendar.DATE); int hour = c.get(Calendar.HOUR_OF_DAY); int minute = c.get(Calendar.MINUTE); System.out.println(year + &quot;-&quot; + month + &quot;-&quot; + day + &quot; &quot; + hour + &quot;:&quot; + minute); &#125; @Test public void test3()&#123; Calendar calendar = Calendar.getInstance(); // 从一个 Calendar 对象中获取 Date 对象 Date date = calendar.getTime(); // 使用给定的 Date 设置此 Calendar 的时间 date = new Date(234234235235L); calendar.setTime(date); calendar.set(Calendar.DAY_OF_MONTH, 8); System.out.println(&quot;当前时间日设置为8后,时间是:&quot; + calendar.getTime()); calendar.add(Calendar.HOUR, 2); System.out.println(&quot;当前时间加2小时后,时间是:&quot; + calendar.getTime()); calendar.add(Calendar.MONTH, -2); System.out.println(&quot;当前日期减2个月后,时间是:&quot; + calendar.getTime()); &#125;&#125; 3.5 练习输入年份和月份，输出该月日历。 闰年计算公式：年份可以被4整除但不能被100整除，或者可以被400整除。 4. JDK8：新的日期时间API如果我们可以跟别人说：“我们在1502643933071见面，别晚了！”那么就再简单不过了。但是我们希望时间与昼夜和四季有关，于是事情就变复杂了。JDK 1.0中包含了一个java.util.Date类，但是它的大多数方法已经在JDK 1.1引入Calendar类之后被弃用了。而Calendar并不比Date好多少。它们面临的问题是： 可变性：像日期和时间这样的类应该是不可变的。 偏移性：Date中的年份是从1900开始的，而月份都从0开始。 格式化：格式化只对Date有用，Calendar则不行。 此外，它们也不是线程安全的；不能处理闰秒等。 闰秒，是指为保持协调世界时接近于世界时时刻，由国际计量局统一规定在年底或年中（也可能在季末）对协调世界时增加或减少1秒的调整。由于地球自转的不均匀性和长期变慢性（主要由潮汐摩擦引起的），会使世界时（民用时）和原子时之间相差超过到±0.9秒时，就把协调世界时向前拨1秒（负闰秒，最后一分钟为59秒）或向后拨1秒（正闰秒，最后一分钟为61秒）； 闰秒一般加在公历年末或公历六月末。 目前，全球已经进行了27次闰秒，均为正闰秒。 总结：对日期和时间的操作一直是Java程序员最痛苦的地方之一。 第三次引入的API是成功的，并且Java 8中引入的java.time API 已经纠正了过去的缺陷，将来很长一段时间内它都会为我们服务。 Java 8 以一个新的开始为 Java 创建优秀的 API。新的日期时间API包含： java.time – 包含值对象的基础包 java.time.chrono – 提供对不同的日历系统的访问。 java.time.format – 格式化和解析时间和日期 java.time.temporal – 包括底层框架和扩展特性 java.time.zone – 包含时区支持的类 说明：新的 java.time 中包含了所有关于时钟（Clock），本地日期（LocalDate）、本地时间（LocalTime）、本地日期时间（LocalDateTime）、时区（ZonedDateTime）和持续时间（Duration）的类。 尽管有68个新的公开类型，但是大多数开发者只会用到基础包和format包，大概占总数的三分之一。 4.1 本地日期时间：LocalDate、LocalTime、LocalDateTime 方法 描述 now() &#x2F; now(ZoneId zone) 静态方法，根据当前时间创建对象&#x2F;指定时区的对象 of(xx,xx,xx,xx,xx,xxx) 静态方法，根据指定日期&#x2F;时间创建对象 getDayOfMonth()&#x2F;getDayOfYear() 获得月份天数(1-31) &#x2F;获得年份天数(1-366) getDayOfWeek() 获得星期几(返回一个 DayOfWeek 枚举值) getMonth() 获得月份, 返回一个 Month 枚举值 getMonthValue() &#x2F; getYear() 获得月份(1-12) &#x2F;获得年份 getHours()&#x2F;getMinute()&#x2F;getSecond() 获得当前对象对应的小时、分钟、秒 withDayOfMonth()&#x2F;withDayOfYear()&#x2F;withMonth()&#x2F;withYear() 将月份天数、年份天数、月份、年份修改为指定的值并返回新的对象 with(TemporalAdjuster t) 将当前日期时间设置为校对器指定的日期时间 plusDays(), plusWeeks(), plusMonths(), plusYears(),plusHours() 向当前对象添加几天、几周、几个月、几年、几小时 minusMonths() &#x2F; minusWeeks()&#x2F;minusDays()&#x2F;minusYears()&#x2F;minusHours() 从当前对象减去几月、几周、几天、几年、几小时 plus(TemporalAmount t)&#x2F;minus(TemporalAmount t) 添加或减少一个 Duration 或 Period isBefore()&#x2F;isAfter() 比较两个 LocalDate isLeapYear() 判断是否是闰年（在LocalDate类中声明） format(DateTimeFormatter t) 格式化本地日期、时间，返回一个字符串 parse(Charsequence text) 将指定格式的字符串解析为日期、时间 123456789101112131415161718192021222324252627282930313233343536373839404142434445import org.junit.Test;import java.time.LocalDate;import java.time.LocalDateTime;import java.time.LocalTime;public class TestLocalDateTime &#123; @Test public void test01()&#123; LocalDate now = LocalDate.now(); System.out.println(now); &#125; @Test public void test02()&#123; LocalTime now = LocalTime.now(); System.out.println(now); &#125; @Test public void test03()&#123; LocalDateTime now = LocalDateTime.now(); System.out.println(now); &#125; @Test public void test04()&#123; LocalDate lai = LocalDate.of(2019, 5, 13); System.out.println(lai); &#125; @Test public void test05()&#123; LocalDate lai = LocalDate.of(2019, 5, 13); System.out.println(lai.getDayOfYear()); &#125; @Test public void test06()&#123; LocalDate lai = LocalDate.of(2019, 5, 13); LocalDate go = lai.plusDays(160); System.out.println(go);//2019-10-20 &#125; @Test public void test7()&#123; LocalDate now = LocalDate.now(); LocalDate before = now.minusDays(100); System.out.println(before);//2019-02-26 &#125; &#125; 4.2 瞬时：Instant Instant：时间线上的一个瞬时点。 这可能被用来记录应用程序中的事件时间戳。 时间戳是指格林威治时间1970年01月01日00时00分00秒(北京时间1970年01月01日08时00分00秒)起至现在的总秒数。 java.time.Instant表示时间线上的一点，而不需要任何上下文信息，例如，时区。概念上讲，它只是简单的表示自1970年1月1日0时0分0秒（UTC）开始的秒数。 方法 描述 now() 静态方法，返回默认UTC时区的Instant类的对象 ofEpochMilli(long epochMilli) 静态方法，返回在1970-01-01 00:00:00基础上加上指定毫秒数之后的Instant类的对象 atOffset(ZoneOffset offset) 结合即时的偏移来创建一个 OffsetDateTime toEpochMilli() 返回1970-01-01 00:00:00到当前时间的毫秒数，即为时间戳 中国大陆、中国香港、中国澳门、中国台湾、蒙古国、新加坡、马来西亚、菲律宾、西澳大利亚州的时间与UTC的时差均为+8，也就是UTC+8。 instant.atOffset(ZoneOffset.ofHours(8)); 整个地球分为二十四时区，每个时区都有自己的本地时间。北京时区是东八区，领先UTC八个小时，在电子邮件信头的Date域记为+0800。如果在电子邮件的信头中有这么一行： Date: Fri, 08 Nov 2002 09:42:22 +0800 说明信件的发送地的地方时间是二○○二年十一月八号，星期五，早上九点四十二分（二十二秒），这个地方的本地时领先UTC八个小时(+0800， 就是东八区时间)。电子邮件信头的Date域使用二十四小时的时钟，而不使用AM和PM来标记上下午。 4.3 日期时间格式化：DateTimeFormatter该类提供了三种格式化方法： (了解)预定义的标准格式。如：ISO_LOCAL_DATE_TIME、ISO_LOCAL_DATE、ISO_LOCAL_TIME (了解)本地化相关的格式。如：ofLocalizedDate(FormatStyle.LONG) 12345// 本地化相关的格式。如：ofLocalizedDateTime()// FormatStyle.MEDIUM / FormatStyle.SHORT :适用于LocalDateTime // 本地化相关的格式。如：ofLocalizedDate()// FormatStyle.FULL / FormatStyle.LONG / FormatStyle.MEDIUM / FormatStyle.SHORT : 适用于LocalDate 自定义的格式。如：ofPattern(“yyyy-MM-dd hh:mm:ss”) 方 法 描 述 ofPattern(String pattern) 静态方法，返回一个指定字符串格式的DateTimeFormatter format(TemporalAccessor t) 格式化一个日期、时间，返回字符串 parse(CharSequence text) 将指定格式的字符序列解析为一个日期、时间 举例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657import org.junit.Test;import java.time.LocalDateTime;import java.time.ZoneId;import java.time.format.DateTimeFormatter;import java.time.format.FormatStyle;public class TestDatetimeFormatter &#123; @Test public void test1()&#123; // 方式一：预定义的标准格式。如：ISO_LOCAL_DATE_TIME;ISO_LOCAL_DATE;ISO_LOCAL_TIME DateTimeFormatter formatter = DateTimeFormatter.ISO_LOCAL_DATE_TIME; // 格式化:日期--&gt;字符串 LocalDateTime localDateTime = LocalDateTime.now(); String str1 = formatter.format(localDateTime); System.out.println(localDateTime); System.out.println(str1);//2022-12-04T21:02:14.808 // 解析：字符串 --&gt;日期 TemporalAccessor parse = formatter.parse(&quot;2022-12-04T21:02:14.808&quot;); LocalDateTime dateTime = LocalDateTime.from(parse); System.out.println(dateTime); &#125; @Test public void test2()&#123; LocalDateTime localDateTime = LocalDateTime.now(); // 方式二： // 本地化相关的格式。如：ofLocalizedDateTime() // FormatStyle.LONG / FormatStyle.MEDIUM / FormatStyle.SHORT :适用于LocalDateTime DateTimeFormatter formatter1 = DateTimeFormatter.ofLocalizedDateTime(FormatStyle.LONG); // 格式化 String str2 = formatter1.format(localDateTime); System.out.println(str2);// 2022年12月4日 下午09时03分55秒 // 本地化相关的格式。如：ofLocalizedDate() // FormatStyle.FULL / FormatStyle.LONG / FormatStyle.MEDIUM / FormatStyle.SHORT : 适用于LocalDate DateTimeFormatter formatter2 = DateTimeFormatter.ofLocalizedDate(FormatStyle.FULL); // 格式化 String str3 = formatter2.format(LocalDate.now()); System.out.println(str3);// 2022年12月4日 星期日 &#125; @Test public void test3()&#123; //方式三：自定义的方式（关注、重点） DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern(&quot;yyyy/MM/dd HH:mm:ss&quot;); //格式化 String strDateTime = dateTimeFormatter.format(LocalDateTime.now()); System.out.println(strDateTime); //2022/12/04 21:05:42 //解析 TemporalAccessor accessor = dateTimeFormatter.parse(&quot;2022/12/04 21:05:42&quot;); LocalDateTime localDateTime = LocalDateTime.from(accessor); System.out.println(localDateTime); //2022-12-04T21:05:42 &#125;&#125; 4.4 其它API1、指定时区日期时间：ZondId和ZonedDateTime ZoneId：该类中包含了所有的时区信息，一个时区的ID，如 Europe&#x2F;Paris ZonedDateTime：一个在ISO-8601日历系统时区的日期时间，如 2007-12-03T10:15:30+01:00 Europe&#x2F;Paris。 其中每个时区都对应着ID，地区ID都为“{区域}&#x2F;{城市}”的格式，例如：Asia&#x2F;Shanghai等 常见时区ID： 123Asia/ShanghaiUTCAmerica/New_York 可以通过ZondId获取所有可用的时区ID： 1234567891011121314151617181920212223242526import java.time.ZoneId;import java.time.ZonedDateTime;import java.util.Set;public class TestZone &#123; @Test public void test01() &#123; //需要知道一些时区的id //Set&lt;String&gt;是一个集合，容器 Set&lt;String&gt; availableZoneIds = ZoneId.getAvailableZoneIds(); //快捷模板iter for (String availableZoneId : availableZoneIds) &#123; System.out.println(availableZoneId); &#125; &#125; @Test public void test02()&#123; ZonedDateTime t1 = ZonedDateTime.now(); System.out.println(t1); ZonedDateTime t2 = ZonedDateTime.now(ZoneId.of(&quot;America/New_York&quot;)); System.out.println(t2); &#125;&#125; 2、持续日期&#x2F;时间：Period和Duration 持续时间：Duration，用于计算两个“时间”间隔 日期间隔：Period，用于计算两个“日期”间隔 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374import org.junit.Test;import java.time.Duration;import java.time.LocalDate;import java.time.LocalDateTime;import java.time.Period;public class TestPeriodDuration &#123; @Test public void test01()&#123; LocalDate t1 = LocalDate.now(); LocalDate t2 = LocalDate.of(2018, 12, 31); Period between = Period.between(t1, t2); System.out.println(between); System.out.println(&quot;相差的年数：&quot;+between.getYears()); System.out.println(&quot;相差的月数：&quot;+between.getMonths()); System.out.println(&quot;相差的天数：&quot;+between.getDays()); System.out.println(&quot;相差的总数：&quot;+between.toTotalMonths()); &#125; @Test public void test02()&#123; LocalDateTime t1 = LocalDateTime.now(); LocalDateTime t2 = LocalDateTime.of(2017, 8, 29, 0, 0, 0, 0); Duration between = Duration.between(t1, t2); System.out.println(between); System.out.println(&quot;相差的总天数：&quot;+between.toDays()); System.out.println(&quot;相差的总小时数：&quot;+between.toHours()); System.out.println(&quot;相差的总分钟数：&quot;+between.toMinutes()); System.out.println(&quot;相差的总秒数：&quot;+between.getSeconds()); System.out.println(&quot;相差的总毫秒数：&quot;+between.toMillis()); System.out.println(&quot;相差的总纳秒数：&quot;+between.toNanos()); System.out.println(&quot;不够一秒的纳秒数：&quot;+between.getNano()); &#125; @Test public void test03()&#123; //Duration:用于计算两个“时间”间隔，以秒和纳秒为基准 LocalTime localTime = LocalTime.now(); LocalTime localTime1 = LocalTime.of(15, 23, 32); //between():静态方法，返回Duration对象，表示两个时间的间隔 Duration duration = Duration.between(localTime1, localTime); System.out.println(duration); System.out.println(duration.getSeconds()); System.out.println(duration.getNano()); LocalDateTime localDateTime = LocalDateTime.of(2016, 6, 12, 15, 23, 32); LocalDateTime localDateTime1 = LocalDateTime.of(2017, 6, 12, 15, 23, 32); Duration duration1 = Duration.between(localDateTime1, localDateTime); System.out.println(duration1.toDays()); &#125; @Test public void test4()&#123; //Period:用于计算两个“日期”间隔，以年、月、日衡量 LocalDate localDate = LocalDate.now(); LocalDate localDate1 = LocalDate.of(2028, 3, 18); Period period = Period.between(localDate, localDate1); System.out.println(period); System.out.println(period.getYears()); System.out.println(period.getMonths()); System.out.println(period.getDays()); Period period1 = period.withYears(2); System.out.println(period1); &#125;&#125; 3、Clock：使用时区提供对当前即时、日期和时间的访问的时钟。 4、 TemporalAdjuster : 时间校正器。有时我们可能需要获取例如：将日期调整到“下一个工作日”等操作。TemporalAdjusters : 该类通过静态方法(firstDayOfXxx()&#x2F;lastDayOfXxx()&#x2F;nextXxx())提供了大量的常用 TemporalAdjuster 的实现。 123456789101112131415161718192021222324@Testpublic void test1()&#123; // TemporalAdjuster:时间校正器 // 获取当前日期的下一个周日是哪天？ TemporalAdjuster temporalAdjuster = TemporalAdjusters.next(DayOfWeek.SUNDAY); LocalDateTime localDateTime = LocalDateTime.now().with(temporalAdjuster); System.out.println(localDateTime); // 获取下一个工作日是哪天？ LocalDate localDate = LocalDate.now().with(new TemporalAdjuster() &#123; @Override public Temporal adjustInto(Temporal temporal) &#123; LocalDate date = (LocalDate) temporal; if (date.getDayOfWeek().equals(DayOfWeek.FRIDAY)) &#123; return date.plusDays(3); &#125; else if (date.getDayOfWeek().equals(DayOfWeek.SATURDAY)) &#123; return date.plusDays(2); &#125; else &#123; return date.plusDays(1); &#125; &#125; &#125;); System.out.println(&quot;下一个工作日是：&quot; + localDate);&#125; 4.5 与传统日期处理的转换 类 To 遗留类 From 遗留类 java.time.Instant与java.util.Date Date.from(instant) date.toInstant() java.time.Instant与java.sql.Timestamp Timestamp.from(instant) timestamp.toInstant() java.time.ZonedDateTime与java.util.GregorianCalendar GregorianCalendar.from(zonedDateTime) cal.toZonedDateTime() java.time.LocalDate与java.sql.Time Date.valueOf(localDate) date.toLocalDate() java.time.LocalTime与java.sql.Time Date.valueOf(localDate) date.toLocalTime() java.time.LocalDateTime与java.sql.Timestamp Timestamp.valueOf(localDateTime) timestamp.toLocalDateTime() java.time.ZoneId与java.util.TimeZone Timezone.getTimeZone(id) timeZone.toZoneId() java.time.format.DateTimeFormatter与java.text.DateFormat formatter.toFormat() 无 5. Java比较器我们知道基本数据类型的数据（除boolean类型外）需要比较大小的话，之间使用比较运算符即可，但是引用数据类型是不能直接使用比较运算符来比较大小的。那么，如何解决这个问题呢？ 在Java中经常会涉及到对象数组的排序问题，那么就涉及到对象之间的比较问题。 Java实现对象排序的方式有两种： 自然排序：java.lang.Comparable 定制排序：java.util.Comparator 5.1 自然排序：java.lang.Comparable Comparable接口强行对实现它的每个类的对象进行整体排序。这种排序被称为类的自然排序。 实现 Comparable 的类必须实现 compareTo(Object obj) 方法，两个对象即通过 compareTo(Object obj) 方法的返回值来比较大小。如果当前对象this大于形参对象obj，则返回正整数，如果当前对象this小于形参对象obj，则返回负整数，如果当前对象this等于形参对象obj，则返回零。 12345package java.lang;public interface Comparable&#123; int compareTo(Object obj);&#125; 实现Comparable接口的对象列表（和数组）可以通过 Collections.sort 或 Arrays.sort进行自动排序。实现此接口的对象可以用作有序映射中的键或有序集合中的元素，无需指定比较器。 对于类 C 的每一个 e1 和 e2 来说，当且仅当 e1.compareTo(e2) &#x3D;&#x3D; 0 与 e1.equals(e2) 具有相同的 boolean 值时，类 C 的自然排序才叫做与 equals 一致。建议（虽然不是必需的）最好使自然排序与 equals 一致。 Comparable 的典型实现：(默认都是从小到大排列的) String：按照字符串中字符的Unicode值进行比较 Character：按照字符的Unicode值来进行比较 数值类型对应的包装类以及BigInteger、BigDecimal：按照它们对应的数值大小进行比较 Boolean：true 对应的包装类实例大于 false 对应的包装类实例 Date、Time等：后面的日期时间比前面的日期时间大 代码示例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465package com.atguigu.api;public class Student implements Comparable &#123; private int id; private String name; private int score; private int age; public Student(int id, String name, int score, int age) &#123; this.id = id; this.name = name; this.score = score; this.age = age; &#125; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getScore() &#123; return score; &#125; public void setScore(int score) &#123; this.score = score; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; @Override public String toString() &#123; return &quot;Student&#123;&quot; + &quot;id=&quot; + id + &quot;, name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, score=&quot; + score + &quot;, age=&quot; + age + &#x27;&#125;&#x27;; &#125; @Override public int compareTo(Object o) &#123; //这些需要强制，将o对象向下转型为Student类型的变量，才能调用Student类中的属性 //默认按照学号比较大小 Student stu = (Student) o; return this.id - stu.id; &#125;&#125; 测试类 123456789101112131415161718192021222324252627282930313233343536package com.atguigu.api;public class TestStudent &#123; public static void main(String[] args) &#123; Student[] arr = new Student[5]; arr[0] = new Student(3,&quot;张三&quot;,90,23); arr[1] = new Student(1,&quot;熊大&quot;,100,22); arr[2] = new Student(5,&quot;王五&quot;,75,25); arr[3] = new Student(4,&quot;李四&quot;,85,24); arr[4] = new Student(2,&quot;熊二&quot;,85,18); //单独比较两个对象 System.out.println(arr[0].compareTo(arr[1])); System.out.println(arr[1].compareTo(arr[2])); System.out.println(arr[2].compareTo(arr[2])); System.out.println(&quot;所有学生：&quot;); for (int i = 0; i &lt; arr.length; i++) &#123; System.out.println(arr[i]); &#125; System.out.println(&quot;按照学号排序：&quot;); for (int i = 1; i &lt; arr.length; i++) &#123; for (int j = 0; j &lt; arr.length-i; j++) &#123; if(arr[j].compareTo(arr[j+1])&gt;0)&#123; Student temp = arr[j]; arr[j] = arr[j+1]; arr[j+1] = temp; &#125; &#125; &#125; for (int i = 0; i &lt; arr.length; i++) &#123; System.out.println(arr[i]); &#125; &#125;&#125; 再举例： 123456789101112131415161718192021222324252627282930313233343536373839public class Student implements Comparable &#123; private String name; private int score; public Student(String name, int score) &#123; this.name = name; this.score = score; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getScore() &#123; return score; &#125; public void setScore(int score) &#123; this.score = score; &#125; @Override public String toString() &#123; return &quot;Student&#123;&quot; + &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, score=&quot; + score + &#x27;&#125;&#x27;; &#125; @Override public int compareTo(Object o) &#123; return this.score - ((Student)o).score; &#125;&#125; 测试： 1234567891011@Testpublic void test02() &#123; Student[] students = new Student[3]; students[0] = new Student(&quot;张三&quot;, 96); students[1] = new Student(&quot;李四&quot;, 85); students[2] = new Student(&quot;王五&quot;, 98); System.out.println(Arrays.toString(students)); Arrays.sort(students); System.out.println(Arrays.toString(students));&#125; 再举例： 12345678910111213141516171819202122class Goods implements Comparable &#123; private String name; private double price; //按照价格，比较商品的大小 @Override public int compareTo(Object o) &#123; if(o instanceof Goods) &#123; Goods other = (Goods) o; if (this.price &gt; other.price) &#123; return 1; &#125; else if (this.price &lt; other.price) &#123; return -1; &#125; return 0; &#125; throw new RuntimeException(&quot;输入的数据类型不一致&quot;); &#125; //构造器、getter、setter、toString()方法略&#125; 测试： 1234567891011121314151617public class ComparableTest&#123; public static void main(String[] args) &#123; Goods[] all = new Goods[4]; all[0] = new Goods(&quot;《红楼梦》&quot;, 100); all[1] = new Goods(&quot;《西游记》&quot;, 80); all[2] = new Goods(&quot;《三国演义》&quot;, 140); all[3] = new Goods(&quot;《水浒传》&quot;, 120); Arrays.sort(all); System.out.println(Arrays.toString(all)); &#125;&#125; 5.2 定制排序：java.util.Comparator 思考 当元素的类型没有实现java.lang.Comparable接口而又不方便修改代码（例如：一些第三方的类，你只有.class文件，没有源文件） 如果一个类，实现了Comparable接口，也指定了两个对象的比较大小的规则，但是此时此刻我不想按照它预定义的方法比较大小，但是我又不能随意修改，因为会影响其他地方的使用，怎么办？ JDK在设计类库之初，也考虑到这种情况，所以又增加了一个java.util.Comparator接口。强行对多个对象进行整体排序的比较。 重写compare(Object o1,Object o2)方法，比较o1和o2的大小：如果方法返回正整数，则表示o1大于o2；如果返回0，表示相等；返回负整数，表示o1小于o2。 可以将 Comparator 传递给 sort 方法（如 Collections.sort 或 Arrays.sort），从而允许在排序顺序上实现精确控制。 12345package java.util;public interface Comparator&#123; int compare(Object o1,Object o2);&#125; 举例： 12345678910111213package com.atguigu.api;import java.util.Comparator;//定义定制比较器类public class StudentScoreComparator implements Comparator &#123; @Override public int compare(Object o1, Object o2) &#123; Student s1 = (Student) o1; Student s2 = (Student) o2; int result = s1.getScore() - s2.getScore(); return result != 0 ? result : s1.getId() - s2.getId(); &#125;&#125; 测试类 123456789101112131415161718192021222324252627282930313233package com.atguigu.api;public class TestStudent &#123; public static void main(String[] args) &#123; Student[] arr = new Student[5]; arr[0] = new Student(3, &quot;张三&quot;, 90, 23); arr[1] = new Student(1, &quot;熊大&quot;, 100, 22); arr[2] = new Student(5, &quot;王五&quot;, 75, 25); arr[3] = new Student(4, &quot;李四&quot;, 85, 24); arr[4] = new Student(2, &quot;熊二&quot;, 85, 18); System.out.println(&quot;所有学生：&quot;); for (int i = 0; i &lt; arr.length; i++) &#123; System.out.println(arr[i]); &#125; System.out.println(&quot;按照成绩排序&quot;); StudentScoreComparator sc = new StudentScoreComparator(); for (int i = 1; i &lt; arr.length; i++) &#123; for (int j = 0; j &lt; arr.length - i; j++) &#123; if (sc.compare(arr[j], arr[j + 1]) &gt; 0) &#123; Student temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; &#125; &#125; &#125; for (int i = 0; i &lt; arr.length; i++) &#123; System.out.println(arr[i]); &#125; &#125;&#125; 再举例： 12345678910111213141516@Testpublic void test01() &#123; Student[] students = new Student[5]; students[0] = new Student(3, &quot;张三&quot;, 90, 23); students[1] = new Student(1, &quot;熊大&quot;, 100, 22); students[2] = new Student(5, &quot;王五&quot;, 75, 25); students[3] = new Student(4, &quot;李四&quot;, 85, 24); students[4] = new Student(2, &quot;熊二&quot;, 85, 18); System.out.println(Arrays.toString(students)); //定制排序 StudentScoreComparator sc = new StudentScoreComparator(); Arrays.sort(students, sc); System.out.println(&quot;排序之后：&quot;); System.out.println(Arrays.toString(students));&#125; 再举例： 12345678910111213141516171819Goods[] all = new Goods[4];all[0] = new Goods(&quot;War and Peace&quot;, 100);all[1] = new Goods(&quot;Childhood&quot;, 80);all[2] = new Goods(&quot;Scarlet and Black&quot;, 140);all[3] = new Goods(&quot;Notre Dame de Paris&quot;, 120);Arrays.sort(all, new Comparator() &#123; @Override public int compare(Object o1, Object o2) &#123; Goods g1 = (Goods) o1; Goods g2 = (Goods) o2; return g1.getName().compareTo(g2.getName()); &#125;&#125;);System.out.println(Arrays.toString(all)); 6. 系统相关类6.1 java.lang.System类 System类代表系统，系统级的很多属性和控制方法都放置在该类的内部。该类位于java.lang包。 由于该类的构造器是private的，所以无法创建该类的对象。其内部的成员变量和成员方法都是static的，所以也可以很方便的进行调用。 成员变量 Scanner scan &#x3D; new Scanner(System.in); System类内部包含in、out和err三个成员变量，分别代表标准输入流(键盘输入)，标准输出流(显示器)和标准错误输出流(显示器)。 成员方法 native long currentTimeMillis()：该方法的作用是返回当前的计算机时间，时间的表达格式为当前计算机时间和GMT时间(格林威治时间)1970年1月1号0时0分0秒所差的毫秒数。 void exit(int status)：该方法的作用是退出程序。其中status的值为0代表正常退出，非零代表异常退出。使用该方法可以在图形界面编程中实现程序的退出功能等。 void gc()：该方法的作用是请求系统进行垃圾回收。至于系统是否立刻回收，则取决于系统中垃圾回收算法的实现以及系统执行时的情况。 String getProperty(String key)：该方法的作用是获得系统中属性名为key的属性对应的值。系统中常见的属性名以及属性的作用如下表所示： 举例 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071import org.junit.Test;public class TestSystem &#123; @Test public void test01()&#123; long time = System.currentTimeMillis(); System.out.println(&quot;现在的系统时间距离1970年1月1日凌晨：&quot; + time + &quot;毫秒&quot;); System.exit(0); System.out.println(&quot;over&quot;);//不会执行 &#125; @Test public void test02()&#123; String javaVersion = System.getProperty(&quot;java.version&quot;); System.out.println(&quot;java的version:&quot; + javaVersion); String javaHome = System.getProperty(&quot;java.home&quot;); System.out.println(&quot;java的home:&quot; + javaHome); String osName = System.getProperty(&quot;os.name&quot;); System.out.println(&quot;os的name:&quot; + osName); String osVersion = System.getProperty(&quot;os.version&quot;); System.out.println(&quot;os的version:&quot; + osVersion); String userName = System.getProperty(&quot;user.name&quot;); System.out.println(&quot;user的name:&quot; + userName); String userHome = System.getProperty(&quot;user.home&quot;); System.out.println(&quot;user的home:&quot; + userHome); String userDir = System.getProperty(&quot;user.dir&quot;); System.out.println(&quot;user的dir:&quot; + userDir); &#125; @Test public void test03() throws InterruptedException &#123; for (int i=1; i &lt;=10; i++)&#123; MyDemo my = new MyDemo(i); //每一次循环my就会指向新的对象，那么上次的对象就没有变量引用它了，就成垃圾对象 &#125; //为了看到垃圾回收器工作，我要加下面的代码，让main方法不那么快结束，因为main结束就会导致JVM退出，GC也会跟着结束。 System.gc();//如果不调用这句代码，GC可能不工作，因为当前内存很充足，GC就觉得不着急回收垃圾对象。 //调用这句代码，会让GC尽快来工作。 Thread.sleep(5000); &#125;&#125;class MyDemo&#123; private int value; public MyDemo(int value) &#123; this.value = value; &#125; @Override public String toString() &#123; return &quot;MyDemo&#123;&quot; + &quot;value=&quot; + value + &#x27;&#125;&#x27;; &#125; //重写finalize方法，让大家看一下它的调用效果 @Override protected void finalize() throws Throwable &#123;// 正常重写，这里是编写清理系统内存的代码// 这里写输出语句是为了看到finalize()方法被调用的效果 System.out.println(this+ &quot;轻轻的我走了，不带走一段代码....&quot;); &#125;&#125; static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length)： 从指定源数组中复制一个数组，复制从指定的位置开始，到目标数组的指定位置结束。常用于数组的插入和删除 12345678910111213141516171819202122232425262728import org.junit.Test;import java.util.Arrays;public class TestSystemArrayCopy &#123; @Test public void test01()&#123; int[] arr1 = &#123;1,2,3,4,5&#125;; int[] arr2 = new int[10]; System.arraycopy(arr1,0,arr2,3,arr1.length); System.out.println(Arrays.toString(arr1)); System.out.println(Arrays.toString(arr2)); &#125; @Test public void test02()&#123; int[] arr = &#123;1,2,3,4,5&#125;; System.arraycopy(arr,0,arr,1,arr.length-1); System.out.println(Arrays.toString(arr)); &#125; @Test public void test03()&#123; int[] arr = &#123;1,2,3,4,5&#125;; System.arraycopy(arr,1,arr,0,arr.length-1); System.out.println(Arrays.toString(arr)); &#125;&#125; 6.2 java.lang.Runtime类每个 Java 应用程序都有一个 Runtime 类实例，使应用程序能够与其运行的环境相连接。 public static Runtime getRuntime()： 返回与当前 Java 应用程序相关的运行时对象。应用程序不能创建自己的 Runtime 类实例。 public long totalMemory()：返回 Java 虚拟机中初始化时的内存总量。此方法返回的值可能随时间的推移而变化，这取决于主机环境。默认为物理电脑内存的1&#x2F;64。 public long maxMemory()：返回 Java 虚拟机中最大程度能使用的内存总量。默认为物理电脑内存的1&#x2F;4。 public long freeMemory()：回 Java 虚拟机中的空闲内存量。调用 gc 方法可能导致 freeMemory 返回值的增加。 12345678910111213141516171819package com.atguigu.system;public class TestRuntime &#123; public static void main(String[] args) &#123; Runtime runtime = Runtime.getRuntime(); long initialMemory = runtime.totalMemory(); //获取虚拟机初始化时堆内存总量 long maxMemory = runtime.maxMemory(); //获取虚拟机最大堆内存总量 String str = &quot;&quot;; //模拟占用内存 for (int i = 0; i &lt; 10000; i++) &#123; str += i; &#125; long freeMemory = runtime.freeMemory(); //获取空闲堆内存总量 System.out.println(&quot;总内存：&quot; + initialMemory / 1024 / 1024 * 64 + &quot;MB&quot;); System.out.println(&quot;总内存：&quot; + maxMemory / 1024 / 1024 * 4 + &quot;MB&quot;); System.out.println(&quot;空闲内存：&quot; + freeMemory / 1024 / 1024 + &quot;MB&quot;) ; System.out.println(&quot;已用内存：&quot; + (initialMemory-freeMemory) / 1024 / 1024 + &quot;MB&quot;); &#125;&#125; 7. 和数学相关的类7.1 java.lang.Mathjava.lang.Math 类包含用于执行基本数学运算的方法，如初等指数、对数、平方根和三角函数。类似这样的工具类，其所有方法均为静态方法，并且不会创建对象，调用起来非常简单。 public static double abs(double a) ：返回 double 值的绝对值。 12double d1 = Math.abs(-5); //d1的值为5double d2 = Math.abs(5); //d2的值为5 public static double ceil(double a) ：返回大于等于参数的最小的整数。 123double d1 = Math.ceil(3.3); //d1的值为 4.0double d2 = Math.ceil(-3.3); //d2的值为 -3.0double d3 = Math.ceil(5.1); //d3的值为 6.0 public static double floor(double a) ：返回小于等于参数最大的整数。 123double d1 = Math.floor(3.3); //d1的值为3.0double d2 = Math.floor(-3.3); //d2的值为-4.0double d3 = Math.floor(5.1); //d3的值为 5.0 public static long round(double a) ：返回最接近参数的 long。(相当于四舍五入方法) 1234long d1 = Math.round(5.5); //d1的值为6long d2 = Math.round(5.4); //d2的值为5long d3 = Math.round(-3.3); //d3的值为-3long d4 = Math.round(-3.8); //d4的值为-4 public static double pow(double a,double b)：返回a的b幂次方法 public static double sqrt(double a)：返回a的平方根 public static double random()：返回[0,1)的随机值 public static final double PI：返回圆周率 public static double max(double x, double y)：返回x,y中的最大值 public static double min(double x, double y)：返回x,y中的最小值 其它：acos,asin,atan,cos,sin,tan 三角函数 1234double result = Math.pow(2,31);double sqrt = Math.sqrt(256);double rand = Math.random();double pi = Math.PI; 7.2 java.math包7.2.1 BigInteger Integer类作为int的包装类，能存储的最大整型值为2^31-1，Long类也是有限的，最大为2^63-1。如果要表示再大的整数，不管是基本数据类型还是他们的包装类都无能为力，更不用说进行运算了。 java.math包的BigInteger可以表示不可变的任意精度的整数。BigInteger 提供所有 Java 的基本整数操作符的对应物，并提供 java.lang.Math 的所有相关方法。另外，BigInteger 还提供以下运算：模算术、GCD 计算、质数测试、素数生成、位操作以及一些其他操作。 构造器 BigInteger(String val)：根据字符串构建BigInteger对象 方法 public BigInteger abs()：返回此 BigInteger 的绝对值的 BigInteger。 BigInteger add(BigInteger val) ：返回其值为 (this + val) 的 BigInteger BigInteger subtract(BigInteger val) ：返回其值为 (this - val) 的 BigInteger BigInteger multiply(BigInteger val) ：返回其值为 (this * val) 的 BigInteger BigInteger divide(BigInteger val) ：返回其值为 (this &#x2F; val) 的 BigInteger。整数相除只保留整数部分。 BigInteger remainder(BigInteger val) ：返回其值为 (this % val) 的 BigInteger。 BigInteger[] divideAndRemainder(BigInteger val)：返回包含 (this &#x2F; val) 后跟 (this % val) 的两个 BigInteger 的数组。 BigInteger pow(int exponent) ：返回其值为 (this^exponent) 的 BigInteger。 123456789101112131415@Testpublic void test01()&#123; //long bigNum = 123456789123456789123456789L; BigInteger b1 = new BigInteger(&quot;12345678912345678912345678&quot;); BigInteger b2 = new BigInteger(&quot;78923456789123456789123456789&quot;); //System.out.println(&quot;和：&quot; + (b1+b2));//错误的，无法直接使用+进行求和 System.out.println(&quot;和：&quot; + b1.add(b2)); System.out.println(&quot;减：&quot; + b1.subtract(b2)); System.out.println(&quot;乘：&quot; + b1.multiply(b2)); System.out.println(&quot;除：&quot; + b2.divide(b1)); System.out.println(&quot;余：&quot; + b2.remainder(b1));&#125; 7.2.2 BigDecimal 一般的Float类和Double类可以用来做科学计算或工程计算，但在商业计算中，要求数字精度比较高，故用到java.math.BigDecimal类。 BigDecimal类支持不可变的、任意精度的有符号十进制定点数。 构造器 public BigDecimal(double val) public BigDecimal(String val) –&gt; 推荐 常用方法 public BigDecimal add(BigDecimal augend) public BigDecimal subtract(BigDecimal subtrahend) public BigDecimal multiply(BigDecimal multiplicand) public BigDecimal divide(BigDecimal divisor, int scale, int roundingMode)：divisor是除数，scale指明保留几位小数，roundingMode指明舍入模式（ROUND_UP :向上加1、ROUND_DOWN :直接舍去、ROUND_HALF_UP:四舍五入） 举例 1234567891011@Testpublic void test03()&#123; BigInteger bi = new BigInteger(&quot;12433241123&quot;); BigDecimal bd = new BigDecimal(&quot;12435.351&quot;); BigDecimal bd2 = new BigDecimal(&quot;11&quot;); System.out.println(bi); // System.out.println(bd.divide(bd2)); System.out.println(bd.divide(bd2, BigDecimal.ROUND_HALF_UP)); System.out.println(bd.divide(bd2, 15, BigDecimal.ROUND_HALF_UP));&#125; 7.3 java.util.Random用于产生随机数 boolean nextBoolean():返回下一个伪随机数，它是取自此随机数生成器序列的均匀分布的 boolean 值。 void nextBytes(byte[] bytes):生成随机字节并将其置于用户提供的 byte 数组中。 double nextDouble():返回下一个伪随机数，它是取自此随机数生成器序列的、在 0.0 和 1.0 之间均匀分布的 double 值。 float nextFloat():返回下一个伪随机数，它是取自此随机数生成器序列的、在 0.0 和 1.0 之间均匀分布的 float 值。 double nextGaussian():返回下一个伪随机数，它是取自此随机数生成器序列的、呈高斯（“正态”）分布的 double 值，其平均值是 0.0，标准差是 1.0。 int nextInt():返回下一个伪随机数，它是此随机数生成器的序列中均匀分布的 int 值。 int nextInt(int n):返回一个伪随机数，它是取自此随机数生成器序列的、在 0（包括）和指定值（不包括）之间均匀分布的 int 值。 long nextLong():返回下一个伪随机数，它是取自此随机数生成器序列的均匀分布的 long 值。 1234567@Testpublic void test04()&#123; Random r = new Random(); System.out.println(&quot;随机整数：&quot; + r.nextInt()); System.out.println(&quot;随机小数：&quot; + r.nextDouble()); System.out.println(&quot;随机布尔值：&quot; + r.nextBoolean());&#125;","categories":[{"name":"java基础","slug":"java基础","permalink":"http://example.com/categories/java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"java","slug":"java","permalink":"http://example.com/tags/java/"}]},{"title":"第07章_面向对象编程(进阶)","slug":"Java/尚硅谷_第07章_面向对象编程（进阶）/尚硅谷_宋红康_第07章_面向对象编程（进阶）","date":"2022-09-27T00:55:57.000Z","updated":"2023-10-07T11:38:36.281Z","comments":true,"path":"2022/09/27/Java/尚硅谷_第07章_面向对象编程（进阶）/尚硅谷_宋红康_第07章_面向对象编程（进阶）/","link":"","permalink":"http://example.com/2022/09/27/Java/%E5%B0%9A%E7%A1%85%E8%B0%B7_%E7%AC%AC07%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E8%BF%9B%E9%98%B6%EF%BC%89/%E5%B0%9A%E7%A1%85%E8%B0%B7_%E5%AE%8B%E7%BA%A2%E5%BA%B7_%E7%AC%AC07%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E8%BF%9B%E9%98%B6%EF%BC%89/","excerpt":"","text":"本章专题与脉络 1. 关键字：this1.1 this是什么？ 在Java中，this关键字不算难理解，它的作用和其词义很接近。 它在方法（准确的说是实例方法或非static的方法）内部使用，表示调用该方法的对象 它在构造器内部使用，表示该构造器正在初始化的对象。 this可以调用的结构：成员变量、方法和构造器 1.2 什么时候使用this1.2.1 实例方法或构造器中使用当前对象的成员在实例方法或构造器中，如果使用当前类的成员变量或成员方法可以在其前面添加this，增强程序的可读性。不过，通常我们都习惯省略this。 但是，当形参与成员变量同名时，如果在方法内或构造器内需要使用成员变量，必须添加this来表明该变量是类的成员变量。即：我们可以用this来区分成员变量和局部变量。比如： 另外，使用this访问属性和方法时，如果在本类中未找到，会从父类中查找。这个在继承中会讲到。 举例1： 12345678910111213141516171819202122class Person&#123; // 定义Person类 private String name ; private int age ; public Person(String name,int age)&#123; this.name = name ; this.age = age ; &#125; public void setName(String name)&#123; this.name = name; &#125; public void setAge(int age)&#123; this.age = age; &#125; public void getInfo()&#123; System.out.println(&quot;姓名：&quot; + name) ; this.speak(); &#125; public void speak()&#123; System.out.println(“年龄：” + this.age); &#125;&#125; 举例2： 1234567891011121314151617181920212223242526public class Rectangle &#123; int length; int width; public int area() &#123; return this.length * this.width; &#125; public int perimeter()&#123; return 2 * (this.length + this.width); &#125; public void print(char sign) &#123; for (int i = 1; i &lt;= this.width; i++) &#123; for (int j = 1; j &lt;= this.length; j++) &#123; System.out.print(sign); &#125; System.out.println(); &#125; &#125; public String getInfo()&#123; return &quot;长：&quot; + this.length + &quot;，宽：&quot; + this.width +&quot;，面积：&quot; + this.area() +&quot;，周长：&quot; + this.perimeter(); &#125;&#125; 测试类： 1234567891011121314151617181920212223public class TestRectangle &#123; public static void main(String[] args) &#123; Rectangle r1 = new Rectangle(); Rectangle r2 = new Rectangle(); System.out.println(&quot;r1对象：&quot; + r1.getInfo()); System.out.println(&quot;r2对象：&quot; + r2.getInfo()); r1.length = 10; r1.width = 2; System.out.println(&quot;r1对象：&quot; + r1.getInfo()); System.out.println(&quot;r2对象：&quot; + r2.getInfo()); r1.print(&#x27;#&#x27;); System.out.println(&quot;---------------------&quot;); r1.print(&#x27;&amp;&#x27;); System.out.println(&quot;---------------------&quot;); r2.print(&#x27;#&#x27;); System.out.println(&quot;---------------------&quot;); r2.print(&#x27;%&#x27;); &#125;&#125; 1.2.2 同一个类中构造器互相调用this可以作为一个类中构造器相互调用的特殊格式。 this()：调用本类的无参构造器 this(实参列表)：调用本类的有参构造器 12345678910111213141516171819202122232425262728293031323334353637public class Student &#123; private String name; private int age; // 无参构造 public Student() &#123;// this(&quot;&quot;,18);//调用本类有参构造器 &#125; // 有参构造 public Student(String name) &#123; this();//调用本类无参构造器 this.name = name; &#125; // 有参构造 public Student(String name,int age)&#123; this(name);//调用本类中有一个String参数的构造器 this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public String getInfo()&#123; return &quot;姓名：&quot; + name +&quot;，年龄：&quot; + age; &#125;&#125; 注意： 不能出现递归调用。比如，调用自身构造器。 推论：如果一个类中声明了n个构造器，则最多有 n - 1个构造器中使用了”this(形参列表)” this()和this(实参列表)只能声明在构造器首行。 推论：在类的一个构造器中，最多只能声明一个”this(参数列表)” 1.3 练习练习1：添加必要的构造器，综合应用构造器的重载，this关键字。 练习2： （1）按照如下的UML类图，创建相应的类，提供必要的结构： 在提款方法withdraw()中，需要判断用户余额是否能够满足提款数额的要求，如果不能，应给出提示。deposit()方法表示存款。 （2）按照如下的UML类图，创建相应的类，提供必要的结构 （3）按照如下的UML类图，创建相应的类，提供必要的结构 addCustomer 方法必须依照参数（姓，名）构造一个新的 Customer对象，然后把它放到 customer 数组中。还必须把 numberOfCustomer 属性的值加 1。 getNumOfCustomers 方法返回 numberofCustomers 属性值。 getCustomer方法返回与给出的index参数相关的客户。 （4）创建BankTest类，进行测试。 内存解析图： 2. 面向对象特征二：继承(Inheritance)2.1 继承的概述2.1.1 生活中的继承 财产继承： 绿化：前人栽树，后人乘凉 “绿水青山，就是金山银山” 样貌： 继承之外，是不是还可以”进化“： 继承有延续（下一代延续上一代的基因、财富）、扩展（下一代和上一代又有所不同）的意思。 2.1.2 Java中的继承角度一：从上而下 为描述和处理个人信息，定义类Person： 为描述和处理学生信息，定义类Student： 通过继承，简化Student类的定义： 说明：Student类继承了父类Person的所有属性和方法，并增加了一个属性school。Person中的属性和方法，Student都可以使用。 角度二：从下而上 多个类中存在相同属性和行为时，将这些内容抽取到单独一个类中，那么多个类中无需再定义这些属性和行为，只需要和抽取出来的类构成继承关系。如图所示： 再举例： 2.1.3 继承的好处 继承的出现减少了代码冗余，提高了代码的复用性。 继承的出现，更有利于功能的扩展。 继承的出现让类与类之间产生了is-a的关系，为多态的使用提供了前提。 继承描述事物之间的所属关系，这种关系是：is-a 的关系。可见，父类更通用、更一般，子类更具体。 注意：不要仅为了获取其他类中某个功能而去继承！ 2.2 继承的语法2.2.1 继承中的语法格式通过 extends 关键字，可以声明一个类B继承另外一个类A，定义格式如下： 12345678[修饰符] class 类A &#123; ...&#125;[修饰符] class 类B extends 类A &#123; ...&#125; 2.2.2 继承中的基本概念类B，称为子类、派生类(derived class)、SubClass 类A，称为父类、超类、基类(base class)、SuperClass 2.3 代码举例1、父类 123456789101112131415161718package com.atguigu.inherited.grammar;/* * 定义动物类Animal，做为父类 */public class Animal &#123; // 定义name属性 String name; // 定义age属性 int age; // 定义动物的吃东西方法 public void eat() &#123; System.out.println(age + &quot;岁的&quot; + name + &quot;在吃东西&quot;); &#125;&#125; 2、子类 123456789101112131415package com.atguigu.inherited.grammar;/* * 定义猫类Cat 继承 动物类Animal */public class Cat extends Animal &#123; int count;//记录每只猫抓的老鼠数量 // 定义一个猫抓老鼠的方法catchMouse public void catchMouse() &#123; count++; System.out.println(&quot;抓老鼠，已经抓了&quot; + count + &quot;只老鼠&quot;); &#125;&#125; 3、测试类 123456789101112131415161718package com.atguigu.inherited.grammar;public class TestCat &#123; public static void main(String[] args) &#123; // 创建一个猫类对象 Cat cat = new Cat(); // 为该猫类对象的name属性进行赋值 cat.name = &quot;Tom&quot;; // 为该猫类对象的age属性进行赋值 cat.age = 2; // 调用该猫继承来的eat()方法 cat.eat(); // 调用该猫的catchMouse()方法 cat.catchMouse(); cat.catchMouse(); cat.catchMouse(); &#125;&#125; 2.4 继承性的细节说明1、子类会继承父类所有的实例变量和实例方法 从类的定义来看，类是一类具有相同特性的事物的抽象描述。父类是所有子类共同特征的抽象描述。而实例变量和实例方法就是事物的特征，那么父类中声明的实例变量和实例方法代表子类事物也有这个特征。 当子类对象被创建时，在堆中给对象申请内存时，就要看子类和父类都声明了什么实例变量，这些实例变量都要分配内存。 当子类对象调用方法时，编译器会先在子类模板中看该类是否有这个方法，如果没找到，会看它的父类甚至父类的父类是否声明了这个方法，遵循从下往上找的顺序，找到了就停止，一直到根父类都没有找到，就会报编译错误。 所以继承意味着子类的对象除了看子类的类模板还要看父类的类模板。 2、子类不能直接访问父类中私有的(private)的成员变量和方法 子类虽会继承父类私有(private)的成员变量，但子类不能对继承的私有成员变量直接进行访问，可通过继承的get&#x2F;set方法进行访问。如图所示： 3、在Java 中，继承的关键字用的是“extends”，即子类不是父类的子集，而是对父类的“扩展” 子类在继承父类以后，还可以定义自己特有的方法，这就可以看做是对父类功能上的扩展。 4、Java支持多层继承(继承体系) 123class A&#123;&#125;class B extends A&#123;&#125;class C extends B&#123;&#125; 说明： 子类和父类是一种相对的概念 顶层父类是Object类。所有的类默认继承Object，作为父类。 5、一个父类可以同时拥有多个子类 1234class A&#123;&#125;class B extends A&#123;&#125;class D extends A&#123;&#125;class E extends A&#123;&#125; 6、Java只支持单继承，不支持多重继承 123456public class A&#123;&#125;class B extends A&#123;&#125;//一个类只能有一个父类，不可以有多个直接父类。class C extends B&#123;&#125; //okclass C extends A,B... //error 2.5 练习练习1：定义一个学生类Student，它继承自Person类 练习2： (1)定义一个ManKind类，包括 成员变量int sex和int salary； 方法void manOrWoman()：根据sex的值显示“man”(sex&#x3D;&#x3D;1)或者“woman”(sex&#x3D;&#x3D;0)； 方法void employeed()：根据salary的值显示“no job”(salary&#x3D;&#x3D;0)或者“ job”(salary!&#x3D;0)。 (2)定义类Kids继承ManKind，并包括 成员变量int yearsOld； 方法printAge()打印yearsOld的值。 (3)定义类KidsTest，在类的main方法中实例化Kids的对象someKid，用该对象访问其父类的成员变量及方法。 练习3：根据下图实现类。在CylinderTest类中创建Cylinder类的对象，设置圆柱的底面半径和高，并输出圆柱的体积。 3. 方法的重写（override&#x2F;overwrite）父类的所有方法子类都会继承，但是当某个方法被继承到子类之后，子类觉得父类原来的实现不适合于自己当前的类，该怎么办呢？子类可以对从父类中继承来的方法进行改造，我们称为方法的重写 (override、overwrite)。也称为方法的重置、覆盖。 在程序执行时，子类的方法将覆盖父类的方法。 3.1 方法重写举例比如新的手机增加来电显示头像的功能，代码如下： 1234567891011121314package com.atguigu.inherited.method;public class Phone &#123; public void sendMessage()&#123; System.out.println(&quot;发短信&quot;); &#125; public void call()&#123; System.out.println(&quot;打电话&quot;); &#125; public void showNum()&#123; System.out.println(&quot;来电显示号码&quot;); &#125;&#125; 1234567891011121314151617package com.atguigu.inherited.method;//SmartPhone：智能手机public class SmartPhone extends Phone&#123; //重写父类的来电显示功能的方法 @Override public void showNum()&#123; //来电显示姓名和图片功能 System.out.println(&quot;显示来电姓名&quot;); System.out.println(&quot;显示头像&quot;); &#125; //重写父类的通话功能的方法 @Override public void call() &#123; System.out.println(&quot;语音通话 或 视频通话&quot;); &#125;&#125; 1234567891011121314package com.atguigu.inherited.method;public class TestOverride &#123; public static void main(String[] args) &#123; // 创建子类对象 SmartPhone sp = new SmartPhone(); // 调用父类继承而来的方法 sp.call(); // 调用子类重写的方法 sp.showNum(); &#125;&#125; @Override使用说明： 写在方法上面，用来检测是不是满足重写方法的要求。这个注解就算不写，只要满足要求，也是正确的方法覆盖重写。建议保留，这样编译器可以帮助我们检查格式，另外也可以让阅读源代码的程序员清晰的知道这是一个重写的方法。 3.2 方法重写的要求 子类重写的方法必须和父类被重写的方法具有相同的方法名称、参数列表。 子类重写的方法的返回值类型不能大于父类被重写的方法的返回值类型。（例如：Student &lt; Person）。 注意：如果返回值类型是基本数据类型和void，那么必须是相同 子类重写的方法使用的访问权限不能小于父类被重写的方法的访问权限。（public &gt; protected &gt; 缺省 &gt; private） 注意：① 父类私有方法不能重写 ② 跨包的父类缺省的方法也不能重写 子类方法抛出的异常不能大于父类被重写方法的异常 此外，子类与父类中同名同参数的方法必须同时声明为非static的(即为重写)，或者同时声明为static的（不是重写）。因为static方法是属于类的，子类无法覆盖父类的方法。 3.3 小结：方法的重载与重写方法的重载：方法名相同，形参列表不同。不看返回值类型。 方法的重写：见上面。 （1）同一个类中 12345678910111213package com.atguigu.inherited.method;public class TestOverload &#123; public int max(int a, int b)&#123; return a &gt; b ? a : b; &#125; public double max(double a, double b)&#123; return a &gt; b ? a : b; &#125; public int max(int a, int b,int c)&#123; return max(max(a,b),c); &#125;&#125; （2）父子类中 12345678910111213141516171819202122232425262728package com.atguigu.inherited.method;public class TestOverloadOverride &#123; public static void main(String[] args) &#123; Son s = new Son(); s.method(1);//只有一个形式的method方法 Daughter d = new Daughter(); d.method(1); d.method(1,2);//有两个形式的method方法 &#125;&#125;class Father&#123; public void method(int i)&#123; System.out.println(&quot;Father.method&quot;); &#125;&#125;class Son extends Father&#123; public void method(int i)&#123;//重写 System.out.println(&quot;Son.method&quot;); &#125;&#125;class Daughter extends Father&#123; public void method(int i,int j)&#123;//重载 System.out.println(&quot;Daughter.method&quot;); &#125;&#125; 3.4 练习练习1：如果现在父类的一个方法定义成private访问权限，在子类中将此方法声明为default访问权限，那么这样还叫重写吗？ (NO) 练习2：修改继承内容的练习2中定义的类Kids，在Kids中重新定义employeed()方法，覆盖父类ManKind中定义的employeed()方法，输出“Kids should study and no job.” 4. 再谈封装性中的4种权限修饰权限修饰符：public,protected,缺省,private 修饰符 本类 本包 其他包子类 其他包非子类 private √ × × × 缺省 √ √（本包子类非子类都可见） × × protected √ √（本包子类非子类都可见） √（其他包仅限于子类中可见） × public √ √ √ √ 外部类：public和缺省 成员变量、成员方法等：public,protected,缺省,private 1、外部类要跨包使用必须是public，否则仅限于本包使用 （1）外部类的权限修饰符如果缺省，本包使用没问题 （2）外部类的权限修饰符如果缺省，跨包使用有问题 2、成员的权限修饰符问题 （1）本包下使用：成员的权限修饰符可以是public、protected、缺省 （2）跨包下使用：要求严格 （3）跨包使用时，如果类的权限修饰符缺省，成员权限修饰符&gt;类的权限修饰符也没有意义 5. 关键字：super5.1 super的理解在Java类中使用super来调用父类中的指定操作： super可用于访问父类中定义的属性 super可用于调用父类中定义的成员方法 super可用于在子类构造器中调用父类的构造器 注意： 尤其当子父类出现同名成员时，可以用super表明调用的是父类中的成员 super的追溯不仅限于直接父类 super和this的用法相像，this代表本类对象的引用，super代表父类的内存空间的标识 5.2 super的使用场景5.2.1 子类中调用父类被重写的方法 如果子类没有重写父类的方法，只要权限修饰符允许，在子类中完全可以直接调用父类的方法； 如果子类重写了父类的方法，在子类中需要通过super.才能调用父类被重写的方法，否则默认调用的子类重写的方法 举例： 1234567891011121314151617181920212223242526package com.atguigu.inherited.method;public class Phone &#123; public void sendMessage()&#123; System.out.println(&quot;发短信&quot;); &#125; public void call()&#123; System.out.println(&quot;打电话&quot;); &#125; public void showNum()&#123; System.out.println(&quot;来电显示号码&quot;); &#125;&#125;//smartphone：智能手机public class SmartPhone extends Phone&#123; //重写父类的来电显示功能的方法 public void showNum()&#123; //来电显示姓名和图片功能 System.out.println(&quot;显示来电姓名&quot;); System.out.println(&quot;显示头像&quot;); //保留父类来电显示号码的功能 super.showNum();//此处必须加super.，否则就是无限递归，那么就会栈内存溢出 &#125;&#125; 总结： 方法前面没有super.和this. 先从子类找匹配方法，如果没有，再从直接父类找，再没有，继续往上追溯 方法前面有this. 先从子类找匹配方法，如果没有，再从直接父类找，再没有，继续往上追溯 方法前面有super. 从当前子类的直接父类找，如果没有，继续往上追溯 5.2.2 子类中调用父类中同名的成员变量 如果实例变量与局部变量重名，可以在实例变量前面加this.进行区别 如果子类实例变量和父类实例变量重名，并且父类的该实例变量在子类仍然可见，在子类中要访问父类声明的实例变量需要在父类实例变量前加super.，否则默认访问的是子类自己声明的实例变量 如果父子类实例变量没有重名，只要权限修饰符允许，在子类中完全可以直接访问父类中声明的实例变量，也可以用this.实例访问，也可以用super.实例变量访问 举例： 12345678910111213141516171819202122232425262728293031323334353637class Father&#123; int a = 10; int b = 11;&#125;class Son extends Father&#123; int a = 20; public void test()&#123; //子类与父类的属性同名，子类对象中就有两个a System.out.println(&quot;子类的a：&quot; + a);//20 先找局部变量找，没有再从本类成员变量找 System.out.println(&quot;子类的a：&quot; + this.a);//20 先从本类成员变量找 System.out.println(&quot;父类的a：&quot; + super.a);//10 直接从父类成员变量找 //子类与父类的属性不同名，是同一个b System.out.println(&quot;b = &quot; + b);//11 先找局部变量找，没有再从本类成员变量找，没有再从父类找 System.out.println(&quot;b = &quot; + this.b);//11 先从本类成员变量找，没有再从父类找 System.out.println(&quot;b = &quot; + super.b);//11 直接从父类局部变量找 &#125; public void method(int a, int b)&#123; //子类与父类的属性同名，子类对象中就有两个成员变量a，此时方法中还有一个局部变量a System.out.println(&quot;局部变量的a：&quot; + a);//30 先找局部变量 System.out.println(&quot;子类的a：&quot; + this.a);//20 先从本类成员变量找 System.out.println(&quot;父类的a：&quot; + super.a);//10 直接从父类成员变量找 System.out.println(&quot;b = &quot; + b);//13 先找局部变量 System.out.println(&quot;b = &quot; + this.b);//11 先从本类成员变量找 System.out.println(&quot;b = &quot; + super.b);//11 直接从父类局部变量找 &#125;&#125;class Test&#123; public static void main(String[] args)&#123; Son son = new Son(); son.test(); son.method(30,13); &#125;&#125; 总结：起点不同（就近原则） 变量前面没有super.和this. 在构造器、代码块、方法中如果出现使用某个变量，先查看是否是当前块声明的局部变量， 如果不是局部变量，先从当前执行代码的本类去找成员变量 如果从当前执行代码的本类中没有找到，会往上找父类声明的成员变量（权限修饰符允许在子类中访问的） 变量前面有this. 通过this找成员变量时，先从当前执行代码的&#x3D;&#x3D;本类去找成员变量&#x3D;&#x3D; 如果从当前执行代码的本类中没有找到，会往上找&#x3D;&#x3D;父类声明的成员变量（&#x3D;&#x3D;权限修饰符允许在子类中访问的） 变量前面super. 通过super找成员变量，直接从当前执行代码的直接父类去找成员变量（权限修饰符允许在子类中访问的） 如果直接父类没有，就去父类的父类中找（权限修饰符允许在子类中访问的） 特别说明：应该避免子类声明和父类重名的成员变量 在阿里的开发规范等文档中都做出明确说明： 5.2.3 子类构造器中调用父类构造器① 子类继承父类时，不会继承父类的构造器。只能通过“super(形参列表)”的方式调用父类指定的构造器。 ② 规定：“super(形参列表)”，必须声明在构造器的首行。 ③ 我们前面讲过，在构造器的首行可以使用”this(形参列表)”，调用本类中重载的构造器， 结合②，结论：在构造器的首行，”this(形参列表)” 和 “super(形参列表)”只能二选一。 ④ 如果在子类构造器的首行既没有显示调用”this(形参列表)”，也没有显式调用”super(形参列表)”，​ 则子类此构造器默认调用”super()”，即调用父类中空参的构造器。 ⑤ 由③和④得到结论：子类的任何一个构造器中，要么会调用本类中重载的构造器，要么会调用父类的构造器。 只能是这两种情况之一。 ⑥ 由⑤得到：一个类中声明有n个构造器，最多有n-1个构造器中使用了”this(形参列表)”，则剩下的那个一定使用”super(形参列表)”。 开发中常见错误： 如果子类构造器中既未显式调用父类或本类的构造器，且父类中又没有空参的构造器，则编译出错。 情景举例1： 1234567891011121314class A&#123;&#125;class B extends A&#123;&#125;class Test&#123; public static void main(String[] args)&#123; B b = new B(); //A类和B类都是默认有一个无参构造，B类的默认无参构造中还会默认调用A类的默认无参构造 //但是因为都是默认的，没有打印语句，看不出来 &#125;&#125; 情景举例2： 1234567891011121314151617class A&#123; A()&#123; System.out.println(&quot;A类无参构造器&quot;); &#125;&#125;class B extends A&#123;&#125;class Test&#123; public static void main(String[] args)&#123; B b = new B(); //A类显示声明一个无参构造， //B类默认有一个无参构造， //B类的默认无参构造中会默认调用A类的无参构造 //可以看到会输出“A类无参构造器&quot; &#125;&#125; 情景举例3： 12345678910111213141516171819class A&#123; A()&#123; System.out.println(&quot;A类无参构造器&quot;); &#125;&#125;class B extends A&#123; B()&#123; System.out.println(&quot;B类无参构造器&quot;); &#125;&#125;class Test&#123; public static void main(String[] args)&#123; B b = new B(); //A类显示声明一个无参构造， //B类显示声明一个无参构造， //B类的无参构造中虽然没有写super()，但是仍然会默认调用A类的无参构造 //可以看到会输出“A类无参构造器&quot;和&quot;B类无参构造器&quot;) &#125;&#125; 情景举例4： 1234567891011121314151617181920class A&#123; A()&#123; System.out.println(&quot;A类无参构造器&quot;); &#125;&#125;class B extends A&#123; B()&#123; super(); System.out.println(&quot;B类无参构造器&quot;); &#125;&#125;class Test&#123; public static void main(String[] args)&#123; B b = new B(); //A类显示声明一个无参构造， //B类显示声明一个无参构造， //B类的无参构造中明确写了super()，表示调用A类的无参构造 //可以看到会输出“A类无参构造器&quot;和&quot;B类无参构造器&quot;) &#125;&#125; 情景举例5： 12345678910111213141516171819class A&#123; A(int a)&#123; System.out.println(&quot;A类有参构造器&quot;); &#125;&#125;class B extends A&#123; B()&#123; System.out.println(&quot;B类无参构造器&quot;); &#125;&#125;class Test05&#123; public static void main(String[] args)&#123; B b = new B(); //A类显示声明一个有参构造，没有写无参构造，那么A类就没有无参构造了 //B类显示声明一个无参构造， //B类的无参构造没有写super(...)，表示默认调用A类的无参构造 //编译报错，因为A类没有无参构造 &#125;&#125; 情景举例6： 1234567891011121314151617181920class A&#123; A(int a)&#123; System.out.println(&quot;A类有参构造器&quot;); &#125;&#125;class B extends A&#123; B()&#123; super(); System.out.println(&quot;B类无参构造器&quot;); &#125;&#125;class Test06&#123; public static void main(String[] args)&#123; B b = new B(); //A类显示声明一个有参构造，没有写无参构造，那么A类就没有无参构造了 //B类显示声明一个无参构造， //B类的无参构造明确写super()，表示调用A类的无参构造 //编译报错，因为A类没有无参构造 &#125;&#125; 情景举例7： 1234567891011121314151617181920class A&#123; A(int a)&#123; System.out.println(&quot;A类有参构造器&quot;); &#125;&#125;class B extends A&#123; B(int a)&#123; super(a); System.out.println(&quot;B类有参构造器&quot;); &#125;&#125;class Test07&#123; public static void main(String[] args)&#123; B b = new B(10); //A类显示声明一个有参构造，没有写无参构造，那么A类就没有无参构造了 //B类显示声明一个有参构造， //B类的有参构造明确写super(a)，表示调用A类的有参构造 //会打印“A类有参构造器&quot;和&quot;B类有参构造器&quot; &#125;&#125; 情景举例8： 123456789101112131415161718192021222324class A&#123; A()&#123; System.out.println(&quot;A类无参构造器&quot;); &#125; A(int a)&#123; System.out.println(&quot;A类有参构造器&quot;); &#125;&#125;class B extends A&#123; B()&#123; super();//可以省略，调用父类的无参构造 System.out.println(&quot;B类无参构造器&quot;); &#125; B(int a)&#123; super(a);//调用父类有参构造 System.out.println(&quot;B类有参构造器&quot;); &#125;&#125;class Test8&#123; public static void main(String[] args)&#123; B b1 = new B(); B b2 = new B(10); &#125;&#125; 5.3 小结：this与super1、this和super的意义 this：当前对象 在构造器和非静态代码块中，表示正在new的对象 在实例方法中，表示调用当前方法的对象 super：引用父类声明的成员 2、this和super的使用格式 this this.成员变量：表示当前对象的某个成员变量，而不是局部变量 this.成员方法：表示当前对象的某个成员方法，完全可以省略this. this()或this(实参列表)：调用另一个构造器协助当前对象的实例化，只能在构造器首行，只会找本类的构造器，找不到就报错 super super.成员变量：表示当前对象的某个成员变量，该成员变量在父类中声明的 super.成员方法：表示当前对象的某个成员方法，该成员方法在父类中声明的 super()或super(实参列表)：调用父类的构造器协助当前对象的实例化，只能在构造器首行，只会找直接父类的对应构造器，找不到就报错 5.4 练习练习1：修改方法重写的练习2中定义的类Kids中employeed()方法，在该方法中调用父类ManKind的employeed()方法，然后再输出“but Kids should study and no job.” 练习2：修改继承中的练习3中定义的Cylinder类，在Cylinder类中覆盖findArea()方法，计算圆柱的表面积。考虑：findVolume方法怎样做相应的修改？ 在CylinderTest类中创建Cylinder类的对象，设置圆柱的底面半径和高，并输出圆柱的表面积和体积。 附加题：在CylinderTest类中创建一个Circle类的对象，设置圆的半径，计算输出圆的面积。体会父类和子类成员的分别调用。 练习3： 1、写一个名为Account的类模拟账户。该类的属性和方法如下图所示。该类包括的属性：账号id，余额balance，年利率annualInterestRate；包含的方法：访问器方法（getter和setter方法），返回月利率的方法getMonthlyInterest()，取款方法withdraw()，存款方法deposit()。 写一个用户程序测试Account类。在用户程序中，创建一个账号为1122、余额为20000、年利率4.5%的Account对象。使用withdraw方法提款30000元，并打印余额。再使用withdraw方法提款2500元，使用deposit方法存款3000元，然后打印余额和月利率。 提示：在提款方法withdraw中，需要判断用户余额是否能够满足提款数额的要求，如果不能，应给出提示。运行结果如图所示： 2、创建Account类的一个子类CheckAccount代表可透支的账户，该账户中定义一个属性overdraft代表可透支限额。在CheckAccount类中重写withdraw方法，其算法如下： 12345678如果（取款金额&lt;账户余额）， 可直接取款如果（取款金额&gt;账户余额）， 计算需要透支的额度 判断可透支额overdraft是否足够支付本次透支需要，如果可以 将账户余额修改为0，冲减可透支金额 如果不可以 提示用户超过可透支额的限额 要求：写一个用户程序测试CheckAccount类。在用户程序中，创建一个账号为1122、余额为20000、年利率4.5%，可透支限额为5000元的CheckAccount对象。 使用withdraw方法提款5000元，并打印账户余额和可透支额。 再使用withdraw方法提款18000元，并打印账户余额和可透支额。 再使用withdraw方法提款3000元，并打印账户余额和可透支额。 提示： （1）子类CheckAccount的构造方法需要将从父类继承的3个属性和子类自己的属性全部初始化。 （2）父类Account的属性balance被设置为private，但在子类CheckAccount的withdraw方法中需要修改它的值，因此应修改父类的balance属性，定义其为protected。 运行结果如下图所示： 6. 子类对象实例化全过程 1Dog dog = new Dog(&quot;小花&quot;,&quot;小红&quot;); 举例： 123456789101112131415161718192021222324class Creature &#123; public Creature() &#123; System.out.println(&quot;Creature无参数的构造器&quot;); &#125;&#125;class Animal extends Creature &#123; public Animal(String name) &#123; System.out.println(&quot;Animal带一个参数的构造器，该动物的name为&quot; + name); &#125; public Animal(String name, int age) &#123; this(name); System.out.println(&quot;Animal带两个参数的构造器，其age为&quot; + age); &#125;&#125;public class Dog extends Animal &#123; public Dog() &#123; super(&quot;汪汪队阿奇&quot;, 3); System.out.println(&quot;Dog无参数的构造器&quot;); &#125; public static void main(String[] args) &#123; new Dog(); &#125;&#125; 7. 面向对象特征三：多态性 一千个读者眼中有一千个哈姆雷特。 7.1 多态的形式和体现7.1.1 对象的多态性多态性，是面向对象中最重要的概念，在Java中的体现：对象的多态性：父类的引用指向子类的对象 格式：（父类类型：指子类继承的父类类型，或者实现的接口类型） 1父类类型 变量名 = 子类对象； 举例： 12345Person p = new Student();Object o = new Person();//Object类型的变量o，指向Person类型的对象o = new Student(); //Object类型的变量o，指向Student类型的对象 对象的多态：在Java中，子类的对象可以替代父类的对象使用。所以，一个引用类型变量可能指向(引用)多种不同类型的对象 7.1.2 多态的理解Java引用变量有两个类型：编译时类型和运行时类型。编译时类型由声明该变量时使用的类型决定，运行时类型由实际赋给该变量的对象决定。简称：编译时，看左边；运行时，看右边。 若编译时类型和运行时类型不一致，就出现了对象的多态性(Polymorphism) 多态情况下，“看左边”：看的是父类的引用（父类中不具备子类特有的方法） “看右边”：看的是子类的对象（实际运行的是子类重写父类的方法） 多态的使用前提：① 类的继承关系 ② 方法的重写 7.1.3 举例1234567891011121314151617package com.atguigu.polymorphism.grammar;public class Pet &#123; private String nickname; //昵称 public String getNickname() &#123; return nickname; &#125; public void setNickname(String nickname) &#123; this.nickname = nickname; &#125; public void eat()&#123; System.out.println(nickname + &quot;吃东西&quot;); &#125;&#125; 1234567891011121314package com.atguigu.polymorphism.grammar;public class Cat extends Pet &#123; //子类重写父类的方法 @Override public void eat() &#123; System.out.println(&quot;猫咪&quot; + getNickname() + &quot;吃鱼仔&quot;); &#125; //子类扩展的方法 public void catchMouse() &#123; System.out.println(&quot;抓老鼠&quot;); &#125;&#125; 1234567891011121314package com.atguigu.polymorphism.grammar;public class Dog extends Pet &#123; //子类重写父类的方法 @Override public void eat() &#123; System.out.println(&quot;狗子&quot; + getNickname() + &quot;啃骨头&quot;); &#125; //子类扩展的方法 public void watchHouse() &#123; System.out.println(&quot;看家&quot;); &#125;&#125; 1、方法内局部变量的赋值体现多态 123456789101112131415161718192021package com.atguigu.polymorphism.grammar;public class TestPet &#123; public static void main(String[] args) &#123; //多态引用 Pet pet = new Dog(); pet.setNickname(&quot;小白&quot;); //多态的表现形式 /* 编译时看父类：只能调用父类声明的方法，不能调用子类扩展的方法； 运行时，看“子类”，如果子类重写了方法，一定是执行子类重写的方法体； */ pet.eat();//运行时执行子类Dog重写的方法// pet.watchHouse();//不能调用Dog子类扩展的方法 pet = new Cat(); pet.setNickname(&quot;雪球&quot;); pet.eat();//运行时执行子类Cat重写的方法 &#125;&#125; 2、方法的形参声明体现多态 1234567891011package com.atguigu.polymorphism.grammar;public class Person&#123; private Pet pet; public void adopt(Pet pet) &#123;//形参是父类类型，实参是子类对象 this.pet = pet; &#125; public void feed()&#123; pet.eat();//pet实际引用的对象类型不同，执行的eat方法也不同 &#125;&#125; 1234567891011121314151617package com.atguigu.polymorphism.grammar;public class TestPerson &#123; public static void main(String[] args) &#123; Person person = new Person(); Dog dog = new Dog(); dog.setNickname(&quot;小白&quot;); person.adopt(dog);//实参是dog子类对象，形参是父类Pet类型 person.feed(); Cat cat = new Cat(); cat.setNickname(&quot;雪球&quot;); person.adopt(cat);//实参是cat子类对象，形参是父类Pet类型 person.feed(); &#125;&#125; 3、方法返回值类型体现多态 1234567891011121314package com.atguigu.polymorphism.grammar;public class PetShop &#123; //返回值类型是父类类型，实际返回的是子类对象 public Pet sale(String type)&#123; switch (type)&#123; case &quot;Dog&quot;: return new Dog(); case &quot;Cat&quot;: return new Cat(); &#125; return null; &#125;&#125; 123456789101112131415package com.atguigu.polymorphism.grammar;public class TestPetShop &#123; public static void main(String[] args) &#123; PetShop shop = new PetShop(); Pet dog = shop.sale(&quot;Dog&quot;); dog.setNickname(&quot;小白&quot;); dog.eat(); Pet cat = shop.sale(&quot;Cat&quot;); cat.setNickname(&quot;雪球&quot;); cat.eat(); &#125;&#125; 7.2 为什么需要多态性(polymorphism)？开发中，有时我们在设计一个数组、或一个成员变量、或一个方法的形参、返回值类型时，无法确定它具体的类型，只能确定它是某个系列的类型。 案例： （1）声明一个Dog类，包含public void eat()方法，输出“狗啃骨头” （2）声明一个Cat类，包含public void eat()方法，输出“猫吃鱼仔” （3）声明一个Person类，功能如下： 包含宠物属性 包含领养宠物方法 public void adopt(宠物类型Pet) 包含喂宠物吃东西的方法 public void feed()，实现为调用宠物对象.eat()方法 12345public class Dog &#123; public void eat()&#123; System.out.println(&quot;狗啃骨头&quot;); &#125;&#125; 12345public class Cat &#123; public void eat()&#123; System.out.println(&quot;猫吃鱼仔&quot;); &#125;&#125; 1234567891011121314151617181920212223public class Person &#123; private Dog dog; //adopt：领养 public void adopt(Dog dog)&#123; this.dog = dog; &#125; //feed：喂食 public void feed()&#123; if(dog != null)&#123; dog.eat(); &#125; &#125; /* 问题： 1、从养狗切换到养猫怎么办？ 修改代码把Dog修改为养猫？ 2、或者有的人养狗，有的人养猫怎么办？ 3、要是还有更多其他宠物类型怎么办？ 如果Java不支持多态，那么上面的问题将会非常麻烦，代码维护起来很难，扩展性很差。 */&#125; 7.3 多态的好处和弊端好处：变量引用的子类对象不同，执行的方法就不同，实现动态绑定。代码编写更灵活、功能更强大，可维护性和扩展性更好了。 弊端：一个引用类型变量如果声明为父类的类型，但实际引用的是子类对象，那么该变量就不能再访问子类中添加的属性和方法。 123456Student m = new Student();m.school = &quot;pku&quot;; //合法,Student类有school成员变量Person e = new Student(); e.school = &quot;pku&quot;; //非法,Person类没有school成员变量// 属性是在编译时确定的，编译时e为Person类型，没有school成员变量，因而编译错误。 开发中： 使用父类做方法的形参，是多态使用最多的场合。即使增加了新的子类，方法也无需改变，提高了扩展性，符合开闭原则。 【开闭原则OCP】 对扩展开放，对修改关闭 通俗解释：软件系统中的各种组件，如模块（Modules）、类（Classes）以及功能（Functions）等，应该在不修改现有代码的基础上，引入新功能 7.4 虚方法调用(Virtual Method Invocation)在Java中虚方法是指在编译阶段不能确定方法的调用入口地址，在运行阶段才能确定的方法，即可能被重写的方法。 12Person e = new Student();e.getInfo(); //调用Student类的getInfo()方法 子类中定义了与父类同名同参数的方法，在多态情况下，将此时父类的方法称为虚方法，父类根据赋给它的不同子类对象，动态调用属于子类的该方法。这样的方法调用在编译期是无法确定的。 举例： 前提：Person类中定义了welcome()方法，各个子类重写了welcome()。 执行：多态的情况下，调用对象的welcome()方法，实际执行的是子类重写的方法。 拓展： 静态链接（或早起绑定）：当一个字节码文件被装载进JVM内部时，如果被调用的目标方法在编译期可知，且运行期保持不变时。这种情况下将调用方法的符号引用转换为直接引用的过程称之为静态链接。那么调用这样的方法，就称为非虚方法调用。比如调用静态方法、私有方法、final方法、父类构造器、本类重载构造器等。 动态链接（或晚期绑定）：如果被调用的方法在编译期无法被确定下来，也就是说，只能够在程序运行期将调用方法的符号引用转换为直接引用，由于这种引用转换过程具备动态性，因此也就被称之为动态链接。调用这样的方法，就称为虚方法调用。比如调用重写的方法（针对父类）、实现的方法（针对接口）。 7.5 成员变量没有多态性 若子类重写了父类方法，就意味着子类里定义的方法彻底覆盖了父类里的同名方法，系统将不可能把父类里的方法转移到子类中。 对于实例变量则不存在这样的现象，即使子类里定义了与父类完全相同的实例变量，这个实例变量依然不可能覆盖父类中定义的实例变量 12345678910111213141516171819package com.atguigu.polymorphism.grammar;public class TestVariable &#123; public static void main(String[] args) &#123; Base b = new Sub(); System.out.println(b.a); System.out.println(((Sub)b).a); Sub s = new Sub(); System.out.println(s.a); System.out.println(((Base)s).a); &#125;&#125;class Base&#123; int a = 1;&#125;class Sub extends Base&#123; int a = 2;&#125; 7.6 向上转型与向下转型首先，一个对象在new的时候创建是哪个类型的对象，它从头至尾都不会变。即这个对象的运行时类型，本质的类型用于不会变。但是，把这个对象赋值给不同类型的变量时，这些变量的编译时类型却不同。 7.6.1 为什么要类型转换因为多态，就一定会有把子类对象赋值给父类变量的时候，这个时候，在编译期间，就会出现类型转换的现象。 但是，使用父类变量接收了子类对象之后，我们就不能调用子类拥有，而父类没有的方法了。这也是多态给我们带来的一点”小麻烦”。所以，想要调用子类特有的方法，必须做类型转换，使得编译通过。 向上转型：当左边的变量的类型（父类） &gt; 右边对象&#x2F;变量的类型（子类），我们就称为向上转型 此时，编译时按照左边变量的类型处理，就只能调用父类中有的变量和方法，不能调用子类特有的变量和方法了 但是，运行时，仍然是对象本身的类型，所以执行的方法是子类重写的方法体。 此时，一定是安全的，而且也是自动完成的 向下转型：当左边的变量的类型（子类）&lt;右边对象&#x2F;变量的编译时类型（父类），我们就称为向下转型 此时，编译时按照左边变量的类型处理，就可以调用子类特有的变量和方法了 但是，运行时，仍然是对象本身的类型 不是所有通过编译的向下转型都是正确的，可能会发生ClassCastException，为了安全，可以通过isInstanceof关键字进行判断 7.6.2 如何向上或向下转型向上转型：自动完成 向下转型：（子类类型）父类变量 12345678910111213141516171819202122package com.atguigu.polymorphism.grammar;public class ClassCastTest &#123; public static void main(String[] args) &#123; //没有类型转换 Dog dog = new Dog();//dog的编译时类型和运行时类型都是Dog //向上转型 Pet pet = new Dog();//pet的编译时类型是Pet，运行时类型是Dog pet.setNickname(&quot;小白&quot;); pet.eat();//可以调用父类Pet有声明的方法eat，但执行的是子类重写的eat方法体// pet.watchHouse();//不能调用父类没有的方法watchHouse Dog d = (Dog) pet; System.out.println(&quot;d.nickname = &quot; + d.getNickname()); d.eat();//可以调用eat方法 d.watchHouse();//可以调用子类扩展的方法watchHouse Cat c = (Cat) pet;//编译通过，因为从语法检查来说，pet的编译时类型是Pet，Cat是Pet的子类，所以向下转型语法正确 //这句代码运行报错ClassCastException，因为pet变量的运行时类型是Dog，Dog和Cat之间是没有继承关系的 &#125;&#125; 7.6.3 instanceof关键字为了避免ClassCastException的发生，Java提供了 instanceof 关键字，给引用变量做类型的校验。如下代码格式： 12//检验对象a是否是数据类型A的对象，返回值为boolean型对象a instanceof 数据类型A 说明： 只要用instanceof判断返回true的，那么强转为该类型就一定是安全的，不会报ClassCastException异常。 如果对象a属于类A的子类B，a instanceof A值也为true。 要求对象a所属的类与类A必须是子类和父类的关系，否则编译错误。 代码： 1234567891011121314151617181920212223package com.atguigu.polymorphism.grammar;public class TestInstanceof &#123; public static void main(String[] args) &#123; Pet[] pets = new Pet[2]; pets[0] = new Dog();//多态引用 pets[0].setNickname(&quot;小白&quot;); pets[1] = new Cat();//多态引用 pets[1].setNickname(&quot;雪球&quot;); for (int i = 0; i &lt; pets.length; i++) &#123; pets[i].eat(); if(pets[i] instanceof Dog)&#123; Dog dog = (Dog) pets[i]; dog.watchHouse(); &#125;else if(pets[i] instanceof Cat)&#123; Cat cat = (Cat) pets[i]; cat.catchMouse(); &#125; &#125; &#125;&#125; 7.7 练习练习1：笔试&amp;面试 题目1：继承成员变量和继承方法的区别 1234567891011121314151617181920212223242526class Base &#123; int count = 10; public void display() &#123; System.out.println(this.count); &#125;&#125;class Sub extends Base &#123; int count = 20; public void display() &#123; System.out.println(this.count); &#125;&#125;public class FieldMethodTest &#123; public static void main(String[] args)&#123; Sub s = new Sub(); System.out.println(s.count); s.display(); Base b = s; System.out.println(b == s); System.out.println(b.count); b.display(); &#125;&#125; 题目2： 123456789101112131415161718192021222324252627282930//考查多态的笔试题目：public class InterviewTest1 &#123; public static void main(String[] args) &#123; Base base = new Sub(); base.add(1, 2, 3);// Sub s = (Sub)base;// s.add(1,2,3); &#125;&#125;class Base &#123; public void add(int a, int... arr) &#123; System.out.println(&quot;base&quot;); &#125;&#125;class Sub extends Base &#123; public void add(int a, int[] arr) &#123; System.out.println(&quot;sub_1&quot;); &#125;// public void add(int a, int b, int c) &#123;// System.out.println(&quot;sub_2&quot;);// &#125;&#125; 题目3： 1234567891011121314151617181920212223242526272829303132333435363738394041424344//getXxx()和setXxx()声明在哪个类中，内部操作的属性就是哪个类里的。public class InterviewTest2 &#123; public static void main(String[] args) &#123; Father f = new Father(); Son s = new Son(); System.out.println(f.getInfo());//atguigu System.out.println(s.getInfo());//尚硅谷 s.test();//尚硅谷 atguigu System.out.println(&quot;-----------------&quot;); s.setInfo(&quot;大硅谷&quot;); System.out.println(f.getInfo());//atguigu System.out.println(s.getInfo());//大硅谷 s.test();//大硅谷 atguigu &#125;&#125;class Father &#123; private String info = &quot;atguigu&quot;; public void setInfo(String info) &#123; this.info = info; &#125; public String getInfo() &#123; return info; &#125;&#125;class Son extends Father &#123; private String info = &quot;尚硅谷&quot;; public void setInfo(String info) &#123; this.info = info; &#125; public String getInfo() &#123; return info; &#125; public void test() &#123; System.out.println(this.getInfo()); System.out.println(super.getInfo()); &#125;&#125; 题目4：多态是编译时行为还是运行时行为？ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546//证明如下：class Animal &#123; protected void eat() &#123; System.out.println(&quot;animal eat food&quot;); &#125;&#125;class Cat extends Animal &#123; protected void eat() &#123; System.out.println(&quot;cat eat fish&quot;); &#125;&#125;class Dog extends Animal &#123; public void eat() &#123; System.out.println(&quot;Dog eat bone&quot;); &#125;&#125;class Sheep extends Animal &#123; public void eat() &#123; System.out.println(&quot;Sheep eat grass&quot;); &#125;&#125;public class InterviewTest &#123; public static Animal getInstance(int key) &#123; switch (key) &#123; case 0: return new Cat (); case 1: return new Dog (); default: return new Sheep (); &#125; &#125; public static void main(String[] args) &#123; int key = new Random().nextInt(3); System.out.println(key); Animal animal = getInstance(key); animal.eat(); &#125;&#125; 练习2： 1234567891011121314151617181920212223class Person &#123; protected String name=&quot;person&quot;; protected int age=50; public String getInfo() &#123; return &quot;Name: &quot;+ name + &quot;\\n&quot; +&quot;age: &quot;+ age; &#125;&#125;class Student extends Person &#123; protected String school=&quot;pku&quot;; public String getInfo() &#123; return &quot;Name: &quot;+ name + &quot;\\nage: &quot;+ age + &quot;\\nschool: &quot;+ school; &#125; &#125;class Graduate extends Student&#123; public String major=&quot;IT&quot;; public String getInfo() &#123; return &quot;Name: &quot;+ name + &quot;\\nage: &quot;+ age + &quot;\\nschool: &quot;+ school+&quot;\\nmajor:&quot;+major; &#125;&#125; 建立InstanceTest 类，在类中定义方法method(Person e);在method中:(1)根据e的类型调用相应类的getInfo()方法。(2)根据e的类型执行：如果e为Person类的对象，输出：“a person”;如果e为Student类的对象，输出：“a student”“a person ”如果e为Graduate类的对象，输出：“a graduated student”“a student”“a person” 练习3：定义三个类，父类GeometricObject代表几何形状，子类Circle代表圆形，MyRectangle代表矩形。定义一个测试类GeometricTest，编写equalsArea方法测试两个对象的面积是否相等（注意方法的参数类型，利用动态绑定技术），编写displayGeometricObject方法显示对象的面积（注意方法的参数类型，利用动态绑定技术）。 8. Object 类的使用8.1 如何理解根父类类 java.lang.Object是类层次结构的根类，即所有其它类的父类。每个类都使用 Object 作为超类。 Object类型的变量与除Object以外的任意引用数据类型的对象都存在多态引用 12345method(Object obj)&#123;…&#125; //可以接收任何类作为其参数Person o = new Person(); method(o); 所有对象（包括数组）都实现这个类的方法。 如果一个类没有特别指定父类，那么默认则继承自Object类。例如： 1234567public class Person &#123; ...&#125;//等价于：public class Person extends Object &#123; ...&#125; 8.2 Object类的方法根据JDK源代码及Object类的API文档，Object类当中包含的方法有11个。这里我们主要关注其中的6个： 1、(重点)equals()&#x3D; &#x3D;： 基本类型比较值:只要两个变量的值相等，即为true。 12int a=5; if(a==6)&#123;…&#125; 引用类型比较引用(是否指向同一个对象)：只有指向同一个对象时，&#x3D;&#x3D;才返回true。 123Person p1=new Person(); Person p2=new Person();if (p1==p2)&#123;…&#125; 用“&#x3D;&#x3D;”进行比较时，符号两边的数据类型必须兼容(可自动转换的基本数据类型除外)，否则编译出错 equals()：所有类都继承了Object，也就获得了equals()方法。还可以重写。 只能比较引用类型，Object类源码中equals()的作用与“&#x3D;&#x3D;”相同：比较是否指向同一个对象。 格式:obj1.equals(obj2) 特例：当用equals()方法进行比较时，对类File、String、Date及包装类（Wrapper Class）来说，是比较类型及内容而不考虑引用的是否是同一个对象； 原因：在这些类中重写了Object类的equals()方法。 当自定义使用equals()时，可以重写。用于比较两个对象的“内容”是否都相等 重写equals()方法的原则 对称性：如果x.equals(y)返回是“true”，那么y.equals(x)也应该返回是“true”。 自反性：x.equals(x)必须返回是“true”。 传递性：如果x.equals(y)返回是“true”，而且y.equals(z)返回是“true”，那么z.equals(x)也应该返回是“true”。 一致性：如果x.equals(y)返回是“true”，只要x和y内容一直不变，不管你重复x.equals(y)多少次，返回都是“true”。 任何情况下，x.equals(null)，永远返回是“false”； ​ x.equals(和x不同类型的对象)永远返回是“false”。 重写举例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263class User&#123; private String host; private String username; private String password; public User(String host, String username, String password) &#123; super(); this.host = host; this.username = username; this.password = password; &#125; public User() &#123; super(); &#125; public String getHost() &#123; return host; &#125; public void setHost(String host) &#123; this.host = host; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; @Override public String toString() &#123; return &quot;User [host=&quot; + host + &quot;, username=&quot; + username + &quot;, password=&quot; + password + &quot;]&quot;; &#125; @Override public boolean equals(Object obj) &#123; if (this == obj) return true; if (obj == null) return false; if (getClass() != obj.getClass()) return false; User other = (User) obj; if (host == null) &#123; if (other.host != null) return false; &#125; else if (!host.equals(other.host)) return false; if (password == null) &#123; if (other.password != null) return false; &#125; else if (!password.equals(other.password)) return false; if (username == null) &#123; if (other.username != null) return false; &#125; else if (!username.equals(other.username)) return false; return true; &#125; &#125; 面试题：&#x3D;&#x3D;和equals的区别 从我面试的反馈，85%的求职者“理直气壮”的回答错误… &#x3D;&#x3D; 既可以比较基本类型也可以比较引用类型。对于基本类型就是比较值，对于引用类型就是比较内存地址 equals的话，它是属于java.lang.Object类里面的方法，如果该方法没有被重写过默认也是&#x3D;&#x3D;;我们可以看到String等类的equals方法是被重写过的，而且String类在日常开发中用的比较多，久而久之，形成了equals是比较值的错误观点。 具体要看自定义类里有没有重写Object的equals方法来判断。 通常情况下，重写equals方法，会比较类中的相应属性是否都相等。 练习1： 12345678910111213141516int it = 65;float fl = 65.0f;System.out.println(“65和65.0f是否相等？” + (it == fl)); //char ch1 = &#x27;A&#x27;; char ch2 = 12;System.out.println(&quot;65和&#x27;A&#x27;是否相等？&quot; + (it == ch1));//System.out.println(&quot;12和ch2是否相等？&quot; + (12 == ch2));//String str1 = new String(&quot;hello&quot;);String str2 = new String(&quot;hello&quot;);System.out.println(&quot;str1和str2是否相等？&quot;+ (str1 == str2));//System.out.println(&quot;str1是否equals str2？&quot;+(str1.equals(str2)));//System.out.println(“hello” == new java.util.Date()); // 练习2： 编写Order类，有int型的orderId，String型的orderName，相应的getter()和setter()方法，两个参数的构造器，重写父类的equals()方法：public boolean equals(Object obj)，并判断测试类中创建的两个对象是否相等。 练习3： 请根据以下代码自行定义能满足需要的MyDate类,在MyDate类中覆盖equals方法，使其判断当两个MyDate类型对象的年月日都相同时，结果为true，否则为false。 public boolean equals(Object o) 123456789101112131415161718public class EqualsTest &#123; public static void main(String[] args) &#123; MyDate m1 = new MyDate(14, 3, 1976); MyDate m2 = new MyDate(14, 3, 1976); if (m1 == m2) &#123; System.out.println(&quot;m1==m2&quot;); &#125; else &#123; System.out.println(&quot;m1!=m2&quot;); // m1 != m2 &#125; if (m1.equals(m2)) &#123; System.out.println(&quot;m1 is equal to m2&quot;);// m1 is equal to m2 &#125; else &#123; System.out.println(&quot;m1 is not equal to m2&quot;); &#125; &#125;&#125; 2、(重点)toString()方法签名：public String toString() ① 默认情况下，toString()返回的是“对象的运行时类型 @ 对象的hashCode值的十六进制形式” ② 在进行String与其它类型数据的连接操作时，自动调用toString()方法 123Date now=new Date();System.out.println(“now=”+now); //相当于System.out.println(“now=”+now.toString()); ③ 如果我们直接System.out.println(对象)，默认会自动调用这个对象的toString() 因为Java的引用数据类型的变量中存储的实际上时对象的内存地址，但是Java对程序员隐藏内存地址信息，所以不能直接将内存地址显示出来，所以当你打印对象时，JVM帮你调用了对象的toString()。 ④ 可以根据需要在用户自定义类型中重写toString()方法 如String 类重写了toString()方法，返回字符串的值。 12s1=&quot;hello&quot;;System.out.println(s1);//相当于System.out.println(s1.toString()); 例如自定义的Person类： 123456789public class Person &#123; private String name; private int age; @Override public String toString() &#123; return &quot;Person&#123;&quot; + &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, age=&quot; + age + &#x27;&#125;&#x27;; &#125;&#125; 练习：定义两个类，父类GeometricObject代表几何形状，子类Circle代表圆形。 3、clone()1234567891011121314151617181920212223242526272829303132333435363738394041424344454647//Object类的clone()的使用public class CloneTest &#123; public static void main(String[] args) &#123; Animal a1 = new Animal(&quot;花花&quot;); try &#123; Animal a2 = (Animal) a1.clone(); System.out.println(&quot;原始对象：&quot; + a1); a2.setName(&quot;毛毛&quot;); System.out.println(&quot;clone之后的对象：&quot; + a2); &#125; catch (CloneNotSupportedException e) &#123; e.printStackTrace(); &#125; &#125;&#125;class Animal implements Cloneable&#123; private String name; public Animal() &#123; super(); &#125; public Animal(String name) &#123; super(); this.name = name; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; @Override public String toString() &#123; return &quot;Animal [name=&quot; + name + &quot;]&quot;; &#125; @Override protected Object clone() throws CloneNotSupportedException &#123; // TODO Auto-generated method stub return super.clone(); &#125; &#125; 4、finalize() 当对象被回收时，系统自动调用该对象的 finalize() 方法。（不是垃圾回收器调用的，是本类对象调用的） 永远不要主动调用某个对象的finalize方法，应该交给垃圾回收机制调用。 什么时候被回收：当某个对象没有任何引用时，JVM就认为这个对象是垃圾对象，就会在之后不确定的时间使用垃圾回收机制来销毁该对象，在销毁该对象前，会先调用 finalize()方法。 子类可以重写该方法，目的是在对象被清理之前执行必要的清理操作。比如，在方法内断开相关连接资源。 如果重写该方法，让一个新的引用变量重新引用该对象，则会重新激活对象。 在JDK 9中此方法已经被标记为过时的。 1234567891011121314151617181920212223242526272829303132333435363738394041public class FinalizeTest &#123; public static void main(String[] args) &#123; Person p = new Person(&quot;Peter&quot;, 12); System.out.println(p); p = null;//此时对象实体就是垃圾对象，等待被回收。但时间不确定。 System.gc();//强制性释放空间 &#125;&#125;class Person&#123; private String name; private int age; public Person(String name, int age) &#123; super(); this.name = name; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; //子类重写此方法，可在释放对象前进行某些操作 @Override protected void finalize() throws Throwable &#123; System.out.println(&quot;对象被释放---&gt;&quot; + this); &#125; @Override public String toString() &#123; return &quot;Person [name=&quot; + name + &quot;, age=&quot; + age + &quot;]&quot;; &#125; &#125; 5、getClass()public final Class&lt;?&gt; getClass()：获取对象的运行时类型 因为Java有多态现象，所以一个引用数据类型的变量的编译时类型与运行时类型可能不一致，因此如果需要查看这个变量实际指向的对象的类型，需要用getClass()方法 1234public static void main(String[] args) &#123; Object obj = new Person(); System.out.println(obj.getClass());//运行时类型&#125; 结果： 1class com.atguigu.java.Person 6、hashCode()public int hashCode()：返回每个对象的hash值。(后续在集合框架章节重点讲解) 1234public static void main(String[] args) &#123; System.out.println(&quot;AA&quot;.hashCode());//2080 System.out.println(&quot;BB&quot;.hashCode());//2112&#125; 8.3 native关键字的理解使用native关键字说明这个方法是原生函数，也就是这个方法是用C/C++等非Java语言实现的，并且被编译成了DLL，由Java去调用。 本地方法是有方法体的，用c语言编写。由于本地方法的方法体源码没有对我们开源，所以我们看不到方法体 在Java中定义一个native方法时，并不提供实现体。 1. 为什么要用native方法 Java使用起来非常方便，然而有些层次的任务用java实现起来不容易，或者我们对程序的效率很在意时，例如：Java需要与一些底层操作系统或某些硬件交换信息时的情况。native方法正是这样一种交流机制：它为我们提供了一个非常简洁的接口，而且我们无需去了解Java应用之外的繁琐的细节。 2. native声明的方法，对于调用者，可以当做和其他Java方法一样使用 native method的存在并不会对其他类调用这些本地方法产生任何影响，实际上调用这些方法的其他类甚至不知道它所调用的是一个本地方法。JVM将控制调用本地方法的所有细节。","categories":[{"name":"java基础","slug":"java基础","permalink":"http://example.com/categories/java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"java","slug":"java","permalink":"http://example.com/tags/java/"}]},{"title":"第09章_异常处理","slug":"Java/尚硅谷_第09章_异常处理/尚硅谷_宋红康_第09章_异常处理","date":"2022-09-27T00:55:57.000Z","updated":"2023-10-07T11:39:41.600Z","comments":true,"path":"2022/09/27/Java/尚硅谷_第09章_异常处理/尚硅谷_宋红康_第09章_异常处理/","link":"","permalink":"http://example.com/2022/09/27/Java/%E5%B0%9A%E7%A1%85%E8%B0%B7_%E7%AC%AC09%E7%AB%A0_%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/%E5%B0%9A%E7%A1%85%E8%B0%B7_%E5%AE%8B%E7%BA%A2%E5%BA%B7_%E7%AC%AC09%E7%AB%A0_%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/","excerpt":"","text":"本章专题与脉络 1. 异常概述1.1 什么是生活的异常男主角小明每天开车上班，正常车程1小时。但是，不出意外的话，可能会出现意外。 出现意外，即为异常情况。我们会做相应的处理。如果不处理，到不了公司。处理完了，就可以正常开车去公司。 1.2 什么是程序的异常在使用计算机语言进行项目开发的过程中，即使程序员把代码写得尽善尽美，在系统的运行过程中仍然会遇到一些问题，因为很多问题不是靠代码能够避免的，比如：客户输入数据的格式问题，读取文件是否存在，网络是否始终保持通畅等等。 异常 ：指的是程序在执行过程中，出现的非正常情况，如果不处理最终会导致JVM的非正常停止。 异常指的并不是语法错误和逻辑错误。语法错了，编译不通过，不会产生字节码文件，根本不能运行。 代码逻辑错误，只是没有得到想要的结果，例如：求a与b的和，你写成了a-b 1.3 异常的抛出机制Java中是如何表示不同的异常情况，又是如何让程序员得知，并处理异常的呢？ Java中把不同的异常用不同的类表示，一旦发生某种异常，就创建该异常类型的对象，并且抛出（throw）。然后程序员可以捕获(catch)到这个异常对象，并处理；如果没有捕获(catch)这个异常对象，那么这个异常对象将会导致程序终止。 举例： 运行下面的程序，程序会产生一个数组角标越界异常ArrayIndexOfBoundsException。我们通过图解来解析下异常产生和抛出的过程。 1234567public class ArrayTools &#123; // 对给定的数组通过给定的角标获取元素。 public static int getElement(int[] arr, int index) &#123; int element = arr[index]; return element; &#125;&#125; 测试类 12345678public class ExceptionDemo &#123; public static void main(String[] args) &#123; int[] arr = &#123; 34, 12, 67 &#125;; intnum = ArrayTools.getElement(arr, 4) System.out.println(&quot;num=&quot; + num); System.out.println(&quot;over&quot;); &#125;&#125; 上述程序执行过程图解： 1.4 如何对待异常 对于程序出现的异常，一般有两种解决方法：一是遇到错误就终止程序的运行。另一种方法是程序员在编写程序时，就充分考虑到各种可能发生的异常和错误，极力预防和避免。实在无法避免的，要编写相应的代码进行异常的检测、以及异常的处理，保证代码的健壮性。 2. Java异常体系2.1 Throwablejava.lang.Throwable 类是Java程序执行过程中发生的异常事件对应的类的根父类。 Throwable中的常用方法： public void printStackTrace()：打印异常的详细信息。 包含了异常的类型、异常的原因、异常出现的位置、在开发和调试阶段都得使用printStackTrace。 public String getMessage()：获取发生异常的原因。 2.2 Error 和 ExceptionThrowable可分为两类：Error和Exception。分别对应着java.lang.Error与java.lang.Exception两个类。 Error：Java虚拟机无法解决的严重问题。如：JVM系统内部错误、资源耗尽等严重情况。一般不编写针对性的代码进行处理。 例如：StackOverflowError（栈内存溢出）和OutOfMemoryError（堆内存溢出，简称OOM）。 Exception: 其它因编程错误或偶然的外在因素导致的一般性问题，需要使用针对性的代码进行处理，使程序继续运行。否则一旦发生异常，程序也会挂掉。例如： 空指针访问 试图读取不存在的文件 网络连接中断 数组角标越界 说明： 无论是Error还是Exception，还有很多子类，异常的类型非常丰富。当代码运行出现异常时，特别是我们不熟悉的异常时，不要紧张，把异常的简单类名，拷贝到API中去查去认识它即可。 我们本章讲的异常处理，其实针对的就是Exception。 2.3 编译时异常和运行时异常Java程序的执行分为编译时过程和运行时过程。有的错误只有在运行时才会发生。比如：除数为0，数组下标越界等。 因此，根据异常可能出现的阶段，可以将异常分为： 编译时期异常（即checked异常、受检异常）：在代码编译阶段，编译器就能明确警示当前代码可能发生（不是一定发生）xx异常，并明确督促程序员提前编写处理它的代码。如果程序员没有编写对应的异常处理代码，则编译器就会直接判定编译失败，从而不能生成字节码文件。通常，这类异常的发生不是由程序员的代码引起的，或者不是靠加简单判断就可以避免的，例如：FileNotFoundException（文件找不到异常）。 运行时期异常（即runtime异常、unchecked异常、非受检异常）：在代码编译阶段，编译器完全不做任何检查，无论该异常是否会发生，编译器都不给出任何提示。只有等代码运行起来并确实发生了xx异常，它才能被发现。通常，这类异常是由程序员的代码编写不当引起的，只要稍加判断，或者细心检查就可以避免。 java.lang.RuntimeException类及它的子类都是运行时异常。比如：ArrayIndexOutOfBoundsException数组下标越界异常，ClassCastException类型转换异常。 3. 常见的错误和异常3.1 Error最常见的就是VirtualMachineError，它有两个经典的子类：StackOverflowError、OutOfMemoryError。 12345678910111213141516package com.atguigu.exception;import org.junit.Test;public class TestStackOverflowError &#123; @Test public void test01()&#123; //StackOverflowError recursion(); &#125; public void recursion()&#123; //递归方法 recursion(); &#125;&#125; 12345678910111213141516171819202122package com.atguigu.exception;import org.junit.Test;public class TestOutOfMemoryError &#123; @Test public void test02()&#123; //OutOfMemoryError //方式一： int[] arr = new int[Integer.MAX_VALUE]; &#125; @Test public void test03()&#123; //OutOfMemoryError //方式二： StringBuilder s = new StringBuilder(); while(true)&#123; s.append(&quot;atguigu&quot;); &#125; &#125;&#125; 3.2 运行时异常123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package com.atguigu.exception;import org.junit.Test;import java.util.Scanner;public class TestRuntimeException &#123; @Test public void test01()&#123; //NullPointerException int[][] arr = new int[3][]; System.out.println(arr[0].length); &#125; @Test public void test02()&#123; //ClassCastException Object obj = 15; String str = (String) obj; &#125; @Test public void test03()&#123; //ArrayIndexOutOfBoundsException int[] arr = new int[5]; for (int i = 1; i &lt;= 5; i++) &#123; System.out.println(arr[i]); &#125; &#125; @Test public void test04()&#123; //InputMismatchException Scanner input = new Scanner(System.in); System.out.print(&quot;请输入一个整数：&quot;);//输入非整数 int num = input.nextInt(); input.close(); &#125; @Test public void test05()&#123; int a = 1; int b = 0; //ArithmeticException System.out.println(a/b); &#125;&#125; 3.3 编译时异常123456789101112131415161718192021222324252627282930313233343536373839404142package com.atguigu.exception;import org.junit.Test;import java.io.FileInputStream;import java.io.FileNotFoundException;import java.sql.Connection;import java.sql.DriverManager;import java.sql.SQLException;public class TestCheckedException &#123; @Test public void test06() &#123; Thread.sleep(1000);//休眠1秒 InterruptedException &#125; @Test public void test07()&#123; Class c = Class.forName(&quot;java.lang.String&quot;);//ClassNotFoundException &#125; @Test public void test08() &#123; Connection conn = DriverManager.getConnection(&quot;....&quot;); //SQLException &#125; @Test public void test09() &#123; FileInputStream fis = new FileInputStream(&quot;尚硅谷Java秘籍.txt&quot;); //FileNotFoundException &#125; @Test public void test10() &#123; File file = new File(&quot;尚硅谷Java秘籍.txt&quot;); FileInputStream fis = new FileInputStream(file);//FileNotFoundException int b = fis.read();//IOException while(b != -1)&#123; System.out.print((char)b); b = fis.read();//IOException &#125; fis.close();//IOException &#125;&#125; 4. 异常的处理4.1 异常处理概述在编写程序时，经常要在可能出现错误的地方加上检测的代码，如进行x&#x2F;y运算时，要检测分母为0，数据为空，输入的不是数据而是字符等。过多的if-else分支会导致程序的代码加长、臃肿，可读性差，程序员需要花很大的精力“堵漏洞”。因此采用异常处理机制。 Java异常处理 Java采用的异常处理机制，是将异常处理的程序代码集中在一起，与正常的程序代码分开，使得程序简洁、优雅，并易于维护。 Java异常处理的方式： 方式一：try-catch-finally 方式二：throws + 异常类型 4.2 方式1：捕获异常（try-catch-finally）Java提供了异常处理的抓抛模型。 前面提到，Java程序的执行过程中如出现异常，会生成一个异常类对象，该异常对象将被提交给Java运行时系统，这个过程称为抛出(throw)异常。 如果一个方法内抛出异常，该异常对象会被抛给调用者方法中处理。如果异常没有在调用者方法中处理，它继续被抛给这个调用方法的上层方法。这个过程将一直继续下去，直到异常被处理。这一过程称为捕获(catch)异常。 如果一个异常回到main()方法，并且main()也不处理，则程序运行终止。 4.2.1 try-catch-finally基本格式捕获异常语法如下： 12345678910111213try&#123; ...... //可能产生异常的代码&#125;catch( 异常类型1 e )&#123; ...... //当产生异常类型1型异常时的处置措施&#125;catch( 异常类型2 e )&#123; ...... //当产生异常类型2型异常时的处置措施&#125; finally&#123; ...... //无论是否发生异常，都无条件执行的语句&#125; 1、整体执行过程： 当某段代码可能发生异常，不管这个异常是编译时异常（受检异常）还是运行时异常（非受检异常），我们都可以使用try块将它括起来，并在try块下面编写catch分支尝试捕获对应的异常对象。 如果在程序运行时，try块中的代码没有发生异常，那么catch所有的分支都不执行。 如果在程序运行时，try块中的代码发生了异常，根据异常对象的类型，将从上到下选择第一个匹配的catch分支执行。此时try中发生异常的语句下面的代码将不执行，而整个try…catch之后的代码可以继续运行。 如果在程序运行时，try块中的代码发生了异常，但是所有catch分支都无法匹配（捕获）这个异常，那么JVM将会终止当前方法的执行，并把异常对象“抛”给调用者。如果调用者不处理，程序就挂了。 2、try 捕获异常的第一步是用try&#123;…&#125;语句块选定捕获异常的范围，将可能出现异常的业务逻辑代码放在try语句块中。 3、catch (Exceptiontype e) catch分支，分为两个部分，catch()中编写异常类型和异常参数名，{}中编写如果发生了这个异常，要做什么处理的代码。 如果明确知道产生的是何种异常，可以用该异常类作为catch的参数；也可以用其父类作为catch的参数。 比如：可以用ArithmeticException类作为参数的地方，就可以用RuntimeException类作为参数，或者用所有异常的父类Exception类作为参数。但不能是与ArithmeticException类无关的异常，如NullPointerException（catch中的语句将不会执行）。 每个try语句块可以伴随一个或多个catch语句，用于处理可能产生的不同类型的异常对象。 如果有多个catch分支，并且多个异常类型有父子类关系，必须保证小的子异常类型在上，大的父异常类型在下。否则，报错。 catch中常用异常处理的方式 public String getMessage()：获取异常的描述信息，返回字符串 public void printStackTrace()：打印异常的跟踪栈信息并输出到控制台。包含了异常的类型、异常的原因、还包括异常出现的位置，在开发和调试阶段，都得使用printStackTrace()。 4.2.2 使用举例举例1： 1234567891011121314public class IndexOutExp &#123; public static void main(String[] args) &#123; String friends[] = &#123; &quot;lisa&quot;, &quot;bily&quot;, &quot;kessy&quot; &#125;; try &#123; for (int i = 0; i &lt; 5; i++) &#123; System.out.println(friends[i]); &#125; &#125; catch (ArrayIndexOutOfBoundsException e) &#123; System.out.println(&quot;index err&quot;); &#125; System.out.println(&quot;\\nthis is the end&quot;); &#125;&#125; 举例2： 1234567891011121314public class DivideZero1 &#123; int x; public static void main(String[] args) &#123; int y; DivideZero1 c = new DivideZero1(); try &#123; y = 3 / c.x; &#125; catch (ArithmeticException e) &#123; System.out.println(&quot;divide by zero error!&quot;); &#125; System.out.println(&quot;program ends ok!&quot;); &#125;&#125; 举例3： 12345678910111213141516171819@Testpublic void test1()&#123; try&#123; String str1 = &quot;atguigu.com&quot;; str1 = null; System.out.println(str1.charAt(0)); &#125;catch(NullPointerException e)&#123; //异常的处理方式1 System.out.println(&quot;不好意思，亲~出现了小问题，正在加紧解决...&quot;); &#125;catch(ClassCastException e)&#123; //异常的处理方式2 System.out.println(&quot;出现了类型转换的异常&quot;); &#125;catch(RuntimeException e)&#123; //异常的处理方式3 System.out.println(&quot;出现了运行时异常&quot;); &#125; //此处的代码，在异常被处理了以后，是可以正常执行的 System.out.println(&quot;hello&quot;);&#125; 举例4： 1 4.2.3 finally使用及举例 因为异常会引发程序跳转，从而会导致有些语句执行不到。而程序中有一些特定的代码无论异常是否发生，都需要执行。例如，数据库连接、输入流输出流、Socket连接、Lock锁的关闭等，这样的代码通常就会放到finally块中。所以，我们通常将一定要被执行的代码声明在finally中。 唯一的例外，使用 System.exit(0) 来终止当前正在运行的 Java 虚拟机。 不论在try代码块中是否发生了异常事件，catch语句是否执行，catch语句是否有异常，catch语句中是否有return，finally块中的语句都会被执行。 finally语句和catch语句是可选的，但finally不能单独使用。 12345try&#123; &#125;finally&#123; &#125; 举例1：确保资源关闭 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package com.atguigu.keyword;import java.util.InputMismatchException;import java.util.Scanner;public class TestFinally &#123; public static void main(String[] args) &#123; Scanner input = new Scanner(System.in); try &#123; System.out.print(&quot;请输入第一个整数：&quot;); int a = input.nextInt(); System.out.print(&quot;请输入第二个整数：&quot;); int b = input.nextInt(); int result = a/b; System.out.println(a + &quot;/&quot; + b +&quot;=&quot; + result); &#125; catch (InputMismatchException e) &#123; System.out.println(&quot;数字格式不正确，请输入两个整数&quot;); &#125;catch (ArithmeticException e)&#123; System.out.println(&quot;第二个整数不能为0&quot;); &#125; finally &#123; System.out.println(&quot;程序结束，释放资源&quot;); input.close(); &#125; &#125; @Test public void test1()&#123; FileInputStream fis = null; try&#123; File file = new File(&quot;hello1.txt&quot;); fis = new FileInputStream(file);//FileNotFoundException int b = fis.read();//IOException while(b != -1)&#123; System.out.print((char)b); b = fis.read();//IOException &#125; &#125;catch(IOException e)&#123; e.printStackTrace(); &#125;finally&#123; try &#123; if(fis != null) fis.close();//IOException &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 举例2：从try回来 1234567891011121314151617public class FinallyTest1 &#123; public static void main(String[] args) &#123; int result = test(&quot;12&quot;); System.out.println(result); &#125; public static int test(String str)&#123; try&#123; Integer.parseInt(str); return 1; &#125;catch(NumberFormatException e)&#123; return -1; &#125;finally&#123; System.out.println(&quot;test结束&quot;); &#125; &#125;&#125; 举例3：从catch回来 1234567891011121314151617public class FinallyTest2 &#123; public static void main(String[] args) &#123; int result = test(&quot;a&quot;); System.out.println(result); &#125; public static int test(String str) &#123; try &#123; Integer.parseInt(str); return 1; &#125; catch (NumberFormatException e) &#123; return -1; &#125; finally &#123; System.out.println(&quot;test结束&quot;); &#125; &#125;&#125; 举例4：从finally回来 123456789101112131415161718public class FinallyTest3 &#123; public static void main(String[] args) &#123; int result = test(&quot;a&quot;); System.out.println(result); &#125; public static int test(String str) &#123; try &#123; Integer.parseInt(str); return 1; &#125; catch (NumberFormatException e) &#123; return -1; &#125; finally &#123; System.out.println(&quot;test结束&quot;); return 0; &#125; &#125;&#125; 笔试题： 123456789101112131415public class ExceptionTest &#123; public static void main(String[] args) &#123; int result = test(); System.out.println(result); //100 &#125; public static int test()&#123; int i = 100; try &#123; return i; &#125; finally &#123; i++; &#125; &#125;&#125; 笔试题：final、finally、finalize有什么区别？ 4.2.4 练习编写一个类ExceptionTest，在main方法中使用try、catch、finally，要求： 在try块中，编写被零除的代码。 在catch块中，捕获被零除所产生的异常，并且打印异常信息 在finally块中，打印一条语句。 4.2.5 异常处理的体会 前面使用的异常都是RuntimeException类或是它的子类，这些类的异常的特点是：即使没有使用try和catch捕获，Java自己也能捕获，并且编译通过 ( 但运行时会发生异常使得程序运行终止 )。所以，对于这类异常，可以不作处理，因为这类异常很普遍，若全处理可能会对程序的可读性和运行效率产生影响。 如果抛出的异常是IOException等类型的非运行时异常，则必须捕获，否则编译错误。也就是说，我们必须处理编译时异常，将异常进行捕捉，转化为运行时异常。 4.3 方式2：声明抛出异常类型（throws） 如果在编写方法体的代码时，某句代码可能发生某个编译时异常，不处理编译不通过，但是在当前方法体中可能不适合处理或无法给出合理的处理方式，则此方法应显示地声明抛出异常，表明该方法将不对这些异常进行处理，而由该方法的调用者负责处理。 具体方式：在方法声明中用throws语句可以声明抛出异常的列表，throws后面的异常类型可以是方法中产生的异常类型，也可以是它的父类。 4.3.1 throws基本格式声明异常格式： 1修饰符 返回值类型 方法名(参数) throws 异常类名1,异常类名2…&#123; &#125; 在throws后面可以写多个异常类型，用逗号隔开。 举例： 1234567public void readFile(String file) throws FileNotFoundException,IOException &#123; ... // 读文件的操作可能产生FileNotFoundException或IOException类型的异常 FileInputStream fis = new FileInputStream(file); //...&#125; 4.3.2 throws 使用举例举例：针对于编译时异常 12345678910111213141516171819202122package com.atguigu.keyword;public class TestThrowsCheckedException &#123; public static void main(String[] args) &#123; System.out.println(&quot;上课.....&quot;); try &#123; afterClass();//换到这里处理异常 &#125; catch (InterruptedException e) &#123; e.printStackTrace(); System.out.println(&quot;准备提前上课&quot;); &#125; System.out.println(&quot;上课.....&quot;); &#125; public static void afterClass() throws InterruptedException &#123; for(int i=10; i&gt;=1; i--)&#123; Thread.sleep(1000);//本来应该在这里处理异常 System.out.println(&quot;距离上课还有：&quot; + i + &quot;分钟&quot;); &#125; &#125;&#125; 举例：针对于运行时异常： throws后面也可以写运行时异常类型，只是运行时异常类型，写或不写对于编译器和程序执行来说都没有任何区别。如果写了，唯一的区别就是调用者调用该方法后，使用try…catch结构时，IDEA可以获得更多的信息，需要添加哪种catch分支。 123456789101112131415161718192021222324252627package com.atguigu.keyword;import java.util.InputMismatchException;import java.util.Scanner;public class TestThrowsRuntimeException &#123; public static void main(String[] args) &#123; Scanner input = new Scanner(System.in); try &#123; System.out.print(&quot;请输入第一个整数：&quot;); int a = input.nextInt(); System.out.print(&quot;请输入第二个整数：&quot;); int b = input.nextInt(); int result = divide(a,b); System.out.println(a + &quot;/&quot; + b +&quot;=&quot; + result); &#125; catch (ArithmeticException | InputMismatchException e) &#123; e.printStackTrace(); &#125; finally &#123; input.close(); &#125; &#125; public static int divide(int a, int b)throws ArithmeticException&#123; return a/b; &#125;&#125; 4.3.3 方法重写中throws的要求方法重写时，对于方法签名是有严格要求的。复习： 1234567（1）方法名必须相同（2）形参列表必须相同（3）返回值类型 - 基本数据类型和void：必须相同 - 引用数据类型：&lt;=（4）权限修饰符：&gt;=，而且要求父类被重写方法在子类中是可见的（5）不能是static，final修饰的方法 此外，对于throws异常列表要求： 如果父类被重写方法的方法签名后面没有 “throws 编译时异常类型”，那么重写方法时，方法签名后面也不能出现“throws 编译时异常类型”。 如果父类被重写方法的方法签名后面有 “throws 编译时异常类型”，那么重写方法时，throws的编译时异常类型必须 &lt;&#x3D; 被重写方法throws的编译时异常类型，或者不throws编译时异常。 方法重写，对于“throws 运行时异常类型”没有要求。 123456789101112131415package com.atguigu.keyword;import java.io.IOException;class Father&#123; public void method()throws Exception&#123; System.out.println(&quot;Father.method&quot;); &#125;&#125;class Son extends Father&#123; @Override public void method() throws IOException,ClassCastException &#123; System.out.println(&quot;Son.method&quot;); &#125;&#125; 4.4 两种异常处理方式的选择前提：对于异常，使用相应的处理方式。此时的异常，主要指的是编译时异常。 如果程序代码中，涉及到资源的调用（流、数据库连接、网络连接等），则必须考虑使用try-catch-finally来处理，保证不出现内存泄漏。 如果父类被重写的方法没有throws异常类型，则子类重写的方法中如果出现异常，只能考虑使用try-catch-finally进行处理，不能throws。 开发中，方法a中依次调用了方法b,c,d等方法，方法b,c,d之间是递进关系。此时，如果方法b,c,d中有异常，我们通常选择使用throws，而方法a中通常选择使用try-catch-finally。 5. 手动抛出异常对象：throwJava 中异常对象的生成有两种方式： 由虚拟机自动生成：程序运行过程中，虚拟机检测到程序发生了问题，那么针对当前代码，就会在后台自动创建一个对应异常类的实例对象并抛出。 由开发人员手动创建：new 异常类型([实参列表]);，如果创建好的异常对象不抛出对程序没有任何影响，和创建一个普通对象一样，但是一旦throw抛出，就会对程序运行产生影响了。 5.1 使用格式1throw new 异常类名(参数); throw语句抛出的异常对象，和JVM自动创建和抛出的异常对象一样。 如果是编译时异常类型的对象，同样需要使用throws或者try…catch处理，否则编译不通过。 如果是运行时异常类型的对象，编译器不提示。 可以抛出的异常必须是Throwable或其子类的实例。下面的语句在编译时将会产生语法错误： 1throw new String(&quot;want to throw&quot;); 5.2 使用注意点：无论是编译时异常类型的对象，还是运行时异常类型的对象，如果没有被try..catch合理的处理，都会导致程序崩溃。 throw语句会导致程序执行流程被改变，throw语句是明确抛出一个异常对象，因此它下面的代码将不会执行。 如果当前方法没有try…catch处理这个异常对象，throw语句就会代替return语句提前终止当前方法的执行，并返回一个异常对象给调用者。 1234567891011121314151617181920212223242526272829303132333435package com.atguigu.keyword;public class TestThrow &#123; public static void main(String[] args) &#123; try &#123; System.out.println(max(4,2,31,1)); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; try &#123; System.out.println(max(4)); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; try &#123; System.out.println(max()); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; public static int max(int... nums)&#123; if(nums == null || nums.length==0)&#123; throw new IllegalArgumentException(&quot;没有传入任何整数，无法获取最大值&quot;); &#125; int max = nums[0]; for (int i = 1; i &lt; nums.length; i++) &#123; if(nums[i] &gt; max)&#123; max = nums[i]; &#125; &#125; return max; &#125;&#125; 6. 自定义异常6.1 为什么需要自定义异常类Java中不同的异常类，分别表示着某一种具体的异常情况。那么在开发中总是有些异常情况是核心类库中没有定义好的，此时我们需要根据自己业务的异常情况来定义异常类。例如年龄负数问题，考试成绩负数问题，某员工已在团队中等。 6.2 如何自定义异常类（1）要继承一个异常类型 ​ 自定义一个编译时异常类型：自定义类继承java.lang.Exception。 ​ 自定义一个运行时异常类型：自定义类继承java.lang.RuntimeException。 （2）建议大家提供至少两个构造器，一个是无参构造，一个是(String message)构造器。 （3）自定义异常需要提供serialVersionUID 6.3 注意点 自定义的异常只能通过throw抛出。 自定义异常最重要的是异常类的名字和message属性。当异常出现时，可以根据名字判断异常类型。比如：TeamException(&quot;成员已满，无法添加&quot;); 、 TeamException(&quot;该员工已是某团队成员&quot;); 自定义异常对象只能手动抛出。抛出后由try..catch处理，也可以甩锅throws给调用者处理。 6.4 举例举例1： 1234567891011121314class MyException extends Exception &#123; static final long serialVersionUID = 23423423435L; private int idnumber; public MyException(String message, int id) &#123; super(message); this.idnumber = id; &#125; public int getId() &#123; return idnumber; &#125;&#125; 123456789101112131415161718192021public class MyExpTest &#123; public void regist(int num) throws MyException &#123; if (num &lt; 0) throw new MyException(&quot;人数为负值，不合理&quot;, 3); else System.out.println(&quot;登记人数&quot; + num); &#125; public void manager() &#123; try &#123; regist(100); &#125; catch (MyException e) &#123; System.out.print(&quot;登记失败，出错种类&quot; + e.getId()); &#125; System.out.print(&quot;本次登记操作结束&quot;); &#125; public static void main(String args[]) &#123; MyExpTest t = new MyExpTest(); t.manager(); &#125;&#125; 举例2： 12345678910111213package com.atguigu.define;//自定义异常：public class NotTriangleException extends Exception&#123; static final long serialVersionUID = 13465653435L; public NotTriangleException() &#123; &#125; public NotTriangleException(String message) &#123; super(message); &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970package com.atguigu.define;public class Triangle &#123; private double a; private double b; private double c; public Triangle(double a, double b, double c) throws NotTriangleException &#123; if(a&lt;=0 || b&lt;=0 || c&lt;=0)&#123; throw new NotTriangleException(&quot;三角形的边长必须是正数&quot;); &#125; if(a+b&lt;=c || b+c&lt;=a || a+c&lt;=b)&#123; throw new NotTriangleException(a+&quot;,&quot; + b +&quot;,&quot; + c +&quot;不能构造三角形，三角形任意两边之后必须大于第三边&quot;); &#125; this.a = a; this.b = b; this.c = c; &#125; public double getA() &#123; return a; &#125; public void setA(double a) throws NotTriangleException&#123; if(a&lt;=0)&#123; throw new NotTriangleException(&quot;三角形的边长必须是正数&quot;); &#125; if(a+b&lt;=c || b+c&lt;=a || a+c&lt;=b)&#123; throw new NotTriangleException(a+&quot;,&quot; + b +&quot;,&quot; + c +&quot;不能构造三角形，三角形任意两边之后必须大于第三边&quot;); &#125; this.a = a; &#125; public double getB() &#123; return b; &#125; public void setB(double b) throws NotTriangleException &#123; if(b&lt;=0)&#123; throw new NotTriangleException(&quot;三角形的边长必须是正数&quot;); &#125; if(a+b&lt;=c || b+c&lt;=a || a+c&lt;=b)&#123; throw new NotTriangleException(a+&quot;,&quot; + b +&quot;,&quot; + c +&quot;不能构造三角形，三角形任意两边之后必须大于第三边&quot;); &#125; this.b = b; &#125; public double getC() &#123; return c; &#125; public void setC(double c) throws NotTriangleException &#123; if(c&lt;=0)&#123; throw new NotTriangleException(&quot;三角形的边长必须是正数&quot;); &#125; if(a+b&lt;=c || b+c&lt;=a || a+c&lt;=b)&#123; throw new NotTriangleException(a+&quot;,&quot; + b +&quot;,&quot; + c +&quot;不能构造三角形，三角形任意两边之后必须大于第三边&quot;); &#125; this.c = c; &#125; @Override public String toString() &#123; return &quot;Triangle&#123;&quot; + &quot;a=&quot; + a + &quot;, b=&quot; + b + &quot;, c=&quot; + c + &#x27;&#125;&#x27;; &#125;&#125; 12345678910111213141516171819202122232425package com.atguigu.define;public class TestTriangle &#123; public static void main(String[] args) &#123; Triangle t = null; try &#123; t = new Triangle(2,2,3); System.out.println(&quot;三角形创建成功：&quot;); System.out.println(t); &#125; catch (NotTriangleException e) &#123; System.err.println(&quot;三角形创建失败&quot;); e.printStackTrace(); &#125; try &#123; if(t != null) &#123; t.setA(1); &#125; System.out.println(&quot;三角形边长修改成功&quot;); &#125; catch (NotTriangleException e) &#123; System.out.println(&quot;三角形边长修改失败&quot;); e.printStackTrace(); &#125; &#125;&#125; 7. 练习练习1： 12345678910111213141516171819202122232425262728public class ReturnExceptionDemo &#123; static void methodA() &#123; try &#123; System.out.println(&quot;进入方法A&quot;); throw new RuntimeException(&quot;制造异常&quot;); &#125;finally &#123; System.out.println(&quot;用A方法的finally&quot;); &#125; &#125; static void methodB() &#123; try &#123; System.out.println(&quot;进入方法B&quot;); return; &#125; finally &#123; System.out.println(&quot;调用B方法的finally&quot;); &#125; &#125; public static void main(String[] args) &#123; try &#123; methodA(); &#125; catch (Exception e) &#123; System.out.println(e.getMessage()); &#125; methodB(); &#125;&#125; 练习2： 从键盘接收学生成绩，成绩必须在0~100之间。 自定义成绩无效异常。 编写方法接收成绩并返回该成绩，如果输入无效，则抛出自定义异常。 练习3： 编写应用程序EcmDef.java，接收命令行的两个参数，要求不能输入负数，计算两数相除。对数据类型不一致(NumberFormatException)、缺少命令行参数(ArrayIndexOutOfBoundsException、除0(ArithmeticException)及输入负数(EcDef 自定义的异常)进行异常处理。 提示：(1)在主类(EcmDef)中定义异常方法(ecm)完成两数相除功能。 (2)在main()方法中使用异常处理语句进行异常处理。 (3)在程序中，自定义对应输入负数的异常类(EcDef)。 (4)运行时接受参数 java EcmDef 20 10 &#x2F;&#x2F;args[0]&#x3D;“20” args[1]&#x3D;“10” (5)Interger类的static方法parseInt(String s)将s转换成对应的int值。 如：int a&#x3D;Interger.parseInt(“314”); &#x2F;&#x2F;a&#x3D;314; 8. 小结与小悟8.1 小结：异常处理5个关键字 类比：上游排污，下游治污 8.2 感悟小哲理： 世界上最遥远的距离，是我在if里你在else里，似乎一直相伴又永远分离； 世界上最痴心的等待，是我当case你是switch，或许永远都选不上自己； 世界上最真情的相依，是你在try我在catch。无论你发神马脾气，我都默默承受，静静处理。到那时，再来期待我们的finally。 歌词：","categories":[{"name":"java基础","slug":"java基础","permalink":"http://example.com/categories/java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"java","slug":"java","permalink":"http://example.com/tags/java/"}]},{"title":"第08章_面向对象编程(高级)","slug":"Java/尚硅谷_第08章_面向对象编程（高级）/尚硅谷_宋红康_第08章_面向对象编程（高级）","date":"2022-09-27T00:55:57.000Z","updated":"2023-10-07T11:39:13.449Z","comments":true,"path":"2022/09/27/Java/尚硅谷_第08章_面向对象编程（高级）/尚硅谷_宋红康_第08章_面向对象编程（高级）/","link":"","permalink":"http://example.com/2022/09/27/Java/%E5%B0%9A%E7%A1%85%E8%B0%B7_%E7%AC%AC08%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E9%AB%98%E7%BA%A7%EF%BC%89/%E5%B0%9A%E7%A1%85%E8%B0%B7_%E5%AE%8B%E7%BA%A2%E5%BA%B7_%E7%AC%AC08%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E9%AB%98%E7%BA%A7%EF%BC%89/","excerpt":"","text":"本章专题与脉络 1. 关键字：static回顾类中的实例变量（即非static的成员变量） 123456789class Circle&#123; private double radius; public Circle(double radius)&#123; this.radius=radius; &#125; public double findArea()&#123; return Math.PI*radius*radius; &#125;&#125; 创建两个Circle对象： 12Circle c1=new Circle(2.0); //c1.radius=2.0Circle c2=new Circle(3.0); //c2.radius=3.0 Circle类中的变量radius是一个实例变量(instance variable)，它属于类的每一个对象，c1中的radius变化不会影响c2的radius，反之亦然。 如果想让一个成员变量被类的所有实例所共享，就用static修饰即可，称为类变量（或类属性）！ 1.1 类属性、类方法的设计思想当我们编写一个类时，其实就是在描述其对象的属性和行为，而并没有产生实质上的对象，只有通过new关键字才会产出对象，这时系统才会分配内存空间给对象，其方法才可以供外部调用。我们有时候希望无论是否产生了对象或无论产生了多少对象的情况下，某些特定的数据在内存空间里只有一份。例如，所有的中国人都有个国家名称，每一个中国人都共享这个国家名称，不必在每一个中国人的实例对象中都单独分配一个用于代表国家名称的变量。 此外，在类中声明的实例方法，在类的外面必须要先创建对象，才能调用。但是有些方法的调用者和当前类的对象无关，这样的方法通常被声明为类方法，由于不需要创建对象就可以调用类方法，从而简化了方法的调用。 这里的类变量、类方法，只需要使用static修饰即可。所以也称为静态变量、静态方法。 1.2 static关键字 使用范围： 在Java类中，可用static修饰属性、方法、代码块、内部类 被修饰后的成员具备以下特点： 随着类的加载而加载 优先于对象存在 修饰的成员，被所有对象所共享 访问权限允许时，可不创建对象，直接被类调用 1.3 静态变量1.3.1 语法格式使用static修饰的成员变量就是静态变量（或类变量、类属性） 123[修饰符] class 类&#123; [其他修饰符] static 数据类型 变量名;&#125; 1.3.2 静态变量的特点 静态变量的默认值规则和实例变量一样。 静态变量值是所有对象共享。 静态变量在本类中，可以在任意方法、代码块、构造器中直接使用。 如果权限修饰符允许，在其他类中可以通过“类名.静态变量”直接访问，也可以通过“对象.静态变量”的方式访问（但是更推荐使用类名.静态变量的方式）。 静态变量的get&#x2F;set方法也静态的，当局部变量与静态变量重名时，使用“类名.静态变量”进行区分。 1.3.3 举例举例1： 12345678910111213141516171819202122232425262728293031323334353637class Chinese&#123; //实例变量 String name; int age; //类变量 static String nation;//国籍 public Chinese() &#123; &#125; public Chinese(String name, int age) &#123; this.name = name; this.age = age; &#125; @Override public String toString() &#123; return &quot;Chinese&#123;&quot; + &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, age=&quot; + age + &quot;, nation=&#x27;&quot; + nation + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125;&#125;public class StaticTest &#123; public static void main(String[] args) &#123; Chinese c1 = new Chinese(&quot;康师傅&quot;,36); c1.nation = &quot;中华人民共和国&quot;; Chinese c2 = new Chinese(&quot;老干妈&quot;,66); System.out.println(c1); System.out.println(c2); System.out.println(Chinese.nation); &#125;&#125; 对应的内存结构：（以经典的JDK6内存解析为例，此时静态变量存储在方法区） 举例2： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package com.atguigu.keyword;public class Employee &#123; private static int total;//这里私有化，在类的外面必须使用get/set方法的方式来访问静态变量 static String company; //这里缺省权限修饰符，是为了方便类外以“类名.静态变量”的方式访问 private int id; private String name; public Employee() &#123; total++; id = total;//这里使用total静态变量的值为id属性赋值 &#125; public Employee(String name) &#123; this(); this.name = name; &#125; public void setId(int id) &#123; this.id = id; &#125; public int getId() &#123; return id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public static int getTotal() &#123; return total; &#125; public static void setTotal(int total) &#123; Employee.total = total; &#125; @Override public String toString() &#123; return &quot;Employee&#123;company = &quot; + company + &quot;,id = &quot; + id + &quot; ,name=&quot; + name +&quot;&#125;&quot;; &#125;&#125; 123456789101112131415161718192021222324package com.atguigu.keyword;public class TestStaticVariable &#123; public static void main(String[] args) &#123; //静态变量total的默认值是0 System.out.println(&quot;Employee.total = &quot; + Employee.getTotal()); Employee e1 = new Employee(&quot;张三&quot;); Employee e2 = new Employee(&quot;李四&quot;); System.out.println(e1);//静态变量company的默认值是null System.out.println(e2);//静态变量company的默认值是null System.out.println(&quot;Employee.total = &quot; + Employee.getTotal());//静态变量total值是2 Employee.company = &quot;尚硅谷&quot;; System.out.println(e1);//静态变量company的值是尚硅谷 System.out.println(e2);//静态变量company的值是尚硅谷 //只要权限修饰符允许,虽然不推荐，但是也可以通过“对象.静态变量”的形式来访问 e1.company = &quot;超级尚硅谷&quot;; System.out.println(e1);//静态变量company的值是超级尚硅谷 System.out.println(e2);//静态变量company的值是超级尚硅谷 &#125;&#125; 1.3.4 内存解析 1.4 静态方法1.4.1 语法格式用static修饰的成员方法就是静态方法。 12345[修饰符] class 类&#123; [其他修饰符] static 返回值类型 方法名(形参列表)&#123; 方法体 &#125;&#125; 1.4.2 静态方法的特点 静态方法在本类的任意方法、代码块、构造器中都可以直接被调用。 只要权限修饰符允许，静态方法在其他类中可以通过“类名.静态方法“的方式调用。也可以通过”对象.静态方法“的方式调用（但是更推荐使用类名.静态方法的方式）。 在static方法内部只能访问类的static修饰的属性或方法，不能访问类的非static的结构。 静态方法可以被子类继承，但不能被子类重写。 静态方法的调用都只看编译时类型。 因为不需要实例就可以访问static方法，因此static方法内部不能有this，也不能有super。如果有重名问题，使用“类名.”进行区别。 1.4.3 举例1234567891011package com.atguigu.keyword;public class Father &#123; public static void method()&#123; System.out.println(&quot;Father.method&quot;); &#125; public static void fun()&#123; System.out.println(&quot;Father.fun&quot;); &#125;&#125; 12345678package com.atguigu.keyword;public class Son extends Father&#123;// @Override //尝试重写静态方法，加上@Override编译报错，去掉Override不报错，但是也不是重写 public static void fun()&#123; System.out.println(&quot;Son.fun&quot;); &#125;&#125; 1234567891011package com.atguigu.keyword;public class TestStaticMethod &#123; public static void main(String[] args) &#123; Father.method(); Son.method();//继承静态方法 Father f = new Son(); f.method();//执行Father类中的method &#125;&#125; 1.5 练习笔试题：如下程序执行会不会报错 12345678910111213141516/** * @author 尚硅谷-宋红康 * @create 14:30 */public class StaticTest &#123; public static void main(String[] args) &#123; Demo test = null; test.hello(); &#125;&#125;class Demo&#123; public static void hello()&#123; System.out.println(&quot;hello!&quot;); &#125;&#125; 练习： 编写一个类实现银行账户的概念，包含的属性有“帐号”、“密码”、“存款余额”、“利率”、“最小余额”，定义封装这些属性的方法。账号要自动生成。 编写主类，使用银行账户类，输入、输出3个储户的上述信息。 考虑：哪些属性可以设计成static属性。 2. 单例(Singleton)设计模式2.1 设计模式概述设计模式是在大量的实践中总结和理论化之后优选的代码结构、编程风格、以及解决问题的思考方式。设计模式免去我们自己再思考和摸索。就像是经典的棋谱，不同的棋局，我们用不同的棋谱。”套路” 经典的设计模式共有23种。每个设计模式均是特定环境下特定问题的处理方法。 简单工厂模式并不是23中经典模式的一种，是其中工厂方法模式的简化版 对软件设计模式的研究造就了一本可能是面向对象设计方面最有影响的书籍：《设计模式》：《Design Patterns: Elements of Reusable Object-Oriented Software》（即后述《设计模式》一书），由 Erich Gamma、Richard Helm、Ralph Johnson 和 John Vlissides 合著（Addison-Wesley，1995）。这几位作者常被称为”四人组（Gang of Four）”，而这本书也就被称为”四人组（或 GoF）”书。 2.2 何为单例模式所谓类的单例设计模式，就是采取一定的方法保证在整个的软件系统中，对某个类只能存在一个对象实例，并且该类只提供一个取得其对象实例的方法。 2.3 实现思路如果我们要让类在一个虚拟机中只能产生一个对象，我们首先必须将类的构造器的访问权限设置为private，这样，就不能用new操作符在类的外部产生类的对象了，但在类内部仍可以产生该类的对象。因为在类的外部开始还无法得到类的对象，只能调用该类的某个静态方法以返回类内部创建的对象，静态方法只能访问类中的静态成员变量，所以，指向类内部产生的该类对象的变量也必须定义成静态的。 2.4 单例模式的两种实现方式2.4.1 饿汉式123456789101112131415class Singleton &#123; // 1.私有化构造器 private Singleton() &#123; &#125; // 2.内部提供一个当前类的实例 // 4.此实例也必须静态化 private static Singleton single = new Singleton(); // 3.提供公共的静态的方法，返回当前类的对象 public static Singleton getInstance() &#123; return single; &#125;&#125; 2.4.2 懒汉式12345678910111213141516class Singleton &#123; // 1.私有化构造器 private Singleton() &#123; &#125; // 2.内部提供一个当前类的实例 // 4.此实例也必须静态化 private static Singleton single; // 3.提供公共的静态的方法，返回当前类的对象 public static Singleton getInstance() &#123; if(single == null) &#123; single = new Singleton(); &#125; return single; &#125;&#125; 2.4.3 饿汉式 vs 懒汉式饿汉式： 特点：立即加载，即在使用类的时候已经将对象创建完毕。 优点：实现起来简单；没有多线程安全问题。 缺点：当类被加载的时候，会初始化static的实例，静态变量被创建并分配内存空间，从这以后，这个static的实例便一直占着这块内存，直到类被卸载时，静态变量被摧毁，并释放所占有的内存。因此在某些特定条件下会耗费内存。 懒汉式： 特点：延迟加载，即在调用静态方法时实例才被创建。 优点：实现起来比较简单；当类被加载的时候，static的实例未被创建并分配内存空间，当静态方法第一次被调用时，初始化实例变量，并分配内存，因此在某些特定条件下会节约内存。 缺点：在多线程环境中，这种实现方法是完全错误的，线程不安全，根本不能保证单例的唯一性。 说明：在多线程章节，会将懒汉式改造成线程安全的模式。 2.5 单例模式的优点及应用场景由于单例模式只生成一个实例，减少了系统性能开销，当一个对象的产生需要比较多的资源时，如读取配置、产生其他依赖对象时，则可以通过在应用启动时直接产生一个单例对象，然后永久驻留内存的方式来解决。 举例： 应用场景 Windows的Task Manager (任务管理器)就是很典型的单例模式 Windows的Recycle Bin (回收站)也是典型的单例应用。在整个系统运行过程中，回收站一直维护着仅有的一个实例。 Application 也是单例的典型应用 应用程序的日志应用，一般都使用单例模式实现，这一般是由于共享的日志文件一直处于打开状态，因为只 能有一个实例去操作，否则内容不好追加。 数据库连接池的设计一般也是采用单例模式，因为数据库连接是一种数据库资源。 3. 理解main方法的语法由于JVM需要调用类的main()方法，所以该方法的访问权限必须是public，又因为JVM在执行main()方法时不必创建对象，所以该方法必须是static的，该方法接收一个String类型的数组参数，该数组中保存执行Java命令时传递给所运行的类的参数。 又因为main() 方法是静态的，我们不能直接访问该类中的非静态成员，必须创建该类的一个实例对象后，才能通过这个对象去访问类中的非静态成员，这种情况，我们在之前的例子中多次碰到。 命令行参数用法举例 12345678public class CommandPara &#123; public static void main(String[] args) &#123; for (int i = 0; i &lt; args.length; i++) &#123; System.out.println(&quot;args[&quot; + i + &quot;] = &quot; + args[i]); &#125; &#125;&#125; 12//运行程序CommandPara.javajava CommandPara &quot;Tom&quot; &quot;Jerry&quot; &quot;Shkstart&quot; 12345//输出结果args[0] = Tomargs[1] = Jerryargs[2] = Shkstart IDEA工具： （1）配置运行参数 （2）运行程序 笔试题： 12345678910//此处，Something类的文件名叫OtherThing.javaclass Something &#123; public static void main(String[] something_to_do) &#123; System.out.println(&quot;Do something ...&quot;); &#125;&#125;//上述程序是否可以正常编译、运行？ 4. 类的成员之四：代码块如果成员变量想要初始化的值不是一个硬编码的常量值，而是需要通过复杂的计算或读取文件、或读取运行环境信息等方式才能获取的一些值，该怎么办呢？此时，可以考虑代码块（或初始化块）。 代码块(或初始化块)的作用： 对Java类或对象进行初始化 代码块(或初始化块)的分类： 一个类中代码块若有修饰符，则只能被static修饰，称为静态代码块(static block) 没有使用static修饰的，为非静态代码块。 4.1 静态代码块如果想要为静态变量初始化，可以直接在静态变量的声明后面直接赋值，也可以使用静态代码块。 4.1.1 语法格式在代码块的前面加static，就是静态代码块。 12345【修饰符】 class 类&#123; static&#123; 静态代码块 &#125;&#125; 4.1.2 静态代码块的特点 可以有输出语句。 可以对类的属性、类的声明进行初始化操作。 不可以对非静态的属性初始化。即：不可以调用非静态的属性和方法。 若有多个静态的代码块，那么按照从上到下的顺序依次执行。 静态代码块的执行要先于非静态代码块。 静态代码块随着类的加载而加载，且只执行一次。 123456789101112131415161718192021package com.atguigu.keyword;public class Chinese &#123;// private static String country = &quot;中国&quot;; private static String country; private String name; &#123; System.out.println(&quot;非静态代码块，country = &quot; + country); &#125; static &#123; country = &quot;中国&quot;; System.out.println(&quot;静态代码块&quot;); &#125; public Chinese(String name) &#123; this.name = name; &#125;&#125; 123456789package com.atguigu.keyword;public class TestStaticBlock &#123; public static void main(String[] args) &#123; Chinese c1 = new Chinese(&quot;张三&quot;); Chinese c2 = new Chinese(&quot;李四&quot;); &#125;&#125; 4.2 非静态代码块4.2.1 语法格式1234567891011【修饰符】 class 类&#123; &#123; 非静态代码块 &#125; 【修饰符】 构造器名()&#123; // 实例初始化代码 &#125; 【修饰符】 构造器名(参数列表)&#123; // 实例初始化代码 &#125;&#125; 4.2.2 非静态代码块的作用和构造器一样，也是用于实例变量的初始化等操作。 4.2.3 非静态代码块的意义如果多个重载的构造器有公共代码，并且这些代码都是先于构造器其他代码执行的，那么可以将这部分代码抽取到非静态代码块中，减少冗余代码。 4.2.4 非静态代码块的执行特点 可以有输出语句。 可以对类的属性、类的声明进行初始化操作。 除了调用非静态的结构外，还可以调用静态的变量或方法。 若有多个非静态的代码块，那么按照从上到下的顺序依次执行。 每次创建对象的时候，都会执行一次。且先于构造器执行。 4.3 举例举例1： （1）声明User类， 包含属性：username（String类型），password（String类型），registrationTime（long类型），私有化 包含get&#x2F;set方法，其中registrationTime没有set方法 包含无参构造， 输出“新用户注册”， registrationTime赋值为当前系统时间， username就默认为当前系统时间值， password默认为“123456” 包含有参构造(String username, String password)， 输出“新用户注册”， registrationTime赋值为当前系统时间， username和password由参数赋值 包含public String getInfo()方法，返回：“用户名：xx，密码：xx，注册时间：xx” （2）编写测试类，测试类main方法的代码如下： 1234567public static void main(String[] args) &#123; User u1 = new User(); System.out.println(u1.getInfo()); User u2 = new User(&quot;song&quot;,&quot;8888&quot;); System.out.println(u2.getInfo());&#125; 如果不用非静态代码块，User类是这样的： 1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.atguigu.block.no;public class User &#123; private String username; private String password; private long registrationTime; public User() &#123; System.out.println(&quot;新用户注册&quot;); registrationTime = System.currentTimeMillis(); username = registrationTime+&quot;&quot;; password = &quot;123456&quot;; &#125; public User(String username,String password) &#123; System.out.println(&quot;新用户注册&quot;); registrationTime = System.currentTimeMillis(); this.username = username; this.password = password; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; public long getRegistrationTime() &#123; return registrationTime; &#125; public String getInfo()&#123; return &quot;用户名：&quot; + username + &quot;，密码：&quot; + password + &quot;，注册时间：&quot; + registrationTime; &#125;&#125; 如果提取构造器公共代码到非静态代码块，User类是这样的： 123456789101112131415161718192021222324252627282930313233343536373839404142434445package com.atguigu.block.use;public class User &#123; private String username; private String password; private long registrationTime; &#123; System.out.println(&quot;新用户注册&quot;); registrationTime = System.currentTimeMillis(); &#125; public User() &#123; username = registrationTime+&quot;&quot;; password = &quot;123456&quot;; &#125; public User(String username, String password) &#123; this.username = username; this.password = password; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; public long getRegistrationTime() &#123; return registrationTime; &#125; public String getInfo()&#123; return &quot;用户名：&quot; + username + &quot;，密码：&quot; + password + &quot;，注册时间：&quot; + registrationTime; &#125;&#125; 举例2： 12345678910111213141516171819202122private static DataSource dataSource = null;static&#123; InputStream is = null; try &#123; is = DBCPTest.class.getClassLoader().getResourceAsStream(&quot;dbcp.properties&quot;); Properties pros = new Properties(); pros.load(is); //调用BasicDataSourceFactory的静态方法，获取数据源。 dataSource = BasicDataSourceFactory.createDataSource(pros); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;finally&#123; if(is != null)&#123; try &#123; is.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; 4.4 小结：实例变量赋值顺序 4.5 练习练习1：分析加载顺序 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class Root&#123; static&#123; System.out.println(&quot;Root的静态初始化块&quot;); &#125; &#123; System.out.println(&quot;Root的普通初始化块&quot;); &#125; public Root()&#123; System.out.println(&quot;Root的无参数的构造器&quot;); &#125;&#125;class Mid extends Root&#123; static&#123; System.out.println(&quot;Mid的静态初始化块&quot;); &#125; &#123; System.out.println(&quot;Mid的普通初始化块&quot;); &#125; public Mid()&#123; System.out.println(&quot;Mid的无参数的构造器&quot;); &#125; public Mid(String msg)&#123; //通过this调用同一类中重载的构造器 this(); System.out.println(&quot;Mid的带参数构造器，其参数值：&quot; + msg); &#125;&#125;class Leaf extends Mid&#123; static&#123; System.out.println(&quot;Leaf的静态初始化块&quot;); &#125; &#123; System.out.println(&quot;Leaf的普通初始化块&quot;); &#125; public Leaf()&#123; //通过super调用父类中有一个字符串参数的构造器 super(&quot;尚硅谷&quot;); System.out.println(&quot;Leaf的构造器&quot;); &#125;&#125;public class LeafTest&#123; public static void main(String[] args)&#123; new Leaf(); //new Leaf(); &#125;&#125; 练习2：分析加载顺序 12345678910111213141516171819202122232425262728293031323334353637383940class Father &#123; static &#123; System.out.println(&quot;11111111111&quot;); &#125; &#123; System.out.println(&quot;22222222222&quot;); &#125; public Father() &#123; System.out.println(&quot;33333333333&quot;); &#125;&#125;public class Son extends Father &#123; static &#123; System.out.println(&quot;44444444444&quot;); &#125; &#123; System.out.println(&quot;55555555555&quot;); &#125; public Son() &#123; System.out.println(&quot;66666666666&quot;); &#125; public static void main(String[] args) &#123; System.out.println(&quot;77777777777&quot;); System.out.println(&quot;************************&quot;); new Son(); System.out.println(&quot;************************&quot;); new Son(); System.out.println(&quot;************************&quot;); new Father(); &#125;&#125; 练习3： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package com.atguigu05.field.interview;/** * @author 尚硅谷-宋红康 * @create 16:04 */public class Test04 &#123; public static void main(String[] args) &#123; Zi zi = new Zi(); &#125;&#125;class Fu&#123; private static int i = getNum(&quot;（1）i&quot;); private int j = getNum(&quot;（2）j&quot;); static&#123; print(&quot;（3）父类静态代码块&quot;); &#125; &#123; print(&quot;（4）父类非静态代码块，又称为构造代码块&quot;); &#125; Fu()&#123; print(&quot;（5）父类构造器&quot;); &#125; public static void print(String str)&#123; System.out.println(str + &quot;-&gt;&quot; + i); &#125; public static int getNum(String str)&#123; print(str); return ++i; &#125;&#125;class Zi extends Fu&#123; private static int k = getNum(&quot;（6）k&quot;); private int h = getNum(&quot;（7）h&quot;); static&#123; print(&quot;（8）子类静态代码块&quot;); &#125; &#123; print(&quot;（9）子类非静态代码块，又称为构造代码块&quot;); &#125; Zi()&#123; print(&quot;（10）子类构造器&quot;); &#125; public static void print(String str)&#123; System.out.println(str + &quot;-&gt;&quot; + k); &#125; public static int getNum(String str)&#123; print(str); return ++k; &#125;&#125; 5. final关键字5.1 final的意义final：最终的，不可更改的 5.2 final的使用5.2.1 final修饰类表示这个类不能被继承，没有子类。提高安全性，提高程序的可读性。 例如：String类、System类、StringBuffer类 123456final class Eunuch&#123;//太监类 &#125;class Son extends Eunuch&#123;//错误 &#125; 5.2.2 final修饰方法表示这个方法不能被子类重写。 例如：Object类中的getClass() 12345678910class Father&#123; public final void method()&#123; System.out.println(&quot;father&quot;); &#125;&#125;class Son extends Father&#123; public void method()&#123;//错误 System.out.println(&quot;son&quot;); &#125;&#125; 5.2.3 final修饰变量final修饰某个变量（成员变量或局部变量），一旦赋值，它的值就不能被修改，即常量，常量名建议使用大写字母。 例如：final double MY_PI &#x3D; 3.14; 如果某个成员变量用final修饰后，没有set方法，并且必须初始化（可以显式赋值、或在初始化块赋值、实例变量还可以在构造器中赋值） 修饰成员变量 12345678910111213public final class Test &#123; public static int totalNumber = 5; public final int ID; public Test() &#123; ID = ++totalNumber; // 可在构造器中给final修饰的“变量”赋值 &#125; public static void main(String[] args) &#123; Test t = new Test(); System.out.println(t.ID); &#125;&#125; 修饰局部变量： 12345678public class TestFinal &#123; public static void main(String[] args)&#123; final int MIN_SCORE ; MIN_SCORE = 0; final int MAX_SCORE = 100; MAX_SCORE = 200; //非法 &#125;&#125; 错误演示： 123456789class A &#123; private final String INFO = &quot;atguigu&quot;; //声明常量 public void print() &#123; //The final field A.INFO cannot be assigned //INFO = &quot;尚硅谷&quot;; &#125;&#125; 5.3 笔试题题1：排错 123456public class Something &#123; public int addOne(final int x) &#123; return ++x; // return x + 1; &#125;&#125; 题2：排错 1234567891011121314public class Something &#123; public static void main(String[] args) &#123; Other o = new Other(); new Something().addOne(o); &#125; public void addOne(final Other o) &#123; // o = new Other(); o.i++; &#125;&#125;class Other &#123; public int i;&#125; 6. 抽象类与抽象方法(或abstract关键字)6.1 由来举例1： 随着继承层次中一个个新子类的定义，类变得越来越具体，而父类则更一般，更通用。类的设计应该保证父类和子类能够共享特征。有时将一个父类设计得非常抽象，以至于它没有具体的实例，这样的类叫做抽象类。 举例2： 我们声明一些几何图形类：圆、矩形、三角形类等，发现这些类都有共同特征：求面积、求周长。那么这些共同特征应该抽取到一个共同父类：几何图形类中。但是这些方法在父类中又无法给出具体的实现，而是应该交给子类各自具体实现。那么父类在声明这些方法时，就只有方法签名，没有方法体，我们把没有方法体的方法称为抽象方法。Java语法规定，包含抽象方法的类必须是抽象类。 6.2 语法格式 抽象类：被abstract修饰的类。 抽象方法：被abstract修饰没有方法体的方法。 抽象类的语法格式 123456[权限修饰符] abstract class 类名&#123; &#125;[权限修饰符] abstract class 类名 extends 父类&#123; &#125; 抽象方法的语法格式 1[其他修饰符] abstract 返回值类型 方法名([形参列表]); 注意：抽象方法没有方法体 代码举例： 123public abstract class Animal &#123; public abstract void eat();&#125; 12345public class Cat extends Animal &#123; public void eat ()&#123; System.out.println(&quot;小猫吃鱼和猫粮&quot;); &#125;&#125; 123456789public class CatTest &#123; public static void main(String[] args) &#123; // 创建子类对象 Cat c = new Cat(); // 调用eat方法 c.eat(); &#125;&#125; 此时的方法重写，是子类对父类抽象方法的完成实现，我们将这种方法重写的操作，也叫做实现方法。 6.3 使用说明 抽象类不能创建对象，如果创建，编译无法通过而报错。只能创建其非抽象子类的对象。 理解：假设创建了抽象类的对象，调用抽象的方法，而抽象方法没有具体的方法体，没有意义。 抽象类是用来被继承的，抽象类的子类必须重写父类的抽象方法，并提供方法体。若没有重写全部的抽象方法，仍为抽象类。 抽象类中，也有构造方法，是供子类创建对象时，初始化父类成员变量使用的。 理解：子类的构造方法中，有默认的super()或手动的super(实参列表)，需要访问父类构造方法。 抽象类中，不一定包含抽象方法，但是有抽象方法的类必定是抽象类。 理解：未包含抽象方法的抽象类，目的就是不想让调用者创建该类对象，通常用于某些特殊的类结构设计。 抽象类的子类，必须重写抽象父类中所有的抽象方法，否则，编译无法通过而报错。除非该子类也是抽象类。 理解：假设不重写所有抽象方法，则类中可能包含抽象方法。那么创建对象后，调用抽象的方法，没有意义。 6.4 注意事项 不能用abstract修饰变量、代码块、构造器； 不能用abstract修饰私有方法、静态方法、final的方法、final的类。 6.5 应用举例1 在航运公司系统中，Vehicle类需要定义两个方法分别计算运输工具的燃料效率和行驶距离。 问题：卡车(Truck)和驳船(RiverBarge)的燃料效率和行驶距离的计算方法完全不同。Vehicle类不能提供计算方法，但子类可以。 解决方案：Java允许类设计者指定：超类声明一个方法但不提供实现，该方法的实现由子类提供。这样的方法称为抽象方法。有一个或更多抽象方法的类称为抽象类。 1234567891011121314//Vehicle是一个抽象类，有两个抽象方法。public abstract class Vehicle&#123; public abstract double calcFuelEfficiency(); //计算燃料效率的抽象方法 public abstract double calcTripDistance(); //计算行驶距离的抽象方法&#125;public class Truck extends Vehicle&#123; public double calcFuelEfficiency( ) &#123; //写出计算卡车的燃料效率的具体方法 &#125; public double calcTripDistance( ) &#123; //写出计算卡车行驶距离的具体方法 &#125;&#125;public class RiverBarge extends Vehicle&#123; public double calcFuelEfficiency( ) &#123; //写出计算驳船的燃料效率的具体方法 &#125; public double calcTripDistance( ) &#123; //写出计算驳船行驶距离的具体方法&#125;&#125; 6.6 应用举例2：模板方法设计模式(TemplateMethod)抽象类体现的就是一种模板模式的设计，抽象类作为多个子类的通用模板，子类在抽象类的基础上进行扩展、改造，但子类总体上会保留抽象类的行为方式。 解决的问题： 当功能内部一部分实现是确定的，另一部分实现是不确定的。这时可以把不确定的部分暴露出去，让子类去实现。 换句话说，在软件开发中实现一个算法时，整体步骤很固定、通用，这些步骤已经在父类中写好了。但是某些部分易变，易变部分可以抽象出来，供不同子类实现。这就是一种模板模式。 类比举例：英语六级模板 制作月饼的模板： 举例1： 12345678910111213141516171819abstract class Template &#123; public final void getTime() &#123; long start = System.currentTimeMillis(); code(); long end = System.currentTimeMillis(); System.out.println(&quot;执行时间是：&quot; + (end - start)); &#125; public abstract void code();&#125;class SubTemplate extends Template &#123; public void code() &#123; for (int i = 0; i &lt; 10000; i++) &#123; System.out.println(i); &#125; &#125;&#125; 举例2： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546package com.atguigu.java;//抽象类的应用：模板方法的设计模式public class TemplateMethodTest &#123; public static void main(String[] args) &#123; BankTemplateMethod btm = new DrawMoney(); btm.process(); BankTemplateMethod btm2 = new ManageMoney(); btm2.process(); &#125;&#125;abstract class BankTemplateMethod &#123; // 具体方法 public void takeNumber() &#123; System.out.println(&quot;取号排队&quot;); &#125; public abstract void transact(); // 办理具体的业务 //钩子方法 public void evaluate() &#123; System.out.println(&quot;反馈评分&quot;); &#125; // 模板方法，把基本操作组合到一起，子类一般不能重写 public final void process() &#123; this.takeNumber(); this.transact();// 像个钩子，具体执行时，挂哪个子类，就执行哪个子类的实现代码 this.evaluate(); &#125;&#125;class DrawMoney extends BankTemplateMethod &#123; public void transact() &#123; System.out.println(&quot;我要取款！！！&quot;); &#125;&#125;class ManageMoney extends BankTemplateMethod &#123; public void transact() &#123; System.out.println(&quot;我要理财！我这里有2000万美元!!&quot;); &#125;&#125; 模板方法设计模式是编程中经常用得到的模式。各个框架、类库中都有他的影子，比如常见的有： 数据库访问的封装 Junit单元测试 JavaWeb的Servlet中关于doGet&#x2F;doPost方法调用 Hibernate中模板程序 Spring中JDBCTemlate、HibernateTemplate等 6.7 思考与练习思考： 问题1：为什么抽象类不可以使用final关键字声明？ 问题2：一个抽象类中可以定义构造器吗？ 问题3：是否可以这样理解：抽象类就是比普通类多定义了抽象方法，除了不能直接进行类的实例化操作之外，并没有任何的不同？ 练习1： 编写一个Employee类，声明为抽象类，包含如下三个属性：name，id，salary。提供必要的构造器和抽象方法：work()。 对于Manager类来说，他既是员工，还具有奖金(bonus)的属性。 请使用继承的思想，设计CommonEmployee类和Manager类，要求类中提供必要的方法进行属性访问。 练习2：软件外包公司外派管理 有一家软件外包公司，可以外派开发人员，该公司有两个角色：普通开发人员Developer和项目经理Manager。他们的关系如下图： 普通开发人员的工作内容是“开发项目”，项目经理的工作内容是“项目管理”。对外的报价是普通开发人员每天500,元，超过60天每天400元。项目经理每天800元，超过60天每天700元。 有一家银行需要1名项目经理、2名开发人员，现场开发90天，计算银行需要付给软件公司的总金额。 提示：创建数组 Employee[] emps &#x3D; new Employee[3]。其中存储驻场的3名员工。 练习3： 创建父类Shape，包含绘制形状的抽象方法draw()。 创建Shape的子类Circle和Rectangle，重写draw()方法，绘制圆形和矩形。 绘制多个圆形和矩形。 练习4： 1、声明抽象父类Person，包含抽象方法public abstract void eat();2、声明子类中国人Chinese，重写抽象方法，打印用筷子吃饭3、声明子类美国人American，重写抽象方法，打印用刀叉吃饭4、声明子类印度人Indian，重写抽象方法，打印用手抓饭5、声明测试类PersonTest，创建Person数组，存储各国人对象，并遍历数组，调用eat()方法 练习5：工资系统设计 编写工资系统，实现不同类型员工(多态)的按月发放工资。如果当月出现某个Employee对象的生日，则将该雇员的工资增加100元。 实验说明： （1）定义一个Employee类，该类包含： private成员变量name,number,birthday，其中birthday 为MyDate类的对象； abstract方法earnings()； toString()方法输出对象的name,number和birthday。 （2）MyDate类包含: private成员变量year,month,day ； toDateString()方法返回日期对应的字符串：xxxx年xx月xx日 （3）定义SalariedEmployee类继承Employee类，实现按月计算工资的员工处理。该类包括：private成员变量monthlySalary； 实现父类的抽象方法earnings(),该方法返回monthlySalary值；toString()方法输出员工类型信息及员工的name，number,birthday。 （4）参照SalariedEmployee类定义HourlyEmployee类，实现按小时计算工资的员工处理。该类包括： private成员变量wage和hour； 实现父类的抽象方法earnings(),该方法返回wage*hour值； toString()方法输出员工类型信息及员工的name，number,birthday。 （5）定义PayrollSystem类，创建Employee变量数组并初始化，该数组存放各类雇员对象的引用。利用循环结构遍历数组元素，输出各个对象的类型,name,number,birthday,以及该对象生日。当键盘输入本月月份值时，如果本月是某个Employee对象的生日，还要输出增加工资信息。 123456789//提示：//定义People类型的数组People c1[]=new People[10];//数组元素赋值c1[0]=new People(&quot;John&quot;,&quot;0001&quot;,20);c1[1]=new People(&quot;Bob&quot;,&quot;0002&quot;,19);//若People有两个子类Student和Officer，则数组元素赋值时，可以使父类类型的数组元素指向子类。c1[0]=new Student(&quot;John&quot;,&quot;0001&quot;,20,85.0);c1[1]=new Officer(&quot;Bob&quot;,&quot;0002&quot;,19,90.5); 7. 接口(interface)7.1 类比生活中大家每天都在用USB接口，那么USB接口与我们今天要学习的接口有什么相同点呢？ USB，（Universal Serial Bus，通用串行总线）是Intel公司开发的总线架构，使得在计算机上添加串行设备（鼠标、键盘、打印机、扫描仪、摄像头、充电器、MP3机、手机、数码相机、移动硬盘等）非常容易。 其实，不管是电脑上的USB插口，还是其他设备上的USB插口都只是遵循了USB规范的一种具体设备而已。 只要设备遵循USB规范的，那么就可以与电脑互联，并正常通信。至于这个设备、电脑是哪个厂家制造的，内部是如何实现的，我们都无需关心。 Java的软件系统会有很多模块组成，那么各个模块之间也应该采用这种面向接口的低耦合，为系统提供更好的可扩展性和可维护性。 7.2 概述接口就是规范，定义的是一组规则，体现了现实世界中“如果你是&#x2F;要…则必须能…”的思想。继承是一个”是不是”的is-a关系，而接口实现则是 “能不能”的has-a关系。 例如：电脑都预留了可以插入USB设备的USB接口，USB接口具备基本的数据传输的开启功能和关闭功能。你能不能用USB进行连接，或是否具备USB通信功能，就看你能否遵循USB接口规范 例如：Java程序是否能够连接使用某种数据库产品，那么要看该数据库产品能否实现Java设计的JDBC规范 接口的本质是契约、标准、规范，就像我们的法律一样。制定好后大家都要遵守。 7.3 定义格式接口的定义，它与定义类方式相似，但是使用 interface 关键字。它也会被编译成.class文件，但一定要明确它并不是类，而是另外一种引用数据类型。 引用数据类型：数组，类，枚举，接口，注解。 7.3.1 接口的声明格式123456789[修饰符] interface 接口名&#123; //接口的成员列表： // 公共的静态常量 // 公共的抽象方法 // 公共的默认方法（JDK1.8以上） // 公共的静态方法（JDK1.8以上） // 私有方法（JDK1.9以上）&#125; 示例代码： 1234567891011121314151617181920212223package com.atguigu.interfacetype;public interface USB3&#123; //静态常量 long MAX_SPEED = 500*1024*1024;//500MB/s //抽象方法 void in(); void out(); //默认方法 default void start()&#123; System.out.println(&quot;开始&quot;); &#125; default void stop()&#123; System.out.println(&quot;结束&quot;); &#125; //静态方法 static void show()&#123; System.out.println(&quot;USB 3.0可以同步全速地进行读写操作&quot;); &#125;&#125; 7.3.2 接口的成员说明在JDK8.0 之前，接口中只允许出现： （1）公共的静态的常量：其中public static final可以省略 （2）公共的抽象的方法：其中public abstract可以省略 理解：接口是从多个相似类中抽象出来的规范，不需要提供具体实现 在JDK8.0 时，接口中允许声明默认方法和静态方法： （3）公共的默认的方法：其中public 可以省略，建议保留，但是default不能省略 （4）公共的静态的方法：其中public 可以省略，建议保留，但是static不能省略 在JDK9.0 时，接口又增加了： （5）私有方法 除此之外，接口中没有构造器，没有初始化块，因为接口中没有成员变量需要动态初始化。 7.4 接口的使用规则1、类实现接口（implements） 接口不能创建对象，但是可以被类实现（implements ，类似于被继承）。 类与接口的关系为实现关系，即类实现接口，该类可以称为接口的实现类。实现的动作类似继承，格式相仿，只是关键字不同，实现使用 implements关键字。 123456789【修饰符】 class 实现类 implements 接口&#123; // 重写接口中抽象方法【必须】，当然如果实现类是抽象类，那么可以不重写 // 重写接口中默认方法【可选】&#125;【修饰符】 class 实现类 extends 父类 implements 接口&#123; // 重写接口中抽象方法【必须】，当然如果实现类是抽象类，那么可以不重写 // 重写接口中默认方法【可选】&#125; 注意： 如果接口的实现类是非抽象类，那么必须重写接口中所有抽象方法。 默认方法可以选择保留，也可以重写。 重写时，default单词就不要再写了，它只用于在接口中表示默认方法，到类中就没有默认方法的概念了 接口中的静态方法不能被继承也不能被重写 举例： 123456789101112131415161718192021222324252627282930313233343536373839404142interface USB&#123; // public void start() ; public void stop() ; &#125;class Computer&#123; public static void show(USB usb)&#123; usb.start() ; System.out.println(&quot;=========== USB 设备工作 ========&quot;) ; usb.stop() ; &#125;&#125;;class Flash implements USB&#123; public void start()&#123; // 重写方法 System.out.println(&quot;U盘开始工作。&quot;) ; &#125; public void stop()&#123; // 重写方法 System.out.println(&quot;U盘停止工作。&quot;) ; &#125;&#125;;class Print implements USB&#123; public void start()&#123; // 重写方法 System.out.println(&quot;打印机开始工作。&quot;) ; &#125; public void stop()&#123; // 重写方法 System.out.println(&quot;打印机停止工作。&quot;) ; &#125;&#125;;public class InterfaceDemo&#123; public static void main(String args[])&#123; Computer.show(new Flash()) ; Computer.show(new Print()) ; c.show(new USB()&#123; public void start()&#123; System.out.println(&quot;移动硬盘开始运行&quot;); &#125; public void stop()&#123; System.out.println(&quot;移动硬盘停止运行&quot;); &#125; &#125;); &#125;&#125;; 2、接口的多实现（implements） 之前学过，在继承体系中，一个类只能继承一个父类。而对于接口而言，一个类是可以实现多个接口的，这叫做接口的多实现。并且，一个类能继承一个父类，同时实现多个接口。 实现格式： 123456789【修饰符】 class 实现类 implements 接口1，接口2，接口3。。。&#123; // 重写接口中所有抽象方法【必须】，当然如果实现类是抽象类，那么可以不重写 // 重写接口中默认方法【可选】&#125;【修饰符】 class 实现类 extends 父类 implements 接口1，接口2，接口3。。。&#123; // 重写接口中所有抽象方法【必须】，当然如果实现类是抽象类，那么可以不重写 // 重写接口中默认方法【可选】&#125; 接口中，有多个抽象方法时，实现类必须重写所有抽象方法。如果抽象方法有重名的，只需要重写一次。 举例： 定义多个接口： 12345package com.atguigu.interfacetype;public interface A &#123; void showA();&#125; 12345package com.atguigu.interfacetype;public interface B &#123; void showB();&#125; 定义实现类： 1234567891011121314package com.atguigu.interfacetype;public class C implements A,B &#123; @Override public void showA() &#123; System.out.println(&quot;showA&quot;); &#125; @Override public void showB() &#123; System.out.println(&quot;showB&quot;); &#125;&#125; 测试类 123456789package com.atguigu.interfacetype;public class TestC &#123; public static void main(String[] args) &#123; C c = new C(); c.showA(); c.showB(); &#125;&#125; 3、接口的多继承(extends) 一个接口能继承另一个或者多个接口，接口的继承也使用 extends 关键字，子接口继承父接口的方法。 定义父接口： 1234567package com.atguigu.interfacetype;public interface Chargeable &#123; void charge(); void in(); void out();&#125; 定义子接口： 12345package com.atguigu.interfacetype;public interface UsbC extends Chargeable,USB3 &#123; void reverse();&#125; 定义子接口的实现类： 1234567891011121314151617181920212223package com.atguigu.interfacetype;public class TypeCConverter implements UsbC &#123; @Override public void reverse() &#123; System.out.println(&quot;正反面都支持&quot;); &#125; @Override public void charge() &#123; System.out.println(&quot;可充电&quot;); &#125; @Override public void in() &#123; System.out.println(&quot;接收数据&quot;); &#125; @Override public void out() &#123; System.out.println(&quot;输出数据&quot;); &#125;&#125; 所有父接口的抽象方法都有重写。 方法签名相同的抽象方法只需要实现一次。 4、接口与实现类对象构成多态引用 实现类实现接口，类似于子类继承父类，因此，接口类型的变量与实现类的对象之间，也可以构成多态引用。通过接口类型的变量调用方法，最终执行的是你new的实现类对象实现的方法体。 接口的不同实现类： 12345678910111213package com.atguigu.interfacetype;public class Mouse implements USB3 &#123; @Override public void out() &#123; System.out.println(&quot;发送脉冲信号&quot;); &#125; @Override public void in() &#123; System.out.println(&quot;不接收信号&quot;); &#125;&#125; 1234567891011121314package com.atguigu.interfacetype;public class KeyBoard implements USB3&#123; @Override public void in() &#123; System.out.println(&quot;不接收信号&quot;); &#125; @Override public void out() &#123; System.out.println(&quot;发送按键信号&quot;); &#125;&#125; 测试类 1234567891011121314151617181920212223242526272829package com.atguigu.interfacetype;public class TestComputer &#123; public static void main(String[] args) &#123; Computer computer = new Computer(); USB3 usb = new Mouse(); computer.setUsb(usb); usb.start(); usb.out(); usb.in(); usb.stop(); System.out.println(&quot;--------------------------&quot;); usb = new KeyBoard(); computer.setUsb(usb); usb.start(); usb.out(); usb.in(); usb.stop(); System.out.println(&quot;--------------------------&quot;); usb = new MobileHDD(); computer.setUsb(usb); usb.start(); usb.out(); usb.in(); usb.stop(); &#125;&#125; 5、使用接口的静态成员 接口不能直接创建对象，但是可以通过接口名直接调用接口的静态方法和静态常量。 12345678910package com.atguigu.interfacetype;public class TestUSB3 &#123; public static void main(String[] args) &#123; //通过“接口名.”调用接口的静态方法 (JDK8.0才能开始使用) USB3.show(); //通过“接口名.”直接使用接口的静态常量 System.out.println(USB3.MAX_SPEED); &#125;&#125; 6、使用接口的非静态方法 对于接口的静态方法，直接使用“接口名.”进行调用即可 也只能使用“接口名.”进行调用，不能通过实现类的对象进行调用 对于接口的抽象方法、默认方法，只能通过实现类对象才可以调用 接口不能直接创建对象，只能创建实现类的对象 123456789101112131415161718package com.atguigu.interfacetype;public class TestMobileHDD &#123; public static void main(String[] args) &#123; //创建实现类对象 MobileHDD b = new MobileHDD(); //通过实现类对象调用重写的抽象方法，以及接口的默认方法，如果实现类重写了就执行重写的默认方法，如果没有重写，就执行接口中的默认方法 b.start(); b.in(); b.stop(); //通过接口名调用接口的静态方法// MobileHDD.show();// b.show(); Usb3.show(); &#125;&#125; 7.5 JDK8中相关冲突问题7.5.1 默认方法冲突问题（1）类优先原则 当一个类，既继承一个父类，又实现若干个接口时，父类中的成员方法与接口中的抽象方法重名，子类就近选择执行父类的成员方法。代码如下： 定义接口： 1234567package com.atguigu.interfacetype;public interface Friend &#123; default void date()&#123;//约会 System.out.println(&quot;吃喝玩乐&quot;); &#125;&#125; 定义父类： 1234567package com.atguigu.interfacetype;public class Father &#123; public void date()&#123;//约会 System.out.println(&quot;爸爸约吃饭&quot;); &#125;&#125; 定义子类： 1234567891011121314package com.atguigu.interfacetype;public class Son extends Father implements Friend &#123; @Override public void date() &#123; //(1)不重写默认保留父类的 //(2)调用父类被重写的// super.date(); //(3)保留父接口的// Friend.super.date(); //(4)完全重写 System.out.println(&quot;跟康师傅学Java&quot;); &#125;&#125; 定义测试类： 12345678package com.atguigu.interfacetype;public class TestSon &#123; public static void main(String[] args) &#123; Son s = new Son(); s.date(); &#125;&#125; （2）接口冲突（左右为难） 当一个类同时实现了多个父接口，而多个父接口中包含方法签名相同的默认方法时，怎么办呢？ 无论你多难抉择，最终都是要做出选择的。 声明接口： 1234567package com.atguigu.interfacetype;public interface BoyFriend &#123; default void date()&#123;//约会 System.out.println(&quot;神秘约会&quot;); &#125;&#125; 选择保留其中一个，通过“接口名.super.方法名“的方法选择保留哪个接口的默认方法。 1234567891011121314package com.atguigu.interfacetype;public class Girl implements Friend,BoyFriend&#123; @Override public void date() &#123; //(1)保留其中一个父接口的// Friend.super.date();// BoyFriend.super.date(); //(2)完全重写 System.out.println(&quot;跟康师傅学Java&quot;); &#125;&#125; 测试类 12345678package com.atguigu.interfacetype;public class TestGirl &#123; public static void main(String[] args) &#123; Girl girl = new Girl(); girl.date(); &#125;&#125; 当一个子接口同时继承了多个接口，而多个父接口中包含方法签名相同的默认方法时，怎么办呢？ 另一个父接口： 1234567891011121314151617181920212223package com.atguigu.interfacetype;public interface USB2 &#123; //静态常量 long MAX_SPEED = 60*1024*1024;//60MB/s //抽象方法 void in(); void out(); //默认方法 public default void start()&#123; System.out.println(&quot;开始&quot;); &#125; public default void stop()&#123; System.out.println(&quot;结束&quot;); &#125; //静态方法 public static void show()&#123; System.out.println(&quot;USB 2.0可以高速地进行读写操作&quot;); &#125;&#125; 子接口： 1234567891011121314package com.atguigu.interfacetype;public interface USB extends USB2,USB3 &#123; @Override default void start() &#123; System.out.println(&quot;Usb.start&quot;); &#125; @Override default void stop() &#123; System.out.println(&quot;Usb.stop&quot;); &#125;&#125; 小贴士： 子接口重写默认方法时，default关键字可以保留。 子类重写默认方法时，default关键字不可以保留。 7.5.2 常量冲突问题 当子类继承父类又实现父接口，而父类中存在与父接口常量同名的成员变量，并且该成员变量名在子类中仍然可见。 当子类同时实现多个接口，而多个接口存在相同同名常量。 此时在子类中想要引用父类或父接口的同名的常量或成员变量时，就会有冲突问题。 父类和父接口： 12345package com.atguigu.interfacetype;public class SuperClass &#123; int x = 1;&#125; 123456package com.atguigu.interfacetype;public interface SuperInterface &#123; int x = 2; int y = 2;&#125; 12345package com.atguigu.interfacetype;public interface MotherInterface &#123; int x = 3;&#125; 子类： 1234567891011package com.atguigu.interfacetype;public class SubClass extends SuperClass implements SuperInterface,MotherInterface &#123; public void method()&#123;// System.out.println(&quot;x = &quot; + x);//模糊不清 System.out.println(&quot;super.x = &quot; + super.x); System.out.println(&quot;SuperInterface.x = &quot; + SuperInterface.x); System.out.println(&quot;MotherInterface.x = &quot; + MotherInterface.x); System.out.println(&quot;y = &quot; + y);//没有重名问题，可以直接访问 &#125;&#125; 7.6 接口的总结与面试题 接口本身不能创建对象，只能创建接口的实现类对象，接口类型的变量可以与实现类对象构成多态引用。 声明接口用interface，接口的成员声明有限制： （1）公共的静态常量 （2）公共的抽象方法 （3）公共的默认方法（JDK8.0 及以上） （4）公共的静态方法（JDK8.0 及以上） （5）私有方法（JDK9.0 及以上） 类可以实现接口，关键字是implements，而且支持多实现。如果实现类不是抽象类，就必须实现接口中所有的抽象方法。如果实现类既要继承父类又要实现父接口，那么继承（extends）在前，实现（implements）在后。 接口可以继承接口，关键字是extends，而且支持多继承。 接口的默认方法可以选择重写或不重写。如果有冲突问题，另行处理。子类重写父接口的默认方法，要去掉default，子接口重写父接口的默认方法，不要去掉default。 接口的静态方法不能被继承，也不能被重写。接口的静态方法只能通过“接口名.静态方法名”进行调用。 面试题 1、为什么接口中只能声明公共的静态的常量？ 因为接口是标准规范，那么在规范中需要声明一些底线边界值，当实现者在实现这些规范时，不能去随意修改和触碰这些底线，否则就有“危险”。 例如：USB1.0规范中规定最大传输速率是1.5Mbps，最大输出电流是5V&#x2F;500mA ​ USB3.0规范中规定最大传输速率是5Gbps(500MB&#x2F;s)，最大输出电流是5V&#x2F;900mA 例如：尚硅谷学生行为规范中规定学员，早上8:25之前进班，晚上21:30之后离开等等。 2、为什么JDK8.0 之后允许接口定义静态方法和默认方法呢？因为它违反了接口作为一个抽象标准定义的概念。 静态方法：因为之前的标准类库设计中，有很多Collection&#x2F;Colletions或者Path&#x2F;Paths这样成对的接口和类，后面的类中都是静态方法，而这些静态方法都是为前面的接口服务的，那么这样设计一对API，不如把静态方法直接定义到接口中使用和维护更方便。 默认方法：（1）我们要在已有的老版接口中提供新方法时，如果添加抽象方法，就会涉及到原来使用这些接口的类就会有问题，那么为了保持与旧版本代码的兼容性，只能允许在接口中定义默认方法实现。比如：Java8中对Collection、List、Comparator等接口提供了丰富的默认方法。（2）当我们接口的某个抽象方法，在很多实现类中的实现代码是一样的，此时将这个抽象方法设计为默认方法更为合适，那么实现类就可以选择重写，也可以选择不重写。 3、为什么JDK1.9要允许接口定义私有方法呢？因为我们说接口是规范，规范是需要公开让大家遵守的。 私有方法：因为有了默认方法和静态方法这样具有具体实现的方法，那么就可能出现多个方法由共同的代码可以抽取，而这些共同的代码抽取出来的方法又只希望在接口内部使用，所以就增加了私有方法。 7.7 接口与抽象类之间的对比 在开发中，常看到一个类不是去继承一个已经实现好的类，而是要么继承抽象类，要么实现接口。 7.8 练习笔试题：排错 123456789101112131415interface A &#123; int x = 0;&#125;class B &#123; int x = 1;&#125;class C extends B implements A &#123; public void pX() &#123; System.out.println(x); &#125; public static void main(String[] args) &#123; new C().pX(); &#125;&#125; 笔试题：排错 123456789101112131415161718192021222324252627282930interface Playable &#123; void play();&#125;interface Bounceable &#123; void play();&#125;interface Rollable extends Playable, Bounceable &#123; Ball ball = new Ball(&quot;PingPang&quot;);&#125;class Ball implements Rollable &#123; private String name; public String getName() &#123; return name; &#125; public Ball(String name) &#123; this.name = name; &#125; public void play() &#123; ball = new Ball(&quot;Football&quot;); System.out.println(ball.getName()); &#125;&#125; 练习1： 定义一个接口用来实现两个对象的比较。 1234interface CompareObject&#123; //若返回值是 0 , 代表相等; 若为正数，代表当前对象大；负数代表当前对象小 public int compareTo(Object o); &#125; 定义一个Circle类，声明redius属性，提供getter和setter方法 定义一个ComparableCircle类，继承Circle类并且实现CompareObject接口。在ComparableCircle类中给出接口中方法compareTo的实现体，用来比较两个圆的半径大小。 定义一个测试类InterfaceTest，创建两个ComparableCircle对象，调用compareTo方法比较两个类的半径大小。 思考：参照上述做法定义矩形类Rectangle和ComparableRectangle类，在ComparableRectangle类中给出compareTo方法的实现，比较两个矩形的面积大小。 练习2：交通工具案例 阿里的一个工程师，声明的属性和方法如下： 其中，有一个乘坐交通工具的方法takingVehicle()，在此方法中调用交通工具的run()。为了出行方便，他买了一辆捷安特自行车、一辆雅迪电动车和一辆奔驰轿车。这里涉及到的相关类及接口关系如下： 其中，电动车增加动力的方式是充电，轿车增加动力的方式是加油。在具体交通工具的run()中调用其所在类的相关属性信息。 请编写相关代码，并测试。 提示：创建Vehicle[]数组，保存阿里工程师的三辆交通工具，并分别在工程师的takingVehicle()中调用。 8. 内部类（InnerClass)8.1 概述8.1.1 什么是内部类将一个类A定义在另一个类B里面，里面的那个类A就称为内部类（InnerClass），类B则称为外部类（OuterClass）。 8.1.2 为什么要声明内部类呢具体来说，当一个事物A的内部，还有一个部分需要一个完整的结构B进行描述，而这个内部的完整的结构B又只为外部事物A提供服务，不在其他地方单独使用，那么整个内部的完整结构B最好使用内部类。 总的来说，遵循高内聚、低耦合的面向对象开发原则。 8.1.3 内部类的分类根据内部类声明的位置（如同变量的分类），我们可以分为： 8.2 成员内部类8.2.1 概述如果成员内部类中不使用外部类的非静态成员，那么通常将内部类声明为静态内部类，否则声明为非静态内部类。 语法格式： 1234[修饰符] class 外部类&#123; [其他修饰符] [static] class 内部类&#123; &#125;&#125; 成员内部类的使用特征，概括来讲有如下两种角色： 成员内部类作为类的成员的角色： 和外部类不同，Inner class还可以声明为private或protected； 可以调用外部类的结构。（注意：在静态内部类中不能使用外部类的非静态成员） Inner class 可以声明为static的，但此时就不能再使用外层类的非static的成员变量； 成员内部类作为类的角色： 可以在内部定义属性、方法、构造器等结构 可以继承自己的想要继承的父类，实现自己想要实现的父接口们，和外部类的父类和父接口无关 可以声明为abstract类 ，因此可以被其它的内部类继承 可以声明为final的，表示不能被继承 编译以后生成OuterClass$InnerClass.class字节码文件（也适用于局部内部类） 注意点： 外部类访问成员内部类的成员，需要“内部类.成员”或“内部类对象.成员”的方式 成员内部类可以直接使用外部类的所有成员，包括私有的数据 当想要在外部类的静态成员部分使用内部类时，可以考虑内部类声明为静态的 8.2.2 创建成员内部类对象 实例化静态内部类 12外部类名.静态内部类名 变量 = 外部类名.静态内部类名();变量.非静态方法(); 实例化非静态内部类 123外部类名 变量1 = new 外部类();外部类名.非静态内部类名 变量2 = 变量1.new 非静态内部类名();变量2.非静态方法(); 8.2.3 举例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364public class TestMemberInnerClass &#123; public static void main(String[] args) &#123; //创建静态内部类实例，并调用方法 Outer.StaticInner inner = new Outer.StaticInner(); inner.inFun(); //调用静态内部类静态方法 Outer.StaticInner.inMethod(); System.out.println(&quot;*****************************&quot;); //创建非静态内部类实例（方式1），并调用方法 Outer outer = new Outer(); Outer.NoStaticInner inner1 = outer.new NoStaticInner(); inner1.inFun(); //创建非静态内部类实例（方式2） Outer.NoStaticInner inner2 = outer.getNoStaticInner(); inner1.inFun(); &#125;&#125;class Outer&#123; private static String a = &quot;外部类的静态a&quot;; private static String b = &quot;外部类的静态b&quot;; private String c = &quot;外部类对象的非静态c&quot;; private String d = &quot;外部类对象的非静态d&quot;; static class StaticInner&#123; private static String a =&quot;静态内部类的静态a&quot;; private String c = &quot;静态内部类对象的非静态c&quot;; public static void inMethod()&#123; System.out.println(&quot;Inner.a = &quot; + a); System.out.println(&quot;Outer.a = &quot; + Outer.a); System.out.println(&quot;b = &quot; + b); &#125; public void inFun()&#123; System.out.println(&quot;Inner.inFun&quot;); System.out.println(&quot;Outer.a = &quot; + Outer.a); System.out.println(&quot;Inner.a = &quot; + a); System.out.println(&quot;b = &quot; + b); System.out.println(&quot;c = &quot; + c);// System.out.println(&quot;d = &quot; + d);//不能访问外部类的非静态成员 &#125; &#125; class NoStaticInner&#123; private String a = &quot;非静态内部类对象的非静态a&quot;; private String c = &quot;非静态内部类对象的非静态c&quot;; public void inFun()&#123; System.out.println(&quot;NoStaticInner.inFun&quot;); System.out.println(&quot;Outer.a = &quot; + Outer.a); System.out.println(&quot;a = &quot; + a); System.out.println(&quot;b = &quot; + b); System.out.println(&quot;Outer.c = &quot; + Outer.this.c); System.out.println(&quot;c = &quot; + c); System.out.println(&quot;d = &quot; + d); &#125; &#125; public NoStaticInner getNoStaticInner()&#123; return new NoStaticInner(); &#125;&#125; 8.3 局部内部类8.3.1 非匿名局部内部类语法格式： 123456[修饰符] class 外部类&#123; [修饰符] 返回值类型 方法名(形参列表)&#123; [final/abstract] class 内部类&#123; &#125; &#125; &#125; 编译后有自己的独立的字节码文件，只不过在内部类名前面冠以外部类名、$符号、编号。 这里有编号是因为同一个外部类中，不同的方法中存在相同名称的局部内部类 和成员内部类不同的是，它前面不能有权限修饰符等 局部内部类如同局部变量一样，有作用域 局部内部类中是否能访问外部类的非静态的成员，取决于所在的方法 举例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061/** * ClassName: TestLocalInner * @Author 尚硅谷-宋红康 * @Create 17:19 * @Version 1.0 */public class TestLocalInner &#123; public static void main(String[] args) &#123; Outer.outMethod(); System.out.println(&quot;-------------------&quot;); Outer out = new Outer(); out.outTest(); System.out.println(&quot;-------------------&quot;); Runner runner = Outer.getRunner(); runner.run(); &#125;&#125;class Outer&#123; public static void outMethod()&#123; System.out.println(&quot;Outer.outMethod&quot;); final String c = &quot;局部变量c&quot;; class Inner&#123; public void inMethod()&#123; System.out.println(&quot;Inner.inMethod&quot;); System.out.println(c); &#125; &#125; Inner in = new Inner(); in.inMethod(); &#125; public void outTest()&#123; class Inner&#123; public void inMethod1()&#123; System.out.println(&quot;Inner.inMethod1&quot;); &#125; &#125; Inner in = new Inner(); in.inMethod1(); &#125; public static Runner getRunner()&#123; class LocalRunner implements Runner&#123; @Override public void run() &#123; System.out.println(&quot;LocalRunner.run&quot;); &#125; &#125; return new LocalRunner(); &#125;&#125;interface Runner&#123; void run();&#125; 8.3.2 匿名内部类因为考虑到这个子类或实现类是一次性的，那么我们“费尽心机”的给它取名字，就显得多余。那么我们完全可以使用匿名内部类的方式来实现，避免给类命名的问题。 123new 父类([实参列表])&#123; 重写方法...&#125; 123new 父接口()&#123; 重写方法...&#125; 举例1：使用匿名内部类的对象直接调用方法： 12345678910111213interface A&#123; void a();&#125;public class Test&#123; public static void main(String[] args)&#123; new A()&#123; @Override public void a() &#123; System.out.println(&quot;aaaa&quot;); &#125; &#125;.a(); &#125;&#125; 举例2：通过父类或父接口的变量多态引用匿名内部类的对象 1234567891011121314interface A&#123; void a();&#125;public class Test&#123; public static void main(String[] args)&#123; A obj = new A()&#123; @Override public void a() &#123; System.out.println(&quot;aaaa&quot;); &#125; &#125;; obj.a(); &#125;&#125; 举例3：匿名内部类的对象作为实参 123456789101112131415161718interface A&#123; void method();&#125;public class Test&#123; public static void test(A a)&#123; a.method(); &#125; public static void main(String[] args)&#123; test(new A()&#123; @Override public void method() &#123; System.out.println(&quot;aaaa&quot;); &#125; &#125;); &#125; &#125; 8.4 练习练习：判断输出结果为何？ 12345678910111213141516171819public class Test &#123; public Test() &#123; Inner s1 = new Inner(); s1.a = 10; Inner s2 = new Inner(); s2.a = 20; Test.Inner s3 = new Test.Inner(); System.out.println(s3.a); &#125; class Inner &#123; public int a = 5; &#125; public static void main(String[] args) &#123; Test t = new Test(); Inner r = t.new Inner(); System.out.println(r.a); &#125;&#125; 练习2： 编写一个匿名内部类，它继承Object，并在匿名内部类中，声明一个方法public void test()打印尚硅谷。 请编写代码调用这个方法。 123456789101112package com.atguigu.test01;public class Test01 &#123; public static void main(String[] args) &#123; new Object()&#123; public void test()&#123; System.out.println(&quot;尚硅谷&quot;); &#125; &#125;.test(); &#125;&#125; 9. 枚举类9.1 概述 枚举类型本质上也是一种类，只不过是这个类的对象是有限的、固定的几个，不能让用户随意创建。 枚举类的例子举不胜举： 星期：Monday(星期一)……Sunday(星期天) 性别：Man(男)、Woman(女) 月份：January(1月)……December(12月) 季节：Spring(春节)……Winter(冬天) 三原色：red(红色)、green(绿色)、blue(蓝色) 支付方式：Cash（现金）、WeChatPay（微信）、Alipay(支付宝)、BankCard(银行卡)、CreditCard(信用卡) 就职状态：Busy(忙碌)、Free(空闲)、Vocation(休假)、Dimission(离职) 订单状态：Nonpayment（未付款）、Paid（已付款）、Fulfilled（已配货）、Delivered（已发货）、Checked（已确认收货）、Return（退货）、Exchange（换货）、Cancel（取消） 线程状态：创建、就绪、运行、阻塞、死亡 若枚举只有一个对象, 则可以作为一种单例模式的实现方式。 枚举类的实现： 在JDK5.0 之前，需要程序员自定义枚举类型。 在JDK5.0 之后，Java支持enum关键字来快速定义枚举类型。 9.2 定义枚举类（JDK5.0 之前）在JDK5.0 之前如何声明枚举类呢？ 私有化类的构造器，保证不能在类的外部创建其对象 在类的内部创建枚举类的实例。声明为：public static final ，对外暴露这些常量对象 对象如果有实例变量，应该声明为private final（建议，不是必须），并在构造器中初始化 示例代码： 12345678910111213141516171819202122232425class Season&#123; private final String SEASONNAME;//季节的名称 private final String SEASONDESC;//季节的描述 private Season(String seasonName,String seasonDesc)&#123; this.SEASONNAME = seasonName; this.SEASONDESC = seasonDesc; &#125; public static final Season SPRING = new Season(&quot;春天&quot;, &quot;春暖花开&quot;); public static final Season SUMMER = new Season(&quot;夏天&quot;, &quot;夏日炎炎&quot;); public static final Season AUTUMN = new Season(&quot;秋天&quot;, &quot;秋高气爽&quot;); public static final Season WINTER = new Season(&quot;冬天&quot;, &quot;白雪皑皑&quot;); @Override public String toString() &#123; return &quot;Season&#123;&quot; + &quot;SEASONNAME=&#x27;&quot; + SEASONNAME + &#x27;\\&#x27;&#x27; + &quot;, SEASONDESC=&#x27;&quot; + SEASONDESC + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125;&#125;class SeasonTest&#123; public static void main(String[] args) &#123; System.out.println(Season.AUTUMN); &#125;&#125; 9.3 定义枚举类（JDK5.0 之后）9.3.1 enum关键字声明枚举123456789【修饰符】 enum 枚举类名&#123; 常量对象列表&#125;【修饰符】 enum 枚举类名&#123; 常量对象列表; 对象的实例变量列表;&#125; 举例1： 12345package com.atguigu.enumeration;public enum Week &#123; MONDAY,TUESDAY,WEDNESDAY,THURSDAY,FRIDAY,SATURDAY,SUNDAY;&#125; 123456public class TestEnum &#123; public static void main(String[] args) &#123; Season spring = Season.SPRING; System.out.println(spring); &#125;&#125; 9.3.2 enum方式定义的要求和特点 枚举类的常量对象列表必须在枚举类的首行，因为是常量，所以建议大写。 列出的实例系统会自动添加 public static final 修饰。 如果常量对象列表后面没有其他代码，那么“；”可以省略，否则不可以省略“；”。 编译器给枚举类默认提供的是private的无参构造，如果枚举类需要的是无参构造，就不需要声明，写常量对象列表时也不用加参数 如果枚举类需要的是有参构造，需要手动定义，有参构造的private可以省略，调用有参构造的方法就是在常量对象名后面加(实参列表)就可以。 枚举类默认继承的是java.lang.Enum类，因此不能再继承其他的类型。 JDK5.0 之后switch，提供支持枚举类型，case后面可以写枚举常量名，无需添加枚举类作为限定。 举例2： 123456789101112131415161718192021public enum SeasonEnum &#123; SPRING(&quot;春天&quot;,&quot;春风又绿江南岸&quot;), SUMMER(&quot;夏天&quot;,&quot;映日荷花别样红&quot;), AUTUMN(&quot;秋天&quot;,&quot;秋水共长天一色&quot;), WINTER(&quot;冬天&quot;,&quot;窗含西岭千秋雪&quot;); private final String seasonName; private final String seasonDesc; private SeasonEnum(String seasonName, String seasonDesc) &#123; this.seasonName = seasonName; this.seasonDesc = seasonDesc; &#125; public String getSeasonName() &#123; return seasonName; &#125; public String getSeasonDesc() &#123; return seasonDesc; &#125;&#125; 举例3： 12345678910111213141516171819202122package com.atguigu.enumeration;public enum Week &#123; MONDAY(&quot;星期一&quot;), TUESDAY(&quot;星期二&quot;), WEDNESDAY(&quot;星期三&quot;), THURSDAY(&quot;星期四&quot;), FRIDAY(&quot;星期五&quot;), SATURDAY(&quot;星期六&quot;), SUNDAY(&quot;星期日&quot;); private final String description; private Week(String description)&#123; this.description = description; &#125; @Override public String toString() &#123; return super.toString() +&quot;:&quot;+ description; &#125;&#125; 12345678910111213141516171819202122232425package com.atguigu.enumeration;public class TestWeek &#123; public static void main(String[] args) &#123; Week week = Week.MONDAY; System.out.println(week); switch (week)&#123; case MONDAY: System.out.println(&quot;怀念周末，困意很浓&quot;);break; case TUESDAY: System.out.println(&quot;进入学习状态&quot;);break; case WEDNESDAY: System.out.println(&quot;死撑&quot;);break; case THURSDAY: System.out.println(&quot;小放松&quot;);break; case FRIDAY: System.out.println(&quot;又信心满满&quot;);break; case SATURDAY: System.out.println(&quot;开始盼周末，无心学习&quot;);break; case SUNDAY: System.out.println(&quot;一觉到下午&quot;);break; &#125; &#125;&#125; 经验之谈： 开发中，当需要定义一组常量时，强烈建议使用枚举类。 9.4 enum中常用方法12345678910String toString(): 默认返回的是常量名（对象名），可以继续手动重写该方法！ static 枚举类型[] values():返回枚举类型的对象数组。该方法可以很方便地遍历所有的枚举值，是一个静态方法 static 枚举类型 valueOf(String name)：可以把一个字符串转为对应的枚举类对象。要求字符串必须是枚举类对象的“名字”。如不是，会有运行时异常：IllegalArgumentException。 String name():得到当前枚举常量的名称。建议优先使用toString()。 int ordinal():返回当前枚举常量的次序号，默认从0开始 举例： 123456789101112131415161718192021222324252627282930package com.atguigu.enumeration;import java.util.Scanner;public class TestEnumMethod &#123; public static void main(String[] args) &#123; //values() Week[] values = Week.values(); for (int i = 0; i &lt; values.length; i++) &#123; //ordinal()、name() System.out.println((values[i].ordinal()+1) + &quot;-&gt;&quot; + values[i].name()); &#125; System.out.println(&quot;------------------------&quot;); Scanner input = new Scanner(System.in); System.out.print(&quot;请输入星期值：&quot;); int weekValue = input.nextInt(); Week week = values[weekValue-1]; //toString() System.out.println(week); System.out.print(&quot;请输入星期名：&quot;); String weekName = input.next(); //valueOf() week = Week.valueOf(weekName); System.out.println(week); input.close(); &#125;&#125; 9.5 实现接口的枚举类 和普通 Java 类一样，枚举类可以实现一个或多个接口 若每个枚举值在调用实现的接口方法呈现相同的行为方式，则只要统一实现该方法即可。 若需要每个枚举值在调用实现的接口方法呈现出不同的行为方式，则可以让每个枚举值分别来实现该方法 语法： 123456789101112131415//1、枚举类可以像普通的类一样，实现接口，并且可以多个，但要求必须实现里面所有的抽象方法！enum A implements 接口1，接口2&#123; //抽象方法的实现&#125;//2、如果枚举类的常量可以继续重写抽象方法!enum A implements 接口1，接口2&#123; 常量名1(参数)&#123; //抽象方法的实现或重写 &#125;, 常量名2(参数)&#123; //抽象方法的实现或重写 &#125;, //...&#125; 举例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546interface Info&#123; void show();&#125;//使用enum关键字定义枚举类enum Season1 implements Info&#123; //1. 创建枚举类中的对象,声明在enum枚举类的首位 SPRING(&quot;春天&quot;,&quot;春暖花开&quot;)&#123; public void show()&#123; System.out.println(&quot;春天在哪里？&quot;); &#125; &#125;, SUMMER(&quot;夏天&quot;,&quot;夏日炎炎&quot;)&#123; public void show()&#123; System.out.println(&quot;宁静的夏天&quot;); &#125; &#125;, AUTUMN(&quot;秋天&quot;,&quot;秋高气爽&quot;)&#123; public void show()&#123; System.out.println(&quot;秋天是用来分手的季节&quot;); &#125; &#125;, WINTER(&quot;冬天&quot;,&quot;白雪皑皑&quot;)&#123; public void show()&#123; System.out.println(&quot;2002年的第一场雪&quot;); &#125; &#125;; //2. 声明每个对象拥有的属性:private final修饰 private final String SEASON_NAME; private final String SEASON_DESC; //3. 私有化类的构造器 private Season1(String seasonName,String seasonDesc)&#123; this.SEASON_NAME = seasonName; this.SEASON_DESC = seasonDesc; &#125; public String getSEASON_NAME() &#123; return SEASON_NAME; &#125; public String getSEASON_DESC() &#123; return SEASON_DESC; &#125;&#125; 10. 注解(Annotation)10.1 注解概述10.1.1 什么是注解注解（Annotation）是从JDK5.0开始引入，以“@注解名”在代码中存在。例如： 1@Override 1@Deprecated 1@SuppressWarnings(value=”unchecked”) Annotation 可以像修饰符一样被使用，可用于修饰包、类、构造器、方法、成员变量、参数、局部变量的声明。还可以添加一些参数值，这些信息被保存在 Annotation 的 “name&#x3D;value” 对中。 注解可以在类编译、运行时进行加载，体现不同的功能。 10.1.2 注解与注释注解也可以看做是一种注释，通过使用 Annotation，程序员可以在不改变原有逻辑的情况下，在源文件中嵌入一些补充信息。但是，注解，不同于单行注释和多行注释。 对于单行注释和多行注释是给程序员看的。 而注解是可以被编译器或其他程序读取的。程序还可以根据注解的不同，做出相应的处理。 10.1.3 注解的重要性在JavaSE中，注解的使用目的比较简单，例如标记过时的功能，忽略警告等。在JavaEE/Android中注解占据了更重要的角色，例如用来配置应用程序的任何切面，代替JavaEE旧版中所遗留的繁冗代码和XML配置等。 未来的开发模式都是基于注解的，JPA是基于注解的，Spring2.5以上都是基于注解的，Hibernate3.x以后也是基于注解的，Struts2有一部分也是基于注解的了。注解是一种趋势，一定程度上可以说：框架 = 注解 + 反射 + 设计模式。 10.2 常见的Annotation作用示例1：生成文档相关的注解 1234567@author 标明开发该类模块的作者，多个作者之间使用,分割@version 标明该类模块的版本@see 参考转向，也就是相关主题@since 从哪个版本开始增加的@param 对方法中某参数的说明，如果没有参数就不能写@return 对方法返回值的说明，如果方法的返回值类型是void就不能写@exception 对方法可能抛出的异常进行说明 ，如果方法没有用throws显式抛出的异常就不能写 123456789101112131415161718192021222324package com.annotation.javadoc;/** * @author 尚硅谷-宋红康 * @version 1.0 * @see Math.java */public class JavadocTest &#123; /** * 程序的主方法，程序的入口 * @param args String[] 命令行参数 */ public static void main(String[] args) &#123; &#125; /** * 求圆面积的方法 * @param radius double 半径值 * @return double 圆的面积 */ public static double getArea(double radius)&#123; return Math.PI * radius * radius; &#125;&#125; 示例2：在编译时进行格式检查(JDK内置的三个基本注解) @Override: 限定重写父类方法，该注解只能用于方法 @Deprecated: 用于表示所修饰的元素(类，方法等)已过时。通常是因为所修饰的结构危险或存在更好的选择 @SuppressWarnings: 抑制编译器警告 12345678910111213141516171819package com.annotation.javadoc; public class AnnotationTest&#123; public static void main(String[] args) &#123; @SuppressWarnings(&quot;unused&quot;) int a = 10; &#125; @Deprecated public void print()&#123; System.out.println(&quot;过时的方法&quot;); &#125; @Override public String toString() &#123; return &quot;重写的toString方法()&quot;; &#125;&#125; 示例3：跟踪代码依赖性，实现替代配置文件功能 Servlet3.0提供了注解(annotation)，使得不再需要在web.xml文件中进行Servlet的部署。 1234567891011@WebServlet(&quot;/login&quot;)public class LoginServlet extends HttpServlet &#123; private static final long serialVersionUID = 1L; protected void doGet(HttpServletRequest request, HttpServletResponse response) &#123; &#125; protected void doPost(HttpServletRequest request, HttpServletResponse response) &#123; doGet(request, response); &#125; &#125; 123456789&lt;servlet&gt; &lt;servlet-name&gt;LoginServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;com.servlet.LoginServlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;LoginServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/login&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; Spring框架中关于“事务”的管理 12345678910@Transactional(propagation=Propagation.REQUIRES_NEW,isolation=Isolation.READ_COMMITTED,readOnly=false,timeout=3)public void buyBook(String username, String isbn) &#123; //1.查询书的单价 int price = bookShopDao.findBookPriceByIsbn(isbn); //2. 更新库存 bookShopDao.updateBookStock(isbn); //3. 更新用户的余额 bookShopDao.updateUserAccount(username, price);&#125; 123456789&lt;!-- 配置事务属性 --&gt;&lt;tx:advice transaction-manager=&quot;dataSourceTransactionManager&quot; id=&quot;txAdvice&quot;&gt; &lt;tx:attributes&gt; &lt;!-- 配置每个方法使用的事务属性 --&gt; &lt;tx:method name=&quot;buyBook&quot; propagation=&quot;REQUIRES_NEW&quot; isolation=&quot;READ_COMMITTED&quot; read-only=&quot;false&quot; timeout=&quot;3&quot; /&gt; &lt;/tx:attributes&gt;&lt;/tx:advice&gt; 10.3 三个最基本的注解10.3.1 @Override 用于检测被标记的方法为有效的重写方法，如果不是，则报编译错误！ 只能标记在方法上。 它会被编译器程序读取。 10.3.2 @Deprecated 用于表示被标记的数据已经过时，不推荐使用。 可以用于修饰 属性、方法、构造、类、包、局部变量、参数。 它会被编译器程序读取。 10.3.3 @SuppressWarnings 抑制编译警告。当我们不希望看到警告信息的时候，可以使用 SuppressWarnings 注解来抑制警告信息 可以用于修饰类、属性、方法、构造、局部变量、参数 它会被编译器程序读取。 可以指定的警告类型有（了解） all，抑制所有警告 unchecked，抑制与未检查的作业相关的警告 unused，抑制与未用的程式码及停用的程式码相关的警告 deprecation，抑制与淘汰的相关警告 nls，抑制与非 nls 字串文字相关的警告 null，抑制与空值分析相关的警告 rawtypes，抑制与使用 raw 类型相关的警告 static-access，抑制与静态存取不正确相关的警告 static-method，抑制与可能宣告为 static 的方法相关的警告 super，抑制与置换方法相关但不含 super 呼叫的警告 … 示例代码： 123456789101112131415161718192021222324252627282930313233343536package com.atguigu.annotation;import java.util.ArrayList;public class TestAnnotation &#123; @SuppressWarnings(&quot;all&quot;) public static void main(String[] args) &#123; int i; ArrayList list = new ArrayList(); list.add(&quot;hello&quot;); list.add(123); list.add(&quot;world&quot;); Father f = new Son(); f.show(); f.methodOl(); &#125;&#125;class Father&#123; @Deprecated void show() &#123; System.out.println(&quot;Father.show&quot;); &#125; void methodOl() &#123; System.out.println(&quot;Father Method&quot;); &#125;&#125;class Son extends Father&#123;/* @Override void method01() &#123; System.out.println(&quot;Son Method&quot;); &#125;*/&#125; 10.4 元注解JDK1.5在java.lang.annotation包定义了4个标准的meta-annotation类型，它们被用来提供对其它 annotation类型作说明。 （1）**@Target：**用于描述注解的使用范围 可以通过枚举类型ElementType的10个常量对象来指定 TYPE，METHOD，CONSTRUCTOR，PACKAGE….. （2）**@Retention：**用于描述注解的生命周期 可以通过枚举类型RetentionPolicy的3个常量对象来指定 SOURCE（源代码）、CLASS（字节码）、RUNTIME（运行时） 唯有RUNTIME阶段才能被反射读取到。 （3）**@Documented**：表明这个注解应该被 javadoc工具记录。 （4）**@Inherited：**允许子类继承父类中的注解 示例代码： 12345678package java.lang;import java.lang.annotation.*;@Target(ElementType.METHOD)@Retention(RetentionPolicy.SOURCE)public @interface Override &#123;&#125; 12345678910package java.lang;import java.lang.annotation.*;import static java.lang.annotation.ElementType.*;@Target(&#123;TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE&#125;)@Retention(RetentionPolicy.SOURCE)public @interface SuppressWarnings &#123; String[] value();&#125; 12345678910package java.lang;import java.lang.annotation.*;import static java.lang.annotation.ElementType.*;@Documented@Retention(RetentionPolicy.RUNTIME)@Target(value=&#123;CONSTRUCTOR, FIELD, LOCAL_VARIABLE, METHOD, PACKAGE, PARAMETER, TYPE&#125;)public @interface Deprecated &#123;&#125; 拓展：元数据 String name &#x3D; “Tom”; 10.5 自定义注解的使用一个完整的注解应该包含三个部分：（1）声明（2）使用（3）读取 10.5.1 声明自定义注解1234【元注解】【修饰符】 @interface 注解名&#123; 【成员列表】&#125; 自定义注解可以通过四个元注解@Retention,@Target，@Inherited,@Documented，分别说明它的声明周期，使用位置，是否被继承，是否被生成到API文档中。 Annotation 的成员在 Annotation 定义中以无参数有返回值的抽象方法的形式来声明，我们又称为配置参数。返回值类型只能是八种基本数据类型、String类型、Class类型、enum类型、Annotation类型、以上所有类型的数组 可以使用 default 关键字为抽象方法指定默认返回值 如果定义的注解含有抽象方法，那么使用时必须指定返回值，除非它有默认值。格式是“方法名 &#x3D; 返回值”，如果只有一个抽象方法需要赋值，且方法名为value，可以省略“value&#x3D;”，所以如果注解只有一个抽象方法成员，建议使用方法名value。 12345678910package com.atguigu.annotation;import java.lang.annotation.*;@Inherited@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)public @interface Table &#123; String value();&#125; 1234567891011package com.atguigu.annotation;import java.lang.annotation.*;@Inherited@Target(ElementType.FIELD)@Retention(RetentionPolicy.RUNTIME)public @interface Column &#123; String columnName(); String columnType();&#125; 10.5.2 使用自定义注解12345678910111213141516171819202122232425262728293031323334package com.atguigu.annotation;@Table(&quot;t_stu&quot;)public class Student &#123; @Column(columnName = &quot;sid&quot;,columnType = &quot;int&quot;) private int id; @Column(columnName = &quot;sname&quot;,columnType = &quot;varchar(20)&quot;) private String name; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; @Override public String toString() &#123; return &quot;Student&#123;&quot; + &quot;id=&quot; + id + &quot;, name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125;&#125; 10.5.3 读取和处理自定义注解自定义注解必须配上注解的信息处理流程才有意义。 我们自己定义的注解，只能使用反射的代码读取。所以自定义注解的声明周期必须是RetentionPolicy.RUNTIME。 具体的使用见《尚硅谷_宋红康_第17章_反射机制.md》。 10.6 JUnit单元测试10.6.1 测试分类黑盒测试：不需要写代码，给输入值，看程序是否能够输出期望的值。 白盒测试：需要写代码的。关注程序具体的执行流程。 10.6.2 JUnit单元测试介绍JUnit 是由 Erich Gamma 和 Kent Beck 编写的一个测试框架（regression testing framework），供Java开发人员编写单元测试之用。 JUnit测试是程序员测试，即所谓白盒测试，因为程序员知道被测试的软件如何（How）完成功能和完成什么样（What）的功能。 要使用JUnit，必须在项目的编译路径中引入JUnit的库，即相关的.class文件组成的jar包。jar就是一个压缩包，压缩包都是开发好的第三方（Oracle公司第一方，我们自己第二方，其他都是第三方）工具类，都是以class文件形式存在的。 10.6.3 引入本地JUnit.jar第1步：在项目中File-Project Structure中操作：添加Libraries库 其中，junit-libs包内容如下： 第2步：选择要在哪些module中应用JUnit库 第3步：检查是否应用成功 注意Scope：选择Compile，否则编译时，无法使用JUnit。 第4步：下次如果有新的模块要使用该libs库，这样操作即可 10.6.4 编写和运行@Test单元测试方法JUnit4版本，要求@Test标记的方法必须满足如下要求： 所在的类必须是public的，非抽象的，包含唯一的无参构造器。 @Test标记的方法本身必须是public，非抽象的，非静态的，void无返回值，()无参数的。 1234567891011121314151617181920package com.atguigu.junit;import org.junit.Test;public class TestJUnit &#123; @Test public void test01()&#123; System.out.println(&quot;TestJUnit.test01&quot;); &#125; @Test public void test02()&#123; System.out.println(&quot;TestJUnit.test02&quot;); &#125; @Test public void test03()&#123; System.out.println(&quot;TestJUnit.test03&quot;); &#125;&#125; 10.6.5 设置执行JUnit用例时支持控制台输入1. 设置数据： 默认情况下，在单元测试方法中使用Scanner时，并不能实现控制台数据的输入。需要做如下设置： 在idea64.exe.vmoptions配置文件中加入下面一行设置，重启idea后生效。 1-Deditable.java.test.console=true 2. 配置文件位置： 添加完成之后，重启IDEA即可。 3. 如果上述位置设置不成功，需要继续修改如下位置 修改位置1：IDEA安装目录的bin目录（例如：D:\\develop_tools\\IDEA\\IntelliJ IDEA 2022.1.2\\bin）下的idea64.exe.vmoptions文件。 修改位置2：C盘的用户目录C:\\Users\\用户名\\AppData\\Roaming\\JetBrains\\IntelliJIdea2022.1 下的idea64.exe.vmoptions&#96;件。 10.6.6 定义test测试方法模板选中自定义的模板组，点击”+”（1.Live Template）来定义模板。 11. 包装类11.1 为什么需要包装类Java提供了两个类型系统，基本数据类型与引用数据类型。使用基本数据类型在于效率，然而当要使用只针对对象设计的API或新特性（例如泛型），怎么办呢？例如： 123456789101112131415//情况1：方法形参Object类的equals(Object obj)//情况2：方法形参ArrayList类的add(Object obj)//没有如下的方法：add(int number)add(double d)add(boolean b)//情况3：泛型Set&lt;T&gt;List&lt;T&gt;Cllection&lt;T&gt;Map&lt;K,V&gt; 11.2 有哪些包装类Java针对八种基本数据类型定义了相应的引用类型：包装类（封装类）。有了类的特点，就可以调用类中的方法，Java才是真正的面向对象。 封装以后的，内存结构对比： 1234public static void main(String[] args)&#123; int num = 520; Integer obj = new Integer(520);&#125; 11.3 自定义包装类12345678910111213141516public class MyInteger &#123; int value; public MyInteger() &#123; &#125; public MyInteger(int value) &#123; this.value = value; &#125; @Override public String toString() &#123; return String.valueOf(value); &#125;&#125; 11.4 包装类与基本数据类型间的转换11.4.1 装箱 装箱：把基本数据类型转为包装类对象 转为包装类的对象，是为了使用专门为对象设计的API和特性 基本数值—-&gt;包装对象 12345Integer obj1 = new Integer(4);//使用构造函数函数Float f = new Float(“4.56”);Long l = new Long(“asdf”); //NumberFormatExceptionInteger obj2 = Integer.valueOf(4);//使用包装类中的valueOf方法 11.4.2 拆箱拆箱：把包装类对象拆为基本数据类型 转为基本数据类型，一般是因为需要运算，Java中的大多数运算符是为基本数据类型设计的。比较、算术等 包装对象—-&gt;基本数值 12Integer obj = new Integer(4);int num1 = obj.intValue(); 自动装箱与拆箱： 由于我们经常要做基本类型与包装类之间的转换，从JDK5.0 开始，基本类型与包装类的装箱、拆箱动作可以自动完成。例如： 123Integer i = 4;//自动装箱。相当于Integer i = Integer.valueOf(4);i = i + 5;//等号右边：将i对象转成基本数值(自动拆箱) i.intValue() + 5;//加法运算完成后，再次装箱，把基本数值转成对象。 注意：只能与自己对应的类型之间才能实现自动装箱与拆箱。 12Integer i = 1;Double d = 1;//错误的，1是int类型 11.5 基本数据类型、包装类与字符串间的转换（1）基本数据类型转为字符串 方式1：调用字符串重载的valueOf()方法 1234int a = 10;//String str = a;//错误的String str = String.valueOf(a); 方式2：更直接的方式 123int a = 10;String str = a + &quot;&quot;; （2）字符串转为基本数据类型 方式1：除了Character类之外，其他所有包装类都具有parseXxx静态方法可以将字符串参数转换为对应的基本类型，例如： public static int parseInt(String s)：将字符串参数转换为对应的int基本类型。 public static long parseLong(String s)：将字符串参数转换为对应的long基本类型。 public static double parseDouble(String s)：将字符串参数转换为对应的double基本类型。 方式2：字符串转为包装类，然后可以自动拆箱为基本数据类型 public static Integer valueOf(String s)：将字符串参数转换为对应的Integer包装类，然后可以自动拆箱为int基本类型 public static Long valueOf(String s)：将字符串参数转换为对应的Long包装类，然后可以自动拆箱为long基本类型 public static Double valueOf(String s)：将字符串参数转换为对应的Double包装类，然后可以自动拆箱为double基本类型 注意:如果字符串参数的内容无法正确转换为对应的基本类型，则会抛出java.lang.NumberFormatException异常。 方式3：通过包装类的构造器实现 12345678910int a = Integer.parseInt(&quot;整数的字符串&quot;);double d = Double.parseDouble(&quot;小数的字符串&quot;);boolean b = Boolean.parseBoolean(&quot;true或false&quot;);int a = Integer.valueOf(&quot;整数的字符串&quot;);double d = Double.valueOf(&quot;小数的字符串&quot;);boolean b = Boolean.valueOf(&quot;true或false&quot;);int i = new Integer(“12”); 其他方式小结： 11.6 包装类的其它API11.6.1 数据类型的最大最小值12345Integer.MAX_VALUE和Integer.MIN_VALUE Long.MAX_VALUE和Long.MIN_VALUE Double.MAX_VALUE和Double.MIN_VALUE 11.6.2 字符转大小写123Character.toUpperCase(&#x27;x&#x27;);Character.toLowerCase(&#x27;X&#x27;); 11.6.3 整数转进制12345Integer.toBinaryString(int i) Integer.toHexString(int i) Integer.toOctalString(int i) 11.6.4 比较的方法123Double.compare(double d1, double d2) Integer.compare(int x, int y) 11.7 包装类对象的特点11.7.1 包装类缓存对象 包装类 缓存对象 Byte -128~127 Short -128~127 Integer -128~127 Long -128~127 Float 没有 Double 没有 Character 0~127 Boolean true和false 123456789101112131415Integer a = 1;Integer b = 1;System.out.println(a == b);//trueInteger i = 128;Integer j = 128;System.out.println(i == j);//falseInteger m = new Integer(1);//新new的在堆中Integer n = 1;//这个用的是缓冲的常量对象，在方法区System.out.println(m == n);//falseInteger x = new Integer(1);//新new的在堆中Integer y = new Integer(1);//另一个新new的在堆中System.out.println(x == y);//false 123Double d1 = 1.0;Double d2 = 1.0;System.out.println(d1==d2);//false 比较地址，没有缓存对象，每一个都是新new的 11.7.2 类型转换问题123Integer i = 1000;double j = 1000;System.out.println(i==j);//true 会先将i自动拆箱为int，然后根据基本数据类型“自动类型转换”规则，转为double比较 123Integer i = 1000;int j = 1000;System.out.println(i==j);//true 会自动拆箱，按照基本数据类型进行比较 123Integer i = 1;Double d = 1.0System.out.println(i==d);//编译报错 11.7.3 包装类对象不可变12345678910111213141516171819202122232425262728public class TestExam &#123; public static void main(String[] args) &#123; int i = 1; Integer j = new Integer(2); Circle c = new Circle(); change(i,j,c); System.out.println(&quot;i = &quot; + i);//1 System.out.println(&quot;j = &quot; + j);//2 System.out.println(&quot;c.radius = &quot; + c.radius);//10.0 &#125; /* * 方法的参数传递机制： * （1）基本数据类型：形参的修改完全不影响实参 * （2）引用数据类型：通过形参修改对象的属性值，会影响实参的属性值 * 这类Integer等包装类对象是“不可变”对象，即一旦修改，就是新对象，和实参就无关了 */ public static void change(int a ,Integer b,Circle c )&#123; a += 10;// b += 10;//等价于 b = new Integer(b+10); c.radius += 10; /*c = new Circle(); c.radius+=10;*/ &#125;&#125;class Circle&#123; double radius;&#125; 11.8 练习笔试题：如下两个题目输出结果相同吗？各是什么。 123Object o1 = true ? new Integer(1) : new Double(2.0);System.out.println(o1);//1.0 1234567Object o2;if (true) o2 = new Integer(1);else o2 = new Double(2.0);System.out.println(o2);//1 面试题： 1234567891011121314public void method1() &#123; Integer i = new Integer(1); Integer j = new Integer(1); System.out.println(i == j); Integer m = 1; Integer n = 1; System.out.println(m == n);// Integer x = 128; Integer y = 128; System.out.println(x == y);//&#125; 练习： 利用Vector代替数组处理：从键盘读入学生成绩（以负数代表输入结束），找出最高分，并输出学生成绩等级。 提示：数组一旦创建，长度就固定不变，所以在创建数组前就需要知道它的长度。而向量类java.util.Vector可以根据需要动态伸缩。 创建Vector对象：Vector v&#x3D;new Vector(); 给向量添加元素：v.addElement(Object obj); &#x2F;&#x2F;obj必须是对象 取出向量中的元素：Object obj&#x3D;v.elementAt(0); 注意第一个元素的下标是0，返回值是Object类型的。 计算向量的长度：v.size(); 若与最高分相差10分内：A等；20分内：B等；30分内：C等；其它：D等","categories":[{"name":"java基础","slug":"java基础","permalink":"http://example.com/categories/java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"java","slug":"java","permalink":"http://example.com/tags/java/"}]},{"title":"第10章_多线程","slug":"Java/尚硅谷_第10章_多线程/尚硅谷_宋红康_第10章_多线程","date":"2022-09-27T00:55:57.000Z","updated":"2023-10-07T11:42:34.117Z","comments":true,"path":"2022/09/27/Java/尚硅谷_第10章_多线程/尚硅谷_宋红康_第10章_多线程/","link":"","permalink":"http://example.com/2022/09/27/Java/%E5%B0%9A%E7%A1%85%E8%B0%B7_%E7%AC%AC10%E7%AB%A0_%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%B0%9A%E7%A1%85%E8%B0%B7_%E5%AE%8B%E7%BA%A2%E5%BA%B7_%E7%AC%AC10%E7%AB%A0_%E5%A4%9A%E7%BA%BF%E7%A8%8B/","excerpt":"","text":"本章专题与脉络 我们之前学习的程序在没有跳转语句的情况下，都是由上至下沿着一条路径依次执行。现在想要设计一个程序，可以同时有多条执行路径同时执行。比如，一边游戏，一边qq聊天，一边听歌，怎么设计？ 要解决上述问题，需要使用多进程或者多线程来解决。 1. 相关概念1.1 程序、进程与线程 程序（program）：为完成特定任务，用某种语言编写的一组指令的集合。即指一段静态的代码，静态对象。 进程（process）：程序的一次执行过程，或是正在内存中运行的应用程序。如：运行中的QQ，运行中的网易音乐播放器。 每个进程都有一个独立的内存空间，系统运行一个程序即是一个进程从创建、运行到消亡的过程。（生命周期） 程序是静态的，进程是动态的 进程作为操作系统调度和分配资源的最小单位（亦是系统运行程序的基本单位），系统在运行时会为每个进程分配不同的内存区域。 现代的操作系统，大都是支持多进程的，支持同时运行多个程序。比如：现在我们上课一边使用编辑器，一边使用录屏软件，同时还开着画图板，dos窗口等软件。 线程（thread）：进程可进一步细化为线程，是程序内部的一条执行路径。一个进程中至少有一个线程。 一个进程同一时间若并行执行多个线程，就是支持多线程的。 线程作为CPU调度和执行的最小单位。 一个进程中的多个线程共享相同的内存单元，它们从同一个堆中分配对象，可以访问相同的变量和对象。这就使得线程间通信更简便、高效。但多个线程操作共享的系统资源可能就会带来安全的隐患。 下图中，红框的蓝色区域为线程独享，黄色区域为线程共享。 注意： 不同的进程之间是不共享内存的。 进程之间的数据交换和通信的成本很高。 1.2 查看进程和线程我们可以在电脑底部任务栏，右键—–&gt;打开任务管理器，可以查看当前任务的进程： 1、每个应用程序的运行都是一个进程 2、一个应用程序的多次运行，就是多个进程 3、一个进程中包含多个线程 1.3 线程调度 分时调度 所有线程轮流使用 CPU 的使用权，并且平均分配每个线程占用 CPU 的时间。 抢占式调度 让优先级高的线程以较大的概率优先使用 CPU。如果线程的优先级相同，那么会随机选择一个(线程随机性)，Java使用的为抢占式调度。 1.4 多线程程序的优点背景：以单核CPU为例，只使用单个线程先后完成多个任务（调用多个方法），肯定比用多个线程来完成用的时间更短，为何仍需多线程呢？ 多线程程序的优点： 提高应用程序的响应。对图形化界面更有意义，可增强用户体验。 提高计算机系统CPU的利用率 改善程序结构。将既长又复杂的进程分为多个线程，独立运行，利于理解和修改 1.5 补充概念1.5.1 单核CPU和多核CPU单核CPU，在一个时间单元内，只能执行一个线程的任务。例如，可以把CPU看成是医院的医生诊室，在一定时间内只能给一个病人诊断治疗。所以单核CPU就是，代码经过前面一系列的前导操作（类似于医院挂号，比如有10个窗口挂号），然后到cpu处执行时发现，就只有一个CPU（对应一个医生），大家排队执行。 这时候想要提升系统性能，只有两个办法，要么提升CPU性能（让医生看病快点），要么多加几个CPU（多整几个医生），即为多核的CPU。 问题：多核的效率是单核的倍数吗？譬如4核A53的cpu，性能是单核A53的4倍吗？理论上是，但是实际不可能，至少有两方面的损耗。 一个是多个核心的其他共用资源限制。譬如，4核CPU对应的内存、cache、寄存器并没有同步扩充4倍。这就好像医院一样，1个医生换4个医生，但是做B超检查的还是一台机器，性能瓶颈就从医生转到B超检查了。 另一个是多核CPU之间的协调管理损耗。譬如多个核心同时运行两个相关的任务，需要考虑任务同步，这也需要消耗额外性能。好比公司工作，一个人的时候至少不用开会浪费时间，自己跟自己商量就行了。两个人就要开会同步工作，协调分配，所以工作效率绝对不可能达到2倍。 1.5.2 并行与并发 并行（parallel）：指两个或多个事件在同一时刻发生（同时发生）。指在同一时刻，有多条指令在多个CPU上同时执行。比如：多个人同时做不同的事。 并发（concurrency）：指两个或多个事件在同一个时间段内发生。即在一段时间内，有多条指令在单个CPU上快速轮换、交替执行，使得在宏观上具有多个进程同时执行的效果。 在操作系统中，启动了多个程序，并发指的是在一段时间内宏观上有多个程序同时运行，这在单核 CPU 系统中，每一时刻只能有一个程序执行，即微观上这些程序是分时的交替运行，只不过是给人的感觉是同时运行，那是因为分时交替运行的时间是非常短的。 而在多核 CPU 系统中，则这些可以并发执行的程序便可以分配到多个CPU上，实现多任务并行执行，即利用每个处理器来处理一个可以并发执行的程序，这样多个程序便可以同时执行。目前电脑市场上说的多核 CPU，便是多核处理器，核越多，并行处理的程序越多，能大大的提高电脑运行的效率。 2.创建和启动线程2.1 概述 Java语言的JVM允许程序运行多个线程，使用java.lang.Thread类代表线程，所有的线程对象都必须是Thread类或其子类的实例。 Thread类的特性 每个线程都是通过某个特定Thread对象的run()方法来完成操作的，因此把run()方法体称为线程执行体。 通过该Thread对象的start()方法来启动这个线程，而非直接调用run() 要想实现多线程，必须在主线程中创建新的线程对象。 2.2 方式1：继承Thread类Java通过继承Thread类来创建并启动多线程的步骤如下： 定义Thread类的子类，并重写该类的run()方法，该run()方法的方法体就代表了线程需要完成的任务 创建Thread子类的实例，即创建了线程对象 调用线程对象的start()方法来启动该线程 代码如下： 123456789101112131415161718package com.atguigu.thread;//自定义线程类public class MyThread extends Thread &#123; //定义指定线程名称的构造方法 public MyThread(String name) &#123; //调用父类的String参数的构造方法，指定线程的名称 super(name); &#125; /** * 重写run方法，完成该线程执行的逻辑 */ @Override public void run() &#123; for (int i = 0; i &lt; 10; i++) &#123; System.out.println(getName()+&quot;：正在执行！&quot;+i); &#125; &#125;&#125; 测试类： 123456789101112131415161718192021package com.atguigu.thread;public class TestMyThread &#123; public static void main(String[] args) &#123; //创建自定义线程对象1 MyThread mt1 = new MyThread(&quot;子线程1&quot;); //开启子线程1 mt1.start(); //创建自定义线程对象2 MyThread mt2 = new MyThread(&quot;子线程2&quot;); //开启子线程2 mt2.start(); //在主方法中执行for循环 for (int i = 0; i &lt; 10; i++) &#123; System.out.println(&quot;main线程！&quot;+i); &#125; &#125;&#125; 注意： 如果自己手动调用run()方法，那么就只是普通方法，没有启动多线程模式。 run()方法由JVM调用，什么时候调用，执行的过程控制都有操作系统的CPU调度决定。 想要启动多线程，必须调用start方法。 一个线程对象只能调用一次start()方法启动，如果重复调用了，则将抛出以上的异常“IllegalThreadStateException”。 2.3 方式2：实现Runnable接口Java有单继承的限制，当我们无法继承Thread类时，那么该如何做呢？在核心类库中提供了Runnable接口，我们可以实现Runnable接口，重写run()方法，然后再通过Thread类的对象代理启动和执行我们的线程体run()方法 步骤如下： 定义Runnable接口的实现类，并重写该接口的run()方法，该run()方法的方法体同样是该线程的线程执行体。 创建Runnable实现类的实例，并以此实例作为Thread的target参数来创建Thread对象，该Thread对象才是真正的线程对象。 调用线程对象的start()方法，启动线程。调用Runnable接口实现类的run方法。 代码如下： 12345678910package com.atguigu.thread;public class MyRunnable implements Runnable &#123; @Override public void run() &#123; for (int i = 0; i &lt; 20; i++) &#123; System.out.println(Thread.currentThread().getName() + &quot; &quot; + i); &#125; &#125;&#125; 测试类： 1234567891011121314package com.atguigu.thread;public class TestMyRunnable &#123; public static void main(String[] args) &#123; //创建自定义类对象 线程任务对象 MyRunnable mr = new MyRunnable(); //创建线程对象 Thread t = new Thread(mr, &quot;长江&quot;); t.start(); for (int i = 0; i &lt; 20; i++) &#123; System.out.println(&quot;黄河 &quot; + i); &#125; &#125;&#125; 通过实现Runnable接口，使得该类有了多线程类的特征。所有的分线程要执行的代码都在run方法里面。 在启动的多线程的时候，需要先通过Thread类的构造方法Thread(Runnable target) 构造出对象，然后调用Thread对象的start()方法来运行多线程代码。 实际上，所有的多线程代码都是通过运行Thread的start()方法来运行的。因此，不管是继承Thread类还是实现Runnable接口来实现多线程，最终还是通过Thread的对象的API来控制线程的，熟悉Thread类的API是进行多线程编程的基础。 说明：Runnable对象仅仅作为Thread对象的target，Runnable实现类里包含的run()方法仅作为线程执行体。而实际的线程对象依然是Thread实例，只是该Thread线程负责执行其target的run()方法。 2.4 变形写法使用匿名内部类对象来实现线程的创建和启动 12345678new Thread(&quot;新的线程！&quot;)&#123; @Override public void run() &#123; for (int i = 0; i &lt; 10; i++) &#123; System.out.println(getName()+&quot;：正在执行！&quot;+i); &#125; &#125;&#125;.start(); 12345678new Thread(new Runnable()&#123; @Override public void run() &#123; for (int i = 0; i &lt; 10; i++) &#123; System.out.println(Thread.currentThread().getName()+&quot;：&quot; + i); &#125; &#125;&#125;).start(); 2.5 对比两种方式联系 Thread类实际上也是实现了Runnable接口的类。即： 1public class Thread extends Object implements Runnable 区别 继承Thread：线程代码存放Thread子类run方法中。 实现Runnable：线程代码存在接口的子类的run方法。 实现Runnable接口比继承Thread类所具有的优势 避免了单继承的局限性 多个线程可以共享同一个接口实现类的对象，非常适合多个相同线程来处理同一份资源。 增加程序的健壮性，实现解耦操作，代码可以被多个线程共享，代码和线程独立。 2.6 练习创建两个分线程，让其中一个线程输出1-100之间的偶数，另一个线程输出1-100之间的奇数。 3. Thread类的常用结构3.1 构造器 public Thread() :分配一个新的线程对象。 public Thread(String name) :分配一个指定名字的新的线程对象。 public Thread(Runnable target) :指定创建线程的目标对象，它实现了Runnable接口中的run方法 public Thread(Runnable target,String name) :分配一个带有指定目标新的线程对象并指定名字。 3.2 常用方法系列1 public void run() :此线程要执行的任务在此处定义代码。 public void start() :导致此线程开始执行; Java虚拟机调用此线程的run方法。 public String getName() :获取当前线程名称。 public void setName(String name)：设置该线程名称。 public static Thread currentThread() :返回对当前正在执行的线程对象的引用。在Thread子类中就是this，通常用于主线程和Runnable实现类 public static void sleep(long millis) :使当前正在执行的线程以指定的毫秒数暂停（暂时停止执行）。 public static void yield()：yield只是让当前线程暂停一下，让系统的线程调度器重新调度一次，希望优先级与当前线程相同或更高的其他线程能够获得执行机会，但是这个不能保证，完全有可能的情况是，当某个线程调用了yield方法暂停之后，线程调度器又将其调度出来重新执行。 3.3 常用方法系列2 public final boolean isAlive()：测试线程是否处于活动状态。如果线程已经启动且尚未终止，则为活动状态。 void join() ：等待该线程终止。 void join(long millis) ：等待该线程终止的时间最长为 millis 毫秒。如果millis时间到，将不再等待。 void join(long millis, int nanos) ：等待该线程终止的时间最长为 millis 毫秒 + nanos 纳秒。 public final void stop()：已过时，不建议使用。强行结束一个线程的执行，直接进入死亡状态。run()即刻停止，可能会导致一些清理性的工作得不到完成，如文件，数据库等的关闭。同时，会立即释放该线程所持有的所有的锁，导致数据得不到同步的处理，出现数据不一致的问题。 void suspend() &#x2F; void resume() : 这两个操作就好比播放器的暂停和恢复。二者必须成对出现，否则非常容易发生死锁。suspend()调用会导致线程暂停，但不会释放任何锁资源，导致其它线程都无法访问被它占用的锁，直到调用resume()。已过时，不建议使用。 3.4 常用方法系列3每个线程都有一定的优先级，同优先级线程组成先进先出队列（先到先服务），使用分时调度策略。优先级高的线程采用抢占式策略，获得较多的执行机会。每个线程默认的优先级都与创建它的父线程具有相同的优先级。 Thread类的三个优先级常量： MAX_PRIORITY（10）：最高优先级 MIN _PRIORITY （1）：最低优先级 NORM_PRIORITY （5）：普通优先级，默认情况下main线程具有普通优先级。 public final int getPriority() ：返回线程优先级 public final void setPriority(int newPriority) ：改变线程的优先级，范围在[1,10]之间。 练习：获取main线程对象的名称和优先级。 声明一个匿名内部类继承Thread类，重写run方法，在run方法中获取线程名称和优先级。设置该线程优先级为最高优先级并启动该线程。 1234567891011public static void main(String[] args) &#123; Thread t = new Thread()&#123; public void run()&#123; System.out.println(getName() + &quot;的优先级：&quot; + getPriority()); &#125; &#125;; t.setPriority(Thread.MAX_PRIORITY); t.start(); System.out.println(Thread.currentThread().getName() +&quot;的优先级：&quot; + Thread.currentThread().getPriority());&#125; 案例： 声明一个匿名内部类继承Thread类，重写run方法，实现打印[1,100]之间的偶数，要求每隔1秒打印1个偶数。 声明一个匿名内部类继承Thread类，重写run方法，实现打印[1,100]之间的奇数， 当打印到5时，让奇数线程暂停一下，再继续。 当打印到5时，让奇数线程停下来，让偶数线程执行完再打印。 123456789101112131415161718192021222324252627282930313233343536373839package com.atguigu.api;public class TestThreadStateChange &#123; public static void main(String[] args) &#123; Thread te = new Thread() &#123; @Override public void run() &#123; for (int i = 2; i &lt;= 100; i += 2) &#123; System.out.println(&quot;偶数线程：&quot; + i); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;; te.start(); Thread to = new Thread() &#123; @Override public void run() &#123; for (int i = 1; i &lt;= 100; i += 2) &#123; System.out.println(&quot;奇数线程：&quot; + i); if (i == 5) &#123;// Thread.yield(); try &#123; te.join(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; &#125;; to.start(); &#125;&#125; 生产实践中的趣事： 3.5 守护线程（了解）有一种线程，它是在后台运行的，它的任务是为其他线程提供服务的，这种线程被称为“守护线程”。JVM的垃圾回收线程就是典型的守护线程。 守护线程有个特点，就是如果所有非守护线程都死亡，那么守护线程自动死亡。形象理解：兔死狗烹，鸟尽弓藏 调用setDaemon(true)方法可将指定线程设置为守护线程。必须在线程启动之前设置，否则会报IllegalThreadStateException异常。 调用isDaemon()可以判断线程是否是守护线程。 123456789101112131415161718192021222324public class TestThread &#123; public static void main(String[] args) &#123; MyDaemon m = new MyDaemon(); m.setDaemon(true); m.start(); for (int i = 1; i &lt;= 100; i++) &#123; System.out.println(&quot;main:&quot; + i); &#125; &#125;&#125;class MyDaemon extends Thread &#123; public void run() &#123; while (true) &#123; System.out.println(&quot;我一直守护者你...&quot;); try &#123; Thread.sleep(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 4. 多线程的生命周期Java语言使用Thread类及其子类的对象来表示线程，在它的一个完整的生命周期中通常要经历如下一些状态： 4.1 JDK1.5之前：5种状态线程的生命周期有五种状态：新建（New）、就绪（Runnable）、运行（Running）、阻塞（Blocked）、死亡（Dead）。CPU需要在多条线程之间切换，于是线程状态会多次在运行、阻塞、就绪之间切换。 1.新建 当一个Thread类或其子类的对象被声明并创建时，新生的线程对象处于新建状态。此时它和其他Java对象一样，仅仅由JVM为其分配了内存，并初始化了实例变量的值。此时的线程对象并没有任何线程的动态特征，程序也不会执行它的线程体run()。 2.就绪 但是当线程对象调用了start()方法之后，就不一样了，线程就从新建状态转为就绪状态。JVM会为其创建方法调用栈和程序计数器，当然，处于这个状态中的线程并没有开始运行，只是表示已具备了运行的条件，随时可以被调度。至于什么时候被调度，取决于JVM里线程调度器的调度。 注意： 程序只能对新建状态的线程调用start()，并且只能调用一次，如果对非新建状态的线程，如已启动的线程或已死亡的线程调用start()都会报错IllegalThreadStateException异常。 3.运行 如果处于就绪状态的线程获得了CPU资源时，开始执行run()方法的线程体代码，则该线程处于运行状态。如果计算机只有一个CPU核心，在任何时刻只有一个线程处于运行状态，如果计算机有多个核心，将会有多个线程并行(Parallel)执行。 当然，美好的时光总是短暂的，而且CPU讲究雨露均沾。对于抢占式策略的系统而言，系统会给每个可执行的线程一个小时间段来处理任务，当该时间用完，系统会剥夺该线程所占用的资源，让其回到就绪状态等待下一次被调度。此时其他线程将获得执行机会，而在选择下一个线程时，系统会适当考虑线程的优先级。 4.阻塞 当在运行过程中的线程遇到如下情况时，会让出 CPU 并临时中止自己的执行，进入阻塞状态： 线程调用了sleep()方法，主动放弃所占用的CPU资源； 线程试图获取一个同步监视器，但该同步监视器正被其他线程持有； 线程执行过程中，同步监视器调用了wait()，让它等待某个通知（notify）； 线程执行过程中，同步监视器调用了wait(time) 线程执行过程中，遇到了其他线程对象的加塞（join）； 线程被调用suspend方法被挂起（已过时，因为容易发生死锁）； 当前正在执行的线程被阻塞后，其他线程就有机会执行了。针对如上情况，当发生如下情况时会解除阻塞，让该线程重新进入就绪状态，等待线程调度器再次调度它： 线程的sleep()时间到； 线程成功获得了同步监视器； 线程等到了通知(notify)； 线程wait的时间到了 加塞的线程结束了； 被挂起的线程又被调用了resume恢复方法（已过时，因为容易发生死锁）； 5.死亡 线程会以以下三种方式之一结束，结束后的线程就处于死亡状态： run()方法执行完成，线程正常结束 线程执行过程中抛出了一个未捕获的异常（Exception）或错误（Error） 直接调用该线程的stop()来结束该线程（已过时） 4.2 JDK1.5及之后：6种状态在java.lang.Thread.State的枚举类中这样定义： 12345678public enum State &#123; NEW, RUNNABLE, BLOCKED, WAITING, TIMED_WAITING, TERMINATED;&#125; NEW（新建）：线程刚被创建，但是并未启动。还没调用start方法。 RUNNABLE（可运行）：这里没有区分就绪和运行状态。因为对于Java对象来说，只能标记为可运行，至于什么时候运行，不是JVM来控制的了，是OS来进行调度的，而且时间非常短暂，因此对于Java对象的状态来说，无法区分。 Teminated（被终止）：表明此线程已经结束生命周期，终止运行。 重点说明，根据Thread.State的定义，阻塞状态分为三种：BLOCKED、WAITING、TIMED_WAITING。 BLOCKED（锁阻塞）：在API中的介绍为：一个正在阻塞、等待一个监视器锁（锁对象）的线程处于这一状态。只有获得锁对象的线程才能有执行机会。 比如，线程A与线程B代码中使用同一锁，如果线程A获取到锁，线程A进入到Runnable状态，那么线程B就进入到Blocked锁阻塞状态。 TIMED_WAITING（计时等待）：在API中的介绍为：一个正在限时等待另一个线程执行一个（唤醒）动作的线程处于这一状态。 当前线程执行过程中遇到Thread类的sleep或join，Object类的wait，LockSupport类的park方法，并且在调用这些方法时，设置了时间，那么当前线程会进入TIMED_WAITING，直到时间到，或被中断。 WAITING（无限等待）：在API中介绍为：一个正在无限期等待另一个线程执行一个特别的（唤醒）动作的线程处于这一状态。 当前线程执行过程中遇到遇到Object类的wait，Thread类的join，LockSupport类的park方法，并且在调用这些方法时，没有指定时间，那么当前线程会进入WAITING状态，直到被唤醒。 通过Object类的wait进入WAITING状态的要有Object的notify&#x2F;notifyAll唤醒； 通过Condition的await进入WAITING状态的要有Condition的signal方法唤醒； 通过LockSupport类的park方法进入WAITING状态的要有LockSupport类的unpark方法唤醒 通过Thread类的join进入WAITING状态，只有调用join方法的线程对象结束才能让当前线程恢复； 说明：当从WAITING或TIMED_WAITING恢复到Runnable状态时，如果发现当前线程没有得到监视器锁，那么会立刻转入BLOCKED状态。 或 我们在翻阅API的时候会发现Timed Waiting（计时等待） 与 Waiting（无限等待） 状态联系还是很紧密的，比如Waiting（无限等待） 状态中wait方法是空参的，而timed waiting（计时等待） 中wait方法是带参的。这种带参的方法，其实是一种倒计时操作，相当于我们生活中的小闹钟，我们设定好时间，到时通知，可是如果提前得到（唤醒）通知，那么设定好时间在通知也就显得多此一举了，那么这种设计方案其实是一举两得。如果没有得到（唤醒）通知，那么线程就处于Timed Waiting状态，直到倒计时完毕自动醒来；如果在倒计时期间得到（唤醒）通知，那么线程从Timed Waiting状态立刻唤醒。 举例： 1234567891011121314151617181920212223242526272829303132333435/** * @author 尚硅谷-宋红康 * @create 22:15 */public class ThreadStateTest &#123; public static void main(String[] args) throws InterruptedException &#123; SubThread t = new SubThread(); System.out.println(t.getName() + &quot; 状态 &quot; + t.getState()); t.start(); while (Thread.State.TERMINATED != t.getState()) &#123; System.out.println(t.getName() + &quot; 状态 &quot; + t.getState()); Thread.sleep(500); &#125; System.out.println(t.getName() + &quot; 状态 &quot; + t.getState()); &#125;&#125;class SubThread extends Thread &#123; @Override public void run() &#123; while (true) &#123; for (int i = 0; i &lt; 10; i++) &#123; System.out.println(&quot;打印：&quot; + i); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; break; &#125; &#125;&#125; 命令行演示： 5. 线程安全问题及解决当我们使用多个线程访问同一资源（可以是同一个变量、同一个文件、同一条记录等）的时候，若多个线程只有读操作，那么不会发生线程安全问题。但是如果多个线程中对资源有读和写的操作，就容易出现线程安全问题。 举例： 类比： 5.1 同一个资源问题和线程安全问题案例： 火车站要卖票，我们模拟火车站的卖票过程。因为疫情期间，本次列车的座位共100个（即，只能出售100张火车票）。我们来模拟车站的售票窗口，实现多个窗口同时售票的过程。注意：不能出现错票、重票。 5.1.1 局部变量不能共享示例代码： 123456789101112131415161718192021222324252627package com.atguigu.unsafe;class Window extends Thread &#123; public void run() &#123; int ticket = 100; while (ticket &gt; 0) &#123; System.out.println(getName() + &quot;卖出一张票，票号:&quot; + ticket); ticket--; &#125; &#125;&#125;public class SaleTicketDemo1 &#123; public static void main(String[] args) &#123; Window w1 = new Window(); Window w2 = new Window(); Window w3 = new Window(); w1.setName(&quot;窗口1&quot;); w2.setName(&quot;窗口2&quot;); w3.setName(&quot;窗口3&quot;); w1.start(); w2.start(); w3.start(); &#125;&#125; 结果：发现卖出300张票。 问题：局部变量是每次调用方法都是独立的，那么每个线程的run()的ticket是独立的，不是共享数据。 5.1.2 不同对象的实例变量不共享123456789101112131415161718192021222324252627282930package com.atguigu.unsafe;class TicketWindow extends Thread &#123; private int ticket = 100; public void run() &#123; while (ticket &gt; 0) &#123; System.out.println(getName() + &quot;卖出一张票，票号:&quot; + ticket); ticket--; &#125; &#125;&#125;public class SaleTicketDemo2 &#123; public static void main(String[] args) &#123; TicketWindow w1 = new TicketWindow(); TicketWindow w2 = new TicketWindow(); TicketWindow w3 = new TicketWindow(); w1.setName(&quot;窗口1&quot;); w2.setName(&quot;窗口2&quot;); w3.setName(&quot;窗口3&quot;); w1.start(); w2.start(); w3.start(); &#125;&#125; 结果：发现卖出300张票。 问题：不同的实例对象的实例变量是独立的。 5.1.3 静态变量是共享的示例代码： 123456789101112131415161718192021222324252627282930313233package com.atguigu.unsafe;class TicketSaleThread extends Thread &#123; private static int ticket = 100; public void run() &#123; while (ticket &gt; 0) &#123; try &#123; Thread.sleep(10);//加入这个，使得问题暴露的更明显 &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(getName() + &quot;卖出一张票，票号:&quot; + ticket); ticket--; &#125; &#125;&#125;public class SaleTicketDemo3 &#123; public static void main(String[] args) &#123; TicketSaleThread t1 = new TicketSaleThread(); TicketSaleThread t2 = new TicketSaleThread(); TicketSaleThread t3 = new TicketSaleThread(); t1.setName(&quot;窗口1&quot;); t2.setName(&quot;窗口2&quot;); t3.setName(&quot;窗口3&quot;); t1.start(); t2.start(); t3.start(); &#125;&#125; 运行结果： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102窗口1卖出一张票，票号:100窗口2卖出一张票，票号:100窗口3卖出一张票，票号:100窗口3卖出一张票，票号:97窗口1卖出一张票，票号:97窗口2卖出一张票，票号:97窗口1卖出一张票，票号:94窗口3卖出一张票，票号:94窗口2卖出一张票，票号:94窗口2卖出一张票，票号:91窗口1卖出一张票，票号:91窗口3卖出一张票，票号:91窗口3卖出一张票，票号:88窗口1卖出一张票，票号:88窗口2卖出一张票，票号:88窗口3卖出一张票，票号:85窗口1卖出一张票，票号:85窗口2卖出一张票，票号:85窗口3卖出一张票，票号:82窗口1卖出一张票，票号:82窗口2卖出一张票，票号:82窗口2卖出一张票，票号:79窗口3卖出一张票，票号:79窗口1卖出一张票，票号:79窗口3卖出一张票，票号:76窗口1卖出一张票，票号:76窗口2卖出一张票，票号:76窗口1卖出一张票，票号:73窗口2卖出一张票，票号:73窗口3卖出一张票，票号:73窗口2卖出一张票，票号:70窗口1卖出一张票，票号:70窗口3卖出一张票，票号:70窗口2卖出一张票，票号:67窗口3卖出一张票，票号:67窗口1卖出一张票，票号:67窗口1卖出一张票，票号:64窗口3卖出一张票，票号:64窗口2卖出一张票，票号:64窗口2卖出一张票，票号:61窗口3卖出一张票，票号:61窗口1卖出一张票，票号:61窗口1卖出一张票，票号:58窗口2卖出一张票，票号:58窗口3卖出一张票，票号:58窗口2卖出一张票，票号:55窗口1卖出一张票，票号:55窗口3卖出一张票，票号:55窗口3卖出一张票，票号:52窗口1卖出一张票，票号:52窗口2卖出一张票，票号:52窗口2卖出一张票，票号:49窗口1卖出一张票，票号:49窗口3卖出一张票，票号:49窗口2卖出一张票，票号:46窗口3卖出一张票，票号:46窗口1卖出一张票，票号:46窗口2卖出一张票，票号:43窗口3卖出一张票，票号:43窗口1卖出一张票，票号:43窗口3卖出一张票，票号:40窗口1卖出一张票，票号:40窗口2卖出一张票，票号:40窗口2卖出一张票，票号:37窗口3卖出一张票，票号:37窗口1卖出一张票，票号:37窗口2卖出一张票，票号:34窗口1卖出一张票，票号:34窗口3卖出一张票，票号:34窗口3卖出一张票，票号:31窗口2卖出一张票，票号:31窗口1卖出一张票，票号:31窗口1卖出一张票，票号:28窗口2卖出一张票，票号:28窗口3卖出一张票，票号:28窗口2卖出一张票，票号:25窗口1卖出一张票，票号:25窗口3卖出一张票，票号:25窗口2卖出一张票，票号:22窗口3卖出一张票，票号:22窗口1卖出一张票，票号:22窗口3卖出一张票，票号:19窗口1卖出一张票，票号:19窗口2卖出一张票，票号:19窗口2卖出一张票，票号:16窗口3卖出一张票，票号:16窗口1卖出一张票，票号:16窗口2卖出一张票，票号:13窗口1卖出一张票，票号:13窗口3卖出一张票，票号:13窗口2卖出一张票，票号:10窗口1卖出一张票，票号:10窗口3卖出一张票，票号:10窗口3卖出一张票，票号:7窗口1卖出一张票，票号:7窗口2卖出一张票，票号:7窗口3卖出一张票，票号:4窗口1卖出一张票，票号:4窗口2卖出一张票，票号:4窗口3卖出一张票，票号:1窗口2卖出一张票，票号:1窗口1卖出一张票，票号:1 结果：发现卖出近100张票。 问题1：但是有重复票或负数票问题。 原因：线程安全问题 问题2：如果要考虑有两场电影，各卖100张票等 原因：TicketThread类的静态变量，是所有TicketThread类的对象共享 5.1.4 同一个对象的实例变量共享示例代码：多个Thread线程使用同一个Runnable对象 12345678910111213141516171819202122232425262728293031package com.atguigu.safe;class TicketSaleRunnable implements Runnable &#123; private int ticket = 100; public void run() &#123; while (ticket &gt; 0) &#123; try &#123; Thread.sleep(10);//加入这个，使得问题暴露的更明显 &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + &quot;卖出一张票，票号:&quot; + ticket); ticket--; &#125; &#125;&#125;public class SaleTicketDemo4 &#123; public static void main(String[] args) &#123; TicketSaleRunnable tr = new TicketSaleRunnable(); Thread t1 = new Thread(tr, &quot;窗口一&quot;); Thread t2 = new Thread(tr, &quot;窗口二&quot;); Thread t3 = new Thread(tr, &quot;窗口三&quot;); t1.start(); t2.start(); t3.start(); &#125;&#125; 结果：发现卖出近100张票。 问题：但是有重复票或负数票问题。 原因：线程安全问题 5.1.5 抽取资源类，共享同一个资源对象示例代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657package com.atguigu.unsafe;//1、编写资源类class Ticket &#123; private int ticket = 100; public void sale() &#123; if (ticket &gt; 0) &#123; try &#123; Thread.sleep(10);//加入这个，使得问题暴露的更明显 &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + &quot;卖出一张票，票号:&quot; + ticket); ticket--; &#125; else &#123; throw new RuntimeException(&quot;没有票了&quot;); &#125; &#125; public int getTicket() &#123; return ticket; &#125;&#125;public class SaleTicketDemo5 &#123; public static void main(String[] args) &#123; //2、创建资源对象 Ticket ticket = new Ticket(); //3、启动多个线程操作资源类的对象 Thread t1 = new Thread(&quot;窗口一&quot;) &#123; public void run() &#123; while (true) &#123; ticket.sale(); &#125; &#125; &#125;; Thread t2 = new Thread(&quot;窗口二&quot;) &#123; public void run() &#123; while (true) &#123; ticket.sale(); &#125; &#125; &#125;; Thread t3 = new Thread(new Runnable() &#123; public void run() &#123; ticket.sale(); &#125; &#125;, &quot;窗口三&quot;); t1.start(); t2.start(); t3.start(); &#125;&#125; 结果：发现卖出近100张票。 问题：但是有重复票或负数票问题。 原因：线程安全问题 5.2 同步机制解决线程安全问题要解决上述多线程并发访问一个资源的安全性问题:也就是解决重复票与不存在票问题，Java中提供了同步机制(synchronized)来解决。 根据案例简述： 窗口1线程进入操作的时候，窗口2和窗口3线程只能在外等着，窗口1操作结束，窗口1和窗口2和窗口3才有机会进入代码去执行。也就是说在某个线程修改共享资源的时候，其他线程不能修改该资源，等待修改完毕同步之后，才能去抢夺CPU资源，完成对应的操作，保证了数据的同步性，解决了线程不安全的现象。 为了保证每个线程都能正常执行原子操作，Java引入了线程同步机制。注意:在任何时候,最多允许一个线程拥有同步锁，谁拿到锁就进入代码块，其他的线程只能在外等着(BLOCKED)。 5.2.1 同步机制解决线程安全问题的原理同步机制的原理，其实就相当于给某段代码加“锁”，任何线程想要执行这段代码，都要先获得“锁”，我们称它为同步锁。因为Java对象在堆中的数据分为分为对象头、实例变量、空白的填充。而对象头中包含： Mark Word：记录了和当前对象有关的GC、锁标记等信息。 指向类的指针：每一个对象需要记录它是由哪个类创建出来的。 数组长度（只有数组对象才有） 哪个线程获得了“同步锁”对象之后，”同步锁“对象就会记录这个线程的ID，这样其他线程就只能等待了，除非这个线程”释放“了锁对象，其他线程才能重新获得&#x2F;占用”同步锁“对象。 5.2.2 同步代码块和同步方法同步代码块：synchronized 关键字可以用于某个区块前面，表示只对这个区块的资源实行互斥访问。格式: 123synchronized(同步锁)&#123; 需要同步操作的代码&#125; 同步方法：synchronized 关键字直接修饰方法，表示同一时刻只有一个线程能进入这个方法，其他线程在外面等着。 123public synchronized void method()&#123; 可能会产生线程安全问题的代码&#125; 5.2.3 同步锁机制在《Thinking in Java》中，是这么说的：对于并发工作，你需要某种方式来防止两个任务访问相同的资源（其实就是共享资源竞争）。 防止这种冲突的方法就是当资源被一个任务使用时，在其上加锁。第一个访问某项资源的任务必须锁定这项资源，使其他任务在其被解锁之前，就无法访问它了，而在其被解锁之时，另一个任务就可以锁定并使用它了。 5.2.4 synchronized的锁是什么同步锁对象可以是任意类型，但是必须保证竞争“同一个共享资源”的多个线程必须使用同一个“同步锁对象”。 对于同步代码块来说，同步锁对象是由程序员手动指定的（很多时候也是指定为this或类名.class），但是对于同步方法来说，同步锁对象只能是默认的： 静态方法：当前类的Class对象（类名.class） 非静态方法：this 5.2.5 同步操作的思考顺序1、如何找问题，即代码是否存在线程安全？（非常重要）（1）明确哪些代码是多线程运行的代码（2）明确多个线程是否有共享数据（3）明确多线程运行代码中是否有多条语句操作共享数据 2、如何解决呢？（非常重要）对多条操作共享数据的语句，只能让一个线程都执行完，在执行过程中，其他线程不可以参与执行。即所有操作共享数据的这些语句都要放在同步范围中 3、切记： 范围太小：不能解决安全问题 范围太大：因为一旦某个线程抢到锁，其他线程就只能等待，所以范围太大，效率会降低，不能合理利用CPU资源。 5.2.6 代码演示示例一：静态方法加锁123456789101112131415161718192021222324252627282930313233package com.atguigu.safe;class TicketSaleThread extends Thread&#123; private static int ticket = 100; public void run()&#123;//直接锁这里，肯定不行，会导致，只有一个窗口卖票 while (ticket &gt; 0) &#123; saleOneTicket(); &#125; &#125; public synchronized static void saleOneTicket()&#123;//锁对象是TicketSaleThread类的Class对象，而一个类的Class对象在内存中肯定只有一个 if(ticket &gt; 0) &#123;//不加条件，相当于条件判断没有进入锁管控，线程安全问题就没有解决 System.out.println(Thread.currentThread().getName() + &quot;卖出一张票，票号:&quot; + ticket); ticket--; &#125; &#125;&#125;public class SaleTicketDemo3 &#123; public static void main(String[] args) &#123; TicketSaleThread t1 = new TicketSaleThread(); TicketSaleThread t2 = new TicketSaleThread(); TicketSaleThread t3 = new TicketSaleThread(); t1.setName(&quot;窗口1&quot;); t2.setName(&quot;窗口2&quot;); t3.setName(&quot;窗口3&quot;); t1.start(); t2.start(); t3.start(); &#125;&#125; 示例二：非静态方法加锁1234567891011121314151617181920212223242526272829303132package com.atguigu.safe;public class SaleTicketDemo4 &#123; public static void main(String[] args) &#123; TicketSaleRunnable tr = new TicketSaleRunnable(); Thread t1 = new Thread(tr, &quot;窗口一&quot;); Thread t2 = new Thread(tr, &quot;窗口二&quot;); Thread t3 = new Thread(tr, &quot;窗口三&quot;); t1.start(); t2.start(); t3.start(); &#125;&#125;class TicketSaleRunnable implements Runnable &#123; private int ticket = 100; public void run() &#123;//直接锁这里，肯定不行，会导致，只有一个窗口卖票 while (ticket &gt; 0) &#123; saleOneTicket(); &#125; &#125; public synchronized void saleOneTicket() &#123;//锁对象是this，这里就是TicketSaleRunnable对象，因为上面3个线程使用同一个TicketSaleRunnable对象，所以可以 if (ticket &gt; 0) &#123;//不加条件，相当于条件判断没有进入锁管控，线程安全问题就没有解决 System.out.println(Thread.currentThread().getName() + &quot;卖出一张票，票号:&quot; + ticket); ticket--; &#125; &#125;&#125; 示例三：同步代码块123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263package com.atguigu.safe;public class SaleTicketDemo5 &#123; public static void main(String[] args) &#123; //2、创建资源对象 Ticket ticket = new Ticket(); //3、启动多个线程操作资源类的对象 Thread t1 = new Thread(&quot;窗口一&quot;) &#123; public void run() &#123;//不能给run()直接加锁，因为t1,t2,t3的三个run方法分别属于三个Thread类对象， // run方法是非静态方法，那么锁对象默认选this，那么锁对象根本不是同一个 while (true) &#123; synchronized (ticket) &#123; ticket.sale(); &#125; &#125; &#125; &#125;; Thread t2 = new Thread(&quot;窗口二&quot;) &#123; public void run() &#123; while (true) &#123; synchronized (ticket) &#123; ticket.sale(); &#125; &#125; &#125; &#125;; Thread t3 = new Thread(new Runnable() &#123; public void run() &#123; while (true) &#123; synchronized (ticket) &#123; ticket.sale(); &#125; &#125; &#125; &#125;, &quot;窗口三&quot;); t1.start(); t2.start(); t3.start(); &#125;&#125;//1、编写资源类class Ticket &#123; private int ticket = 1000; public void sale() &#123;//也可以直接给这个方法加锁，锁对象是this，这里就是Ticket对象 if (ticket &gt; 0) &#123; System.out.println(Thread.currentThread().getName() + &quot;卖出一张票，票号:&quot; + ticket); ticket--; &#125; else &#123; throw new RuntimeException(&quot;没有票了&quot;); &#125; &#125; public int getTicket() &#123; return ticket; &#125;&#125; 5.3 练习银行有一个账户。有两个储户分别向同一个账户存3000元，每次存1000，存3次。每次存完打印账户余额。 问题：该程序是否有安全问题，如果有，如何解决？ 【提示】1，明确哪些代码是多线程运行代码，须写入run()方法2，明确什么是共享数据。3，明确多线程运行代码中哪些语句是操作共享数据的。 【拓展问题】可否实现两个储户交替存钱的操作 6. 再谈同步6.1 单例设计模式的线程安全问题6.1.1 饿汉式没有线程安全问题饿汉式：在类初始化时就直接创建单例对象，而类初始化过程是没有线程安全问题的 形式一： 1234567891011package com.atguigu.single.hungry;public class HungrySingle &#123; private static HungrySingle INSTANCE = new HungrySingle(); //对象是否声明为final 都可以 private HungrySingle()&#123;&#125; public static HungrySingle getInstance()&#123; return INSTANCE; &#125;&#125; 形式二： 123456789/*public class HungryOne&#123; public static final HungryOne INSTANCE = new HungryOne(); private HungryOne()&#123;&#125;&#125;*/public enum HungryOne&#123; INSTANCE&#125; 测试类： 1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.atguigu.single.hungry;public class HungrySingleTest &#123; static HungrySingle hs1 = null; static HungrySingle hs2 = null; //演示存在的线程安全问题 public static void main(String[] args) &#123; Thread t1 = new Thread() &#123; @Override public void run() &#123; hs1 = HungrySingle.getInstance(); &#125; &#125;; Thread t2 = new Thread() &#123; @Override public void run() &#123; hs2 = HungrySingle.getInstance(); &#125; &#125;; t1.start(); t2.start(); try &#123; t1.join(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; try &#123; t2.join(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(hs1); System.out.println(hs2); System.out.println(hs1 == hs2);//true &#125;&#125; 6.1.2 懒汉式线程安全问题懒汉式：延迟创建对象，第一次调用getInstance方法再创建对象 形式一： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package com.atguigu.single.lazy;public class LazyOne &#123; private static LazyOne instance; private LazyOne()&#123;&#125; //方式1： public static synchronized LazyOne getInstance1()&#123; if(instance == null)&#123; instance = new LazyOne(); &#125; return instance; &#125; //方式2： public static LazyOne getInstance2()&#123; synchronized(LazyOne.class) &#123; if (instance == null) &#123; instance = new LazyOne(); &#125; return instance; &#125; &#125; //方式3： public static LazyOne getInstance3()&#123; if(instance == null)&#123; synchronized (LazyOne.class) &#123; try &#123; Thread.sleep(10);//加这个代码，暴露问题 &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; if(instance == null)&#123; instance = new LazyOne(); &#125; &#125; &#125; return instance; &#125; /* 注意：上述方式3中，有指令重排问题 mem = allocate(); 为单例对象分配内存空间 instance = mem; instance引用现在非空，但还未初始化 ctorSingleton(instance); 为单例对象通过instance调用构造器 从JDK2开始，分配空间、初始化、调用构造器会在线程的工作存储区一次性完成，然后复制到主存储区。但是需要 volatile关键字，避免指令重排。 */ &#125; 形式二：使用内部类 1234567891011121314package com.atguigu.single.lazy;public class LazySingle &#123; private LazySingle()&#123;&#125; public static LazySingle getInstance()&#123; return Inner.INSTANCE; &#125; private static class Inner&#123; static final LazySingle INSTANCE = new LazySingle(); &#125; &#125; 内部类只有在外部类被调用才加载，产生INSTANCE实例；又不用加锁。 此模式具有之前两个模式的优点，同时屏蔽了它们的缺点，是最好的单例模式。 此时的内部类，使用enum进行定义，也是可以的。 测试类： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778package com.atguigu.single.lazy;import org.junit.Test;public class TestLazy &#123; @Test public void test01()&#123; LazyOne s1 = LazyOne.getInstance(); LazyOne s2 = LazyOne.getInstance(); System.out.println(s1); System.out.println(s2); System.out.println(s1 == s2); &#125; //把s1和s2声明在外面，是想要在线程的匿名内部类中为s1和s2赋值 LazyOne s1; LazyOne s2; @Test public void test02()&#123; Thread t1 = new Thread()&#123; public void run()&#123; s1 = LazyOne.getInstance(); &#125; &#125;; Thread t2 = new Thread()&#123; public void run()&#123; s2 = LazyOne.getInstance(); &#125; &#125;; t1.start(); t2.start(); try &#123; t1.join(); t2.join(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(s1); System.out.println(s2); System.out.println(s1 == s2); &#125; LazySingle obj1; LazySingle obj2; @Test public void test03()&#123; Thread t1 = new Thread()&#123; public void run()&#123; obj1 = LazySingle.getInstance(); &#125; &#125;; Thread t2 = new Thread()&#123; public void run()&#123; obj2 = LazySingle.getInstance(); &#125; &#125;; t1.start(); t2.start(); try &#123; t1.join(); t2.join(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(obj1); System.out.println(obj2); System.out.println(obj1 == obj2); &#125;&#125; 6.2 死锁不同的线程分别占用对方需要的同步资源不放弃，都在等待对方放弃自己需要的同步资源，就形成了线程的死锁。 【小故事】 面试官：你能解释清楚什么是死锁，我就录取你！面试者：你录取我，我就告诉你什么是死锁！….恭喜你，面试通过了 一旦出现死锁，整个程序既不会发生异常，也不会给出任何提示，只是所有线程处于阻塞状态，无法继续。 举例1： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public class DeadLockTest &#123; public static void main(String[] args) &#123; StringBuilder s1 = new StringBuilder(); StringBuilder s2 = new StringBuilder(); new Thread() &#123; public void run() &#123; synchronized (s1) &#123; s1.append(&quot;a&quot;); s2.append(&quot;1&quot;); try &#123; Thread.sleep(10); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; synchronized (s2) &#123; s1.append(&quot;b&quot;); s2.append(&quot;2&quot;); System.out.println(s1); System.out.println(s2); &#125; &#125; &#125; &#125;.start(); new Thread() &#123; public void run() &#123; synchronized (s2) &#123; s1.append(&quot;c&quot;); s2.append(&quot;3&quot;); try &#123; Thread.sleep(10); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; synchronized (s1) &#123; s1.append(&quot;d&quot;); s2.append(&quot;4&quot;); System.out.println(s1); System.out.println(s2); &#125; &#125; &#125; &#125;.start(); &#125;&#125; 举例2： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263class A &#123; public synchronized void foo(B b) &#123; System.out.println(&quot;当前线程名: &quot; + Thread.currentThread().getName() + &quot; 进入了A实例的foo方法&quot;); // ① try &#123; Thread.sleep(200); &#125; catch (InterruptedException ex) &#123; ex.printStackTrace(); &#125; System.out.println(&quot;当前线程名: &quot; + Thread.currentThread().getName() + &quot; 企图调用B实例的last方法&quot;); // ③ b.last(); &#125; public synchronized void last() &#123; System.out.println(&quot;进入了A类的last方法内部&quot;); &#125;&#125;class B &#123; public synchronized void bar(A a) &#123; System.out.println(&quot;当前线程名: &quot; + Thread.currentThread().getName() + &quot; 进入了B实例的bar方法&quot;); // ② try &#123; Thread.sleep(200); &#125; catch (InterruptedException ex) &#123; ex.printStackTrace(); &#125; System.out.println(&quot;当前线程名: &quot; + Thread.currentThread().getName() + &quot; 企图调用A实例的last方法&quot;); // ④ a.last(); &#125; public synchronized void last() &#123; System.out.println(&quot;进入了B类的last方法内部&quot;); &#125;&#125;public class DeadLock implements Runnable &#123; A a = new A(); B b = new B(); public void init() &#123; Thread.currentThread().setName(&quot;主线程&quot;); // 调用a对象的foo方法 a.foo(b); System.out.println(&quot;进入了主线程之后&quot;); &#125; public void run() &#123; Thread.currentThread().setName(&quot;副线程&quot;); // 调用b对象的bar方法 b.bar(a); System.out.println(&quot;进入了副线程之后&quot;); &#125; public static void main(String[] args) &#123; DeadLock dl = new DeadLock(); new Thread(dl).start(); dl.init(); &#125;&#125; 举例3： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class TestDeadLock &#123; public static void main(String[] args) &#123; Object g = new Object(); Object m = new Object(); Owner s = new Owner(g,m); Customer c = new Customer(g,m); new Thread(s).start(); new Thread(c).start(); &#125;&#125;class Owner implements Runnable&#123; private Object goods; private Object money; public Owner(Object goods, Object money) &#123; super(); this.goods = goods; this.money = money; &#125; @Override public void run() &#123; synchronized (goods) &#123; System.out.println(&quot;先给钱&quot;); synchronized (money) &#123; System.out.println(&quot;发货&quot;); &#125; &#125; &#125;&#125;class Customer implements Runnable&#123; private Object goods; private Object money; public Customer(Object goods, Object money) &#123; super(); this.goods = goods; this.money = money; &#125; @Override public void run() &#123; synchronized (money) &#123; System.out.println(&quot;先发货&quot;); synchronized (goods) &#123; System.out.println(&quot;再给钱&quot;); &#125; &#125; &#125;&#125; 诱发死锁的原因： 互斥条件 占用且等待 不可抢夺（或不可抢占） 循环等待 以上4个条件，同时出现就会触发死锁。 解决死锁： 死锁一旦出现，基本很难人为干预，只能尽量规避。可以考虑打破上面的诱发条件。 针对条件1：互斥条件基本上无法被破坏。因为线程需要通过互斥解决安全问题。 针对条件2：可以考虑一次性申请所有所需的资源，这样就不存在等待的问题。 针对条件3：占用部分资源的线程在进一步申请其他资源时，如果申请不到，就主动释放掉已经占用的资源。 针对条件4：可以将资源改为线性顺序。申请资源时，先申请序号较小的，这样避免循环等待问题。 6.3 JDK5.0新特性：Lock(锁) JDK5.0的新增功能，保证线程的安全。与采用synchronized相比，Lock可提供多种锁方案，更灵活、更强大。Lock通过显式定义同步锁对象来实现同步。同步锁使用Lock对象充当。 java.util.concurrent.locks.Lock接口是控制多个线程对共享资源进行访问的工具。锁提供了对共享资源的独占访问，每次只能有一个线程对Lock对象加锁，线程开始访问共享资源之前应先获得Lock对象。 在实现线程安全的控制中，比较常用的是ReentrantLock，可以显式加锁、释放锁。 ReentrantLock类实现了 Lock 接口，它拥有与 synchronized 相同的并发性和内存语义，但是添加了类似锁投票、定时锁等候和可中断锁等候的一些特性。此外，它还提供了在激烈争用情况下更佳的性能。 Lock锁也称同步锁，加锁与释放锁方法，如下： public void lock() :加同步锁。 public void unlock() :释放同步锁。 代码结构 12345678910111213141516class A&#123; //1. 创建Lock的实例，必须确保多个线程共享同一个Lock实例 private final ReentrantLock lock = new ReenTrantLock(); public void m()&#123; //2. 调动lock()，实现需共享的代码的锁定 lock.lock(); try&#123; //保证线程安全的代码; &#125; finally&#123; //3. 调用unlock()，释放共享代码的锁定 lock.unlock(); &#125; &#125;&#125; 注意：如果同步代码有异常，要将unlock()写入finally语句块。 举例： 12345678910111213141516171819202122232425262728293031323334353637383940import java.util.concurrent.locks.ReentrantLock;class Window implements Runnable&#123; int ticket = 100; //1. 创建Lock的实例，必须确保多个线程共享同一个Lock实例 private final ReentrantLock lock = new ReentrantLock(); public void run()&#123; while(true)&#123; try&#123; //2. 调动lock()，实现需共享的代码的锁定 lock.lock(); if(ticket &gt; 0)&#123; try &#123; Thread.sleep(10); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(ticket--); &#125;else&#123; break; &#125; &#125;finally&#123; //3. 调用unlock()，释放共享代码的锁定 lock.unlock(); &#125; &#125; &#125;&#125;public class ThreadLock &#123; public static void main(String[] args) &#123; Window t = new Window(); Thread t1 = new Thread(t); Thread t2 = new Thread(t); t1.start(); t2.start(); &#125;&#125; synchronized与Lock的对比 Lock是显式锁（手动开启和关闭锁，别忘记关闭锁），synchronized是隐式锁，出了作用域、遇到异常等自动解锁 Lock只有代码块锁，synchronized有代码块锁和方法锁 使用Lock锁，JVM将花费较少的时间来调度线程，性能更好。并且具有更好的扩展性（提供更多的子类），更体现面向对象。 （了解）Lock锁可以对读不加锁，对写加锁，synchronized不可以 （了解）Lock锁可以有多种获取锁的方式，可以从sleep的线程中抢到锁，synchronized不可以 说明：开发建议中处理线程安全问题优先使用顺序为： • Lock —-&gt; 同步代码块 —-&gt; 同步方法 7. 线程的通信7.1 线程间通信为什么要处理线程间通信： 当我们需要多个线程来共同完成一件任务，并且我们希望他们有规律的执行，那么多线程之间需要一些通信机制，可以协调它们的工作，以此实现多线程共同操作一份数据。 比如：线程A用来生产包子的，线程B用来吃包子的，包子可以理解为同一资源，线程A与线程B处理的动作，一个是生产，一个是消费，此时B线程必须等到A线程完成后才能执行，那么线程A与线程B之间就需要线程通信，即—— 等待唤醒机制。 7.2 等待唤醒机制这是多个线程间的一种协作机制。谈到线程我们经常想到的是线程间的竞争（race），比如去争夺锁，但这并不是故事的全部，线程间也会有协作机制。 在一个线程满足某个条件时，就进入等待状态（wait() / wait(time)）， 等待其他线程执行完他们的指定代码过后再将其唤醒（notify()）;或可以指定wait的时间，等时间到了自动唤醒；在有多个线程进行等待时，如果需要，可以使用 notifyAll()来唤醒所有的等待线程。wait&#x2F;notify 就是线程间的一种协作机制。 wait：线程不再活动，不再参与调度，进入 wait set 中，因此不会浪费 CPU 资源，也不会去竞争锁了，这时的线程状态是 WAITING 或 TIMED_WAITING。它还要等着别的线程执行一个特别的动作，也即“通知（notify）”或者等待时间到，在这个对象上等待的线程从wait set 中释放出来，重新进入到调度队列（ready queue）中 notify：则选取所通知对象的 wait set 中的一个线程释放； notifyAll：则释放所通知对象的 wait set 上的全部线程。 注意： 被通知的线程被唤醒后也不一定能立即恢复执行，因为它当初中断的地方是在同步块内，而此刻它已经不持有锁，所以它需要再次尝试去获取锁（很可能面临其它线程的竞争），成功后才能在当初调用 wait 方法之后的地方恢复执行。 总结如下： 如果能获取锁，线程就从 WAITING 状态变成 RUNNABLE（可运行） 状态； 否则，线程就从 WAITING 状态又变成 BLOCKED（等待锁） 状态 7.3 举例例题：使用两个线程打印 1-100。线程1, 线程2 交替打印 12345678910111213141516171819class Communication implements Runnable &#123; int i = 1; public void run() &#123; while (true) &#123; synchronized (this) &#123; notify(); if (i &lt;= 100) &#123; System.out.println(Thread.currentThread().getName() + &quot;:&quot; + i++); &#125; else break; try &#123; wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125; 7.4 调用wait和notify需注意的细节 wait方法与notify方法必须要由同一个锁对象调用。因为：对应的锁对象可以通过notify唤醒使用同一个锁对象调用的wait方法后的线程。 wait方法与notify方法是属于Object类的方法的。因为：锁对象可以是任意对象，而任意对象的所属类都是继承了Object类的。 wait方法与notify方法必须要在同步代码块或者是同步函数中使用。因为：必须要通过锁对象调用这2个方法。否则会报java.lang.IllegalMonitorStateException异常。 7.5 生产者与消费者问题等待唤醒机制可以解决经典的“生产者与消费者”的问题。生产者与消费者问题（英语：Producer-consumer problem），也称有限缓冲问题（英语：Bounded-buffer problem），是一个多线程同步问题的经典案例。该问题描述了两个（多个）共享固定大小缓冲区的线程——即所谓的“生产者”和“消费者”——在实际运行时会发生的问题。 生产者的主要作用是生成一定量的数据放到缓冲区中，然后重复此过程。与此同时，消费者也在缓冲区消耗这些数据。该问题的关键就是要保证生产者不会在缓冲区满时加入数据，消费者也不会在缓冲区中空时消耗数据。 举例： 生产者(Productor)将产品交给店员(Clerk)，而消费者(Customer)从店员处取走产品，店员一次只能持有固定数量的产品(比如:20），如果生产者试图生产更多的产品，店员会叫生产者停一下，如果店中有空位放产品了再通知生产者继续生产；如果店中没有产品了，店员会告诉消费者等一下，如果店中有产品了再通知消费者来取走产品。 类似的场景，比如厨师和服务员等。 生产者与消费者问题中其实隐含了两个问题： 线程安全问题：因为生产者与消费者共享数据缓冲区，产生安全问题。不过这个问题可以使用同步解决。 线程的协调工作问题： 要解决该问题，就必须让生产者线程在缓冲区满时等待(wait)，暂停进入阻塞状态，等到下次消费者消耗了缓冲区中的数据的时候，通知(notify)正在等待的线程恢复到就绪状态，重新开始往缓冲区添加数据。同样，也可以让消费者线程在缓冲区空时进入等待(wait)，暂停进入阻塞状态，等到生产者往缓冲区添加数据之后，再通知(notify)正在等待的线程恢复到就绪状态。通过这样的通信机制来解决此类问题。 代码实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112public class ConsumerProducerTest &#123; public static void main(String[] args) &#123; Clerk clerk = new Clerk(); Producer p1 = new Producer(clerk); Consumer c1 = new Consumer(clerk); Consumer c2 = new Consumer(clerk); p1.setName(&quot;生产者1&quot;); c1.setName(&quot;消费者1&quot;); c2.setName(&quot;消费者2&quot;); p1.start(); c1.start(); c2.start(); &#125;&#125;//生产者class Producer extends Thread&#123; private Clerk clerk; public Producer(Clerk clerk)&#123; this.clerk = clerk; &#125; @Override public void run() &#123; System.out.println(&quot;=========生产者开始生产产品========&quot;); while(true)&#123; try &#123; Thread.sleep(40); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; //要求clerk去增加产品 clerk.addProduct(); &#125; &#125;&#125;//消费者class Consumer extends Thread&#123; private Clerk clerk; public Consumer(Clerk clerk)&#123; this.clerk = clerk; &#125; @Override public void run() &#123; System.out.println(&quot;=========消费者开始消费产品========&quot;); while(true)&#123; try &#123; Thread.sleep(90); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; //要求clerk去减少产品 clerk.minusProduct(); &#125; &#125;&#125;//资源类class Clerk &#123; private int productNum = 0;//产品数量 private static final int MAX_PRODUCT = 20; private static final int MIN_PRODUCT = 1; //增加产品 public synchronized void addProduct() &#123; if(productNum &lt; MAX_PRODUCT)&#123; productNum++; System.out.println(Thread.currentThread().getName() + &quot;生产了第&quot; + productNum + &quot;个产品&quot;); //唤醒消费者 this.notifyAll(); &#125;else&#123; try &#123; this.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; //减少产品 public synchronized void minusProduct() &#123; if(productNum &gt;= MIN_PRODUCT)&#123; System.out.println(Thread.currentThread().getName() + &quot;消费了第&quot; + productNum + &quot;个产品&quot;); productNum--; //唤醒生产者 this.notifyAll(); &#125;else&#123; try &#123; this.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; 7.6 面试题：区分sleep()和wait()相同点：一旦执行，都会使得当前线程结束执行状态，进入阻塞状态。 不同点： ① 定义方法所属的类：sleep():Thread中定义。 wait():Object中定义 ② 使用范围的不同：sleep()可以在任何需要使用的位置被调用； wait():必须使用在同步代码块或同步方法中 ③ 都在同步结构中使用的时候，是否释放同步监视器的操作不同：sleep():不会释放同步监视器 ;wait():会释放同步监视器 ④ 结束等待的方式不同：sleep()：指定时间一到就结束阻塞。 wait():可以指定时间也可以无限等待直到notify或notifyAll。 7.7 是否释放锁的操作任何线程进入同步代码块、同步方法之前，必须先获得对同步监视器的锁定，那么何时会释放对同步监视器的锁定呢？ 7.7.1 释放锁的操作当前线程的同步方法、同步代码块执行结束。 当前线程在同步代码块、同步方法中遇到break、return终止了该代码块、该方法的继续执行。 当前线程在同步代码块、同步方法中出现了未处理的Error或Exception，导致当前线程异常结束。 当前线程在同步代码块、同步方法中执行了锁对象的wait()方法，当前线程被挂起，并释放锁。 7.7.2 不会释放锁的操作线程执行同步代码块或同步方法时，程序调用Thread.sleep()、Thread.yield()方法暂停当前线程的执行。 线程执行同步代码块时，其他线程调用了该线程的suspend()方法将该该线程挂起，该线程不会释放锁（同步监视器）。 应尽量避免使用suspend()和resume()这样的过时来控制线程。 8. JDK5.0新增线程创建方式8.1 新增方式一：实现Callable接口 与使用Runnable相比， Callable功能更强大些 相比run()方法，可以有返回值 方法可以抛出异常 支持泛型的返回值（需要借助FutureTask类，获取返回结果） Future接口（了解） 可以对具体Runnable、Callable任务的执行结果进行取消、查询是否完成、获取结果等。 FutureTask是Futrue接口的唯一的实现类 FutureTask 同时实现了Runnable, Future接口。它既可以作为Runnable被线程执行，又可以作为Future得到Callable的返回值 缺点：在获取分线程执行结果的时候，当前线程（或是主线程）受阻塞，效率较低。 代码举例 123456789101112131415161718192021222324252627282930313233343536373839404142434445/* * 创建多线程的方式三：实现Callable （jdk5.0新增的） *///1.创建一个实现Callable的实现类class NumThread implements Callable &#123; //2.实现call方法，将此线程需要执行的操作声明在call()中 @Override public Object call() throws Exception &#123; int sum = 0; for (int i = 1; i &lt;= 100; i++) &#123; if (i % 2 == 0) &#123; System.out.println(i); sum += i; &#125; &#125; return sum; &#125;&#125;public class CallableTest &#123; public static void main(String[] args) &#123; //3.创建Callable接口实现类的对象 NumThread numThread = new NumThread(); //4.将此Callable接口实现类的对象作为传递到FutureTask构造器中，创建FutureTask的对象 FutureTask futureTask = new FutureTask(numThread); //5.将FutureTask的对象作为参数传递到Thread类的构造器中，创建Thread对象，并调用start() new Thread(futureTask).start();// 接收返回值 try &#123; //6.获取Callable中call方法的返回值 //get()返回值即为FutureTask构造器参数Callable实现类重写的call()的返回值。 Object sum = futureTask.get(); System.out.println(&quot;总和为：&quot; + sum); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; catch (ExecutionException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 8.2 新增方式二：使用线程池现有问题： 如果并发的线程数量很多，并且每个线程都是执行一个时间很短的任务就结束了，这样频繁创建线程就会大大降低系统的效率，因为频繁创建线程和销毁线程需要时间。 那么有没有一种办法使得线程可以复用，即执行完一个任务，并不被销毁，而是可以继续执行其他的任务？ 思路：提前创建好多个线程，放入线程池中，使用时直接获取，使用完放回池中。可以避免频繁创建销毁、实现重复利用。类似生活中的公共交通工具。 好处： 提高响应速度（减少了创建新线程的时间） 降低资源消耗（重复利用线程池中线程，不需要每次都创建） 便于线程管理 corePoolSize：核心池的大小 maximumPoolSize：最大线程数 keepAliveTime：线程没有任务时最多保持多长时间后会终止 … 线程池相关API JDK5.0之前，我们必须手动自定义线程池。从JDK5.0开始，Java内置线程池相关的API。在java.util.concurrent包下提供了线程池相关API：ExecutorService 和 Executors。 ExecutorService：真正的线程池接口。常见子类ThreadPoolExecutor void execute(Runnable command) ：执行任务&#x2F;命令，没有返回值，一般用来执行Runnable &lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task)：执行任务，有返回值，一般又来执行Callable void shutdown() ：关闭连接池 Executors：一个线程池的工厂类，通过此类的静态工厂方法可以创建多种类型的线程池对象。 Executors.newCachedThreadPool()：创建一个可根据需要创建新线程的线程池 Executors.newFixedThreadPool(int nThreads); 创建一个可重用固定线程数的线程池 Executors.newSingleThreadExecutor() ：创建一个只有一个线程的线程池 Executors.newScheduledThreadPool(int corePoolSize)：创建一个线程池，它可安排在给定延迟后运行命令或者定期地执行。 代码举例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263class NumberThread implements Runnable&#123; @Override public void run() &#123; for(int i = 0;i &lt;= 100;i++)&#123; if(i % 2 == 0)&#123; System.out.println(Thread.currentThread().getName() + &quot;: &quot; + i); &#125; &#125; &#125;&#125;class NumberThread1 implements Runnable&#123; @Override public void run() &#123; for(int i = 0;i &lt;= 100;i++)&#123; if(i % 2 != 0)&#123; System.out.println(Thread.currentThread().getName() + &quot;: &quot; + i); &#125; &#125; &#125;&#125;class NumberThread2 implements Callable &#123; @Override public Object call() throws Exception &#123; int evenSum = 0;//记录偶数的和 for(int i = 0;i &lt;= 100;i++)&#123; if(i % 2 == 0)&#123; evenSum += i; &#125; &#125; return evenSum; &#125;&#125;public class ThreadPoolTest &#123; public static void main(String[] args) &#123; //1. 提供指定线程数量的线程池 ExecutorService service = Executors.newFixedThreadPool(10); ThreadPoolExecutor service1 = (ThreadPoolExecutor) service;// //设置线程池的属性// System.out.println(service.getClass());//ThreadPoolExecutor service1.setMaximumPoolSize(50); //设置线程池中线程数的上限 //2.执行指定的线程的操作。需要提供实现Runnable接口或Callable接口实现类的对象 service.execute(new NumberThread());//适合适用于Runnable service.execute(new NumberThread1());//适合适用于Runnable try &#123; Future future = service.submit(new NumberThread2());//适合使用于Callable System.out.println(&quot;总和为：&quot; + future.get()); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; //3.关闭连接池 service.shutdown(); &#125;&#125;","categories":[{"name":"java基础","slug":"java基础","permalink":"http://example.com/categories/java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"java","slug":"java","permalink":"http://example.com/tags/java/"}]},{"title":"第06章_面向对象编程（基础）","slug":"Java/尚硅谷_第06章_面向对象编程（基础）/尚硅谷_宋红康_第06章_面向对象编程（基础）","date":"2022-09-27T00:55:56.000Z","updated":"2023-10-07T11:37:36.519Z","comments":true,"path":"2022/09/27/Java/尚硅谷_第06章_面向对象编程（基础）/尚硅谷_宋红康_第06章_面向对象编程（基础）/","link":"","permalink":"http://example.com/2022/09/27/Java/%E5%B0%9A%E7%A1%85%E8%B0%B7_%E7%AC%AC06%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E5%9F%BA%E7%A1%80%EF%BC%89/%E5%B0%9A%E7%A1%85%E8%B0%B7_%E5%AE%8B%E7%BA%A2%E5%BA%B7_%E7%AC%AC06%E7%AB%A0_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E5%9F%BA%E7%A1%80%EF%BC%89/","excerpt":"","text":"本章专题与脉络 学习面向对象内容的三条主线 Java类及类的成员：（重点）属性、方法、构造器；（熟悉）代码块、内部类 面向对象的特征：封装、继承、多态、（抽象） 其他关键字的使用：this、super、package、import、static、final、interface、abstract等 1. 面向对象编程概述(了解)1.1 程序设计的思路面向对象，是软件开发中的一类编程风格、开发范式。除了面向对象，还有面向过程、指令式编程和函数式编程。在所有的编程范式中，我们接触最多的还是面向过程和面向对象两种。 类比：史书类型 纪传体：以人物传记为中心，“本纪”叙述帝王，“世家”记叙王侯封国和特殊人物，“列传”记叙民间人物。 编年体：按年、月、日顺序编写。 国别体：是一部分国记事的历史散文，分载多国历史。 早期先有面向过程思想，随着软件规模的扩大，问题复杂性的提高，面向过程的弊端越来越明显，出现了面向对象思想并成为目前主流的方式。 1. 面向过程的程序设计思想（Process-Oriented Programming），简称POP 关注的焦点是过程：过程就是操作数据的步骤。如果某个过程的实现代码重复出现，那么就可以把这个过程抽取为一个函数。这样就可以大大简化冗余代码，便于维护。 典型的语言：C语言 代码结构：以函数为组织单位。 是一种“执行者思维”，适合解决简单问题。扩展能力差、后期维护难度较大。 2. 面向对象的程序设计思想（ Object Oriented Programming），简称OOP 关注的焦点是类：在计算机程序设计过程中，参照现实中事物，将事物的属性特征、行为特征抽象出来，用类来表示。 典型的语言：Java、C#、C++、Python、Ruby和PHP等 代码结构：以类为组织单位。每种事物都具备自己的属性和行为/功能。 是一种“设计者思维”，适合解决复杂问题。代码扩展性强、可维护性高。 1.2 由实际问题考虑如何设计程序思考1：如何开车？ 面向过程思想思考问题时，我们首先思考“怎么按步骤实现？”并将步骤对应成方法，一步一步，最终完成。 这个适合简单任务，不需要过多协作的情况。针对如何开车，可以列出步骤： 面向过程适合简单、不需要协作的事务，重点关注如何执行。 思考2：如何造车？ 造车太复杂，需要很多协作才能完成。此时我们思考的是“车怎么设计？”，而不是“怎么按特定步骤造车的问题”。这就是思维方式的转变，前者就是面向对象思想。所以，面向对象(Oriented-Object)思想更契合人的思维模式。 用面向对象思想思考“如何设计车”： 自然地，我们就会从“车由什么组成”开始思考。发现，车由如下结构组成： 我们找轮胎厂完成制造轮胎的步骤，发动机厂完成制造发动机的步骤，…；这样，大家可以同时进行车的制造，最终进行组装，大大提高了效率。但是，具体到轮胎厂的一个流水线操作，仍然是有步骤的，还是离不开面向过程思维！ 因此，面向对象可以帮助我们从宏观上把握、从整体上分析整个系统。 但是，具体到实现部分的微观操作（就是一个个方法），仍然需要面向过程的思路去处理。 注意： 我们千万不要把面向过程和面向对象对立起来。他们是相辅相成的。面向对象离不开面向过程！ 类比举例1： 当需求单一，或者简单时，我们一步步去操作没问题，并且效率也挺高。 可随着需求的更改，功能的增多，发现需要面对每一个步骤很麻烦了，这时就开始思索，能不能把这些步骤和功能进行封装，封装时根据不同的功能，进行不同的封装，功能类似的封装在一起。这样结构就清晰了很多。用的时候，找到对应的类就可以了。这就是面向对象的思想。 类比举例2：人把大象装进冰箱 面向过程 1234561.打开冰箱2.把大象装进冰箱3.把冰箱门关住 面向对象 123456789101112131415161718192021人&#123; 打开（冰箱）&#123; 冰箱.开门(); &#125; 操作(大象)&#123; 大象.进入(冰箱); &#125; 关闭(冰箱)&#123; 冰箱.关门(); &#125;&#125;冰箱&#123; 开门()&#123; &#125; 关门()&#123; &#125;&#125;大象&#123; 进入(冰箱)&#123; &#125;&#125; 练习：抽象出下面系统中的“类”及其关系 1.3 如何掌握这种思想？ 2. Java语言的基本元素：类和对象2.1 引入人认识世界，其实就是面向对象的。比如，我们认识一下美人鱼（都没见过） 经过“仔细学习”，发现美人鱼通常具备一些特征： 女孩 有鱼尾 美丽 这个总结的过程，其实是抽象化的过程。抽象出来的美人鱼的特征，可以归纳为一个美人鱼类。而图片中的都是这个类呈现出来的具体的对象。 2.2 类和对象概述类(Class)和对象(Object)是面向对象的核心概念。 1、什么是类 类：具有相同特征的事物的抽象描述，是抽象的、概念上的定义。 2、什么是对象 对象：实际存在的该类事物的每个个体，是具体的，因而也称为实例(instance)。 可以理解为：类 =&gt; 抽象概念的人；对象 =&gt; 实实在在的某个人 3、类与对象的关系错误理解 1234曰：“白马非马，可乎？”曰：“可。”曰：“何哉？”曰：“马者，所以命形也。白者，所以命色也。命色者，非命形也，故曰白马非马。” 2.3 类的成员概述 面向对象程序设计的重点是类的设计 类的设计，其实就是类的成员的设计 现实世界的生物体，大到鲸鱼，小到蚂蚁，都是由最基本的细胞构成的。同理，Java代码世界是由诸多个不同功能的类构成的。 现实生物世界中的细胞又是由什么构成的呢？细胞核、细胞质、… Java中用类class来描述事物也是如此。类，是一组相关属性和行为的集合，这也是类最基本的两个成员。 属性：该类事物的状态信息。对应类中的成员变量 成员变量 &lt;&#x3D;&gt; 属性 &lt;&#x3D;&gt; Field 行为：该类事物要做什么操作，或者基于事物的状态能做什么。对应类中的成员方法 (成员)方法 &lt;&#x3D;&gt; 函数 &lt;&#x3D;&gt; Method 举例： 2.4 面向对象完成功能的三步骤（重要）步骤1：类的定义类的定义使用关键字：class。格式如下： 1234[修饰符] class 类名&#123; 属性声明; 方法声明;&#125; 举例1： 12345678910public class Person&#123; //声明属性age int age ; //声明方法showAge() public void eat() &#123; System.out.println(&quot;人吃饭&quot;); &#125;&#125; 举例2： 1234567891011public class Dog&#123; //声明属性 String type; //种类 String nickName; //昵称 String hostName; //主人名称 //声明方法 public void eat()&#123; //吃东西 System.out.println(&quot;狗狗进食&quot;); &#125;&#125; 12345678910public class Person&#123; String name; char gender; Dog dog; //喂宠物 public void feed()&#123; dog.eat(); &#125;&#125; 步骤2：对象的创建 创建对象，使用关键字：new 创建对象语法： 1234567//方式1：给创建的对象命名//把创建的对象用一个引用数据类型的变量保存起来，这样就可以反复使用这个对象了类名 对象名 = new 类名();//方式2：new 类名()//也称为匿名对象 举例： 12345678class PersonTest&#123; public static void main(String[] args)&#123; //创建Person类的对象 Person per = new Person(); //创建Dog类的对象 Dog dog = new Dog(); &#125;&#125; 步骤3：对象调用属性或方法 对象是类的一个实例，必然具备该类事物的属性和行为（即方法）。 使用”对象名.属性“ 或 “对象名.方法“的方式访问对象成员（包括属性和方法） 举例1： 123456789101112//声明Animal类public class Animal &#123; //动物类 public int legs; public void eat() &#123; System.out.println(&quot;Eating.&quot;); &#125; public void move() &#123; System.out.println(&quot;Move.&quot;); &#125;&#125; 1234567891011//声明测试类public class AnimalTest &#123; public static void main(String args[]) &#123; //创建对象 Animal xb = new Animal(); xb.legs = 4;//访问属性 System.out.println(xb.legs); xb.eat();//访问方法 xb.move();//访问方法 &#125;&#125; 图示理解： 举例2：针对前面步骤1的举例2：类的实例化（创建类的对象） 12345678910111213141516public class Game&#123; public static void main(String[] args)&#123; Person p = new Person(); //通过Person对象调用属性 p.name = &quot;康师傅&quot;; p.gender = &#x27;男&#x27;; p.dog = new Dog(); //给Person对象的dog属性赋值 //给Person对象的dog属性的type、nickname属性赋值 p.dog.type = &quot;柯基犬&quot;; p.dog.nickName = &quot;小白&quot;; //通过Person对象调用方法 p.feed(); &#125;&#125; 2.5 匿名对象 (anonymous object) 我们也可以不定义对象的句柄，而直接调用这个对象的方法。这样的对象叫做匿名对象。 如：new Person().shout(); 使用情况 如果一个对象只需要进行一次方法调用，那么就可以使用匿名对象。 我们经常将匿名对象作为实参传递给一个方法调用。 3. 对象的内存解析3.1 JVM内存结构划分HotSpot Java虚拟机的架构图如下。其中我们主要关心的是运行时数据区部分（Runtime Data Area）。 其中： 堆（Heap）：此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。这一点在Java虚拟机规范中的描述是：所有的对象实例以及数组都要在堆上分配。 栈（Stack）：是指虚拟机栈。虚拟机栈用于存储局部变量等。局部变量表存放了编译期可知长度的各种基本数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference类型，它不等同于对象本身，是对象在堆内存的首地址）。 方法执行完，自动释放。 方法区（Method Area）：用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。 3.2 对象内存解析举例： 1234567891011121314151617181920class Person &#123; //类：人 String name; int age; boolean isMale;&#125;public class PersonTest &#123; //测试类 public static void main(String[] args) &#123; Person p1 = new Person(); p1.name = &quot;赵同学&quot;; p1.age = 20; p1.isMale = true; Person p2 = new Person(); p2.age = 10; Person p3 = p1; p3.name = &quot;郭同学&quot;; &#125;&#125; 内存解析图： 说明： 堆：凡是new出来的结构(对象、数组)都放在堆空间中。 对象的属性存放在堆空间中。 创建一个类的多个对象（比如p1、p2），则每个对象都拥有当前类的一套”副本”（即属性）。当通过一个对象修改其属性时，不会影响其它对象此属性的值。 当声明一个新的变量使用现有的对象进行赋值时（比如p3 &#x3D; p1），此时并没有在堆空间中创建新的对象。而是两个变量共同指向了堆空间中同一个对象。当通过一个对象修改属性时，会影响另外一个对象对此属性的调用。 面试题：对象名中存储的是什么呢？ 答：对象地址 1234567891011public class StudentTest&#123; public static void main(String[] args)&#123; System.out.println(new Student());//Student@7852e922 Student stu = new Student(); System.out.println(stu);//Student@4e25154f int[] arr = new int[5]; System.out.println(arr);//[I@70dea4e &#125;&#125; 直接打印对象名和数组名都是显示“类型@对象的hashCode值”，所以说类、数组都是引用数据类型，引用数据类型的变量中存储的是对象的地址，或者说指向堆中对象的首地址。 3.3 练习根据代码，画出内存图 123456789101112131415161718class Car &#123; String color = &quot;red&quot;; int num = 4; void show() &#123; System.out.println(&quot;color=&quot; + color + &quot;,num=&quot; + num); &#125;&#125;class CarTest &#123; public static void main(String[] args) &#123; Car c1 = new Car(); //建立对象c1 Car c2 = new Car(); //建立对象c2 c1.color = &quot;blue&quot;; //对对象的属性进行修改 c1.show(); //使用对象的方法 c2.show(); &#125;&#125; 4. 类的成员之一：成员变量(field)4.1 如何声明成员变量 语法格式： 123[修饰符1] class 类名&#123; [修饰符2] 数据类型 成员变量名 [= 初始化值]; &#125; 说明： 位置要求：必须在类中，方法外 修饰符2(暂不考虑) 常用的权限修饰符有：private、缺省、protected、public 其他修饰符：static、final 数据类型 任何基本数据类型(如int、Boolean) 或 任何引用数据类型。 成员变量名 属于标识符，符合命名规则和规范即可。 初始化值 根据情况，可以显式赋值；也可以不赋值，使用默认值 示例： 12345public class Person&#123; private int age; //声明private变量 age public String name = “Lila”; //声明public变量 name&#125; 4.2 成员变量 vs 局部变量1、变量的分类：成员变量与局部变量 在方法体外，类体内声明的变量称为成员变量。 在方法体内部等位置声明的变量称为局部变量。 其中，static可以将成员变量分为两大类，静态变量和非静态变量。其中静态变量又称为类变量，非静态变量又称为实例变量或者属性。接下来先学习实例变量。 2、成员变量 与 局部变量 的对比 相同点 变量声明的格式相同： 数据类型 变量名 &#x3D; 初始化值 变量必须先声明、后初始化、再使用。 变量都有其对应的作用域。只在其作用域内是有效的 不同点 1、声明位置和方式（1）实例变量：在类中方法外（2）局部变量：在方法体{}中或方法的形参列表、代码块中 2、在内存中存储的位置不同（1）实例变量：堆（2）局部变量：栈 3、生命周期（1）实例变量：和对象的生命周期一样，随着对象的创建而存在，随着对象被GC回收而消亡， 而且每一个对象的实例变量是独立的。（2）局部变量：和方法调用的生命周期一样，每一次方法被调用而在存在，随着方法执行的结束而消亡， 而且每一次方法调用都是独立。 4、作用域（1）实例变量：通过对象就可以使用，本类中直接调用，其他类中“对象.实例变量”（2）局部变量：出了作用域就不能使用 5、修饰符（后面来讲）（1）实例变量：public,protected,private,final,volatile,transient等（2）局部变量：final 6、默认值（1）实例变量：有默认值（2）局部变量：没有，必须手动初始化。其中的形参比较特殊，靠实参给它初始化。 3、对象属性的默认初始化赋值 当一个对象被创建时，会对其中各种类型的成员变量自动进行初始化赋值。 4、举例 1234567891011121314151617181920class Person &#123;//人类 //1.属性 String name;//姓名 int age = 1;//年龄 boolean isMale;//是否是男性 public void show(String nation) &#123; //nation:局部变量 String color;//color:局部变量 color = &quot;yellow&quot;; &#125;&#125;//测试类class PersonTest &#123; public static void main(String[] args) &#123; Person p = new Person(); p.show(&quot;CHN&quot;); &#125;&#125; 5. 类的成员之二：方法(method)5.1 方法的引入 《街霸》游戏中，每次人物出拳、出脚或跳跃等动作都需要编写50-80行的代码，在每次出拳、出脚或跳跃的地方都需要重复地编写这50-80行代码，这样程序会变得很臃肿，可读性也非常差。为了解决代码重复编写的问题，可以将出拳、出脚或跳跃的代码提取出来放在一个{}中，并为这段代码起个名字，这样在每次的出拳、出脚或跳跃的地方通过这个名字来调用这个{}的代码就可以了。 上述过程中，所提取出来的代码可以被看作是程序中定义的一个方法，程序在需要出拳、出脚或跳跃时调用该方法即可。 5.2 方法(method、函数)的理解 方法是类或对象行为特征的抽象，用来完成某个功能操作。在某些语言中也称为函数或过程。 将功能封装为方法的目的是，可以实现代码重用，减少冗余，简化代码 Java里的方法不能独立存在，所有的方法必须定义在类里。 举例1： Math.random()的random()方法 Math.sqrt(x)的sqrt(x)方法 System.out.println(x)的println(x)方法 new Scanner(System.in).nextInt()的nextInt()方法 Arrays类中的binarySearch()方法、sort()方法、equals()方法 举例2： 12345678910public class Person&#123; private int age; public int getAge() &#123; //声明方法getAge() return age; &#125; public void setAge(int i) &#123; //声明方法setAge age = i; //将参数i的值赋给类的成员变量age &#125;&#125; 5.3 如何声明方法1、声明方法的语法格式 123[修饰符] 返回值类型 方法名([形参列表])[throws 异常列表]&#123; 方法体的功能代码&#125; （1）一个完整的方法 &#x3D; 方法头 + 方法体。 方法头就是[修饰符] 返回值类型 方法名([形参列表])[throws 异常列表]，也称为方法签名。通常调用方法时只需要关注方法头就可以，从方法头可以看出这个方法的功能和调用格式。 方法体就是方法被调用后要执行的代码。对于调用者来说，不了解方法体如何实现的，并不影响方法的使用。 （2）方法头可能包含5个部分 修饰符：可选的。方法的修饰符也有很多，例如：public、protected、private、static、abstract、native、final、synchronized等，后面会一一学习。 其中，权限修饰符有public、protected、private。在讲封装性之前，我们先默认使用pulbic修饰方法。 其中，根据是否有static，可以将方法分为静态方法和非静态方法。其中静态方法又称为类方法，非静态方法又称为实例方法。咱们在讲static前先学习实例方法。 返回值类型： 表示方法运行的结果的数据类型，方法执行后将结果返回到调用者。 无返回值，则声明：void 有返回值，则声明出返回值类型（可以是任意类型）。与方法体中“return 返回值”搭配使用 方法名：属于标识符，命名时遵循标识符命名规则和规范，“见名知意” 形参列表：表示完成方法体功能时需要外部提供的数据列表。可以包含零个，一个或多个参数。 无论是否有参数，()不能省略 如果有参数，每一个参数都要指定数据类型和参数名，多个参数之间使用逗号分隔，例如： 一个参数： (数据类型 参数名) 二个参数： (数据类型1 参数1, 数据类型2 参数2) 参数的类型可以是基本数据类型、引用数据类型 throws 异常列表：可选，在【第09章-异常处理】章节再讲 （3）方法体：方法体必须有{}括起来，在{}中编写完成方法功能的代码 （4）关于方法体中return语句的说明： return语句的作用是结束方法的执行，并将方法的结果返回去 如果返回值类型不是void，方法体中必须保证一定有 return 返回值; 语句，并且要求该返回值结果的类型与声明的返回值类型一致或兼容。 如果返回值类型为void时，方法体中可以没有return语句，如果要用return语句提前结束方法的执行，那么return后面不能跟返回值，直接写return ; 就可以。 return语句后面就不能再写其他代码了，否则会报错：Unreachable code 补充：方法的分类：按照是否有形参及返回值 2、类比举例 3、代码示例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package com.atguigu.test04.method;/** * 方法定义案例演示 */public class MethodDefineDemo &#123; /** * 无参无返回值方法的演示 */ public void sayHello()&#123; System.out.println(&quot;hello&quot;); &#125; /** * 有参无返回值方法的演示 * @param length int 第一个参数，表示矩形的长 * @param width int 第二个参数，表示矩形的宽 * @param sign char 第三个参数，表示填充矩形图形的符号 */ public void printRectangle(int length, int width, char sign)&#123; for (int i = 1; i &lt;= length ; i++) &#123; for(int j=1; j &lt;= width; j++)&#123; System.out.print(sign); &#125; System.out.println(); &#125; &#125; /** * 无参有返回值方法的演示 * @return */ public int getIntBetweenOneToHundred()&#123; return (int)(Math.random()*100+1); &#125; /** * 有参有返回值方法的演示 * @param a int 第一个参数，要比较大小的整数之一 * @param b int 第二个参数，要比较大小的整数之二 * @return int 比较大小的两个整数中较大者的值 */ public int max(int a, int b)&#123; return a &gt; b ? a : b; &#125;&#125; 5.4 如何调用实例方法方法通过方法名被调用，且只有被调用才会执行。 1、方法调用语法格式 1对象.方法名([实参列表]) 2、示例 举例1： 12345678910111213141516171819202122232425262728293031323334353637383940414243package com.atguigu.test04.method;/** * 方法调用案例演示 */public class MethodInvokeDemo &#123; public static void main(String[] args) &#123; //创建对象 MethodDefineDemo md = new MethodDefineDemo(); System.out.println(&quot;-----------------------方法调用演示-------------------------&quot;); //调用MethodDefineDemo类中无参无返回值的方法sayHello md.sayHello(); md.sayHello(); md.sayHello(); //调用一次，执行一次，不调用不执行 System.out.println(&quot;------------------------------------------------&quot;); //调用MethodDefineDemo类中有参无返回值的方法printRectangle md.printRectangle(5,10,&#x27;@&#x27;); System.out.println(&quot;------------------------------------------------&quot;); //调用MethodDefineDemo类中无参有返回值的方法getIntBetweenOneToHundred md.getIntBetweenOneToHundred();//语法没问题，就是结果丢失 int num = md.getIntBetweenOneToHundred(); System.out.println(&quot;num = &quot; + num); System.out.println(md.getIntBetweenOneToHundred()); //上面的代码调用了getIntBetweenOneToHundred三次，这个方法执行了三次 System.out.println(&quot;------------------------------------------------&quot;); //调用MethodDefineDemo类中有参有返回值的方法max md.max(3,6);//语法没问题，就是结果丢失 int bigger = md.max(5,6); System.out.println(&quot;bigger = &quot; + bigger); System.out.println(&quot;8,3中较大者是：&quot; + md.max(8,9)); &#125;&#125; 举例2： 12345678//1、创建Scanner的对象Scanner input = new Scanner(System.in);//System.in默认代表键盘输入//2、提示输入xxSystem.out.print(&quot;请输入一个整数：&quot;); //对象.非静态方法(实参列表)//3、接收输入内容int num = input.nextInt(); //对象.非静态方法() 5.5 使用的注意点（1）必须先声明后使用，且方法必须定义在类的内部 （2）调用一次就执行一次，不调用不执行。 （3）方法中可以调用类中的方法或属性，不可以在方法内部定义方法。 正确示例： 12345678类&#123; 方法1()&#123; &#125; 方法2()&#123; &#125;&#125; 错误示例： 1234567类&#123; 方法1()&#123; 方法2()&#123; //位置错误 &#125; &#125;&#125; 5.6 关键字return的使用 return在方法中的作用： 作用1：结束一个方法 作用2：结束一个方法的同时，可以返回数据给方法的调用者 注意点：在return关键字的直接后面不能声明执行语句 5.7 方法调用内存分析 方法没有被调用的时候，都在方法区中的字节码文件(.class)中存储。 方法被调用的时候，需要进入到栈内存中运行。方法每调用一次就会在栈中有一个入栈动作，即给当前方法开辟一块独立的内存区域，用于存储当前方法的局部变量的值。 当方法执行结束后，会释放该内存，称为出栈，如果方法有返回值，就会把结果返回调用处，如果没有返回值，就直接结束，回到调用处继续执行下一条指令。 栈结构：先进后出，后进先出。 举例分析： 12345678910111213141516171819202122/** * @author 尚硅谷-宋红康 * @create 9:21 */public class Person &#123; public static void main(String[] args) &#123; Person p1 = new Person(); p1.eat(); &#125; public static void eat() &#123; sleep(); System.out.println(&quot;人：吃饭&quot;); &#125; public static void sleep()&#123; System.out.println(&quot;人：睡觉&quot;); doSport(); &#125; public static void doSport()&#123; System.out.println(&quot;人：运动&quot;); &#125;&#125; 内存分析： 5.8 练习练习1：创建一个Person类，其定义如下： 要求： (1)创建Person类的对象，设置该对象的name、age和sex属性，调用study方法，输出字符串“studying”，调用showAge()方法显示age值，调用addAge()方法给对象的age属性值增加2岁。(2)创建第二个对象，执行上述操作，体会同一个类的不同对象之间的关系。 练习2：利用面向对象的编程方法，设计圆类Circle，包含属性（半径）和计算圆面积的方法。定义测试类，创建该Circle类的对象，并进行测试。 练习3： 3.1 编写程序，声明一个method方法，在方法中打印一个10*8的*型矩形，在main方法中调用该方法。 3.2 修改上一个程序，在method方法中，除打印一个10*8的*型矩形外，再计算该矩形的面积，并将其作为方法返回值。在main方法中调用该方法，接收返回的面积值并打印。 3.3 修改上一个程序，在method方法提供m和n两个参数，方法中打印一个m*n的*型矩形，并计算该矩形的面积， 将其作为方法返回值。在main方法中调用该方法，接收返回的面积值并打印。 练习4：声明一个日期类型MyDate：有属性：年year,月month，日day。创建2个日期对象，分别赋值为：你的出生日期，你对象的出生日期，并显示信息。 练习5（课下练习）：用面向对象的方式编写用户登录程序。 用户类： 属性：用户名，密码 方法：登录 界面类： 在界面类中添加main方法，接受用户输入，并调用用户类的登录方法进行验证。 输出： 登录失败：用户名或密码错误！ 登录成功：欢迎你，用户名！ 参考代码： 123456789101112131415161718192021222324252627282930313233343536public class User &#123; String name; String password;//密码 /** * 实现用户登录的判断 * * @param inputName 输入的用户名 * @param inputPwd 输入的密码 */ public void login(String inputName,String inputPwd)&#123; if(name.equals(inputName) &amp;&amp; password.equals(inputPwd))&#123; System.out.println(&quot;登录成功：欢迎你，&quot; + name); &#125;else&#123; System.out.println(&quot;登录失败：用户名或密码错误！&quot;); &#125; &#125; /** * 实现用户登录的判断 * @param inputName 输入的用户名 * @param inputPwd 输入的密码 * @return true:登录成功 false:登录失败 */ public boolean login1(String inputName,String inputPwd)&#123;// if(name.equals(inputName) &amp;&amp; password.equals(inputPwd))&#123;// return true;// &#125;else&#123;// return false;// &#125; //简化为： return name.equals(inputName) &amp;&amp; password.equals(inputPwd); &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940/** * * 用户界面类UserInterface： * * - 在用户界面类中添加main方法，接受用户输入，并调用用户类的登录方法进行验证。 * - 输出： * - 登录失败：用户名或密码错误！ * - 登录成功：欢迎你，用户名！ * * @author 尚硅谷-宋红康 * @create 9:58 */public class UserInterface &#123; public static void main(String[] args) &#123; User u1 = new User(); u1.name = &quot;Tom&quot;; u1.password = &quot;abc123&quot;; Scanner scanner = new Scanner(System.in); System.out.print(&quot;请输入用户名：&quot;); String name = scanner.next(); System.out.print(&quot;请输入密码：&quot;); String pwd = scanner.next(); //演示1：// u1.login(name,pwd); //演示2： boolean isLogin = u1.login1(name, pwd); if(isLogin)&#123; System.out.println(&quot;登录成功：欢迎你，&quot; + u1.name); &#125;else&#123; System.out.println(&quot;登录失败：用户名或密码错误！&quot;); &#125; scanner.close(); &#125;&#125; 6. 对象数组数组的元素可以是基本数据类型，也可以是引用数据类型。当元素是引用类型中的类时，我们称为对象数组。 1、案例 定义类Student，包含三个属性：学号number(int)，年级state(int)，成绩score(int)。 创建20个学生对象，学号为1到20，年级和成绩都由随机数确定。 问题一：打印出3年级(state值为3）的学生信息。 问题二：使用冒泡排序按学生成绩排序，并遍历所有学生信息 提示： 生成随机数：Math.random()，返回值类型double; 四舍五入取整：Math.round(double d)，返回值类型long。 12345678910111213141516/* * 定义类Student，包含三个属性：学号number(int)，年级state(int)，成绩score(int)。 */public class Student &#123; int number;//学号 int state;//年级 int score;//成绩 public void info()&#123; System.out.println(&quot;number : &quot; + number + &quot;,state : &quot; + state + &quot;,score : &quot; + score); &#125; &#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475public class StudentTest &#123; public static void main(String[] args) &#123; // Student s1 = new Student(); // s1.number = 1; // s1.state = (int)(Math.random() * 6 + 1);//[1,6] // s1.score = (int)(Math.random() * 101);//[0,100] // // Student s2 = new Student(); // s2.number = 2; // s2.state = (int)(Math.random() * 6 + 1);//[1,6] // s2.score = (int)(Math.random() * 101);//[0,100] // // //.... // 对象数组 // String[] arr = new String[10]; // 数组的创建 Student[] students = new Student[20]; // 通过循环结构给数组的属性赋值 for (int i = 0; i &lt; students.length; i++) &#123; // 数组元素的赋值 students[i] = new Student(); // 数组元素是一个对象，给对象的各个属性赋值 students[i].number = (i + 1); students[i].state = (int) (Math.random() * 6 + 1);// [1,6] students[i].score = (int) (Math.random() * 101);// [0,100] &#125; // 问题一：打印出3年级(state值为3）的学生信息。 for (int i = 0; i &lt; students.length; i++) &#123; if (students[i].state == 3) &#123;// System.out.println(// &quot;number:&quot; + students[i].number + &quot;,state:&quot; + students[i].state + &quot;,score:&quot; + students[i].score); students[i].info(); &#125; &#125; System.out.println(&quot;******************************&quot;); // 问题二：使用冒泡排序按学生成绩排序，并遍历所有学生信息 // 排序前 for (int i = 0; i &lt; students.length; i++) &#123;// System.out.println(// &quot;number:&quot; + students[i].number + &quot;,state:&quot; + // students[i].state + &quot;,score:&quot; + students[i].score); students[i].info(); &#125; System.out.println(); // 排序： for (int i = 0; i &lt; students.length - 1; i++) &#123; for (int j = 0; j &lt; students.length - 1 - i; j++) &#123; if (students[j].score &gt; students[j + 1].score) &#123; Student temp = students[j]; students[j] = students[j + 1]; students[j + 1] = temp; &#125; &#125; &#125; // 排序后： for (int i = 0; i &lt; students.length; i++) &#123;// System.out.println(// &quot;number:&quot; + students[i].number + &quot;,state:&quot; + // students[i].state + &quot;,score:&quot; + students[i].score); students[i].info(); &#125; &#125;&#125; 内存解析： 2、注意点 对象数组，首先要创建数组对象本身，即确定数组的长度，然后再创建每一个元素对象，如果不创建，数组的元素的默认值就是null，所以很容易出现空指针异常NullPointerException。 3、练习 （1）定义矩形类Rectangle，包含长、宽属性，area()返回矩形面积的方法，perimeter()返回矩形周长的方法，String getInfo()返回圆对象的详细信息（如：长、宽、面积、周长等数据）的方法 （2）在测试类中创建长度为3的Rectangle[]数组，用来装3个矩形对象，并给3个矩形对象的长分别赋值为10,20,30，宽分别赋值为5,15,25，遍历输出 12345678910111213141516171819202122package com.atguigu.test08.array;public class Rectangle &#123; double length; double width; public double area()&#123;//面积 return length * width; &#125; public double perimeter()&#123;//周长 return 2 * (length + width); &#125; public String getInfo()&#123; return &quot;长：&quot; + length + &quot;，宽：&quot; + width + &quot;，面积：&quot; + area() + &quot;，周长：&quot; + perimeter(); &#125;&#125; 123456789101112131415161718192021222324package com.atguigu.test08.array;public class ObjectArrayTest &#123; public static void main(String[] args) &#123; //声明并创建一个长度为3的矩形对象数组 Rectangle[] array = new Rectangle[3]; //创建3个矩形对象，并为对象的实例变量赋值， //3个矩形对象的长分别是10,20,30 //3个矩形对象的宽分别是5,15,25 //调用矩形对象的getInfo()返回对象信息后输出 for (int i = 0; i &lt; array.length; i++) &#123; //创建矩形对象 array[i] = new Rectangle(); //为矩形对象的成员变量赋值 array[i].length = (i+1) * 10; array[i].width = (2*i+1) * 5; //获取并输出对象对象的信息 System.out.println(array[i].getInfo()); &#125; &#125;&#125; 内存解析： 7. 再谈方法7.1 方法的重载（overload）7.1.1 概念及特点 方法重载：在同一个类中，允许存在一个以上的同名方法，只要它们的参数列表不同即可。 参数列表不同，意味着参数个数或参数类型的不同 重载的特点：与修饰符、返回值类型无关，只看参数列表，且参数列表必须不同。(参数个数或参数类型)。调用时，根据方法参数列表的不同来区别。 重载方法调用：JVM通过方法的参数列表，调用匹配的方法。 先找个数、类型最匹配的 再找个数和类型可以兼容的，如果同时多个方法可以兼容将会报错 7.1.2 示例举例1： 12345678910111213141516171819202122//System.out.println()方法就是典型的重载方法，其内部的声明形式如下：public class PrintStream &#123; public void println(byte x) public void println(short x) public void println(int x) public void println(long x) public void println(float x) public void println(double x) public void println(char x) public void println(double x) public void println()&#125;public class HelloWorld&#123; public static void main(String[] args) &#123; System.out.println(3); System.out.println(1.2f); System.out.println(&quot;hello!&quot;); &#125;&#125; ​ 举例2： 1234567891011121314//返回两个整数的和public int add(int x,int y)&#123; return x+y;&#125;//返回三个整数的和public int add(int x,int y,int z)&#123; return x+y+z;&#125;//返回两个小数的和public double add(double x,double y)&#123; return x+y;&#125; ​ 举例3：方法的重载和返回值类型无关 1234567891011public class MathTools &#123; //以下方法不是重载，会报错 public int getOneToHundred()&#123; return (int)(Math.random()*100); &#125; public double getOneToHundred()&#123; return Math.random()*100; &#125;&#125; 7.1.3 练习练习1：判 断与void show(int a,char b,double c)&#123;&#125;构成重载的有： 12345678910111213a)void show(int x,char y,double z)&#123;&#125; // nob)int show(int a,double c,char b)&#123;&#125; // yesc) void show(int a,double c,char b)&#123;&#125; // yesd) boolean show(int c,char b)&#123;&#125; // yese) void show(double c)&#123;&#125; // yesf) double show(int x,char y,double z)&#123;&#125; // nog) void shows()&#123;double c&#125; // no 练习2：编写程序，定义三个重载方法并调用。 方法名为mOL。 三个方法分别接收一个int参数、两个int参数、一个字符串参数。分别执行平方运算并输出结果，相乘并输出结果，输出字符串信息。 在主类的main ()方法中分别用参数区别调用三个方法。 练习3：定义三个重载方法max()，第一个方法求两个int值中的最大值，第二个方法求两个double值中的最大值，第三个方法求三个double值中的最大值，并分别调用三个方法。 7.2 可变个数的形参在**JDK 5.0 中提供了Varargs(variable number of arguments)**机制。即当定义一个方法时，形参的类型可以确定，但是形参的个数不确定，那么可以考虑使用可变个数的形参。 格式： 1方法名(参数的类型名 ...参数名) 举例： 123456//JDK 5.0以前：采用数组形参来定义方法，传入多个同一类型变量public static void test(int a ,String[] books);//JDK5.0：采用可变个数形参来定义方法，传入多个同一类型变量public static void test(int a ,String...books); 特点： 可变参数：方法参数部分指定类型的参数个数是可变多个：0个，1个或多个 可变个数形参的方法与同名的方法之间，彼此构成重载 可变参数方法的使用与方法参数部分使用数组是一致的，二者不能同时声明，否则报错。 方法的参数部分有可变形参，需要放在形参声明的最后 在一个方法的形参中，最多只能声明一个可变个数的形参 案例分析： 案例1：n个字符串进行拼接，每一个字符串之间使用某字符进行分割，如果没有传入字符串，那么返回空字符串”” 12345678910111213public class StringTools &#123; String concat(char seperator, String... args)&#123; String str = &quot;&quot;; for (int i = 0; i &lt; args.length; i++) &#123; if(i==0)&#123; str += args[i]; &#125;else&#123; str += seperator + args[i]; &#125; &#125; return str; &#125;&#125; 123456789101112package com.atguigu.test05.param;public class StringToolsTest &#123; public static void main(String[] args) &#123; StringTools tools = new StringTools(); System.out.println(tools.concat(&#x27;-&#x27;)); System.out.println(tools.concat(&#x27;-&#x27;,&quot;hello&quot;)); System.out.println(tools.concat(&#x27;-&#x27;,&quot;hello&quot;,&quot;world&quot;)); System.out.println(tools.concat(&#x27;-&#x27;,&quot;hello&quot;,&quot;world&quot;,&quot;java&quot;)); &#125;&#125; 案例2：求n个整数的和 1234567891011121314151617public class NumberTools &#123; public int total(int[] nums)&#123; int sum = 0; for (int i = 0; i &lt; nums.length; i++) &#123; sum += nums[i]; &#125; return sum; &#125; public int sum(int... nums)&#123; int sum = 0; for (int i = 0; i &lt; nums.length; i++) &#123; sum += nums[i]; &#125; return sum; &#125;&#125; 123456789101112131415public class TestVarParam &#123; public static void main(String[] args) &#123; NumberTools tools = new NumberTools(); System.out.println(tools.sum());//0个实参 System.out.println(tools.sum(5));//1个实参 System.out.println(tools.sum(5,6,2,4));//4个实参 System.out.println(tools.sum(new int[]&#123;5,6,2,4&#125;));//传入数组实参 System.out.println(&quot;------------------------------------&quot;); System.out.println(tools.total(new int[]&#123;&#125;));//0个元素的数组 System.out.println(tools.total(new int[]&#123;5&#125;));//1个元素的数组 System.out.println(tools.total(new int[]&#123;5,6,2,4&#125;));//传入数组实参 &#125;&#125; 案例3：如下的方法彼此构成重载 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class MathTools &#123; //求两个整数的最大值 public int max(int a,int b)&#123; return a&gt;b?a:b; &#125; //求两个小数的最大值 public double max(double a, double b)&#123; return a&gt;b?a:b; &#125; //求三个整数的最大值 public int max(int a, int b, int c)&#123; return max(max(a,b),c); &#125; //求n个整数的最大值 public int max(int... nums)&#123; int max = nums[0];//如果没有传入整数，或者传入null，这句代码会报异常 for (int i = 1; i &lt; nums.length; i++) &#123; if(nums[i] &gt; max)&#123; max = nums[i]; &#125; &#125; return max; &#125; /* //求n整数的最大值 public int max(int[] nums)&#123; //编译就报错，与(int... nums)无法区分 int max = nums[0];//如果没有传入整数，或者传入null，这句代码会报异常 for (int i = 1; i &lt; nums.length; i++) &#123; if(nums[i] &gt; max)&#123; max = nums[i]; &#125; &#125; return max; &#125;*//* //求n整数的最大值 public int max(int first, int... nums)&#123; //当前类不报错，但是调用时会引起多个方法同时匹配 int max = first; for (int i = 0; i &lt; nums.length; i++) &#123; if(nums[i] &gt; max)&#123; max = nums[i]; &#125; &#125; return max; &#125;*/&#125; 7.3 方法的参数传递机制7.3.1 形参和实参 形参（formal parameter）：在定义方法时，方法名后面括号()中声明的变量称为形式参数，简称形参。 实参（actual parameter）：在调用方法时，方法名后面括号()中的使用的值&#x2F;变量&#x2F;表达式称为实际参数，简称实参。 7.3.2 参数传递机制：值传递Java里方法的参数传递方式只有一种：值传递。 即将实际参数值的副本（复制品）传入方法内，而参数本身不受影响。 形参是基本数据类型：将实参基本数据类型变量的“数据值”传递给形参 形参是引用数据类型：将实参引用数据类型变量的“地址值”传递给形参 7.3.3 举例1、形参是基本数据类型 案例：编写方法，交换两个整型变量的值 123456789101112131415161718192021222324public class Test &#123; public static void main(String[] args) &#123; int m = 10; int n = 20; System.out.println(&quot;m = &quot; + m + &quot;, n = &quot; + n); //交换m和n的值// int temp = m;// m = n;// n = temp; ValueTransferTest1 test = new ValueTransferTest1(); test.swap(m, n); System.out.println(&quot;m = &quot; + m + &quot;, n = &quot; + n); &#125; public void swap(int m,int n)&#123; int temp = m; m = n; n = temp; &#125; &#125; 内存解析： 2、形参是引用数据类型 123456789101112131415161718192021222324public class Test &#123; public static void main(String[] args) &#123; Data d1 = new Data(); d1.m = 10; d1.n = 20; System.out.println(&quot;m = &quot; + d1.m + &quot;, n = &quot; + d1.n); //实现 换序 ValueTransferTest2 test = new ValueTransferTest2(); test.swap(d1); System.out.println(&quot;m = &quot; + d1.m + &quot;, n = &quot; + d1.n); &#125; public void swap(Data data)&#123; int temp = data.m; data.m = data.n; data.n = temp; &#125;&#125; 1234class Data&#123; int m; int n;&#125; 内存解析： 7.3.4 练习练习1：判断如下程序输出的结果 12345678910111213141516171819202122232425public class AssignNewObject &#123; public void swap(MyData my)&#123; my = new MyData(); //考虑堆空间此新创建的对象，和main中的data对象是否有关 int temp = my.x; my.x = my.y; my.y = temp; &#125; public static void main(String[] args) &#123; AssignNewObject tools = new AssignNewObject(); MyData data = new MyData(); data.x = 1; data.y = 2; System.out.println(&quot;交换之前：x = &quot; + data.x +&quot;,y = &quot; + data.y);// tools.swap(data);//调用完之后，x与y的值交换？ System.out.println(&quot;交换之后：x = &quot; + data.x +&quot;,y = &quot; + data.y);// &#125;&#125;class MyData&#123; int x ; int y;&#125; 练习2：如下操作是否可以实现数组排序 123456789101112131415161718192021222324252627282930313233343536public class ArrayTypeParam &#123; //冒泡排序，实现数组从小到大排序 public void sort(int[] arr)&#123; for (int i = 0; i &lt; arr.length - 1; i++) &#123; for (int j = 0; j &lt; arr.length - 1 - i; j++) &#123; if(arr[j] &gt; arr[j+1])&#123; int temp = arr[j]; arr[j] = arr[j+1]; arr[j+1] = temp; &#125; &#125; &#125; &#125; //打印数组的元素 public void print(int[] arr)&#123; for (int i = 0; i &lt; arr.length; i++) &#123; System.out.print(arr[i]+&quot; &quot;); &#125; System.out.println(); &#125; public static void main(String[] args) &#123; ArrayTypeParam tools = new ArrayTypeParam(); int[] nums = &#123;4,3,1,6,7&#125;; System.out.println(&quot;排序之前：&quot;); tools.print(nums); tools.sort(nums);//对nums数组进行排序 System.out.println(&quot;排序之后：&quot;); tools.print(nums);//输出nums数组的元素 &#125;&#125; 练习3：通过内存结构图，写出如下程序的输出结果 12345678910111213141516171819202122232425262728//栈：每个方法在调用时，都会有以栈帧的方法压入栈中。栈帧中保存了当前方法中声明的变量：方法内声明的，形参//堆：存放new出来的&quot;东西&quot;：对象（成员变量在对象中）、数组实体（数组元素）。 //注意：变量前如果声明有类型，那么这就是一个新的刚要定义的变量。如果变量前没有声明类型，那就说明此变量在之前已经声明过。public class TransferTest3 &#123; public static void main(String args[]) &#123; TransferTest3 test = new TransferTest3(); test.first(); &#125; public void first() &#123; int i = 5; Value v = new Value(); v.i = 25; second(v, i); System.out.println(v.i); &#125; public void second(Value v, int i) &#123; i = 0; v.i = 20; Value val = new Value(); v = val; System.out.println(v.i + &quot; &quot; + i); &#125;&#125;class Value &#123; int i = 15;&#125; 内存解析： 练习4：貌似是考查方法的参数传递 1234567891011121314151617181920212223242526272829//法一： public static void method(int a, int b) &#123; // 在不改变原本题目的前提下，如何写这个函数才能在main函数中输出a=100，b=200？ a = a * 10; b = b * 20; System.out.println(a); System.out.println(b); System.exit(0); &#125; //法二： public static void method(int a, int b) &#123; PrintStream ps = new PrintStream(System.out) &#123; @Override public void println(String x) &#123; if (&quot;a=10&quot;.equals(x)) &#123; x = &quot;a=100&quot;; &#125; else if (&quot;b=10&quot;.equals(x)) &#123; x = &quot;b=200&quot;; &#125; super.println(x); &#125; &#125;; System.setOut(ps); &#125; 练习5：将对象作为参数传递给方法 （1）定义一个Circle类，包含一个double型的radius属性代表圆的半径，一个findArea()方法返回圆的面积。（2）定义一个类PassObject，在类中定义一个方法printAreas()，该方法的定义如下：public void printAreas(Circle c, int time)，在printAreas方法中打印输出1到time之间的每个整数半径值，以及对应的面积。例如，times为5，则输出半径1，2，3，4，5，以及对应的圆面积。（3）在main方法中调用printAreas()方法，调用完毕后输出当前半径值。程序运行结果如图所示。 7.4 递归(recursion)方法举例1： 举例2： 123456从前有座山,山上有座庙,庙里有个老和尚,老和尚在给小和尚讲故事,讲的啥? 从前有座山,山上有座庙,庙里有个老和尚,老和尚在给小和尚讲故事,讲的啥? 从前有座山,山上有座庙,庙里有个老和尚,老和尚在给小和尚讲故事,讲的啥? 从前有座山,山上有座庙,庙里有个老和尚,老和尚在给小和尚讲故事,讲的啥?... ...老和尚没了,庙塌了,小和尚还俗结婚了。 递归方法调用：方法自己调用自己的现象就称为递归。 **递归的分类:**直接递归、间接递归。 直接递归：方法自身调用自己。 123public void methodA()&#123; methodA();&#125; 间接递归：可以理解为A()方法调用B()方法，B()方法调用C()方法，C()方法调用A()方法。 1234567891011public static void A()&#123; B();&#125;public static void B()&#123; C();&#125;public static void C()&#123; A();&#125; 说明： 递归方法包含了一种隐式的循环。 递归方法会重复执行某段代码，但这种重复执行无须循环控制。 递归一定要向已知方向递归，否则这种递归就变成了无穷递归，停不下来，类似于死循环。最终发生栈内存溢出。 举例： 举例1：计算1 ~ n的和 12345678910111213141516171819202122232425262728293031public class RecursionDemo &#123; public static void main(String[] args) &#123; RecursionDemo demo = new RecursionDemo(); //计算1~num的和，使用递归完成 int num = 5; // 调用求和的方法 int sum = demo.getSum(num); // 输出结果 System.out.println(sum); &#125; /* 通过递归算法实现. 参数列表:int 返回值类型: int */ public int getSum(int num) &#123; /* num为1时,方法返回1, 相当于是方法的出口,num总有是1的情况 */ if(num == 1)&#123; return 1; &#125; /* num不为1时,方法返回 num +(num-1)的累和 递归调用getSum方法 */ return num + getSum(num-1); &#125;&#125; 代码执行图解： 举例2：递归方法计算n! 1234567public int multiply(int num)&#123; if(num == 1)&#123; return 1; &#125;else&#123; return num * multiply(num - 1); &#125;&#125; 举例3：已知有一个数列：f(0) &#x3D; 1，f(1) &#x3D; 4，f(n+2)&#x3D;2*f(n+1) + f(n)，其中n是大于0的整数，求f(10)的值。 123456789public int f(int num)&#123; if(num == 0)&#123; return 1; &#125;else if(num == 1)&#123; return 4; &#125;else&#123; return 2 * f(num - 1) + f(num - 2); &#125;&#125; 举例4：已知一个数列：f(20) &#x3D; 1,f(21) &#x3D; 4,f(n+2) &#x3D; 2*f(n+1)+f(n)，其中n是大于0的整数，求f(10)的值。 123456789public int func(int num)&#123; if(num == 20)&#123; return 1; &#125;else if(num == 21)&#123; return 4; &#125;else&#123; return func(num + 2) - 2 * func(num + 1); &#125;&#125; 举例5：计算斐波那契数列（Fibonacci）的第n个值，斐波那契数列满足如下规律， 11,1,2,3,5,8,13,21,34,55,.... 即从第三个数开始，一个数等于前两个数之和。假设f(n)代表斐波那契数列的第n个值，那么f(n)满足：f(n) &#x3D; f(n-2) + f(n-1); 123456789101112131415161718192021222324252627282930313233343536373839404142//使用递归的写法 int f(int n) &#123;//计算斐波那契数列第n个值是多少 if (n &lt; 1) &#123;//负数是返回特殊值1，表示不计算负数情况 return 1; &#125; if (n == 1 || n == 2) &#123; return 1; &#125; return f(n - 2) + f(n - 1); &#125; //不用递归 int fValue(int n) &#123;//计算斐波那契数列第n个值是多少 if (n &lt; 1) &#123;//负数是返回特殊值1，表示不计算负数情况 return 1; &#125; if (n == 1 || n == 2) &#123; return 1; &#125; //从第三个数开始， 等于 前两个整数相加 int beforeBefore = 1; //相当于n=1时的值 int before = 1;//相当于n=2时的值 int current = beforeBefore + before; //相当于n=3的值 //再完后 for (int i = 4; i &lt;= n; i++) &#123; beforeBefore = before; before = current; current = beforeBefore + before; /* 假设i=4 beforeBefore = before; //相当于n=2时的值 before = current; //相当于n=3的值 current = beforeBefore + before; //相当于n = 4的值 假设i=5 beforeBefore = before; //相当于n=3的值 before = current; //相当于n = 4的值 current = beforeBefore + before; //相当于n = 5的值 .... */ &#125; return current; &#125; 举例6：面试题 宋老师，我今天去百度面试，遇到一个一个双重递归调用的问题，我琢磨了一下，完全不知道为什么。打断点了，也还是没看懂为什么程序会那样走。您有空可以看一下，求指教。 123456789101112private int count = 0; public int recursion(int k) &#123; count++; System.out.println(&quot;count1:&quot; + count + &quot; k:&quot; + k); if (k &lt;= 0) &#123; return 0; &#125; return recursion(k - 1) + recursion(k - 2);//287 //return recursion(k - 1);//11 //return recursion(k - 1) + recursion(k - 1);//2047 &#125; 剖析： 最后说两句： 递归调用会占用大量的系统堆栈，内存耗用多，在递归调用层次多时速度要比循环慢的多，所以在使用递归时要慎重。 在要求高性能的情况下尽量避免使用递归，递归调用既花时间又耗内存。考虑使用循环迭代 8. 关键字：package、import8.1 package(包)package，称为包，用于指明该文件中定义的类、接口等结构所在的包。 8.1.1 语法格式1package 顶层包名.子包名 ; 举例：pack1\\pack2\\PackageTest.java 1234567package pack1.pack2; //指定类PackageTest属于包pack1.pack2public class PackageTest&#123; public void display()&#123; System.out.println(&quot;in method display()&quot;); &#125;&#125; 说明： 一个源文件只能有一个声明包的package语句 package语句作为Java源文件的第一条语句出现。若缺省该语句，则指定为无名包。 包名，属于标识符，满足标识符命名的规则和规范（全部小写）、见名知意 包通常使用所在公司域名的倒置：com.atguigu.xxx。 大家取包名时不要使用”java.xx“包 包对应于文件系统的目录，package语句中用 “.” 来指明包(目录)的层次，每.一次就表示一层文件目录。 同一个包下可以声明多个结构（类、接口），但是不能定义同名的结构（类、接口）。不同的包下可以定义同名的结构（类、接口） 8.1.2 包的作用 包可以包含类和子包，划分项目层次，便于管理 帮助管理大型软件系统：将功能相近的类划分到同一个包中。比如：MVC的设计模式 解决类命名冲突的问题 控制访问权限 8.1.3 应用举例举例1：某航运软件系统包括：一组域对象、GUI和reports子系统 举例2：MVC设计模式 MVC是一种软件构件模式，目的是为了降低程序开发中代码业务的耦合度。 MVC设计模式将整个程序分为三个层次：视图模型(Viewer)层，控制器(Controller)层，与数据模型(Model)层。这种将程序输入输出、数据处理，以及数据的展示分离开来的设计模式使程序结构变的灵活而且清晰，同时也描述了程序各个对象间的通信方式，降低了程序的耦合性。 12345678910111213141516视图层viewer：显示数据,为用户提供使用界面，与用户直接进行交互。 &gt;相关工具类 view.utils &gt;自定义view view.ui控制层controller：解析用户请求，处理业务逻辑，给予用户响应 &gt;应用界面相关 controller.activity &gt;存放fragment controller.fragment &gt;显示列表的适配器 controller.adapter &gt;服务相关的 controller.service &gt;抽取的基类 controller.base 模型层model：主要承载数据、处理数据 &gt;数据对象封装 model.bean/domain &gt;数据库操作类 model.dao &gt;数据库 model.db 8.1.4 JDK中主要的包介绍java.lang—-包含一些Java语言的核心类，如String、Math、Integer、 System和Thread，提供常用功能java.net—-包含执行与网络相关的操作的类和接口。java.io —-包含能提供多种输入&#x2F;输出功能的类。java.util—-包含一些实用工具类，如定义系统特性、接口的集合框架类、使用与日期日历相关的函数。java.text—-包含了一些java格式化相关的类java.sql—-包含了java进行JDBC数据库编程的相关类&#x2F;接口java.awt—-包含了构成抽象窗口工具集（abstract window toolkits）的多个类，这些类被用来构建和管理应用程序的图形用户界面(GUI)。 8.2 import(导入)为了使用定义在其它包中的Java类，需用import语句来显式引入指定包下所需要的类。相当于import语句告诉编译器到哪里去寻找这个类。 8.2.1 语法格式1import 包名.类名; 8.2.2 应用举例12345678import pack1.pack2.Test; //import pack1.pack2.*;表示引入pack1.pack2包中的所有结构public class PackTest&#123; public static void main(String args[])&#123; Test t = new Test(); //Test类在pack1.pack2包中定义 t.display(); &#125;&#125; 8.2.3 注意事项 import语句，声明在包的声明和类的声明之间。 如果需要导入多个类或接口，那么就并列显式多个import语句即可 如果使用a.*导入结构，表示可以导入a包下的所有的结构。举例：可以使用java.util.*的方式，一次性导入util包下所有的类或接口。 如果导入的类或接口是java.lang包下的，或者是当前包下的，则可以省略此import语句。 如果已经导入java.a包下的类，那么如果需要使用a包的子包下的类的话，仍然需要导入。 如果在代码中使用不同包下的同名的类，那么就需要使用类的全类名的方式指明调用的是哪个类。 （了解）import static组合的使用：调用指定类或接口下的静态的属性或方法 9. 面向对象特征一：封装性(encapsulation)9.1 为什么需要封装？ 我要用洗衣机，只需要按一下开关和洗涤模式就可以了。有必要了解洗衣机内部的结构吗？有必要碰电动机吗？ 我要开车，我不需要懂离合、油门、制动等原理和维修也可以驾驶。 客观世界里每一个事物的内部信息都隐藏在其内部，外界无法直接操作和修改，只能通过指定的方式进行访问和修改。 随着我们系统越来越复杂，类会越来越多，那么类之间的访问边界必须把握好，面向对象的开发原则要遵循“高内聚、低耦合”。 高内聚、低耦合是软件工程中的概念，也是UNIX 操作系统设计的经典原则。 内聚，指一个模块内各个元素彼此结合的紧密程度；耦合指一个软件结构内不同模块之间互连程度的度量。内聚意味着重用和独立，耦合意味着多米诺效应牵一发动全身。 而“高内聚，低耦合”的体现之一： 高内聚：类的内部数据操作细节自己完成，不允许外部干涉； 低耦合：仅暴露少量的方法给外部使用，尽量方便外部调用。 9.2 何为封装性？所谓封装，就是把客观事物封装成抽象概念的类，并且类可以把自己的数据和方法只向可信的类或者对象开放，向没必要开放的类或者对象隐藏信息。 通俗的讲，把该隐藏的隐藏起来，该暴露的暴露出来。这就是封装性的设计思想。 9.3 Java如何实现数据封装 实现封装就是控制类或成员的可见性范围。这就需要依赖访问控制修饰符，也称为权限修饰符来控制。 权限修饰符：public、protected、缺省、private。具体访问范围如下： 修饰符 本类内部 本包内 其他包的子类 其他包非子类 private √ × × × 缺省 √ √ × × protected √ √ √ × public √ √ √ √ 具体修饰的结构： 外部类：public、缺省 成员变量、成员方法、构造器、成员内部类：public、protected、缺省、private 9.4 封装性的体现9.4.1 成员变量&#x2F;属性私有化概述：私有化类的成员变量，提供公共的get和set方法，对外暴露获取和修改属性的功能。 实现步骤： ① 使用 private 修饰成员变量 1private 数据类型 变量名 ； 代码如下： 12345public class Person &#123; private String name; private int age; private boolean marry;&#125; ② 提供 getXxx方法 &#x2F; setXxx 方法，可以访问成员变量，代码如下： 1234567891011121314151617181920212223242526272829public class Person &#123; private String name; private int age; private boolean marry; public void setName(String n) &#123; name = n; &#125; public String getName() &#123; return name; &#125; public void setAge(int a) &#123; age = a; &#125; public int getAge() &#123; return age; &#125; public void setMarry(boolean m)&#123; marry = m; &#125; public boolean isMarry()&#123; return marry; &#125;&#125; ③ 测试： 12345678910111213141516171819public class PersonTest &#123; public static void main(String[] args) &#123; Person p = new Person(); //实例变量私有化，跨类是无法直接使用的 /* p.name = &quot;张三&quot;; p.age = 23; p.marry = true;*/ p.setName(&quot;张三&quot;); System.out.println(&quot;p.name = &quot; + p.getName()); p.setAge(23); System.out.println(&quot;p.age = &quot; + p.getAge()); p.setMarry(true); System.out.println(&quot;p.marry = &quot; + p.isMarry()); &#125;&#125; 成员变量封装的好处： 让使用者只能通过事先预定的方法来访问数据，从而可以在该方法里面加入控制逻辑，限制对成员变量的不合理访问。还可以进行数据检查，从而有利于保证对象信息的完整性。 便于修改，提高代码的可维护性。主要说的是隐藏的部分，在内部修改了，如果其对外可以的访问方式不变的话，外部根本感觉不到它的修改。例如：Java8-&gt;Java9，String从char[]转为byte[]内部实现，而对外的方法不变，我们使用者根本感觉不到它内部的修改。 开心一笑： 123456A man and woman are in a computer programming lecture. The man touches the woman&#x27;s breasts.&quot;Hey!&quot; she says. &quot;Those are private!&quot;The man says, &quot;But we&#x27;re in the same class!&quot; 9.4.2 私有化方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179/** * * @Description 自定义的操作数组的工具类 * @author 尚硅谷-宋红康 Email:shkstart@126.com * @version * */public class ArrayUtil &#123; /** * * @Description 求int型数组的最大值 * @author 尚硅谷-宋红康 * @param arr * @return */ public int max(int[] arr) &#123; int maxValue = arr[0]; for(int i = 1;i &lt; arr.length;i++)&#123; if(maxValue &lt; arr[i])&#123; maxValue = arr[i]; &#125; &#125; return maxValue; &#125; /** * * @Description 求int型数组的最小值 * @author 尚硅谷-宋红康 * @param arr * @return */ public int min(int[] arr)&#123; int minValue = arr[0]; for(int i = 1;i &lt; arr.length;i++)&#123; if(minValue &gt; arr[i])&#123; minValue = arr[i]; &#125; &#125; return minValue; &#125; /** * * @Description 求int型数组的总和 * @author 尚硅谷-宋红康 * @param arr * @return */ public int sum(int[] arr) &#123; int sum = 0; for(int i = 0;i &lt; arr.length;i++)&#123; sum += arr[i]; &#125; return sum; &#125; /** * * @Description 求int型数组的元素的平均值 * @author 尚硅谷-宋红康 * @param arr * @return */ public int avg(int[] arr) &#123; int sumValue = sum(arr); return sumValue / arr.length; &#125; // 创建一系列重载的上述方法 // public double max(double[] arr)&#123;&#125; // public float max(float[] arr)&#123;&#125; // public byte max(byte[] arr)&#123;&#125; /** * * @Description 遍历数组 * @author 尚硅谷-宋红康 * @param arr */ public void print(int[] arr) &#123; for(int i = 0;i &lt; arr.length;i++)&#123; System.out.print(arr[i] + &quot; &quot;); &#125; System.out.println(); &#125; /** * * @Description 复制数组arr * @author 尚硅谷-宋红康 * @param arr * @return */ public int[] copy(int[] arr) &#123; int[] arr1 = new int[arr.length]; for(int i = 0;i &lt; arr.length;i++)&#123; arr1[i] = arr[i]; &#125; return arr1; &#125; /** * * @Description 反转数组 * @author 尚硅谷-宋红康 * @param arr */ public void reverse(int[] arr) &#123; for(int i = 0,j = arr.length - 1;i &lt; j;i++,j--)&#123; int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; &#125; &#125; /** * * @Description 数组的排序 * @author 尚硅谷-宋红康 * @param arr * @param desc 指明排序的方式。 ascend:升序 descend:降序 */ public void sort(int[] arr,String desc) &#123; if(&quot;ascend&quot;.equals(desc))&#123;//if(desc.equals(&quot;ascend&quot;))&#123; for (int i = 0; i &lt; arr.length - 1; i++) &#123; for (int j = 0; j &lt; arr.length - 1 - i; j++) &#123; if (arr[j] &gt; arr[j + 1]) &#123;// int temp = arr[j];// arr[j] = arr[j + 1];// arr[j + 1] = temp; swap(arr,j,j+1); &#125; &#125; &#125; &#125;else if (&quot;descend&quot;.equals(desc))&#123; for (int i = 0; i &lt; arr.length - 1; i++) &#123; for (int j = 0; j &lt; arr.length - 1 - i; j++) &#123; if (arr[j] &lt; arr[j + 1]) &#123;// int temp = arr[j];// arr[j] = arr[j + 1];// arr[j + 1] = temp; swap(arr,j,j+1); &#125; &#125; &#125; &#125;else&#123; System.out.println(&quot;您输入的排序方式有误！&quot;); &#125; &#125; private void swap(int[] arr,int i,int j)&#123; int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; &#125; /** * * @Description 查找指定的value值在arr数组中出现的位置 * @author 尚硅谷-宋红康 * @param arr * @param value * @return 返回value值出现的位置 或 -1：未找到 */ public int getValue(int[] arr, int value) &#123; //方法：线性查找 for(int i = 0;i &lt; arr.length;i++)&#123; if(value == arr[i])&#123; return i; &#125; &#125; return - 1; &#125;&#125; 注意： 开发中，一般成员实例变量都习惯使用private修饰，再提供相应的public权限的get&#x2F;set方法访问。 对于final的实例变量，不提供set()方法。（后面final关键字的时候讲） 对于static final的成员变量，习惯上使用public修饰。 9.5 练习练习1： 创建程序：在其中定义两个类：Person和PersonTest类。定义如下： 用setAge()设置人的合法年龄(0~130)，用getAge()返回人的年龄。在PersonTest类中实例化Person类的对象b，调用setAge()和getAge()方法，体会Java的封装性。 练习2： 自定义图书类。设定属性包括：书名bookName，作者author，出版社名publisher，价格price；方法包括：相应属性的get&#x2F;set方法，图书信息介绍等。 10. 类的成员之三：构造器(Constructor)我们new完对象时，所有成员变量都是默认值，如果我们需要赋别的值，需要挨个为它们再赋值，太麻烦了。我们能不能在new对象时，直接为当前对象的某个或所有成员变量直接赋值呢？ 可以，Java给我们提供了构造器（Constructor)，也称为构造方法。 10.1 构造器的作用new对象，并在new对象的时候为实例变量赋值。 举例：Person p &#x3D; new Person(“Peter”,15); 解释：如同我们规定每个“人”一出生就必须先洗澡，我们就可以在“人”的构造器中加入完成“洗澡”的程序代码，于是每个“人”一出生就会自动完成“洗澡”，程序就不必再在每个人刚出生时一个一个地告诉他们要“洗澡”了。 10.2 构造器的语法格式12345678[修饰符] class 类名&#123; [修饰符] 构造器名()&#123; // 实例初始化代码 &#125; [修饰符] 构造器名(参数列表)&#123; // 实例初始化代码 &#125;&#125; 说明： 构造器名必须与它所在的类名必须相同。 它没有返回值，所以不需要返回值类型，也不需要void。 构造器的修饰符只能是权限修饰符，不能被其他任何修饰。比如，不能被static、final、synchronized、abstract、native修饰，不能有return语句返回值。 代码如下： 12345678910111213141516171819202122232425262728293031public class Student &#123; private String name; private int age; // 无参构造 public Student() &#123;&#125; // 有参构造 public Student(String n,int a) &#123; name = n; age = a; &#125; public String getName() &#123; return name; &#125; public void setName(String n) &#123; name = n; &#125; public int getAge() &#123; return age; &#125; public void setAge(int a) &#123; age = a; &#125; public String getInfo()&#123; return &quot;姓名：&quot; + name +&quot;，年龄：&quot; + age; &#125;&#125; 123456789101112public class TestStudent &#123; public static void main(String[] args) &#123; //调用无参构造创建学生对象 Student s1 = new Student(); //调用有参构造创建学生对象 Student s2 = new Student(&quot;张三&quot;,23); System.out.println(s1.getInfo()); System.out.println(s2.getInfo()); &#125;&#125; 10.3 使用说明 当我们没有显式的声明类中的构造器时，系统会默认提供一个无参的构造器并且该构造器的修饰符默认与类的修饰符相同 当我们显式的定义类的构造器以后，系统就不再提供默认的无参的构造器了。 在类中，至少会存在一个构造器。 构造器是可以重载的。 10.4 练习练习1：编写两个类，TriAngle和TriAngleTest，其中TriAngle类中声明私有的底边长base和高height，同时声明公共方法访问私有变量。此外，提供类必要的构造器。另一个类中使用这些公共方法，计算三角形的面积。 练习2： (1)定义Student类,有4个属性： String name; int age; String school; String major; (2)定义Student类的3个构造器: 第一个构造器Student(String n, int a)设置类的name和age属性； 第二个构造器Student(String n, int a, String s)设置类的name, age 和school属性； 第三个构造器Student(String n, int a, String s, String m)设置类的name, age ,school和major属性； (3)在main方法中分别调用不同的构造器创建的对象，并输出其属性值。 练习3： 1、写一个名为Account的类模拟账户。该类的属性和方法如下图所示。 该类包括的属性：账号id，余额balance，年利率annualInterestRate； 包含的方法：访问器方法（getter和setter方法），取款方法withdraw()，存款方法deposit()。 提示：在提款方法withdraw中，需要判断用户余额是否能够满足提款数额的要求，如果不能，应给出提示。 创建Customer类。 a. 声明三个私有对象属性：firstName、lastName和account。b. 声明一个公有构造器，这个构造器带有两个代表对象属性的参数（f和l）c. 声明两个公有存取器来访问该对象属性，方法getFirstName和getLastName返回相应的属性。d. 声明setAccount 方法来对account属性赋值。e. 声明getAccount 方法以获取account属性。 3.写一个测试程序。 （1）创建一个Customer ，名字叫 Jane Smith, 他有一个账号为1000，余额为2000元，年利率为 1.23％ 的账户。（2）对Jane Smith操作。存入 100 元，再取出960元。再取出2000元。打印出Jane Smith 的基本信息 1234成功存入 ：100.0成功取出：960.0余额不足，取款失败Customer [Smith, Jane] has a account: id is 1000, annualInterestRate is 1.23％, balance is 1140.0 11. 阶段性知识补充11.1 类中属性赋值过程1、在类的属性中，可以有哪些位置给属性赋值？ ① 默认初始化 ② 显式初始化 ③ 构造器中初始化 ④ 通过”对象.属性”或”对象.方法”的方式，给属性赋值 2、这些位置执行的先后顺序是怎样？ 顺序：① - ② - ③ - ④ 3、说明： 上述中的①、②、③在对象创建过程中，只执行一次。 ④ 是在对象创建后执行的，可以根据需求多次执行。 11.2 JavaBean JavaBean是一种Java语言写成的可重用组件。 好比你做了一个扳手，这个扳手会在很多地方被拿去用。这个扳手也提供多种功能(你可以拿这个扳手扳、锤、撬等等)，而这个扳手就是一个组件。 所谓JavaBean，是指符合如下标准的Java类： 类是公共的 有一个无参的公共的构造器 有属性，且有对应的get、set方法 用户可以使用JavaBean将功能、处理、值、数据库访问和其他任何可以用Java代码创造的对象进行打包，并且其他的开发者可以通过内部的JSP页面、Servlet、其他JavaBean、applet程序或者应用来使用这些对象。用户可以认为JavaBean提供了一种随时随地的复制和粘贴的功能，而不用关心任何改变。 《Think in Java》中提到，JavaBean最初是为Java GUI的可视化编程实现的。你拖动IDE构建工具创建一个GUI 组件（如多选框），其实是工具给你创建Java类，并提供将类的属性暴露出来给你修改调整，将事件监听器暴露出来。 示例 12345678910111213141516171819public class JavaBean &#123; private String name; // 属性一般定义为private private int age; public JavaBean() &#123; &#125; public int getAge() &#123; return age; &#125; public void setAge(int a) &#123; age = a; &#125; public String getName() &#123; return name; &#125; public void setName(String n) &#123; name = n; &#125;&#125; 11.3 UML类图 UML（Unified Modeling Language，统一建模语言），用来描述软件模型和架构的图形化语言。 常用的UML工具软件有PowerDesinger、Rose和Enterprise Architect。 UML工具软件不仅可以绘制软件开发中所需的各种图表，还可以生成对应的源代码。 在软件开发中，使用UML类图可以更加直观地描述类内部结构（类的属性和操作）以及类之间的关系（如关联、依赖、聚合等）。 +表示 public 类型， - 表示 private 类型，#表示protected类型 方法的写法:方法的类型(+、-) 方法名(参数名： 参数类型)：返回值类型 斜体表示抽象方法或类。","categories":[{"name":"java基础","slug":"java基础","permalink":"http://example.com/categories/java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"java","slug":"java","permalink":"http://example.com/tags/java/"}]},{"title":"第01章_Java语言概述","slug":"Java/尚硅谷_第01章_Java语言概述/尚硅谷_宋红康_第01章_Java语言概述","date":"2022-09-27T00:55:54.000Z","updated":"2023-10-07T11:52:09.719Z","comments":true,"path":"2022/09/27/Java/尚硅谷_第01章_Java语言概述/尚硅谷_宋红康_第01章_Java语言概述/","link":"","permalink":"http://example.com/2022/09/27/Java/%E5%B0%9A%E7%A1%85%E8%B0%B7_%E7%AC%AC01%E7%AB%A0_Java%E8%AF%AD%E8%A8%80%E6%A6%82%E8%BF%B0/%E5%B0%9A%E7%A1%85%E8%B0%B7_%E5%AE%8B%E7%BA%A2%E5%BA%B7_%E7%AC%AC01%E7%AB%A0_Java%E8%AF%AD%E8%A8%80%E6%A6%82%E8%BF%B0/","excerpt":"","text":"第01章_Java语言概述 1. Java知识脉络图1.1 Java基础全程脉络图 1.2 本章专题与脉络 2. 抽丝剥茧话Java2.1 当前大学生就业形势 麦可思研究院发布了《2022年中国大学生就业报告》，针对2021届毕业生收入较高的本科专业排行榜： 麦可思研究院发布过《2021年中国大学生就业报告》，应届本科毕业生就业数量较大的前十位行业类的就业质量： 报告还对毕业三年后的2017届毕业生所在十大行业进行了统计： 从国家统计局发布的2021年全国平均工资来看，不管在城镇非私营单位还是私营单位，IT业均为最高。 2.2 IT互联网是否依旧靠谱过去不能代表未来！互联网是否依旧靠谱？！ 2014 年至 2018 年间，我国网民规模从 6.49 亿增长为 8.29 亿，增幅为 27.5%。同一时间段，全国移动互联网接入的流量却从 20.6EB 增长到了 711.1EB，增幅达 3352%（获取和处理的信息量大幅增加）。 随着 5G 技术进一步拓宽移动互联网的速度和容量，产业互联网将在消费型流量的基础上创造生产型流量，根据报告的预测，至 2024 年，全国移动互联网的接入流量将达到 127663.8EB， 流量规模达到2018年的179.5倍。 当下，5G、物联网、人工智能、产业互联网都是国家政策大方向，需要大量能与机器对话的中高端人才。 2.3 IT行业岗位分析 软件开发，是进入互联网IT圈最好的选择之一！ 起始薪资高 工作环境好 涨薪幅度高 行业更公平 2.4 软件开发之Java开发 移动应用领域（集成Android平台）：Java在Android端是主要开发的语言，占有重要的地位。 企业级应用领域（JavaEE后台）：用来开发企业级的应用程序，大型网站如淘宝、京东、12306，以及各大物流、银行、金融、社交、医疗、交通、各种OA系统等都是用JavaEE技术开发的。 大数据分析、人工智能领域：流行的大数据框架，如Hadoop、Flink都是用Java编写的。Spark使用Scala编写，但可以用Java开发应用。 Eversoft公司在提到2022年Java发展趋势时写道： Java 是用于开发大数据项目的最主流的语言。我们可以轻松地预测它也将在之后继续主导大数据！ 游戏领域、桌面应用、嵌入式领域：很多大型游戏的后台、桌面应用等也是Java开发的。 2.5 到底多少人在用Java 2020年，根据 IDC 的报告“Java Turns 25”显示，超过 900 万名开发人员（全球专职开发人员中的 69%）在使用 Java——比其他任何语言都多。该报告指出，大多数企业业务服务都依靠 Java 来实现。 … Java 一直是开发人员中最流行的编程语言，被誉为“宇宙第一语言”。 我想告诉大家： “市场的需求比较大，市场的供给比较大” “如果你在Java领域里持续积累5-7年以上，那么你至少会成为这个行业的一个专家！” 2.6 八卦一下程序员 还可以是： 2.7 Java系列课程体系 见02_学习路线图之《Java中高级程序员全程学习路线图.xmind》 2.8 Java职业晋升路线图 薪资数据统计来源：拉勾网 3. 计算机的硬件与软件3.1 计算机组成：硬件+软件 3.2 CPU、内存与硬盘 CPU（Central Processing Unit，中央处理器） 人靠大脑思考，电脑靠CPU来运算、控制。 硬盘（Hard Disk Drive） 计算机最主要的存储设备，容量大，断电数据不丢失。 正常分类：机械硬盘（HDD）、固态硬盘（SSD）以及混合硬盘（SSHD） 固态硬盘在开机速度和程序加载速度远远高于机械硬盘，缺点就是贵，所有无法完全取代机械硬盘。 内存（Memory） 负责硬盘上的数据与CPU之间数据交换处理 具体的：保存从硬盘读取的数据，提供给CPU使用；保存CPU的一些临时执行结果，以便CPU下次使用或保存到硬盘。 断电后数据丢失。 3.3 输入设备：键盘输入 熟悉指法 不熟悉键盘的小伙伴，可以“金山打字通”走起了。坚决杜绝二指禅！！ 4. 软件相关介绍4.1 什么是软件软件，即一系列按照特定顺序组织的计算机数据和指令的集合。有系统软件和应用软件之分。 Pascal之父Nicklaus Wirth： “Programs &#x3D; Data Structures + Algorithms” 系统软件： 应用软件： 4.2 人机交互方式 图形化界面（Graphical User Interface，GUI），这种方式简单直观，使用者易于接受，容易上手操作。 命令行方式（Command Line Interface，CLI），需要在控制台输入特定的指令，让计算机完成一些操作。需要记忆一些指令，较为麻烦。 4.3 常用的DOS命令DOS（Disk Operating System，磁盘操作系统）是Microsoft公司在Windows之前推出的一个操作系统，是单用户、单任务（即只能执行一个任务）的操作系统。现在被Windows系统取代。 对于Java初学者，学习一些DOS命令，会非常有帮助。 进入DOS操作窗口： 按下Windows+R键盘，打开运行窗口，输入cmd回车，进入到DOS的操作窗口。 常用指令： 操作1：进入和回退 操作 说明 盘符名称: 盘符切换。E:回车，表示切换到E盘。 dir 列出当前目录下的文件以及文件夹 cd 目录 进入指定单级目录。 cd 目录1\\目录2\\… 进入指定多级目录。cd atguigu\\JavaSE cd .. 回退到上一级目录。 cd \\ 或 cd &#x2F; 回退到盘符目录。 操作2：增、删 操作 说明 md 文件目录名 创建指定的文件目录。 rd 文件目录名 删除指定的文件目录（如文件目录内有数据，删除失败） 操作3：其它 操作 说明 cls 清屏。 exit 退出命令提示符窗口。 ← → 移动光标 ↑ ↓ 调阅历史操作命令 Delete和Backspace 删除字符 5. 计算机编程语言5.1 计算机语言是什么 语言：是人与人之间用于沟通的一种方式。例如：中国人与中国人用普通话沟通。而中国人要和英国人交流，可以使用英语或普通话。 计算机编程语言，就是人与计算机交流的方式。人们可以使用编程语言对计算机下达命令，让计算机完成人们需要的功能。 计算机语言有很多种。如：C 、C++、Java、Go、JavaScript、Python，Scala等。 体会：语言 &#x3D; 语法 + 逻辑 5.2 计算机语言简史 第一代：机器语言（相当于人类的石器时代） 1946年2月14日，世界上第一台计算机ENAC诞生，使用的是最原始的穿孔卡片。这种卡片上使用的是用二进制代码表示的语言，与人类语言差别极大，这种语言就称为机器语言。比如一段典型的机器码： 1231. 0000,0000,000000010000 代表 LOAD A, 162. 0000,0001,000000000001 代表 LOAD B, 13. 0001,0001,000000010000 代表 STORE B, 16 这种语言本质上是计算机能识别的唯一语言，人类很难理解。可以大胆想象”此时的程序员99.9%都是异类！“ 第二代：汇编语言（相当于人类的青铜&amp;铁器时代） 使用英文缩写的助记符来表示基本的操作，这些助记符构成了汇编语言的基础。比如：LOAD、MOVE等，使人更容易使用。因此，汇编语言也称为符号语言。 优点：能编写高效率的程序 缺点：汇编语言是面向机器的，不同计算机机型特点不同，因此会有不同的汇编语言，彼此之间不能通用。程序不易移植，较难调试。 比起机器语言，汇编大大进步了，是机器语言向更高级的语言进化的桥梁。目前仍然应用于工业电子编程领域、软件的加密解密、计算机病毒分析等。 第三代：高级语言（相当于人类的信息时代） 高级语言发展于20世纪50年代中叶到70年代，是一种接近于人们使用习惯的程序设计语言。它允许程序员使用接近日常英语的指令来编写程序，程序中的符号和算式也与日常用的数学式子差不多，接近于自然语言和数学语言，容易为人们掌握。比如： 高级语言独立于机器，有一定的通用性；计算机不能直接识别和执行用高级语言编写的程序，需要使用编译器或者解释器，转换为机器语言才能被识别和执行。 此外，高级语言按照程序设计方法的不同，又分为：面向过程的语言、面向对象的语言。 C、Pascal、Fortran面向过程的语言 C++面向过程&#x2F;面向对象 Java跨平台的纯面向对象的语言 C#、Python、JavaScript、Scala… 目前以及可预见的将来，计算机语言仍然处于“第三代高级语言”阶段。但是不管是什么语言，最后都要向机器语言靠近，因为CPU只认识0和1。 5.3 计算机语言排行榜TIOBE （https://www.tiobe.com/tiobe-index/）是一个流行编程语言排行，每月更新。排名权重基于世界范围内 工程师数量，Google、Bing、Yahoo! 、Wikipedia、Amazon、Youtube和百度这些主流的搜索引擎，也将作为排名权重的参考指标。 计算机语言走势 5.4 编程语言，该学哪个？ 网传的编程语言鄙视链： C语言：万物之源 诞生于1972年，由AT&amp;T公司旗下贝尔实验室创建完成，用于构建Unix操作系统。 偏向计算机底层操作（操作系统、网络、硬件驱动等）。 优势：几乎所有现代编程语言都脱胎于C 劣势：相当陡的学习曲线；不支持面向对象编程 C++语言：难学的语言 诞生于1983年，作为C语言的增强方案、升级版本。C++是C语言的超集，C语言的大部分知识也适用于C++。 用途：windows 或 MacOS UI、office全家桶、主流的浏览器、Oracle、MySQL、著名的游戏引擎（如星际争霸、魔兽世界）等 优势：很多公司都用 C++ 开发核心架构，如 Google、腾讯、百度、阿里云等；面向对象性 劣势：体系极为庞大，这是世界目前来说最复杂也是最难的编程语言。 C#语言：背靠大树的语言 诞生于2000年，一款强大而灵活的编程语言。靠着微软这棵大树，是多年来windows平台的一门主流编程语言。 用途：windows桌面应用开发、Windows Azure、游戏开发 PHP语言：最好的语言？ 诞生于1994年，一款服务器端脚本语言。最初表示个人主页（Personal Home Page） PHP语法和C类似，有很多的模板和框架，简单易懂，也许你可以在短短几天做出web app。它主要用于web端，快速建站网络开发 劣势：学习门槛太低；其代码运行速度低于大部分编程语言党争对手 Python：易学的语言 诞生于1991年，一种面向对象的语言，虽然运行效率不高，但是开发效率非常高。 Python被称为胶水语言，哪里都可以用。 JavaScript语言：前端为王 诞生于1995年，网景公司开发完成。 JavaScript是JavaScript 是目前所有主流浏览器上唯一支持的脚本语言。在前端开发中，占有不可替代的地位。 Java语言：需求旺盛 创建于1995年，Java是一种面向对象、基于类的编程语言。 Java可能是目前运用最广的项目语言。代码稳定性超过 C 和 C++，生产力远超 C 和 C++。有 JVM 在，可以轻松地跨平台。 具有强大的开源开发工具，大量的开源共享库。 Java拥有世界上数量最多的程序员，最不缺人。 Go语言：夹缝中生存 Go 语言现在很受关注，它是取代 C 和 C++ 的另一门有潜力的语言。 C 语言太原始了，C++ 太复杂了，Java 太高级了，所以 Go 语言就在这个夹缝中出现了。 Go语言已成为云计算领域事实上的标准语言，尤其是在 Docker&#x2F;Kubernetes 等项目中。 Go 语言语法特别简单，你有了 C 和 C++ 的基础，学习 Go 的学习成本基本为零。 Go社区从Java社区移植了各种优秀的框架或库。 总结： 程序设计语言有很多种，每种语言都是为了实现某个特定的目的而发明的。 没有“最好”的语言，只有在特定场景下相对来说，最适合的语言而已。 如果你掌握了一种编程语言，也会更容易上手其它的编程语言。关键是学习如何使用程序设计方法来解决问题。这也是本套课程的主旨。 Talk is cheap，Show me the code。 6. Java语言概述6.1 Java概述 是SUN(Stanford University Network，斯坦福大学网络公司 ) 1995年推出的一门高级编程语言。 是一种面向Internet的编程语言。Java一开始富有吸引力是因为Java程序可以在Web浏览器中运行。这些Java程序被称为Java小程序（applet），内嵌在HTML代码中。 伴随着互联网的迅猛发展，以及Java技术在web方面的不断成熟，已经成为Web应用程序的首选开发语言。 6.2 Java语言简史起步阶段： 1991年，Sun公司的工程师小组想要设计一种语言，应用在电视机、电话、闹钟、烤面包机等家用电器的控制和通信。由于这些设备的处理能力和内存都很有限，并且不同的厂商会选择不同的中央处理器(CPU)，因此这种语言的关键是代码短小、紧凑且与平台无关（即不能与任何特定的体系结构捆绑在一起）。 Gosling团队率先创造了这个语言，并命名为“Oak“（起名的原因是因为他非常喜欢自己办公室外的橡树)。后因智能化家电的市场需求没有预期的高，Sun公司放弃了该项计划。 随着20世纪90年代互联网的发展，Sun公司发现该语言在互联网上应用的前景，于是改造了Oak，于1995年5月以Java的名称正式发布。（Java是印度尼西亚爪哇岛的英文名称，因盛产咖啡而闻名。） 发展阶段： 发行版本 发行时间 备注 Java 1.0 1996.01.23 Sun公司发布了Java的第一个开发工具包 Java 1.1 1997.02.19 JavaOne会议召开，创当时全球同类会议规模之最。 Java 1.2 1998.12.08 Java拆分成：J2SE（标准版）、J2EE（企业版）、J2ME（小型版） Java 1.3 2000.05.08 Java1.4 2004.02.06 Java 5.0 2004.09.30 ①版本号从1.4直接更新至5.0；②平台更名为JavaSE、JavaEE、JavaME Java 6.0 2006.12.11 2009.04.20 Oracle宣布收购SUN公司 2009.04.20 Oracle公司收购SUN，交易价格74亿美元。 Java 7.0 2011.07.02 Java 8.0 2014.03.18 此版本是继Java 5.0以来变化最大的版本。是长期支持版本（LTS） Java 9.0 2017.09.22 ①此版本开始，每半年更新一次；②Java 9.0开始不再支持windows 32位系统 Java 10.0 2018.03.21 Java 11.0 2018.09.25 JDK安装包取消独立JRE安装包，是长期支持版本（LTS） Java 12.0 2019.03.19 … … Java17.0 2021.09 发布Java 17.0，版本号也称为21.9，是长期支持版本。 … … Java19.0 2022.09 发布Java19.0，版本号也称为22.9。 6.3 Java之父 詹姆斯·高斯林(James Gosling)先生以“Java 技术之父”而闻名于世。他是Java 技术的创始人，他亲手设计了Java语言，并开发了Java编译器和Java虚拟机，使Java成为了世界上最流行的开发语言。 James Gosling于1984 年加入Sun公司，并一直服务于Sun公司，直至2010年前后，Sun被Oracle并购而加入Oracle，担任客户端软件集团的首席技术官; 2010年4月从Oracle离职。 6.4 公司八卦 SUN 与 Oracle SUN是一家极具创新能力的公司，2001年 “9.11”以前，SUN公司市值超过1000亿美元。 但是没能利用Java构建一个强有力、可变现的生态系统，没打好Java这张牌。此后，互联网泡沫破裂，硬件需求大幅减少，它的市值在一个月之内跌幅超过90%。SUN公司的成长用了20年，而衰落只用了1年！ Oracle 与 Google Google和Oracle的侵权事件： 2010 年 8 月，Oracle 起诉 Google 的 Android 系统侵权，要求赔偿 26 亿美元。 Oracle认为Google的代码中使用了Java的37个API，并且认为Google是故意为之，因为这样做的好处是可以让更多的Java程序员更容易接受Android的代码。 Oracle认为Android 中有9行代码直接抄袭了Java的实现。这9行牛气哄哄的代码都出自一人之手，他就是Java 大牛——Joshua Bloch。 2018 年 3 月，美国联邦巡回上诉法院裁决，谷歌侵犯了甲骨文的版权，支付高达88亿美元的赔偿金。 2021 年 4 月，美国最高法院给出了最终裁决：谷歌胜诉，其代码属于“合理使用”的范畴。为期十多年的软件行业“第一版权案”落幕。 12345678910//Code In OpenJDK / Android ：1. private static void rangeCheck(int arrayLen, int fromIndex, int toIndex) &#123;2. if (fromIndex &gt; toIndex)3. throw new IllegalArgumentException(&quot;fromIndex(&quot; + fromIndex +4. &quot;) &gt; toIndex(&quot; + toIndex+&quot;)&quot;);5. if (fromIndex &lt; 0)6. throw new ArrayIndexOutOfBoundsException(fromIndex);7. if (toIndex &gt; arrayLen)8. throw new ArrayIndexOutOfBoundsException(toIndex);9. &#125; 6.5 Java技术体系平台 Java SE(Java Standard Edition)标准版 支持面向桌面级应用（如Windows下的应用程序）的Java平台，即定位个人计算机的应用开发。 包括用户界面接口AWT及Swing，网络功能与国际化、图像处理能力以及输入输出支持等。 此版本以前称为J2SE Java EE(Java Enterprise Edition)企业版 为开发企业环境下的应用程序提供的一套解决方案，即定位在服务器端的Web应用开发。 JavaEE是JavaSE的扩展，增加了用于服务器开发的类库。如：Servlet能够延伸服务器的功能，通过请求-响应的模式来处理客户端的请求；JSP是一种可以将Java程序代码内嵌在网页内的技术。 版本以前称为J2EE Java ME(Java Micro Edition)小型版 支持Java程序运行在移动终端（手机、机顶盒）上的平台，即定位在消费性电子产品的应用开发 JavaME是JavaSE的内伸，精简了JavaSE 的核心类库，同时也提供自己的扩展类。增加了适合微小装置的类库：javax.microedition.io.*等。 此版本以前称为J2ME 注意： Android开发不等同于Java ME的开发 7. Java开发环境搭建（掌握）7.1 什么是JDK、JRE JDK (Java Development Kit)：是Java程序开发工具包，包含JRE 和开发人员使用的工具。 **JRE ** (Java Runtime Environment) ：是Java程序的运行时环境，包含JVM 和运行时所需要的核心类库。 如下是Java 8.0 Platform： 小结： JDK &#x3D; JRE + 开发工具集（例如Javac编译工具等） JRE &#x3D; JVM + Java SE标准类库 7.2 JDK版本选择 自Java 8版本发布以来，其后的每次更新，都会有小伙伴高呼：Java8 YYDS！ 论坛的声音：“你发任你发，我用Java 8！” 数据说话1： JRebel 于2022年4月前后发布了《2022 年Java生态系统状况报告》，报告中提到使用Java11 的占比最多，Java 8 紧随其后，如下图。而此前2020年的报告显示，Java8占比达到了84.48%。 我的分析： G1是最受欢迎的GC算法。Java 11及更高版本的G1收集器是默认的GC，而Java 8中并不是。出于对G1的喜爱，很多开发者才会选择抛弃Java 8。 数据说话2： 此外，某美国软件开发商在对近千名专业的Java开发者调研后，发布的《2022年Java开发者生产力报告》称：八年前发布的Java 8依然是Java中应用最广泛的版本，占比 37%，其次是 Java 11，占比29% 。 高斯林说话： Spring框架说话： 在Java 17正式发布之前，Java开发框架Spring率先在官博宣布，Spring Framework 6和Spring Boot 3计划在2022年第四季度实现总体可用性的高端基线： Java 17+(来自 Spring Framework 5.3.x 线中的 Java 8-17) Jakarta EE 9+（来自Spring框架5.3.x 线中的 Java EE 7-8） Spring 官方说明：https://spring.io/blog/2022/01/20/spring-boot-3-0-0-m1-is-now-available 意味着：springboot3.0 是需要用java17和spring6.0为基础建设。如果从企业选型最新springboot3.0作为架构来说，它搭配jdk17肯定是标配了。 7.3 JDK的下载 下载网址（Oracle公司官网）：www.oracle.com 下载步骤：如图所示，在官网底部选择Developers开发者 （1）在Developers页面中间的技术分类部分，选择Java，单击进入，如图所示： （2）这里展示的是最新Java版本，例如Java17。单击Download Java，然后选择具体的版本下载。 （3）选择Download Java按钮后 （4）如果想安装Java8 可以选择如下位置： （5）选择Accept License Agreement， （6）注册或登录后下载： （7）如果需要安装其它版本，可以选择Java archive： 接着进行选择下载即可： 7.4 JDK的安装 安装说明 傻瓜式安装，下一步即可。 建议：安装路径不要有中文或者空格等特殊符号。 本套课程会同时安装JDK8 和 JDK17，并以JDK17为默认版本进行讲解。 安装步骤： （1）双击jdk-17_windows-x64_bin.exe文件，并单击下一步，如图所示： （2）修改安装路径，单击更改，如图所示： （3）将安装路径修改为D:\\develop_tools\\jdk\\jdk-17.0.2\\，并单击下一步，如图所示： （4）稍后几秒，安装完成，如图所示： 7.5 配置path环境变量7.5.1 理解path环境变量什么是path环境变量？ 答：window操作系统执行命令时，所要搜寻的路径。 为什么配置path？ 答：希望在命令行使用javac.exe等工具时，任意目录下都可以找到这个工具所在的目录。 以JDK为例演示 我们在C:\\Users\\songhk目录下使用javac命令，结果如下： 我们在JDK的安装目录的bin目录下使用javac命令，结果如下： 我们不可能每次使用java.exe，javac.exe等工具的时候都进入到JDK的安装目录下，太麻烦了。这时就需要配置path环境变量。 7.5.2 JDK8配置方案1：只配置path 步骤： （1）打开桌面上的计算机，进入后在左侧找到此电脑，单击鼠标右键，选择属性，如图所示： （2）选择高级系统设置，如图所示： （3）在高级选项卡，单击环境变量，如图所示： （4）在系统变量中，选中Path 环境变量，双击或者点击编辑 ,如图所示： （5）点击新建，填入D:\\develop_tools\\jdk\\jdk1.8.0_271\\bin ，并将此值上移到变量列表的首位。如图所示： 编辑模式1： 编辑模式2：（注意，结尾需要有英文模式下的;） （6）环境变量配置完成，重新开启DOS命令行，在任意目录下输入javac 或java命令或java -version，运行成功。 7.5.3 JDK8配置方案2：配置JAVA_HOME+path（推荐） 步骤： （1）打开桌面上的计算机，进入后在左侧找到计算机，单击鼠标右键，选择属性，如图所示： （2）选择高级系统设置，如图所示： （3）在高级选项卡，单击环境变量，如图所示： （4）在系统变量中，单击新建 ，创建新的环境变量，如图所示： （5）变量名输入JAVA_HOME，变量值输入 D:\\develop_tools\\jdk\\jdk1.8.0_271 ，单击确定，如图所示： （6）选中Path 环境变量，双击或者点击编辑 ，如图所示： （7）在变量值的最前面，键入%JAVA_HOME%\\bin。如图所示： 注意：强烈建议将%JAVA_HOME%\\bin声明在path环境变量中所有变量的最前面！ （8）环境变量配置完成，重启DOS命令行，在任意目录下输入javac 或java命令或java -version，运行成功。 我想说： 有的书籍、论坛、视频上还提到配置classpath，用于指名class文件识别的路径。其实是没必要的，反而建议大家如果配置了classpath环境变量，要删除。对于初学者，反而不友好。 小结如下： 7.5.4 JDK17配置方案：自动配置不管大家有没有提前安装JDK8或其它版本JDK，在我们安装完JDK17之后，理应按JDK8的方式配置path环境变量。但是，我们发现在安装完JDK17以后，配置环境变量之前，执行CMD指令： 竟然成功了！而且是17.0.2版本。因为JDK17在安装之后，自动进行了环境变量的配置。如下： 这里建议，将JDK17安装的路径，设置为JAVA_HOME，并将%JAVA_HOME%\\bin上移到首位。 思考：如果你仍然希望在JDK8下开发Java程序？如何做呢？ 8. 开发体验：HelloWorld（掌握）JDK安装完毕，我们就可以开发第一个Java程序了，习惯性的称为：HelloWorld。 8.1 开发步骤Java程序开发三步骤：编写、编译、运行。 将 Java 代码编写到扩展名为 .java 的源文件中 通过 javac.exe 命令对该 java 文件进行编译，生成一个或多个字节码文件 通过 java.exe 命令对生成的 class 文件进行运行 8.2 编写（1）在D:\\JavaSE\\chapter01 目录下新建文本文件，完整的文件名修改为HelloWorld.java，其中文件名为HelloWorld，后缀名必须为.java。 （2）用记事本或editplus等文本编辑器打开（虽然记事本也可以，但是没有关键字颜色标识，不利于初学者学习） （3）在文件中输入如下代码，并且保存： 12345class HelloChina &#123; public static void main(String[] args) &#123; System.out.println(&quot;HelloWorld!!&quot;); &#125;&#125; 友情提示1：每个字母和符号必须与示例代码一模一样，包括大小写在内。 友情提示2： 或 第一个HelloWord 源程序就编写完成了，但是这个文件是程序员编写的，JVM是看不懂的，也就不能运行，因此我们必须将编写好的Java源文件 编译成JVM可以看懂的字节码文件 ，也就是.class文件。 8.3 编译在DOS命令行中，进入D:\\JavaSE\\chapter01目录，使用javac 命令进行编译。 使用文件资源管理器打开D:\\JavaSE\\chapter01目录，然后在地址栏输入cmd。 命令： 1javac Java源文件名.后缀名java 举例： 1javac HelloWorld.java 编译成功后，命令行没有任何提示。打开D:\\JavaSE\\chapter01目录，发现产生了一个新的文件 HelloChina.class，该文件就是编译后的文件，是Java的可运行文件，称为字节码文件，有了字节码文件，就可以运行程序了。 8.4 运行在DOS命令行中，在字节码文件目录下，使用java 命令进行运行。 命令： 1java 主类名字 主类是指包含main方法的类，main方法是Java程序的入口： 123public static void main(String[] args)&#123; &#125; 举例： 1java HelloChina 错误演示： java HelloChina.class 9. Java开发工具9.1 都有哪些开发Java的工具 级别一：文本开发工具 级别二：集成开发环境（Integrated Development Environment，IDE） 把代码编写，编译，执行，调试等多种功能综合到一起的开发工具。 9.2 如何选择前期我们先使用文本开发工具，培养代码感，利于公司笔、面试。 后期我们使用IDE，提供更强大的功能支持。 10. HelloWorld案例常见错误10.1 拼写问题 单词拼写问题 正确：class 错误：Class 正确：String 错误：string 正确：System 错误：system 正确：main 错误：mian Java语言是一门严格区分大小写的语言 标点符号使用问题 不能用中文符号，英文半角的标点符号（正确） 括号问题，成对出现 10.2 编译、运行路径问题举例1： 源文件名不存在或者写错 当前路径错误 后缀名隐藏问题 举例2： 类文件名写错，尤其文件名与类名不一致时，要小心 类文件不在当前路径下，或者不在classpath指定路径下 10.3 语法问题举例1： 声明为public的类应与文件名一致，否知编译失败。 举例2： 编译失败，注意错误出现的行数，再到源代码中指定位置改错 10.4 字符编码问题当cmd命令行窗口的字符编码与.java源文件的字符编码不一致，如何解决？ 解决方案一： 在Notepad++等编辑器中，修改源文件的字符编码： 在EditPlus中可以将Java源文件另存为ANSI编码方式（中文操作系统下即为GBK字符集） 解决方案二： 在使用javac命令式，可以指定源文件的字符编码 1javac -encoding utf-8 Review01.java 10.5 建议 注意缩进! 一定要有缩进。缩进就像人得体的衣着一样！ 只要遇到{}就缩进，缩进的快捷键tab键。 必要的空格 变量类型、变量、赋值符号、变量值之间填充相应空格，更美观。比如： int num &#x3D; 10; 11. HelloWorld小结11.1 Java程序的结构与格式结构： 12345类&#123; 方法&#123; 语句; &#125;&#125; 格式： （1）每一级缩进一个Tab键 （2）{}的左半部分在行尾，右半部分单独一行，与和它成对的”{“的行首对齐 11.2 Java程序的入口Java程序的入口是main方法 123public static void main(String[] args)&#123; &#125; 11.3 两种常见的输出语句 换行输出语句：输出内容，完毕后进行换行，格式如下： 1System.out.println(输出内容); 直接输出语句：输出内容，完毕后不做任何处理，格式如下 1System.out.print(输出内容); 注意事项： ​ 换行输出语句，括号内可以什么都不写，只做换行处理 ​ 直接输出语句，括号内什么都不写的话，编译报错 11.4 源文件名与类名（1）源文件名是否必须与类名一致？public呢？ 12345如果这个类不是public，那么源文件名可以和类名不一致。但是不便于代码维护。如果这个类是public，那么要求源文件名必须与类名一致。否则编译报错。我们建议大家，不管是否是public，都与源文件名保持一致，而且一个源文件尽量只写一个类，目的是为了好维护。 （2）一个源文件中是否可以有多个类？public呢？ 123一个源文件中可以有多个类，编译后会生成多个.class字节码文件。但是一个源文件只能有一个public的类。 12. 注释(comment) 什么是注释？ 源文件中用于解释、说明程序的文字就是注释。 注释是一个程序员必须要具有的良好编程习惯。实际开发中，程序员可以先将自己的思想通过注释整理出来，再用代码去体现。 程序员最讨厌两件事： 一件是自己写代码被要求加注释 另一件是接手别人代码，发现没有注释 不加注释的危害 Java中的注释类型： 单行注释 1//注释文字 多行注释 12345/* 注释文字1 注释文字2注释文字3*/ 文档注释 (Java特有) 1234/** @author 指定java程序的作者 @version 指定源文件的版本*/ 注释的作用 它提升了程序的可阅读性。（不加注释的危害性，见图。） 调试程序的重要方法。 具体使用1：单行注释、多行注释 对于单行和多行注释，被注释的文字，不会不会出现在字节码文件中，进而不会被JVM（java虚拟机）解释执行。 多行注释里面不允许有多行注释嵌套。 一个段子 12345678910111213141516A：嘿 //是什么意思啊？B：嘿.A：呃 我问你//是什么意思？B：问吧.A：我刚才不是问了么？B：啊？A：你再看看记录...B：看完了.A：......所以//是啥？B：所以什么？A：你存心耍我呢吧？B：没有啊 你想问什么？……不断循环之后，A一气之下和B绝交，自己苦学程序。N年之后，A终于修成正果，回想起B，又把聊天记录翻出来看，这时，他突然发现B没有耍他……而他自己也不知道当年他问B的究竟是什么问题…… 具体使用2：文档注释（Java特有） 文档注释内容可以被JDK提供的工具 javadoc 所解析，生成一套以网页文件形式体现的该程序的说明文档。 操作方式。比如： 1javadoc -d mydoc -author -version HelloWorld.java 案例： 12345678910111213141516171819//单行注释/*多行注释*//**文档注释演示。这是我的第一个Java程序！^_^@author songhk@version 1.0*/public class HelloWorld&#123; /** Java程序的入口 @param args main方法的命令参数 */ public static void main(String[] args)&#123; System.out.println(&quot;hello&quot;); &#125;&#125; 13. Java API文档 API （Application Programming Interface，应用程序编程接口）是 Java 提供的基本编程接口。 Java语言提供了大量的基础类，因此 Oracle 也为这些基础类提供了相应的说明文档，用于告诉开发者如何使用这些类，以及这些类里包含的方法。大多数Java书籍中的类的介绍都要参照它来完成，它是编程者经常查阅的资料。 Java API文档，即为JDK使用说明书、帮助文档。类似于： 下载API文档： 在线看：https://docs.oracle.com/en/java/javase/17/docs/api/index.html 离线下载：https://www.oracle.com/java/technologies/javase-jdk17-doc-downloads.html 14. Java核心机制：JVM14.1 Java语言的优缺点Java确实是从C语言和C++语言继承了许多成份，甚至可以将Java看成是类C语言发展和衍生的产物。“青出于蓝，而胜于蓝”。 14.1.1 优点 跨平台性：这是Java的核心优势。Java在最初设计时就很注重移植和跨平台性。比如：Java的int永远都是32位。不像C++可能是16，32，可能是根据编译器厂商规定的变化。 通过Java语言编写的应用程序在不同的系统平台上都可以运行。“Write once , Run Anywhere”。 原理：只要在需要运行 java 应用程序的操作系统上，先安装一个Java虚拟机 (JVM ，Java Virtual Machine) 即可。由JVM来负责Java程序在该系统中的运行。 面向对象性： 面向对象是一种程序设计技术，非常适合大型软件的设计和开发。面向对象编程支持封装、继承、多态等特性，让程序更好达到高内聚，低耦合的标准。 健壮性：吸收了C&#x2F;C++语言的优点，但去掉了其影响程序健壮性的部分（如指针、内存的申请与释放等），提供了一个相对安全的内存管理和访问机制。 安全性高： Java适合于网络&#x2F;分布式环境，需要提供一个安全机制以防恶意代码的攻击。如：安全防范机制（ClassLoader类加载器），可以分配不同的命名空间以防替代本地的同名类、字节代码检查。 简单性： Java就是C++语法的简化版，我们也可以将Java称之为“C++--”。比如：头文件，指针运算，结构，联合，操作符重载，虚基类等。 高性能： Java最初发展阶段，总是被人诟病“性能低”；客观上，高级语言运行效率总是低于低级语言的，这个无法避免。Java语言本身发展中通过虚拟机的优化提升了几十倍运行效率。比如，通过JIT(JUST IN TIME)即时编译技术提高运行效率。 Java低性能的短腿，已经被完全解决了。业界发展上，我们也看到很多C++应用转到Java开发，很多C++程序员转型为Java程序员。 14.1.2 缺点 语法过于复杂、严谨，对程序员的约束比较多，与python、php等相比入门较难。但是一旦学会了，就业岗位需求量大，而且薪资待遇节节攀升。 一般适用于大型网站开发，整个架构会比较重，对于初创公司开发和维护人员的成本比较高（即薪资高），选择用Java语言开发网站或应用系统的需要一定的经济实力。 并非适用于所有领域。比如，Objective C、Swift在iOS设备上就有着无可取代的地位。浏览器中的处理几乎完全由JavaScript掌控。Windows程序通常都用C++或C#编写。Java在服务器端编程和跨平台客户端应用领域则很有优势。 14.2 JVM功能说明JVM（Java Virtual Machine ，Java虚拟机）：是一个虚拟的计算机，是Java程序的运行环境。JVM具有指令集并使用不同的存储区域，负责执行指令，管理数据、内存、寄存器。 14.2.1 功能1：实现Java程序的跨平台性我们编写的Java代码，都运行在JVM 之上。正是因为有了JVM，才使得Java程序具备了跨平台性。 使用JVM前后对比： 14.2.2 功能2：自动内存管理(内存分配、内存回收) Java程序在运行过程中，涉及到运算的数据的分配、存储等都由JVM来完成 Java消除了程序员回收无用内存空间的职责。提供了一种系统级线程跟踪存储空间的分配情况，在内存空间达到相应阈值时，检查并释放可被释放的存储器空间。 GC的自动回收，提高了内存空间的利用效率，也提高了编程人员的效率，很大程度上减少了因为没有释放空间而导致的内存泄漏。 面试题： Java程序还会出现内存溢出和内存泄漏问题吗？ Yes! 15. 章节案例案例1：个人信息输出 12345678class Exercise1&#123; public static void main(String[] args)&#123; System.out.println(&quot;姓名：康师傅&quot;); System.out.println();//换行操作 System.out.println(&quot;性别：男&quot;); System.out.println(&quot;家庭住址：北京程序员聚集地：回龙观&quot;); &#125;&#125; 案例2：输出：心形 结合\\n(换行)，\\t(制表符)，空格等在控制台打印出如下图所示的效果。 方式一： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586//方式一：class Exercise2&#123; public static void main(String[] args)&#123; System.out.print(&quot;\\t&quot;); System.out.print(&quot;*&quot;); System.out.print(&quot;\\t&quot;); System.out.print(&quot;\\t&quot;); System.out.print(&quot;\\t&quot;); System.out.print(&quot;\\t&quot;); System.out.print(&quot;\\t&quot;); System.out.print(&quot;\\t&quot;); System.out.print(&quot;\\t&quot;); System.out.println(&quot;*&quot;); System.out.print(&quot;*&quot;); System.out.print(&quot;\\t&quot;); //System.out.print(&quot;\\t&quot;); System.out.print(&quot;\\t&quot;); System.out.print(&quot;\\t&quot;); System.out.print(&quot;I love java&quot;); System.out.print(&quot;\\t&quot;); System.out.print(&quot;\\t&quot;); System.out.print(&quot;\\t&quot;); System.out.print(&quot;\\t&quot;); System.out.print(&quot;\\t&quot;); System.out.println(&quot;*&quot;); System.out.print(&quot;\\t&quot;); System.out.print(&quot;*&quot;); System.out.print(&quot;\\t&quot;); System.out.print(&quot;\\t&quot;); System.out.print(&quot;\\t&quot;); System.out.print(&quot;\\t&quot;); System.out.print(&quot;\\t&quot;); System.out.print(&quot;\\t&quot;); System.out.print(&quot;\\t&quot;); System.out.println(&quot;*&quot;); System.out.print(&quot;\\t&quot;); System.out.print(&quot;\\t&quot;); System.out.print(&quot;*&quot;); System.out.print(&quot;\\t&quot;); System.out.print(&quot;\\t&quot;); System.out.print(&quot;\\t&quot;); System.out.print(&quot;\\t&quot;); System.out.print(&quot;\\t&quot;); System.out.println(&quot;*&quot;); System.out.print(&quot;\\t&quot;); System.out.print(&quot;\\t&quot;); System.out.print(&quot;\\t&quot;); System.out.print(&quot;*&quot;); System.out.print(&quot;\\t&quot;); System.out.print(&quot;\\t&quot;); System.out.print(&quot;\\t&quot;); System.out.println(&quot;*&quot;); System.out.print(&quot;\\t&quot;); System.out.print(&quot;\\t&quot;); System.out.print(&quot;\\t&quot;); System.out.print(&quot;\\t&quot;); System.out.print(&quot;*&quot;); System.out.print(&quot;\\t&quot;); System.out.println(&quot;*&quot;); System.out.print(&quot;\\t&quot;); System.out.print(&quot;\\t&quot;); System.out.print(&quot;\\t&quot;); System.out.print(&quot;\\t&quot;); System.out.print(&quot; &quot;); System.out.print(&quot;*&quot;); &#125;&#125; 方式二： 1234567891011121314151617class Exercise3&#123; public static void main(String[] args)&#123; System.out.print(&quot;\\t&quot;+&quot;*&quot;+&quot;\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t&quot;+&quot;*&quot;+&quot;\\t&quot;+&quot;\\n&quot;); System.out.print(&quot;*&quot;+&quot;\\t\\t&quot;+&quot;*&quot;+&quot;\\t\\t\\t\\t&quot;+&quot;I love Java&quot;+&quot;\\t\\t\\t\\t&quot;+&quot;*&quot;+&quot;\\t\\t\\t&quot;+&quot;*&quot;+&quot;\\n&quot;); System.out.print(&quot;\\t&quot;+&quot;*&quot;+&quot;\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t&quot;+&quot;*&quot;+&quot;\\t&quot;+&quot;\\n&quot;); System.out.print(&quot;\\t\\t&quot;+&quot;*&quot;+&quot;\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t&quot;+&quot;*&quot;+&quot;\\t\\t&quot;+&quot;\\n&quot;); System.out.print(&quot;\\t\\t\\t&quot;+&quot;*&quot;+&quot;\\t\\t\\t\\t\\t\\t\\t\\t&quot;+&quot;*&quot;+&quot;\\t&quot;+&quot;\\n&quot;); System.out.print(&quot;\\t\\t\\t\\t&quot;+&quot;*&quot;+&quot;\\t\\t\\t\\t\\t\\t&quot;+&quot;*&quot;+&quot;&quot;+&quot;\\t&quot;+&quot;\\n&quot;); System.out.print(&quot;\\t\\t\\t\\t\\t&quot;+&quot;*&quot;+&quot;\\t\\t\\t\\t&quot;+&quot;*&quot;+&quot;&quot;+&quot;\\t\\t&quot;+&quot;\\n&quot;); System.out.print(&quot;\\t\\t\\t\\t\\t\\t&quot;+&quot;*&quot;+&quot;\\t\\t&quot;+&quot;*&quot;+&quot;&quot;+&quot;\\t\\t&quot;+&quot;\\n&quot;); System.out.print(&quot;\\t\\t\\t\\t\\t\\t\\t&quot;+&quot;*&quot;+&quot;\\n&quot;); &#125;&#125;","categories":[{"name":"java基础","slug":"java基础","permalink":"http://example.com/categories/java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"java","slug":"java","permalink":"http://example.com/tags/java/"}]},{"title":"IntelliJ IDEA 常用快捷键一览表）","slug":"Java/尚硅谷_第04章_IDEA的安装与使用/尚硅谷_宋红康_IntelliJ IDEA 常用快捷键一览表","date":"2022-09-27T00:55:54.000Z","updated":"2023-10-07T11:33:07.579Z","comments":true,"path":"2022/09/27/Java/尚硅谷_第04章_IDEA的安装与使用/尚硅谷_宋红康_IntelliJ IDEA 常用快捷键一览表/","link":"","permalink":"http://example.com/2022/09/27/Java/%E5%B0%9A%E7%A1%85%E8%B0%B7_%E7%AC%AC04%E7%AB%A0_IDEA%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/%E5%B0%9A%E7%A1%85%E8%B0%B7_%E5%AE%8B%E7%BA%A2%E5%BA%B7_IntelliJ%20IDEA%20%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE%E4%B8%80%E8%A7%88%E8%A1%A8/","excerpt":"","text":"IntelliJ IDEA 常用快捷键一览表author：尚硅谷-宋红康 1-IDEA的日常快捷键第1组：通用型 说明 快捷键 复制代码-copy ctrl + c 粘贴-paste ctrl + v 剪切-cut ctrl + x 撤销-undo ctrl + z 反撤销-redo ctrl + shift + z 保存-save all ctrl + s 全选-select all ctrl + a 第2组：提高编写速度（上） 说明 快捷键 智能提示-edit alt + enter 提示代码模板-insert live template ctrl+j 使用xx块环绕-surround with … ctrl+alt+t 调出生成getter&#x2F;setter&#x2F;构造器等结构-generate … alt+insert 自动生成返回值变量-introduce variable … ctrl+alt+v 复制指定行的代码-duplicate line or selection ctrl+d 删除指定行的代码-delete line ctrl+y 切换到下一行代码空位-start new line shift + enter 切换到上一行代码空位-start new line before current ctrl +alt+ enter 向上移动代码-move statement up ctrl+shift+↑ 向下移动代码-move statement down ctrl+shift+↓ 向上移动一行-move line up alt+shift+↑ 向下移动一行-move line down alt+shift+↓ 方法的形参列表提醒-parameter info ctrl+p 第3组：提高编写速度（下） 说明 快捷键 批量修改指定的变量名、方法名、类名等-rename shift+f6 抽取代码重构方法-extract method … ctrl+alt+m 重写父类的方法-override methods … ctrl+o 实现接口的方法-implements methods … ctrl+i 选中的结构的大小写的切换-toggle case ctrl+shift+u 批量导包-optimize imports ctrl+alt+o 第4组：类结构、查找和查看源码 说明 快捷键 如何查看源码-go to class… ctrl + 选中指定的结构 或 ctrl+n 显示当前类结构，支持搜索指定的方法、属性等-file structure ctrl+f12 退回到前一个编辑的页面-back ctrl+alt+← 进入到下一个编辑的页面-forward ctrl+alt+→ 打开的类文件之间切换-select previous&#x2F;next tab alt+←&#x2F;→ 光标选中指定的类，查看继承树结构-Type Hierarchy ctrl+h 查看方法文档-quick documentation ctrl+q 类的UML关系图-show uml popup ctrl+alt+u 定位某行-go to line&#x2F;column ctrl+g 回溯变量或方法的来源-go to implementation(s) ctrl+alt+b 折叠方法实现-collapse all ctrl+shift+ - 展开方法实现-expand all ctrl+shift+ + 第5组：查找、替换与关闭 说明 快捷键 查找指定的结构 ctlr+f 快速查找：选中的Word快速定位到下一个-find next ctrl+l 查找与替换-replace ctrl+r 直接定位到当前行的首位-move caret to line start home 直接定位到当前行的末位 -move caret to line end end 查询当前元素在当前文件中的引用，然后按 F3 可以选择 ctrl+f7 全项目搜索文本-find in path … ctrl+shift+f 关闭当前窗口-close ctrl+f4 第6组：调整格式 说明 快捷键 格式化代码-reformat code ctrl+alt+l 使用单行注释-comment with line comment ctrl + &#x2F; 使用&#x2F;取消多行注释-comment with block comment ctrl + shift + &#x2F; 选中数行，整体往后移动-tab tab 选中数行，整体往前移动-prev tab shift + tab 2-Debug快捷键 说明 快捷键 单步调试（不进入函数内部）- step over F8 单步调试（进入函数内部）- step into F7 强制单步调试（进入函数内部） - force step into alt+shift+f7 选择要进入的函数 - smart step into shift + F7 跳出函数 - step out shift + F8 运行到断点 - run to cursor alt + F9 继续执行，进入下一个断点或执行完程序 - resume program F9 停止 - stop Ctrl+F2 查看断点 - view breakpoints Ctrl+Shift+F8 关闭 - close Ctrl+F4","categories":[{"name":"java基础","slug":"java基础","permalink":"http://example.com/categories/java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"java","slug":"java","permalink":"http://example.com/tags/java/"}]},{"title":"第03章_流程控制语句","slug":"Java/尚硅谷_第03章_流程控制语句/尚硅谷_宋红康_第03章_流程控制语句","date":"2022-09-27T00:55:54.000Z","updated":"2023-10-07T11:29:20.245Z","comments":true,"path":"2022/09/27/Java/尚硅谷_第03章_流程控制语句/尚硅谷_宋红康_第03章_流程控制语句/","link":"","permalink":"http://example.com/2022/09/27/Java/%E5%B0%9A%E7%A1%85%E8%B0%B7_%E7%AC%AC03%E7%AB%A0_%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/%E5%B0%9A%E7%A1%85%E8%B0%B7_%E5%AE%8B%E7%BA%A2%E5%BA%B7_%E7%AC%AC03%E7%AB%A0_%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/","excerpt":"","text":"第03章_流程控制语句本章专题与脉络 流程控制语句是用来控制程序中各语句执行顺序的语句，可以把语句组合成能完成一定功能的小逻辑模块。 程序设计中规定的三种流程结构，即： 顺序结构 程序从上到下逐行地执行，中间没有任何判断和跳转。 分支结构 根据条件，选择性地执行某段代码。 有if…else和switch-case两种分支语句。 循环结构 根据循环条件，重复性的执行某段代码。 有for、while、do-while三种循环语句。 补充：JDK5.0 提供了foreach循环，方便的遍历集合、数组元素。（第12章集合中讲解） 生活中、工业生产中流程控制举例 1. 顺序结构顺序结构就是程序从上到下逐行地执行。表达式语句都是顺序执行的。并且上一行对某个变量的修改对下一行会产生影响。 1234567891011121314public class StatementTest&#123; public static void main(String[] args)&#123; int x = 1; int y = 2; System.out.println(&quot;x = &quot; + x); System.out.println(&quot;y = &quot; + y); //对x、y的值进行修改 x++; y = 2 * x + y; x = x * 10; System.out.println(&quot;x = &quot; + x); System.out.println(&quot;y = &quot; + y); &#125;&#125; Java中定义变量时采用合法的前向引用。如： 1234public static void main(String[] args) &#123; int num1 = 12; int num2 = num1 + 2;&#125; 错误形式： 1234public static void main(String[] args) &#123; int num2 = num1 + 2; int num1 = 12;&#125; 2. 分支语句2.1 if-else条件判断结构2.1.1 基本语法结构1：单分支条件判断：if 格式： 123if(条件表达式)｛ 语句块;｝ 说明：条件表达式必须是布尔表达式（关系表达式或逻辑表达式）或 布尔变量。 执行流程： 首先判断条件表达式看其结果是true还是false 如果是true就执行语句块 如果是false就不执行语句块 结构2：双分支条件判断：if…else 格式： 12345if(条件表达式) &#123; 语句块1;&#125;else &#123; 语句块2;&#125; 执行流程： 首先判断条件表达式看其结果是true还是false 如果是true就执行语句块1 如果是false就执行语句块2 结构3：多分支条件判断：if…else if…else 格式： 1234567891011if (条件表达式1) &#123; 语句块1;&#125; else if (条件表达式2) &#123; 语句块2;&#125;...&#125;else if (条件表达式n) &#123; 语句块n;&#125; else &#123; 语句块n+1;&#125; 说明：一旦条件表达式为true，则进入执行相应的语句块。执行完对应的语句块之后，就跳出当前结构。 执行流程： 首先判断关系表达式1看其结果是true还是false 如果是true就执行语句块1，然后结束当前多分支 如果是false就继续判断关系表达式2看其结果是true还是false 如果是true就执行语句块2，然后结束当前多分支 如果是false就继续判断关系表达式…看其结果是true还是false ​ … n. 如果没有任何关系表达式为true，就执行语句块n+1，然后结束当前多分支。 2.1.2 应用举例案例1：成年人心率的正常范围是每分钟60-100次。体检时，如果心率不在此范围内，则提示需要做进一步的检查。 1234567891011public class IfElseTest1 &#123; public static void main(String[] args)&#123; int heartBeats = 89; if(heartBeats &lt; 60 || heartBeats &gt; 100)&#123; System.out.println(&quot;你需要做进一步的检查&quot;); &#125; System.out.println(&quot;体检结束&quot;); &#125;&#125; 案例2：定义一个整数，判定是偶数还是奇数 1234567891011public class IfElseTest2 &#123; public static void main(String[] args)&#123; int a = 10; if(a % 2 == 0) &#123; System.out.println(a + &quot;是偶数&quot;); &#125; else&#123; System.out.println(a + &quot;是奇数&quot;); &#125; &#125;&#125; 案例3： 12345678岳小鹏参加Java考试，他和父亲岳不群达成承诺：如果：成绩为100分时，奖励一辆跑车；成绩为(80，99]时，奖励一辆山地自行车；当成绩为[60,80]时，奖励环球影城一日游；其它时，胖揍一顿。说明：默认成绩是在[0,100]范围内 123456789101112131415161718192021222324252627282930public class IfElseTest3 &#123; public static void main(String[] args) &#123; int score = 67;//岳小鹏的期末成绩 //写法一：默认成绩范围为[0,100] if(score == 100)&#123; System.out.println(&quot;奖励一辆跑车&quot;); &#125;else if(score &gt; 80 &amp;&amp; score &lt;= 99)&#123; //错误的写法：&#125;else if(80 &lt; score &lt;= 99)&#123; System.out.println(&quot;奖励一辆山地自行车&quot;); &#125;else if(score &gt;= 60 &amp;&amp; score &lt;= 80)&#123; System.out.println(&quot;奖励环球影城玩一日游&quot;); &#125; //else&#123; // System.out.println(&quot;胖揍一顿&quot;); //&#125; //写法二： // 默认成绩范围为[0,100] if(score == 100)&#123; System.out.println(&quot;奖励一辆跑车&quot;); &#125;else if(score &gt; 80)&#123; System.out.println(&quot;奖励一辆山地自行车&quot;); &#125;else if(score &gt;= 60)&#123; System.out.println(&quot;奖励环球影城玩一日游&quot;); &#125;else&#123; System.out.println(&quot;胖揍一顿&quot;); &#125; &#125;&#125; 当条件表达式之间是“互斥”关系时（即彼此没有交集），条件判断语句及执行语句间顺序无所谓。 当条件表达式之间是“包含”关系时，“小上大下 / 子上父下”，否则范围小的条件表达式将不可能被执行。 2.1.3 if…else嵌套在 if 的语句块中，或者是在else语句块中，又包含了另外一个条件判断（可以是单分支、双分支、多分支），就构成了嵌套结构。 执行的特点：（1）如果是嵌套在if语句块中的，只有当外部的if条件满足，才会去判断内部的条件（2）如果是嵌套在else语句块中的，只有当外部的if条件不满足，进入else后，才会去判断内部的条件 案例4：由键盘输入三个整数分别存入变量num1、num2、num3，对它们进行排序(使用 if-else if-else)，并且从小到大输出。 1234567891011121314151617181920212223242526class IfElseTest4 &#123; public static void main(String[] args) &#123; //声明num1,num2,num3三个变量并赋值 int num1 = 23,num2 = 32,num3 = 12; if(num1 &gt;= num2)&#123; if(num3 &gt;= num1) System.out.println(num2 + &quot;-&quot; + num1 + &quot;-&quot; + num3); else if(num3 &lt;= num2) System.out.println(num3 + &quot;-&quot; + num2 + &quot;-&quot; + num1); else System.out.println(num2 + &quot;-&quot; + num3 + &quot;-&quot; + num1); &#125;else&#123; //num1 &lt; num2 if(num3 &gt;= num2)&#123; System.out.println(num1 + &quot;-&quot; + num2 + &quot;-&quot; + num3); &#125;else if(num3 &lt;= num1)&#123; System.out.println(num3 + &quot;-&quot; + num1 + &quot;-&quot; + num2); &#125;else&#123; System.out.println(num1 + &quot;-&quot; + num3 + &quot;-&quot; + num2); &#125; &#125; &#125;&#125; 2.1.4 其它说明 语句块只有一条执行语句时，一对&#123;&#125;可以省略，但建议保留 当if-else结构是“多选一”时，最后的else是可选的，根据需要可以省略 2.1.5 练习练习1： 1234567891011//1)对下列代码，若有输出，指出输出结果。int x = 4;int y = 1;if (x &gt; 2) &#123; if (y &gt; 2) System.out.println(x + y); System.out.println(&quot;atguigu&quot;);&#125; else System.out.println(&quot;x is &quot; + x); 练习2： 12345678910boolean b = true;//如果写成if(b=false)能编译通过吗？如果能，结果是？if(b == false) //建议：if(!b) System.out.println(&quot;a&quot;);else if(b) System.out.println(&quot;b&quot;);else if(!b) System.out.println(&quot;c&quot;);else System.out.println(&quot;d&quot;); 练习3： 定义两个整数，分别为small 和 big，如果第一个整数small大于第二个整数big，就交换。输出显示small和big变量的值。 12345678910111213public class IfElseExer3 &#123; public static void main(String[] args) &#123; int small = 10; int big = 9; if (small &gt; big) &#123; int temp = small; small = big; big = temp; &#125; System.out.println(&quot;small=&quot; + small + &quot;,big=&quot; + big); &#125;&#125; 练习4：小明参加期末Java考试，通过考试成绩，判断其Java等级，成绩范围[0,100] 90-100 优秀 80-89 好 70-79 良 60-69 及格 60以下 不及格 1234567891011121314151617181920212223import java.util.Scanner;//写法一：public class IfElseExer4 &#123; public static void main(String[] args) &#123; System.out.print(&quot;小明的期末Java成绩是：[0,100]&quot;); int score = 89; if (score &lt; 0 || score &gt; 100) &#123; System.out.println(&quot;你的成绩是错误的&quot;); &#125; else if (score &gt;= 90 &amp;&amp; score &lt;= 100) &#123; System.out.println(&quot;你的成绩属于优秀&quot;); &#125; else if (score &gt;= 80 &amp;&amp; score &lt; 90) &#123; System.out.println(&quot;你的成绩属于好&quot;); &#125; else if (score &gt;= 70 &amp;&amp; score &lt; 80) &#123; System.out.println(&quot;你的成绩属于良&quot;); &#125; else if (score &gt;= 60 &amp;&amp; score &lt; 70) &#123; System.out.println(&quot;你的成绩属于及格&quot;); &#125; else &#123; System.out.println(&quot;你的成绩属于不及格&quot;); &#125; &#125;&#125; 123456789101112131415161718192021222324import java.util.Scanner;//写法二：public class IfElseExer4 &#123; public static void main(String[] args) &#123; System.out.print(&quot;小明的期末Java成绩是：[0,100]&quot;); int score = 89; if (score &lt; 0 || score &gt; 100) &#123; System.out.println(&quot;你的成绩是错误的&quot;); &#125; else if (score &gt;= 90) &#123; System.out.println(&quot;你的成绩属于优秀&quot;); &#125; else if (score &gt;= 80) &#123; System.out.println(&quot;你的成绩属于好&quot;); &#125; else if (score &gt;= 70) &#123; System.out.println(&quot;你的成绩属于良&quot;); &#125; else if (score &gt;= 60) &#123; System.out.println(&quot;你的成绩属于及格&quot;); &#125; else &#123; System.out.println(&quot;你的成绩属于不及格&quot;); &#125; &#125;&#125; 练习5： 1编写程序，声明2个int型变量并赋值。判断两数之和，如果大于等于50，打印“hello world!” 12345678910public class IfElseExer5 &#123; public static void main(String[] args) &#123; int num1 = 12, num2 = 32; if (num1 + num2 &gt;= 50) &#123; System.out.println(&quot;hello world!&quot;); &#125; &#125;&#125; 练习6： 1编写程序，声明2个double型变量并赋值。判断第一个数大于10.0，且第2个数小于20.0，打印两数之和。否则，打印两数的乘积。 12345678910111213public class IfElseExer6 &#123; public static void main(String[] args) &#123; double d1 = 21.2,d2 = 12.3; if(d1 &gt; 10.0 &amp;&amp; d2 &lt; 20.0)&#123; System.out.println(&quot;两数之和为：&quot; + (d1 + d2)); &#125;else&#123; System.out.println(&quot;两数乘积为：&quot; + (d1 * d2)); &#125; &#125;&#125; 练习7：判断水的温度 1234567如果大于95℃，则打印“开水”；如果大于70℃且小于等于95℃，则打印“热水”；如果大于40℃且小于等于70℃，则打印“温水”；如果小于等于40℃，则打印“凉水”。 1234567891011121314151617public class IfElseExer7 &#123; public static void main(String[] args) &#123; int waterTemperature = 85; if(waterTemperature &gt; 95)&#123; System.out.println(&quot;开水&quot;); &#125;else if(waterTemperature &gt; 70 &amp;&amp; waterTemperature &lt;= 95)&#123; System.out.println(&quot;热水&quot;); &#125;else if(waterTemperature &gt; 40 &amp;&amp; waterTemperature &lt;= 70)&#123; System.out.println(&quot;温水&quot;); &#125;else&#123; System.out.println(&quot;凉水&quot;); &#125; &#125;&#125; 2.2 switch-case选择结构2.2.1 基本语法语法格式： 12345678910111213switch(表达式)&#123; case 常量值1: 语句块1; //break; case 常量值2: 语句块2; //break; // ... [default: 语句块n+1; break; ]&#125; 执行流程图： 执行过程： 第1步：根据switch中表达式的值，依次匹配各个case。如果表达式的值等于某个case中的常量值，则执行对应case中的执行语句。 第2步：执行完此case的执行语句以后，​ 情况1：如果遇到break,则执行break并跳出当前的switch-case结构​ 情况2：如果没有遇到break，则会继续执行当前case之后的其它case中的执行语句。—&gt;case穿透​ …​ 直到遇到break关键字或执行完所有的case及default的执行语句，跳出当前的switch-case结构 使用注意点： switch(表达式)中表达式的值必须是下述几种类型之一：byte，short，char，int，枚举 (jdk 5.0)，String (jdk 7.0)； case子句中的值必须是常量，不能是变量名或不确定的表达式值或范围； 同一个switch语句，所有case子句中的常量值互不相同； break语句用来在执行完一个case分支后使程序跳出switch语句块； 如果没有break，程序会顺序执行到switch结尾； default子句是可选的。同时，位置也是灵活的。当没有匹配的case时，执行default语句。 2.2.2 应用举例案例1： 12345678910111213141516171819202122public class SwitchCaseTest1 &#123; public static void main(String args[]) &#123; int num = 1; switch(num)&#123; case 0: System.out.println(&quot;zero&quot;); break; case 1: System.out.println(&quot;one&quot;); break; case 2: System.out.println(&quot;two&quot;); break; case 3: System.out.println(&quot;three&quot;); break; default: System.out.println(&quot;other&quot;); //break; &#125; &#125;&#125; 案例2： 12345678910111213141516171819202122public class SwitchCaseTest2 &#123; public static void main(String args[]) &#123; String season = &quot;summer&quot;; switch (season) &#123; case &quot;spring&quot;: System.out.println(&quot;春暖花开&quot;); break; case &quot;summer&quot;: System.out.println(&quot;夏日炎炎&quot;); break; case &quot;autumn&quot;: System.out.println(&quot;秋高气爽&quot;); break; case &quot;winter&quot;: System.out.println(&quot;冬雪皑皑&quot;); break; default: System.out.println(&quot;季节输入有误&quot;); break; &#125; &#125;&#125; 错误举例： 123456789101112int key = 10;switch(key)&#123; case key &gt; 0 : System.out.println(&quot;正数&quot;); break; case key &lt; 0: System.out.println(&quot;负数&quot;); break; default: System.out.println(&quot;零&quot;); break;&#125; 案例3：使用switch-case实现：对学生成绩大于60分的，输出“合格”。低于60分的，输出“不合格”。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859class SwitchCaseTest3 &#123; public static void main(String[] args) &#123; int score = 67; /* 写法1：极不推荐 switch(score)&#123; case 0: System.out.println(&quot;不及格&quot;); break; case 1: System.out.println(&quot;不及格&quot;); break; //... case 60: System.out.println(&quot;及格&quot;); break; //...略... &#125; */ //写法2： switch(score / 10)&#123; case 0: case 1: case 2: case 3: case 4: case 5: System.out.println(&quot;不及格&quot;); break; case 6: case 7: case 8: case 9: case 10: System.out.println(&quot;及格&quot;); break; default: System.out.println(&quot;输入的成绩有误&quot;); break; &#125; //写法3： switch(score / 60)&#123; case 0: System.out.println(&quot;不及格&quot;); break; case 1: System.out.println(&quot;及格&quot;); break; default: System.out.println(&quot;输入的成绩有误&quot;); break; &#125; &#125;&#125; 2.2.3 利用case的穿透性在switch语句中，如果case的后面不写break，将出现穿透现象，也就是一旦匹配成功，不会在判断下一个case的值，直接向后运行，直到遇到break或者整个switch语句结束，执行终止。 案例4：编写程序：从键盘上输入2023年的“month”和“day”，要求通过程序输出输入的日期为2023年的第几天。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071import java.util.Scanner;class SwitchCaseTest4 &#123; public static void main(String[] args) &#123; Scanner scan = new Scanner(System.in); System.out.println(&quot;请输入2023年的month:&quot;); int month = scan.nextInt(); System.out.println(&quot;请输入2023年的day:&quot;); int day = scan.nextInt(); //这里就不针对month和day进行合法性的判断了，以后可以使用正则表达式进行校验。 int sumDays = 0;//记录总天数 //写法1 ：不推荐（存在冗余的数据） /* switch(month)&#123; case 1: sumDays = day; break; case 2: sumDays = 31 + day; break; case 3: sumDays = 31 + 28 + day; break; //.... case 12: //sumDays = 31 + 28 + ... + 30 + day; break; &#125; */ //写法2：推荐 switch(month)&#123; case 12: sumDays += 30;//这个30是代表11月份的满月天数 case 11: sumDays += 31;//这个31是代表10月份的满月天数 case 10: sumDays += 30;//这个30是代表9月份的满月天数 case 9: sumDays += 31;//这个31是代表8月份的满月天数 case 8: sumDays += 31;//这个31是代表7月份的满月天数 case 7: sumDays += 30;//这个30是代表6月份的满月天数 case 6: sumDays += 31;//这个31是代表5月份的满月天数 case 5: sumDays += 30;//这个30是代表4月份的满月天数 case 4: sumDays += 31;//这个31是代表3月份的满月天数 case 3: sumDays += 28;//这个28是代表2月份的满月天数 case 2: sumDays += 31;//这个31是代表1月份的满月天数 case 1: sumDays += day;//这个day是代表当月的第几天 &#125; System.out.println(month + &quot;月&quot; + day + &quot;日是2023年的第&quot; + sumDays + &quot;天&quot;); //关闭资源 scan.close(); &#125;&#125; 拓展： 12345678从键盘分别输入年、月、日，判断这一天是当年的第几天 注：判断一年是否是闰年的标准： 1）可以被4整除，但不可被100整除 或 2）可以被400整除 例如：1900，2200等能被4整除，但同时能被100整除，但不能被400整除，不是闰年 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566import java.util.Scanner;public class SwitchCaseTest04 &#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); System.out.print(&quot;请输入year:&quot;); int year = scanner.nextInt(); System.out.print(&quot;请输入month:&quot;); int month = scanner.nextInt(); System.out.print(&quot;请输入day:&quot;); int day = scanner.nextInt(); //判断这一天是当年的第几天==&gt;从1月1日开始，累加到xx月xx日这一天 //(1)[1,month-1]个月满月天数 //(2)单独考虑2月份是否是29天（依据是看year是否是闰年） //(3)第month个月的day天 //声明一个变量days，用来存储总天数 int sumDays = 0; //累加[1,month-1]个月满月天数 switch (month) &#123; case 12: //累加的1-11月 sumDays += 30;//这个30是代表11月份的满月天数 //这里没有break，继续往下走 case 11: //累加的1-10月 sumDays += 31;//这个31是代表10月的满月天数 //这里没有break，继续往下走 case 10: sumDays += 30;//9月 case 9: sumDays += 31;//8月 case 8: sumDays += 31;//7月 case 7: sumDays += 30;//6月 case 6: sumDays += 31;//5月 case 5: sumDays += 30;//4月 case 4: sumDays += 31;//3月 case 3: sumDays += 28;//2月 //在这里考虑是否可能是29天 if (year % 4 == 0 &amp;&amp; year % 100 != 0 || year % 400 == 0) &#123; sumDays++;//多加1天 &#125; case 2: sumDays += 31;//1月 case 1: sumDays += day;//第month月的day天 &#125; //输出结果 System.out.println(year + &quot;年&quot; + month + &quot;月&quot; + day + &quot;日是这一年的第&quot; + sumDays + &quot;天&quot;); scanner.close(); &#125;&#125; 案例5：根据指定的月份输出对应季节 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990import java.util.Scanner;/* * 需求：指定一个月份，输出该月份对应的季节。一年有四季: * 3,4,5 春季 * 6,7,8 夏季 * 9,10,11 秋季 * 12,1,2 冬季 */public class SwitchCaseTest5 &#123; public static void main(String[] args) &#123; Scanner input = new Scanner(System.in); System.out.print(&quot;请输入月份：&quot;); int month = input.nextInt(); /* switch(month) &#123; case 1: System.out.println(&quot;冬季&quot;); break; case 2: System.out.println(&quot;冬季&quot;); break; case 3: System.out.println(&quot;春季&quot;); break; case 4: System.out.println(&quot;春季&quot;); break; case 5: System.out.println(&quot;春季&quot;); break; case 6: System.out.println(&quot;夏季&quot;); break; case 7: System.out.println(&quot;夏季&quot;); break; case 8: System.out.println(&quot;夏季&quot;); break; case 9: System.out.println(&quot;秋季&quot;); break; case 10: System.out.println(&quot;秋季&quot;); break; case 11: System.out.println(&quot;秋季&quot;); break; case 12: System.out.println(&quot;冬季&quot;); break; default: System.out.println(&quot;你输入的月份有误&quot;); break; &#125; */ // 改进版 switch(month) &#123; case 1: case 2: case 12: System.out.println(&quot;冬季&quot;); break; case 3: case 4: case 5: System.out.println(&quot;春季&quot;); break; case 6: case 7: case 8: System.out.println(&quot;夏季&quot;); break; case 9: case 10: case 11: System.out.println(&quot;秋季&quot;); break; default: System.out.println(&quot;你输入的月份有误&quot;); break; &#125; input.close(); &#125;&#125; 常见错误实现： 12345678910111213141516switch(month)&#123; case 3|4|5://3|4|5 用了位运算符，11 | 100 | 101结果是 111是7 System.out.println(&quot;春季&quot;); break; case 6|7|8://6|7|8用了位运算符，110 | 111 | 1000结果是1111是15 System.out.println(&quot;夏季&quot;); break; case 9|10|11://9|10|11用了位运算符，1001 | 1010 | 1011结果是1011是11 System.out.println(&quot;秋季&quot;); break; case 12|1|2://12|1|2 用了位运算符，1100 | 1 | 10 结果是1111，是15 System.out.println(&quot;冬季&quot;); break; default: System.out.println(&quot;输入有误&quot;);&#125; 使用if-else实现： 1234567891011if ((month == 1) || (month == 2) || (month == 12)) &#123; System.out.println(&quot;冬季&quot;);&#125; else if ((month == 3) || (month == 4) || (month == 5)) &#123; System.out.println(&quot;春季&quot;);&#125; else if ((month == 6) || (month == 7) || (month == 8)) &#123; System.out.println(&quot;夏季&quot;);&#125; else if ((month == 9) || (month == 10) || (month == 11)) &#123; System.out.println(&quot;秋季&quot;);&#125; else &#123; System.out.println(&quot;你输入的月份有误&quot;);&#125; 2.2.4 if-else语句与switch-case语句比较 结论：凡是使用switch-case的结构都可以转换为if-else结构。反之，不成立。 开发经验：如果既可以使用switch-case，又可以使用if-else，建议使用switch-case。因为效率稍高。 细节对比： if-else语句优势 if语句的条件是一个布尔类型值，if条件表达式为true则进入分支，可以用于范围的判断，也可以用于等值的判断，使用范围更广。 switch语句的条件是一个常量值（byte,short,int,char,枚举,String），只能判断某个变量或表达式的结果是否等于某个常量值，使用场景较狭窄。 switch语句优势 当条件是判断某个变量或表达式是否等于某个固定的常量值时，使用if和switch都可以，习惯上使用switch更多。因为效率稍高。当条件是区间范围的判断时，只能使用if语句。 使用switch可以利用穿透性，同时执行多个分支，而if…else没有穿透性。 案例：只能使用 if-else 从键盘输入一个整数，判断是正数、负数、还是零。 1234567891011121314151617181920import java.util.Scanner;public class IfOrSwitchDemo &#123; public static void main(String[] args) &#123; Scanner input = new Scanner(System.in); System.out.print(&quot;请输入整数：&quot;); int num = input.nextInt(); if (num &gt; 0) &#123; System.out.println(num + &quot;是正整数&quot;); &#125; else if (num &lt; 0) &#123; System.out.println(num + &quot;是负整数&quot;); &#125; else &#123; System.out.println(num + &quot;是零&quot;); &#125; input.close(); &#125;&#125; 2.2.5 练习练习1：从键盘输入星期的整数值，输出星期的英文单词 12345678910111213141516171819202122232425262728293031323334353637383940import java.util.Scanner;public class SwitchCaseExer1 &#123; public static void main(String[] args) &#123; //定义指定的星期 Scanner input = new Scanner(System.in); System.out.print(&quot;请输入星期值：&quot;); int weekday = input.nextInt(); //switch语句实现选择 switch(weekday) &#123; case 1: System.out.println(&quot;Monday&quot;); break; case 2: System.out.println(&quot;Tuesday&quot;); break; case 3: System.out.println(&quot;Wednesday&quot;); break; case 4: System.out.println(&quot;Thursday&quot;); break; case 5: System.out.println(&quot;Friday&quot;); break; case 6: System.out.println(&quot;Saturday&quot;); break; case 7: System.out.println(&quot;Sunday&quot;); break; default: System.out.println(&quot;你输入的星期值有误！&quot;); break; &#125; input.close(); &#125;&#125; 练习2： 1使用 switch 把小写类型的 char型转为大写。只转换 a, b, c, d, e. 其它的输出 “other”。 1234567891011121314151617181920212223242526public class SwitchCaseExer2 &#123; public static void main(String[] args) &#123; char word = &#x27;c&#x27;; switch (word) &#123; case &#x27;a&#x27;: System.out.println(&quot;A&quot;); break; case &#x27;b&#x27;: System.out.println(&quot;B&quot;); break; case &#x27;c&#x27;: System.out.println(&quot;C&quot;); break; case &#x27;d&#x27;: System.out.println(&quot;D&quot;); break; case &#x27;e&#x27;: System.out.println(&quot;E&quot;); break; default : System.out.println(&quot;other&quot;); &#125; &#125;&#125; 练习3： 12345678910编写程序：从键盘上读入一个学生成绩，存放在变量score中，根据score的值输出其对应的成绩等级：score&gt;=90 等级: A70&lt;=score&lt;90 等级: B 60&lt;=score&lt;70 等级: Cscore&lt;60 等级: D方式一：使用if-else方式二：使用switch-case: score / 10: 0 - 10 123456789101112131415161718192021222324252627282930313233343536373839404142public class SwitchCaseExer3 &#123; public static void main(String[] args) &#123; Scanner scan = new Scanner(System.in); System.out.println(&quot;请输入学生成绩：&quot;); int score = scan.nextInt(); char grade;//记录学生等级 //方式1：// if(score &gt;= 90)&#123;// grade = &#x27;A&#x27;;// &#125;else if(score &gt;= 70 &amp;&amp; score &lt; 90)&#123;// grade = &#x27;B&#x27;;// &#125;else if(score &gt;= 60 &amp;&amp; score &lt; 70)&#123;// grade = &#x27;C&#x27;;// &#125;else&#123;// grade = &#x27;D&#x27;;// &#125; //方式2： switch(score / 10)&#123; case 10: case 9: grade = &#x27;A&#x27;; break; case 8: case 7: grade = &#x27;B&#x27;; break; case 6: grade = &#x27;C&#x27;; break; default : grade = &#x27;D&#x27;; &#125; System.out.println(&quot;学生成绩为&quot; + score + &quot;,对应的等级为&quot; + grade); scan.close(); &#125;&#125; 练习4： 1234编写一个程序，为一个给定的年份找出其对应的中国生肖。中国的生肖基于12年一个周期，每年用一个动物代表：rat、ox、tiger、rabbit、dragon、snake、horse、sheep、monkey、rooster、dog、pig。提示：2022年：虎 2022 % 12 == 6 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455/** * @author 尚硅谷-宋红康 * @create 18:55 */public class SwitchCaseExer4 &#123; public static void main(String[] args)&#123; //从键盘输入一个年份 Scanner input = new Scanner(System.in); System.out.print(&quot;请输入年份：&quot;); int year = input.nextInt(); input.close(); //判断 switch(year % 12)&#123; case 0: System.out.println(year + &quot;是猴年&quot;); break; case 1: System.out.println(year + &quot;是鸡年&quot;); break; case 2: System.out.println(year + &quot;是狗年&quot;); break; case 3: System.out.println(year + &quot;是猪年&quot;); break; case 4: System.out.println(year + &quot;是鼠年&quot;); break; case 5: System.out.println(year + &quot;是牛年&quot;); break; case 6: System.out.println(year + &quot;是虎年&quot;); break; case 7: System.out.println(year + &quot;是兔年&quot;); break; case 8: System.out.println(year + &quot;是龙年&quot;); break; case 9: System.out.println(year + &quot;是蛇年&quot;); break; case 10: System.out.println(year + &quot;是马年&quot;); break; case 11: System.out.println(year + &quot;是羊年&quot;); break; default: System.out.println(year + &quot;输入错误&quot;); &#125; &#125;&#125; 练习5：押宝游戏 1234随机产生3个1-6的整数，如果三个数相等，那么称为“豹子”，如果三个数之和大于9，称为“大”，如果三个数之和小于等于9，称为“小”，用户从键盘输入押的是“豹子”、“大”、“小”，并判断是否猜对了提示：随机数 Math.random()产生 [0,1)范围内的小数 如何获取[a,b]范围内的随机整数呢？(int)(Math.random() * (b - a + 1)) + a 1234567891011121314151617181920212223242526272829import java.util.Scanner;public class SwitchCaseExer5 &#123; public static void main(String[] args) &#123; //1、随机产生3个1-6的整数 int a = (int)(Math.random()*6 + 1); int b = (int)(Math.random()*6 + 1); int c = (int)(Math.random()*6 + 1); //2、押宝 Scanner input = new Scanner(System.in); System.out.print(&quot;请押宝（豹子、大、小）：&quot;); String ya = input.next(); input.close(); //3、判断结果 boolean result = false; //switch支持String类型 switch (ya)&#123; case &quot;豹子&quot;: result = a == b &amp;&amp; b == c; break; case &quot;大&quot;: result = a + b + c &gt; 9; break; case &quot;小&quot;: result = a + b + c &lt;= 9; break; default:System.out.println(&quot;输入有误！&quot;); &#125; System.out.println(&quot;a,b,c分别是：&quot; + a +&quot;,&quot; + b +&quot;,&quot; + c ); System.out.println(result ? &quot;猜中了&quot; : &quot;猜错了&quot;); &#125;&#125; 练习6： 123456789101112使用switch语句改写下列if语句：int a = 3;int x = 100;if(a==1) x+=5;else if(a==2) x+=10;else if(a==3) x+=16;else x+=34; 1234567891011121314151617int a = 3;int x = 100;switch(a)&#123; case 1: x += 5; break; case 2: x += 10; break; case 3: x += 16; break; default : x += 34;&#125; 3. 循环语句 理解：循环语句具有在某些条件满足的情况下，反复执行特定代码的功能。 循环结构分类： for 循环 while 循环 do-while 循环 循环结构四要素： 初始化部分 循环条件部分 循环体部分 迭代部分 3.1 for循环3.1.1 基本语法语法格式： 123for (①初始化部分; ②循环条件部分; ④迭代部分)｛ ③循环体部分;｝ 执行过程：①-②-③-④-②-③-④-②-③-④-…..-② 图示： 说明： for(;;)中的两个；不能多也不能少 ①初始化部分可以声明多个变量，但必须是同一个类型，用逗号分隔 ②循环条件部分为boolean类型表达式，当值为false时，退出循环 ④可以有多个变量更新，用逗号分隔 3.1.2 应用举例案例1：使用for循环重复执行某些语句 题目：输出5行HelloWorld 12345678910111213141516public class ForTest1 &#123; public static void main(String[] args) &#123; //需求1：控制台输出5行Hello World! //写法1： //System.out.println(&quot;Hello World!&quot;); //System.out.println(&quot;Hello World!&quot;); //System.out.println(&quot;Hello World!&quot;); //System.out.println(&quot;Hello World!&quot;); //System.out.println(&quot;Hello World!&quot;); //写法2： for(int i = 1;i &lt;= 5;i++)&#123; System.out.println(&quot;Hello World!&quot;); &#125; &#125;&#125; 案例2：格式的多样性 题目：写出输出的结果 123456789public class ForTest2 &#123; public static void main(String[] args) &#123; int num = 1; for(System.out.print(&quot;a&quot;);num &lt; 3;System.out.print(&quot;c&quot;),num++)&#123; System.out.print(&quot;b&quot;); &#125; &#125;&#125; 案例3：累加的思想 题目：遍历1-100以内的偶数，并获取偶数的个数，获取所有的偶数的和 1234567891011121314151617181920public class ForTest3 &#123; public static void main(String[] args) &#123; int count = 0;//记录偶数的个数 int sum = 0;//记录偶数的和 for(int i = 1;i &lt;= 100;i++)&#123; if(i % 2 == 0)&#123; System.out.println(i); count++; sum += i; &#125; //System.out.println(&quot;偶数的个数为：&quot; + count); &#125; System.out.println(&quot;偶数的个数为：&quot; + count); System.out.println(&quot;偶数的总和为：&quot; + sum); &#125;&#125; 案例4：结合分支结构使用 题目：输出所有的水仙花数，所谓水仙花数是指一个3位数，其各个位上数字立方和等于其本身。例如： 153 = 1*1*1 + 3*3*3 + 5*5*5 1234567891011121314151617181920212223public class ForTest4 &#123; public static void main(String[] args) &#123; //定义统计变量，初始化值是0 int count = 0; //获取三位数，用for循环实现 for(int x = 100; x &lt; 1000; x++) &#123; //获取三位数的个位，十位，百位 int ge = x % 10; int shi = x / 10 % 10; int bai = x / 100; //判断这个三位数是否是水仙花数，如果是，统计变量++ if((ge*ge*ge+shi*shi*shi+bai*bai*bai) == x) &#123; System.out.println(&quot;水仙花数：&quot; + x); count++; &#125; &#125; //输出统计结果就可以了 System.out.println(&quot;水仙花数共有&quot;+count+&quot;个&quot;); &#125;&#125; 拓展： 1打印出四位数字中“个位+百位”等于“十位+千位”并且个位数为偶数，千位数为奇数的数字，并打印符合条件的数字的个数。 案例5：结合break的使用 说明：输入两个正整数m和n，求其最大公约数和最小公倍数。 比如：12和20的最大公约数是4，最小公倍数是60。 12345678910111213141516171819202122232425262728293031323334353637/** * @author 尚硅谷-宋红康 * @create 17:43 */public class ForTest5 &#123; public static void main(String[] args) &#123; //需求1：最大公约数 int m = 12, n = 20; //取出两个数中的较小值 int min = (m &lt; n) ? m : n; for (int i = min; i &gt;= 1; i--) &#123;//for(int i = 1;i &lt;= min;i++)&#123; if (m % i == 0 &amp;&amp; n % i == 0) &#123; System.out.println(&quot;最大公约数是：&quot; + i); //公约数 break; //跳出当前循环结构 &#125; &#125; //需求2：最小公倍数 //取出两个数中的较大值 int max = (m &gt; n) ? m : n; for (int i = max; i &lt;= m * n; i++) &#123; if (i % m == 0 &amp;&amp; i % n == 0) &#123; System.out.println(&quot;最小公倍数是：&quot; + i);//公倍数 break; &#125; &#125; &#125;&#125; 说明： 1、我们可以在循环中使用break。一旦执行break，就跳出当前循环结构。 2、小结：如何结束一个循环结构？ ​ 结束情况1：循环结构中的循环条件部分返回false ​ 结束情况2：循环结构中执行了break。 3、如果一个循环结构不能结束，那就是一个死循环！我们开发中要避免出现死循环。 3.1.3 练习练习1：打印1~100之间所有奇数的和 12345678910111213public class ForExer1 &#123; public static void main(String[] args) &#123; int sum = 0;//记录奇数的和 for (int i = 1; i &lt; 100; i++) &#123; if(i % 2 != 0)&#123; sum += i; &#125; &#125; System.out.println(&quot;奇数总和为：&quot; + sum); &#125;&#125; 练习2：打印1~100之间所有是7的倍数的整数的个数及总和（体会设置计数器的思想） 12345678910111213141516public class ForExer2 &#123; public static void main(String[] args) &#123; int sum = 0;//记录总和 int count = 0;//记录个数 for (int i = 1; i &lt; 100; i++) &#123; if(i % 7 == 0)&#123; sum += i; count++; &#125; &#125; System.out.println(&quot;1~100之间所有是7的倍数的整数的和为：&quot; + sum); System.out.println(&quot;1~100之间所有是7的倍数的整数的个数为：&quot; + count); &#125;&#125; 练习3： 编写程序从1循环到150，并在每行打印一个值，另外在每个3的倍数行上打印出“foo”,在每个5的倍数行上打印“biz”,在每个7的倍数行上打印输出“baz”。 1234567891011121314151617181920public class ForExer3 &#123; public static void main(String[] args) &#123; for (int i = 1; i &lt; 150; i++) &#123; System.out.print(i + &quot;\\t&quot;); if(i % 3 == 0)&#123; System.out.print(&quot;foo\\t&quot;); &#125; if(i % 5 == 0)&#123; System.out.print(&quot;biz\\t&quot;); &#125; if(i % 7 == 0)&#123; System.out.print(&quot;baz\\t&quot;); &#125; System.out.println(); &#125; &#125;&#125; 3.2 while循环3.2.1 基本语法语法格式： 12345①初始化部分while(②循环条件部分)｛ ③循环体部分; ④迭代部分;&#125; 执行过程：①-②-③-④-②-③-④-②-③-④-…-② 图示： 说明： while(循环条件)中循环条件必须是boolean类型。 注意不要忘记声明④迭代部分。否则，循环将不能结束，变成死循环。 for循环和while循环可以相互转换。二者没有性能上的差别。实际开发中，根据具体结构的情况，选择哪个格式更合适、美观。 for循环与while循环的区别：初始化条件部分的作用域不同。 3.2.2 应用举例案例1：输出5行HelloWorld! 12345678910class WhileTest1 &#123; public static void main(String[] args) &#123; int i = 1; while(i &lt;= 5)&#123; System.out.println(&quot;Hello World!&quot;); i++; &#125; &#125;&#125; 案例2：遍历1-100的偶数，并计算所有偶数的和、偶数的个数（累加的思想） 123456789101112131415161718192021222324class WhileTest2 &#123; public static void main(String[] args) &#123; //遍历1-100的偶数，并计算所有偶数的和、偶数的个数（累加的思想） int num = 1; int sum = 0;//记录1-100所有的偶数的和 int count = 0;//记录1-100之间偶数的个数 while(num &lt;= 100)&#123; if(num % 2 == 0)&#123; System.out.println(num); sum += num; count++; &#125; //迭代条件 num++; &#125; System.out.println(&quot;偶数的总和为：&quot; + sum); System.out.println(&quot;偶数的个数为：&quot; + count); &#125;&#125; 案例3：猜数字游戏 12345随机生成一个100以内的数，猜这个随机数是多少？从键盘输入数，如果大了，提示大了；如果小了，提示小了；如果对了，就不再猜了，并统计一共猜了多少次。提示：生成一个[a,b] 范围的随机数的方式：(int)(Math.random() * (b - a + 1) + a) 123456789101112131415161718192021222324252627282930313233343536/** * @author 尚硅谷-宋红康 * @create 16:42 */public class GuessNumber &#123; public static void main(String[] args) &#123; //获取一个随机数 int random = (int) (Math.random() * 100) + 1; //记录猜的次数 int count = 1; //实例化Scanner Scanner scan = new Scanner(System.in); System.out.println(&quot;请输入一个整数(1-100):&quot;); int guess = scan.nextInt(); while (guess != random) &#123; if (guess &gt; random) &#123; System.out.println(&quot;猜大了&quot;); &#125; else if (guess &lt; random) &#123; System.out.println(&quot;猜小了&quot;); &#125; System.out.println(&quot;请输入一个整数(1-100):&quot;); guess = scan.nextInt(); //累加猜的次数 count++; &#125; System.out.println(&quot;猜中了！&quot;); System.out.println(&quot;一共猜了&quot; + count + &quot;次&quot;); &#125;&#125; 案例4：折纸珠穆朗玛峰 12世界最高山峰是珠穆朗玛峰，它的高度是8848.86米，假如我有一张足够大的纸，它的厚度是0.1毫米。请问，我折叠多少次，可以折成珠穆朗玛峰的高度? 12345678910111213141516171819202122232425/** * @author 尚硅谷-宋红康 * @create 19:08 */public class ZFTest &#123; public static void main(String[] args) &#123; //定义一个计数器，初始值为0 int count = 0; //定义珠穆朗玛峰的高度 int zf = 8848860;//单位：毫米 double paper = 0.1;//单位：毫米 while(paper &lt; zf)&#123; //在循环中执行累加，对应折叠了多少次 count++; paper *= 2;//循环的执行过程中每次纸张折叠，纸张的厚度要加倍 &#125; //打印计数器的值 System.out.println(&quot;需要折叠：&quot; + count + &quot;次&quot;); System.out.println(&quot;折纸的高度为&quot; + paper/1000 + &quot;米，超过了珠峰的高度&quot;); &#125;&#125; 3.2.3 练习练习：从键盘输入整数，输入0结束，统计输入的正数、负数的个数。 1234567891011121314151617181920212223242526import java.util.Scanner;public class Test05While &#123; public static void main(String[] args) &#123; Scanner input = new Scanner(System.in); int positive = 0; //记录正数的个数 int negative = 0; //记录负数的个数 int num = 1; //初始化为特殊值，使得第一次循环条件成立 while(num != 0)&#123; System.out.print(&quot;请输入整数（0表示结束）：&quot;); num = input.nextInt(); if(num &gt; 0)&#123; positive++; &#125;else if(num &lt; 0)&#123; negative++; &#125; &#125; System.out.println(&quot;正数个数：&quot; + positive); System.out.println(&quot;负数个数：&quot; + negative); input.close(); &#125;&#125; 3.3 do-while循环3.3.1 基本语法语法格式： 12345①初始化部分;do&#123; ③循环体部分 ④迭代部分&#125;while(②循环条件部分); 执行过程：①-③-④-②-③-④-②-③-④-…-② 图示： 说明： 结尾while(循环条件)中循环条件必须是boolean类型 do{}while();最后有一个分号 do-while结构的循环体语句是至少会执行一次，这个和for和while是不一样的 循环的三个结构for、while、do-while三者是可以相互转换的。 3.3.2 应用举例案例1：遍历1-100的偶数，并计算所有偶数的和、偶数的个数（累加的思想） 1234567891011121314151617181920212223242526272829class DoWhileTest1 &#123; public static void main(String[] args) &#123; //遍历1-100的偶数，并计算所有偶数的和、偶数的个数（累加的思想） //初始化部分 int num = 1; int sum = 0;//记录1-100所有的偶数的和 int count = 0;//记录1-100之间偶数的个数 do&#123; //循环体部分 if(num % 2 == 0)&#123; System.out.println(num); sum += num; count++; &#125; num++;//迭代部分 &#125;while(num &lt;= 100); //循环条件部分 System.out.println(&quot;偶数的总和为：&quot; + sum); System.out.println(&quot;偶数的个数为：&quot; + count); &#125;&#125; 案例2：体会do-while至少会执行一次循环体 123456789101112131415161718class DoWhileTest2 &#123; public static void main(String[] args) &#123; //while循环: int num1 = 10; while(num1 &gt; 10)&#123; System.out.println(&quot;hello:while&quot;); num1--; &#125; //do-while循环: int num2 = 10; do&#123; System.out.println(&quot;hello:do-while&quot;); num2--; &#125;while(num2 &gt; 10); &#125;&#125; 案例3：ATM取款 12345678声明变量balance并初始化为0，用以表示银行账户的余额，下面通过ATM机程序实现存款，取款等功能。=========ATM======== 1、存款 2、取款 3、显示余额 4、退出请选择(1-4)： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960import java.util.Scanner;/** * @author 尚硅谷-宋红康 * @create 19:12 */public class ATM &#123; public static void main(String[] args) &#123; //初始化条件 double balance = 0.0;//表示银行账户的余额 Scanner scan = new Scanner(System.in); boolean isFlag = true;//用于控制循环的结束 do&#123; System.out.println(&quot;=========ATM========&quot;); System.out.println(&quot;\\t1、存款&quot;); System.out.println(&quot;\\t2、取款&quot;); System.out.println(&quot;\\t3、显示余额&quot;); System.out.println(&quot;\\t4、退出&quot;); System.out.print(&quot;请选择(1-4)：&quot;); int selection = scan.nextInt(); switch(selection)&#123; case 1: System.out.print(&quot;要存款的额度为：&quot;); double addMoney = scan.nextDouble(); if(addMoney &gt; 0)&#123; balance += addMoney; &#125; break; case 2: System.out.print(&quot;要取款的额度为：&quot;); double minusMoney = scan.nextDouble(); if(minusMoney &gt; 0 &amp;&amp; balance &gt;= minusMoney)&#123; balance -= minusMoney; &#125;else&#123; System.out.println(&quot;您输入的数据非法或余额不足&quot;); &#125; break; case 3: System.out.println(&quot;当前的余额为：&quot; + balance); break; case 4: System.out.println(&quot;欢迎下次进入此系统。^_^&quot;); isFlag = false; break; default: System.out.println(&quot;请重新选择！&quot;); break; &#125; &#125;while(isFlag); //资源关闭 scan.close(); &#125;&#125; 3.3.3 练习练习1：随机生成一个100以内的数，猜这个随机数是多少？ 从键盘输入数，如果大了提示，大了；如果小了，提示小了；如果对了，就不再猜了，并统计一共猜了多少次。 12345678910111213141516171819202122232425262728293031323334353637import java.util.Scanner;public class DoWhileExer &#123; public static void main(String[] args) &#123; //随机生成一个100以内的整数 /* Math.random() ==&gt; [0,1)的小数 Math.random()* 100 ==&gt; [0,100)的小数 (int)(Math.random()* 100) ==&gt; [0,100)的整数 */ int num = (int)(Math.random()* 100); //System.out.println(num); //声明一个变量，用来存储猜的次数 int count = 0; Scanner input = new Scanner(System.in); int guess;//提升作用域 do&#123; System.out.print(&quot;请输入100以内的整数：&quot;); guess = input.nextInt(); //输入一次，就表示猜了一次 count++; if(guess &gt; num)&#123; System.out.println(&quot;大了&quot;); &#125;else if(guess &lt; num)&#123; System.out.println(&quot;小了&quot;); &#125; &#125;while(num != guess); System.out.println(&quot;一共猜了：&quot; + count+&quot;次&quot;); input.close(); &#125;&#125; 3.4 对比三种循环结构 三种循环结构都具有四个要素： 循环变量的初始化条件 循环条件 循环体语句块 循环变量的修改的迭代表达式 从循环次数角度分析 do-while循环至少执行一次循环体语句。 for和while循环先判断循环条件语句是否成立，然后决定是否执行循环体。 如何选择 遍历有明显的循环次数（范围）的需求，选择for循环 遍历没有明显的循环次数（范围）的需求，选择while循环 如果循环体语句块至少执行一次，可以考虑使用do-while循环 本质上：三种循环之间完全可以互相转换，都能实现循环的功能 3.5 “无限”循环 3.5.1 基本语法语法格式： 最简单”无限”循环格式：while(true) , for(;;) 适用场景： 开发中，有时并不确定需要循环多少次，需要根据循环体内部某些条件，来控制循环的结束（使用break）。 如果此循环结构不能终止，则构成了死循环！开发中要避免出现死循环。 3.5.2 应用举例案例1：实现爱你到永远… 12345678public class EndlessFor1 &#123; public static void main(String[] args) &#123; for (;;)&#123; System.out.println(&quot;我爱你！&quot;); &#125;// System.out.println(&quot;end&quot;);//永远无法到达的语句，编译报错 &#125;&#125; 1234567public class EndlessFor2 &#123; public static void main(String[] args) &#123; for (; true;)&#123; //条件永远成立，死循环 System.out.println(&quot;我爱你！&quot;); &#125; &#125;&#125; 1234567public class EndlessFor3 &#123; public static void main(String[] args) &#123; for (int i=1; i&lt;=10; )&#123; //循环变量没有修改，条件永远成立，死循环 System.out.println(&quot;我爱你！&quot;); &#125; &#125;&#125; 思考：如下代码执行效果 1234567public class EndlessFor4 &#123; public static void main(String[] args) &#123; for (int i=1; i&gt;=10; )&#123; //一次都不执行 System.out.println(&quot;我爱你！&quot;); &#125; &#125;&#125; 案例2：从键盘读入个数不确定的整数，并判断读入的正数和负数的个数，输入为0时结束程序。 123456789101112131415161718192021222324252627import java.util.Scanner;class PositiveNegative &#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); int positiveNumber = 0;//统计正数的个数 int negativeNumber = 0;//统计负数的个数 for(;;)&#123; //while(true)&#123; System.out.println(&quot;请输入一个整数：(输入为0时结束程序)&quot;); int num = scanner.nextInt(); if(num &gt; 0)&#123; positiveNumber++; &#125;else if(num &lt; 0)&#123; negativeNumber++; &#125;else&#123; System.out.println(&quot;程序结束&quot;); break; &#125; &#125; System.out.println(&quot;正数的个数为：&quot;+ positiveNumber); System.out.println(&quot;负数的个数为：&quot;+ negativeNumber); scanner.close(); &#125; &#125; 3.6 嵌套循环（或多重循环）3.6.1 使用说明 所谓嵌套循环，是指一个循环结构A的循环体是另一个循环结构B。比如，for循环里面还有一个for循环，就是嵌套循环。其中，for ,while ,do-while均可以作为外层循环或内层循环。 外层循环：循环结构A 内层循环：循环结构B 实质上，嵌套循环就是把内层循环当成外层循环的循环体。只有当内层循环的循环条件为false时，才会完全跳出内层循环，才可结束外层的当次循环，开始下一次的外层循环。 设外层循环次数为m次，内层为n次，则内层循环体实际上需要执行m*n次。 技巧：从二维图形的角度看，外层循环控制行数，内层循环控制列数。 开发经验：实际开发中，我们最多见到的嵌套循环是两层。一般不会出现超过三层的嵌套循环。如果将要出现，一定要停下来重新梳理业务逻辑，重新思考算法的实现，控制在三层以内。否则，可读性会很差。 例如：两个for嵌套循环格式 1234567for(初始化语句①; 循环条件语句②; 迭代语句⑦) &#123; for(初始化语句③; 循环条件语句④; 迭代语句⑥) &#123; 循环体语句⑤; &#125;&#125;//执行过程：① - ② - ③ - ④ - ⑤ - ⑥ - ④ - ⑤ - ⑥ - ... - ④ - ⑦ - ② - ③ - ④ - ⑤ - ⑥ - ④.. 执行特点：外层循环执行一次，内层循环执行一轮。 3.6.2 应用举例案例1：打印5行6个* 12345678910111213141516171819202122class ForForTest1 &#123; public static void main(String[] args) &#123; /* ****** ****** ****** ****** ****** */ for(int j = 1;j &lt;= 5;j++)&#123; for(int i = 1;i &lt;= 6;i++)&#123; System.out.print(&quot;*&quot;); &#125; System.out.println(); &#125; &#125;&#125; 案例2：打印5行直角三角形 12345*************** 12345678910public class ForForTest2 &#123; public static void main(String[] args)&#123; for (int i = 1; i &lt;= 5; i++) &#123; for (int j = 1; j &lt;= i; j++) &#123; System.out.print(&quot;*&quot;); &#125; System.out.println(); &#125; &#125;&#125; 案例3：打印5行倒直角三角形 12345*************** 123456789101112public class ForForTest3 &#123; public static void main(String[] args)&#123; for(int i = 1;i &lt;= 5;i++)&#123; for(int j = 1;j &lt;= 6 - i;j++)&#123; System.out.print(&quot;*&quot;); &#125; System.out.println(); &#125; &#125;&#125; 案例4：打印”菱形”形状的图案 123456789 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class ForForTest4 &#123; public static void main(String[] args) &#123; /* 上半部分 i m(表示-的个数) n(表示*的个数)关系式：2*i + m = 10 --&gt; m = 10 - 2*i --------* 1 8 1 n = 2 * i - 1 ------* * * 2 6 3 ----* * * * * 3 4 5 --* * * * * * * 4 2 7 * * * * * * * * * 5 0 9 下半部分 i m n 关系式： m = 2 * i --* * * * * * * 1 2 7 n = 9 - 2 * i ----* * * * * 2 4 5 ------* * * 3 6 3 --------* 4 8 1 */ //上半部分 for (int i = 1; i &lt;= 5; i++) &#123; //- for (int j = 1; j &lt;= 10 - 2 * i; j++) &#123; System.out.print(&quot; &quot;); &#125; //* for (int k = 1; k &lt;= 2 * i - 1; k++) &#123; System.out.print(&quot;* &quot;); &#125; System.out.println(); &#125; //下半部分 for (int i = 1; i &lt;= 4; i++) &#123; //- for (int j = 1; j &lt;= 2 * i; j++) &#123; System.out.print(&quot; &quot;); &#125; //* for (int k = 1; k &lt;= 9 - 2 * i; k++) &#123; System.out.print(&quot;* &quot;); &#125; System.out.println(); &#125; &#125;&#125; 案例5：九九乘法表 12345678910public class ForForTest5 &#123; public static void main(String[] args) &#123; for (int i = 1; i &lt;= 9; i++) &#123; for (int j = 1; j &lt;= i; j++) &#123; System.out.print(i + &quot;*&quot; + j + &quot;=&quot; + (i * j) + &quot;\\t&quot;); &#125; System.out.println(); &#125; &#125;&#125; 3.6.3 练习练习1：将一天中的时间打印到控制台 123456789public class ForForDemo &#123; public static void main (String[] args) &#123; for (int hour = 0;hour &lt; 24 ;hour++ ) &#123; for (int min = 0; min &lt; 60 ; min++) &#123; System.out.println(hour + &quot;时&quot; + min +&quot;分&quot;); &#125; &#125; &#125;&#125; 4. 关键字break和continue的使用4.1 break和continue的说明123456 适用范围 在循环结构中使用的作用 相同点break switch-case 循环结构 一旦执行，就结束(或跳出)当前循环结构 此关键字的后面，不能声明语句continue 循环结构 一旦执行，就结束(或跳出)当次循环结构 此关键字的后面，不能声明语句 此外，很多语言都有goto语句，goto语句可以随意将控制转移到程序中的任意一条语句上，然后执行它，但使程序容易出错。Java中的break和continue是不同于goto的。 4.2 应用举例1234567891011121314151617181920212223242526272829303132class BreakContinueTest1 &#123; public static void main(String[] args) &#123; for(int i = 1;i &lt;= 10;i++)&#123; if(i % 4 == 0)&#123; //break;//123 continue;//123567910 //如下的语句不可能被执行，编译不通过 //System.out.println(&quot;今晚迪丽热巴要约我吃饭&quot;); &#125; System.out.print(i); &#125; System.out.println(&quot;####&quot;); //嵌套循环中的使用 for(int i = 1;i &lt;= 4;i++)&#123; for(int j = 1;j &lt;= 10;j++)&#123; if(j % 4 == 0)&#123; //break; //结束的是包裹break关键字的最近的一层循环！ continue;//结束的是包裹break关键字的最近的一层循环的当次！ &#125; System.out.print(j); &#125; System.out.println(); &#125; &#125;&#125; 4.3 带标签的使用12345678910111213141516break语句用于终止某个语句块的执行&#123; …… break; ……&#125;break语句出现在多层嵌套的语句块中时，可以通过标签指明要终止的是哪一层语句块 label1: &#123; …… label2: &#123; …… label3: &#123; …… break label2; …… &#125; &#125; &#125; continue语句出现在多层嵌套的循环语句体中时，也可以通过标签指明要跳过的是哪一层循环。 标号语句必须紧接在循环的头部。标号语句不能用在非循环语句的前面。 举例： 123456789101112131415class BreakContinueTest2 &#123; public static void main(String[] args) &#123; l:for(int i = 1;i &lt;= 4;i++)&#123; for(int j = 1;j &lt;= 10;j++)&#123; if(j % 4 == 0)&#123; //break l; continue l; &#125; System.out.print(j); &#125; System.out.println(); &#125; &#125;&#125; 4.4 经典案例题目：找出100以内所有的素数（质数）？100000以内的呢？ 目的：不同的代码的实现方式，可以效率差别很大。 分析：素数（质数）：只能被1和它本身整除的自然数。 —&gt; 从2开始，到这个数-1为止，此范围内没有这个数的约数。则此数是一个质数。比如：2、3、5、7、11、13、17、19、23、… 实现方式1： 12345678910111213141516171819202122232425262728293031323334353637383940class PrimeNumberTest &#123; public static void main(String[] args) &#123; //boolean isFlag = true; //用于标识i是否被除尽过 long start = System.currentTimeMillis(); //记录当前时间距离1970-1-1 00:00:00的毫秒数 int count = 0;//记录质数的个数 for(int i = 2;i &lt;= 100000;i++)&#123; //i boolean isFlag = true; //用于标识i是否被除尽过 for(int j = 2;j &lt;= i - 1;j++)&#123; if(i % j == 0)&#123; //表明i有约数 isFlag = false; &#125; &#125; //判断i是否是质数 if(isFlag)&#123; //如果isFlag变量没有给修改过值，就意味着i没有被j除尽过。则i是一个质数 //System.out.println(i); count++; &#125; //重置isFlag //isFlag = true; &#125; long end = System.currentTimeMillis(); System.out.println(&quot;质数的个数为：&quot; + count); System.out.println(&quot;执行此程序花费的毫秒数为：&quot; + (end - start)); //16628 &#125;&#125; 实现方式2：针对实现方式1进行优化 12345678910111213141516171819202122232425262728293031323334class PrimeNumberTest1 &#123; public static void main(String[] args) &#123; long start = System.currentTimeMillis(); //记录当前时间距离1970-1-1 00:00:00的毫秒数 int count = 0;//记录质数的个数 for(int i = 2;i &lt;= 100000;i++)&#123; //i boolean isFlag = true; //用于标识i是否被除尽过 for(int j = 2;j &lt;= Math.sqrt(i);j++)&#123; //优化2：将循环条件中的i改为Math.sqrt(i) if(i % j == 0)&#123; //表明i有约数 isFlag = false; break;//优化1：主要针对非质数起作用 &#125; &#125; //判断i是否是质数 if(isFlag)&#123; //如果isFlag变量没有给修改过值，就意味着i没有被j除尽过。则i是一个质数 //System.out.println(i); count++; &#125; &#125; long end = System.currentTimeMillis(); System.out.println(&quot;质数的个数为：&quot; + count); System.out.println(&quot;执行此程序花费的毫秒数为：&quot; + (end - start));//1062 &#125;&#125; 实现方式3（选做）：使用continue + 标签 12345678910111213141516171819202122232425262728class PrimeNumberTest2 &#123; public static void main(String[] args) &#123; long start = System.currentTimeMillis(); //记录当前时间距离1970-1-1 00:00:00的毫秒数 int count = 0;//记录质数的个数 label:for(int i = 2;i &lt;= 100000;i++)&#123; //i for(int j = 2;j &lt;= Math.sqrt(i);j++)&#123; //优化2：将循环条件中的i改为Math.sqrt(i) if(i % j == 0)&#123; //表明i有约数 continue label; &#125; &#125; //一旦程序能执行到此位置，说明i就是一个质数 System.out.println(i); count++; &#125; long end = System.currentTimeMillis(); System.out.println(&quot;质数的个数为：&quot; + count); System.out.println(&quot;执行此程序花费的毫秒数为：&quot; + (end - start));//1062 &#125;&#125; 4.5 练习练习1： 123生成 1-100 之间的随机数，直到生成了 97 这个数，看看一共用了几次？提示：使用 (int)(Math.random() * 100) + 1 123456789101112131415public class NumberGuessTest &#123; public static void main(String[] args) &#123; int count = 0;//记录循环的次数（或生成随机数进行比较的次数） while(true)&#123; int random = (int)(Math.random() * 100) + 1; count++; if(random == 97)&#123; break; &#125; &#125; System.out.println(&quot;直到生成随机数97，一共比较了&quot; + count + &quot;次&quot;); &#125;&#125; 5. Scanner：键盘输入功能的实现 如何从键盘获取不同类型（基本数据类型、String类型）的变量：使用Scanner类。 键盘输入代码的四个步骤： 导包：import java.util.Scanner; 创建Scanner类型的对象：Scanner scan = new Scanner(System.in); 调用Scanner类的相关方法（next() / nextXxx()），来获取指定类型的变量 释放资源：scan.close(); 注意：需要根据相应的方法，来输入指定类型的值。如果输入的数据类型与要求的类型不匹配时，会报异常 导致程序终止。 5.1 各种类型的数据输入案例：小明注册某交友网站，要求录入个人相关信息。如下： 请输入你的网名、你的年龄、你的体重、你是否单身、你的性别等情况。 12345678910111213141516171819202122232425262728293031323334353637383940//① 导包import java.util.Scanner;public class ScannerTest1 &#123; public static void main(String[] args) &#123; //② 创建Scanner的对象 //Scanner是一个引用数据类型，它的全名称是java.util.Scanner //scanner就是一个引用数据类型的变量了，赋给它的值是一个对象（对象的概念我们后面学习，暂时先这么叫） //new Scanner(System.in)是一个new表达式，该表达式的结果是一个对象 //引用数据类型 变量 = 对象; //这个等式的意思可以理解为用一个引用数据类型的变量代表一个对象，所以这个变量的名称又称为对象名 //我们也把scanner变量叫做scanner对象 Scanner scanner = new Scanner(System.in);//System.in默认代表键盘输入 //③根据提示，调用Scanner的方法，获取不同类型的变量 System.out.println(&quot;欢迎光临你好我好交友网站！&quot;); System.out.print(&quot;请输入你的网名：&quot;); String name = scanner.next(); System.out.print(&quot;请输入你的年龄：&quot;); int age = scanner.nextInt(); System.out.print(&quot;请输入你的体重：&quot;); double weight = scanner.nextDouble(); System.out.print(&quot;你是否单身（true/false)：&quot;); boolean isSingle = scanner.nextBoolean(); System.out.print(&quot;请输入你的性别：&quot;); char gender = scanner.next().charAt(0);//先按照字符串接收，然后再取字符串的第一个字符（下标为0） System.out.println(&quot;你的基本情况如下：&quot;); System.out.println(&quot;网名：&quot; + name + &quot;\\n年龄：&quot; + age + &quot;\\n体重：&quot; + weight + &quot;\\n单身：&quot; + isSingle + &quot;\\n性别：&quot; + gender); //④ 关闭资源 scanner.close(); &#125;&#125; 5.2 练习练习1： 1234567891011121314151617181920大家都知道，男大当婚，女大当嫁。那么女方家长要嫁女儿，当然要提出一定的条件：高：180cm以上；富：财富1千万以上；帅：是。如果这三个条件同时满足，则：“我一定要嫁给他!!!”如果三个条件有为真的情况，则：“嫁吧，比上不足，比下有余。”如果三个条件都不满足，则：“不嫁！”提示：System.out.println(“身高: (cm));scanner.nextInt();System.out.println(“财富: (千万));scanner.nextDouble();System.out.println(“帅否: (true/false)); scanner.nextBoolean(); System.out.println(“帅否: (是/否));scanner.next(); &quot;是&quot;.equals(str) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import java.util.Scanner;class ScannerExer1 &#123; public static void main(String[] args) &#123; Scanner scan = new Scanner(System.in); System.out.println(&quot;请输入你的身高：(cm)&quot;); int height = scan.nextInt(); System.out.println(&quot;请输入你的财富：(以千万为单位)&quot;); double wealth = scan.nextDouble(); /* 方式1：关于是否帅问题，我们使用boolean类型接收 System.out.println(&quot;帅否？(true/false)&quot;); boolean isHandsome = scan.nextBoolean(); //判断 if(height &gt;= 180 &amp;&amp; wealth &gt;= 1.0 &amp;&amp; isHandsome)&#123; //不建议isHandsome == true System.out.println(&quot;我一定要嫁给他!!!&quot;); &#125;else if(height &gt;= 180 || wealth &gt;= 1.0 || isHandsome)&#123; System.out.println(&quot;嫁吧，比上不足，比下有余。&quot;); &#125;else&#123; System.out.println(&quot;不嫁&quot;); &#125; */ //方式2：关于是否帅问题，我们使用String类型接收 System.out.println(&quot;帅否？(是/否)&quot;); String isHandsome = scan.next(); //判断 if(height &gt;= 180 &amp;&amp; wealth &gt;= 1.0 &amp;&amp; isHandsome == &quot;是&quot;)&#123; //知识点：判断两个字符串是否相等，使用String的equals() System.out.println(&quot;我一定要嫁给他!!!&quot;); &#125;else if(height &gt;= 180 || wealth &gt;= 1.0 || isHandsome == &quot;是&quot;)&#123; System.out.println(&quot;嫁吧，比上不足，比下有余。&quot;); &#125;else&#123; System.out.println(&quot;不嫁&quot;); &#125; //关闭资源 scan.close(); &#125;&#125; 练习2： 1234我家的狗5岁了，5岁的狗相当于人类多大呢？其实，狗的前两年每一年相当于人类的10.5岁，之后每增加一年就增加四岁。那么5岁的狗相当于人类多少年龄呢？应该是：10.5 + 10.5 + 4 + 4 + 4 = 33岁。编写一个程序，获取用户输入的狗的年龄，通过程序显示其相当于人类的年龄。如果用户输入负数，请显示一个提示信息。 123456789101112131415161718192021222324import java.util.Scanner;class ScannerExer2 &#123; public static void main(String[] args) &#123; Scanner scan = new Scanner(System.in); System.out.println(&quot;请输入狗狗的年龄：&quot;); int dogAge = scan.nextInt(); //通过分支语句，判断狗狗相当于人的年龄 if(dogAge &lt; 0)&#123; System.out.println(&quot;你输入的狗狗的年龄不合法&quot;); &#125;else if(dogAge &lt;= 2)&#123; System.out.println(&quot;相当于人的年龄：&quot; + (dogAge * 10.5)); &#125;else&#123; System.out.println(&quot;相当于人的年龄：&quot; + (2 * 10.5 + (dogAge - 2) * 4)); &#125; //关闭资源 scan.close(); &#125;&#125; 6. 如何获取一个随机数如何产生一个指定范围的随机整数？ 1、Math类的random()的调用，会返回一个[0,1)范围的一个double型值 2、Math.random() * 100 —&gt; [0,100) (int)(Math.random() * 100) —&gt; [0,99] (int)(Math.random() * 100) + 5 —-&gt; [5,104] 3、如何获取[a,b]范围内的随机整数呢？(int)(Math.random() * (b - a + 1)) + a 4、举例 1234567891011class MathRandomTest &#123; public static void main(String[] args) &#123; double value = Math.random(); System.out.println(value); //[1,6] int number = (int)(Math.random() * 6) + 1; // System.out.println(number); &#125;&#125;","categories":[{"name":"java基础","slug":"java基础","permalink":"http://example.com/categories/java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"java","slug":"java","permalink":"http://example.com/tags/java/"}]},{"title":"第04章_IDEA的安装与使用（上）","slug":"Java/尚硅谷_第04章_IDEA的安装与使用/尚硅谷_宋红康_第04章_IDEA的安装与使用（上）","date":"2022-09-27T00:55:54.000Z","updated":"2023-10-07T11:32:17.254Z","comments":true,"path":"2022/09/27/Java/尚硅谷_第04章_IDEA的安装与使用/尚硅谷_宋红康_第04章_IDEA的安装与使用（上）/","link":"","permalink":"http://example.com/2022/09/27/Java/%E5%B0%9A%E7%A1%85%E8%B0%B7_%E7%AC%AC04%E7%AB%A0_IDEA%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/%E5%B0%9A%E7%A1%85%E8%B0%B7_%E5%AE%8B%E7%BA%A2%E5%BA%B7_%E7%AC%AC04%E7%AB%A0_IDEA%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%8A%EF%BC%89/","excerpt":"","text":"第04章_IDEA的安装与使用（上）讲师：尚硅谷-宋红康（江湖人称：康师傅） 官网：http://www.atguigu.com 本章专题与脉络 【Why IDEA ?】 【注】JetBrains官方说明： 尽管我们采取了多种措施确保受访者的代表性，但结果可能会略微偏向 JetBrains 产品的用户，因为这些用户更有可能参加调查。 此外，2022年，某美国软件开发商在对近千名专业的Java开发者调研后，发布了《2022年Java开发者生产力报告》。报告提到：JetBrains 的 IntelliJ IDEA是最受欢迎的 Java IDE，占 48%，其次是 Eclipse，占 24%，Visual Studio Code 占 18%。 本着”工欲善其事必先利其器“的精神，本章从IDEA的介绍、安装、设置入手，讲解IDEA中项目的创建、快捷键与模板的使用、断点调试、常用插件等。 1. 认识IntelliJ IDEA1.1 JetBrains 公司介绍IDEA，是 JetBrains (https://www.jetbrains.com/)公司的产品，该公司成立于2000年，总部位于捷克的布拉格，致力于为开发者打造最高效智能的开发工具。 公司旗下还有其它产品，比如： WebStorm：用于开发 JavaScript、HTML5、CSS3 等前端技术 PyCharm：用于开发 python PhpStorm：用于开发 PHP RubyMine：用于开发 Ruby&#x2F;Rails AppCode：用于开发 Objective - C&#x2F;Swift CLion：用于开发 C&#x2F;C++ DataGrip：用于开发数据库和 SQL Rider：用于开发.NET GoLand：用于开发 Go 用于开发 Android的Android Studio，也是Google 基于 IDEA 社区版进行迭代的。 1.2 IntelliJ IDEA 介绍IDEA，全称 IntelliJ IDEA，是 Java 语言的集成开发环境，目前已经（基本）代替了Eclipse的使用。IDEA 在业界被公认为是最好的 Java 开发工具（之一），因其功能强悍、设置人性化，而深受Java、大数据、移动端程序员的喜爱。 IntelliJ IDEA 在 2015 年的官网上这样介绍自己： Excel at enterprise, mobile and web development with Java, Scala and Groovy,with all the latest modern technologies and frameworks available out of thebox. 1.3 IDEA的主要优势：(vs Eclipse)功能强大： ① 强大的整合能力。比如：Git、Maven、Spring等 ② 开箱即用的体验（集成版本控制系统、多语言支持的框架随时可用，无需额外安装插件） 符合人体工程学： ① 高度智能（快速的智能代码补全、实时代码分析、可靠的重构工具） ② 提示功能的快速、便捷、范围广 ③ 好用的快捷键和代码模板 ④ 精准搜索 1.4 IDEA 的下载 下载网址： https://www.jetbrains.com/idea/download/#section=windows IDEA 分为两个版本： 旗舰版(Ultimate)和 社区版(Community)。 IDEA的大版本每年迭代一次，大版本下的小版本（如：2022.x）迭代时间不固定，一般每年3个小版本。 两个不同版本的详细对比，可以参照官网：https://www.jetbrains.com/idea/features/editions_comparison_matrix.html 官网提供的详细使用文档：https://www.jetbrains.com/help/idea/meet-intellij-idea.html 2. 卸载与安装2.1 卸载过程这里以卸载2022.1.2版本为例说明。在【控制面板】找到【卸载程序】 右键点击或左键双击IntelliJ IDEA 2022.1.2进行卸载： 如果需要保留下述数据，就不要打√。如果想彻底删除IDEA所有数据，那就打上√。 软件卸载完以后，还需要删除其它几个位置的残留： 2.2 安装前的准备 64 位 Microsoft Windows 11、10、8 最低 2 GB 可用 RAM，推荐 8 GB 系统总 RAM 2.5 GB 硬盘空间，推荐 SSD 最低屏幕分辨率 1024x768 从安装上来看，IntelliJ IDEA 对硬件的要求似乎不是很高。可是在实际开发中并不是这样的，因为 IntelliJ IDEA 执行时会有大量的缓存、索引文件，所以如果你正在使用 Eclipse &#x2F; MyEclipse，想通过 IntelliJ IDEA 来解决计算机的卡、慢等问题，这基本上是不可能的，本质上你应该对自己的硬件设备进行升级。 2.3 安装过程1、下载完安装包，双击直接安装 2、欢迎安装 3、是否删除电脑上低版本的IDEA（如果有，可以选择忽略） 如果电脑上有低版本的IDEA，可以选择删除或保留。 这里没有卸载旧版本，如果需要卸载，记得勾选下面的保留旧的设置和配置。 4、选择安装目录 选择安装目录，目录中要避免中文和空格。 5、创建桌面快捷图标等 确认是否与.java、.groovy、.kt 格式文件进行关联。这里建议不关联。 6、在【开始】菜单新建一个文件夹（这里需要确认文件夹的名称），来管理IDEA的相关内容。 7、完成安装 重启以后，单击登录： 2.4 注册首先，需要通过用户协议： 是否同意发送用户数据（特性、使用的插件、硬件与软件配置等），建议选择：不发送。 接着，会提示我们进行注册。 选择1：试用30天。在IDEA2022.1.2版本中，需要先登录，才能开启试用。 选择2：付费购买旗舰版 选择3：（推荐） 大家参照《.\\03-资料\\01-IDEA 2022.1 注册文档\\IntelliJ IDEA2022.1注册文档.docx》操作即可。 由于存在时效性，如果失效，大家可以自行搜索注册方式即可。 2.5 闪退问题问题描述：2022.1启动不了，双击桌面图标，没有响应。 解决办法： 打开C:\\Users\\songhk\\AppData\\Roaming\\JetBrains\\IntelliJIdea2022.1\\idea64.exe.vmoptions 这个文件。 内容如下所示： 删除红框的数据以后，再登录即可正常进入。 原因：之前使用过的比如2021.2.2版本，pojie了。新版IEDA太智能了，把现有的启运参数也都复制过去了。又因为最新的IDEA，不兼容pojie程序-javaagent:D:\\develop_tools\\IDEA\\IntelliJ IDEA 2021.2.2\\bin\\jetbrains-agent.jar了，所以报错了，所以JVM结束了，所以没有启动画面，凉凉了。 3. HelloWorld的实现3.1 新建Project - Class选择”New Project”： 指名工程名、使用的JDK版本等信息。如下所示： 接着创建Java类： 3.2 编写代码12345public class HelloWorld &#123; public static void main(String[] args) &#123; System.out.println(&quot;Hello,World!&quot;); &#125;&#125; 3.3 运行 4. JDK相关设置4.1 项目的JDK设置File--&gt;Project Structure...--&gt;Platform Settings --&gt;SDKs 注1：SDKs全称是Software Development Kit ，这里一定是选择JDK的安装根目录，不是JRE的目录。 注2：这里还可以从本地添加多个JDK。使用“+”即可实现。 4.2 out目录和编译版本File--&gt;Project Structure...--&gt;Project Settings --&gt;Project 5. 详细设置5.1 如何打开详细配置界面1、显示工具栏 2、选择详细配置菜单或按钮 5.2 系统设置1、默认启动项目配置 启动IDEA时，默认自动打开上次开发的项目？还是自己选择？ 如果去掉Reopen projects on startup前面的对勾，每次启动IDEA就会出现如下界面： 2、取消自动更新Settings–&gt;Appearance &amp; Behavior-&gt;System Settings -&gt; Updates 默认都打√了，建议检查IDE更新的√去掉，检查插件更新的√选上。 5.3 设置整体主题1、选择主题 2、设置菜单和窗口字体和大小 3、设置IDEA背景图 选择一张合适的图片作为背景，即可。 5.4 设置编辑器主题样式1、编辑器主题 2、字体大小 更详细的字体与颜色如下： 温馨提示：如果选择某个font字体，中文乱码，可以在fallback font（备选字体）中选择一个支持中文的字体。 3、注释的字体颜色 Block comment：修改多行注释的字体颜色 Doc Comment –&gt; Text：修改文档注释的字体颜色 Line comment：修改单行注释的字体颜色 5.5 显示行号与方法分隔符 5.6 代码智能提示功能 IntelliJ IDEA 的代码提示和补充功能有一个特性：区分大小写。 如果想不区分大小写的话，就把这个对勾去掉。建议去掉勾选。 5.7 自动导包配置 默认需要自己手动导包，Alt+Enter快捷键 自动导包设置 动态导入明确的包：Add unambiguous imports on the fly，该设置具有全局性； 优化动态导入的包：Optimize imports on the fly，该设置只对当前项目有效； 5.8 设置项目文件编码（一定要改） 说明： Transparent native-to-ascii conversion主要用于转换ascii，显式原生内容。一般都要勾选。 5.9 设置控制台的字符编码 5.10 修改类头的文档注释信息 比如： 12345678/*** ClassName: $&#123;NAME&#125;* Package: $&#123;PACKAGE_NAME&#125;* Description: * @Author 尚硅谷-宋红康* @Create $&#123;DATE&#125; $&#123;TIME&#125; * @Version 1.0 */ 常用的预设的变量，这里直接贴出官网给的： 12345678910111213141516$&#123;PACKAGE_NAME&#125; - the name of the target package where the new class or interface will be created. $&#123;PROJECT_NAME&#125; - the name of the current project. $&#123;FILE_NAME&#125; - the name of the PHP file that will be created. $&#123;NAME&#125; - the name of the new file which you specify in the New File dialog box during the file creation. $&#123;USER&#125; - the login name of the current user. $&#123;DATE&#125; - the current system date. $&#123;TIME&#125; - the current system time. $&#123;YEAR&#125; - the current year. $&#123;MONTH&#125; - the current month. $&#123;DAY&#125; - the current day of the month. $&#123;HOUR&#125; - the current hour. $&#123;MINUTE&#125; - the current minute. $&#123;PRODUCT_NAME&#125; - the name of the IDE in which the file will be created. $&#123;MONTH_NAME_SHORT&#125; - the first 3 letters of the month name. Example: Jan, Feb, etc. $&#123;MONTH_NAME_FULL&#125; - full name of a month. Example: January, February, etc. 5.11 设置自动编译Settings--&gt;Build,Execution,Deployment--&gt;Compiler 5.12 设置为省电模式 (可忽略) IntelliJ IDEA 有一种叫做省电模式的状态，开启这种模式之后 IntelliJ IDEA 会关掉代码检查和代码提示等功能。所以一般也可认为这是一种阅读模式，如果你在开发过程中遇到突然代码文件不能进行检查和提示，可以来看看这里是否有开启该功能。 5.13 取消双击shift搜索因为我们按shift切换中英文输入方式，经常被按到，总是弹出搜索框，太麻烦了。可以取消它。 方式1：适用于IDEA 2022.1.2版本 在2022.1版本中，采用如下方式消双击shift出现搜索框：搜索double即可，勾选Disable double modifier key shortcuts，禁用这个选项。 方式2：适用于IDEA 2022.1.2之前版本 双击shift 或 ctrl + shift + a，打开如下搜索窗口： 选择registry…，找到”ide.suppress.double.click.handler”，把复选框打上勾就可以取消双击shift出现搜索框了。 6. 工程与模块管理6.1 IDEA项目结构层级关系： 1project(工程) - module(模块) - package(包) - class(类) 具体的： 12345一个project中可以创建多个module一个module中可以创建多个package一个package中可以创建多个class 这些结构的划分，是为了方便管理功能代码。 6.2 Project和Module的概念在 IntelliJ IDEA 中，提出了Project和Module这两个概念。 在 IntelliJ IDEA 中Project是最顶级的结构单元，然后就是Module。目前，主流的大型项目结构基本都是多Module的结构，这类项目一般是按功能划分的，比如：user-core-module、user-facade-module和user-hessian-module等等，模块之间彼此可以相互依赖，有着不可分割的业务关系。因此，对于一个Project来说： 当为单Module项目的时候，这个单独的Module实际上就是一个Project。 当为多Module项目的时候，多个模块处于同一个Project之中，此时彼此之间具有互相依赖的关联关系。 当然多个模块没有建立依赖关系的话，也可以作为单独一个“小项目”运行。 6.3 Module和Package在一个module下，可以声明多个包（package），一般命名规范如下： 123451.不要有中文2.不要以数字开头3.给包取名时一般都是公司域名倒着写,而且都是小写 比如：尚硅谷网址是www.atguigu.com 那么我们的package包名应该写成：com.atguigu.子名字。 6.4 创建Module建议创建“Empty空工程”，然后创建多模块，每一个模块可以独立运行，相当于一个小项目。JavaSE阶段不涉及到模块之间的依赖。后期再学习模块之间的依赖。 步骤： （1）选择创建模块 （2）选择模块类型：这里选择创建Java模块，给模块命名，确定存放位置 （4）模块声明在工程下面 6.5 删除模块（1）移除模块 （2）彻底删除模块 6.6 导入老师的模块（1）将老师的模块teacher_chapter04整个的复制到自己IDEA项目的路径下 接着打开自己IDEA的项目，会在项目目录下看到拷贝过来的module，只不过不是以模块的方式呈现。 （2）查看Project Structure，选择import module （3）选择要导入的module： （4）接着可以一路Next下去，最后选择Overwrite 最后点击OK即可了。 6.7 同时打开两个IDEA项目工程1、两个IDEA项目工程效果有些同学想要把上课练习代码和作业代码分开两个IDEA项目工程。 2、新建一个IDEA项目注意：第一次需要新建，之后直接打开项目工程即可 3、打开两个IDEA项目 6.8 导入前几章非IDEA工程代码1、创建chapter01、chapter02、chapter03等章节的module 将相应章节的源文件粘贴到module的src下。 打开其中各个源文件，会发现有乱码。比如： 2、设置编码 当前项目是UTF-8。如果原来的.java文件都是GBK的（如果原来.java文件有的是GBK，有的是UTF-8就比较麻烦了）。 可以单独把这两个模块设置为GBK编码的。 改为GBK，确认即可。如图： 7. 代码模板的使用7.1 查看Postfix Completion模板(后缀补全) 7.2 查看Live Templates模板(实时模板) 7.3 常用代码模板1、非空判断 变量.null：if(变量 &#x3D;&#x3D; null) 变量.nn：if(变量 !&#x3D; null) 变量.notnull：if(变量 !&#x3D; null) ifn：if(xx &#x3D;&#x3D; null) inn：if(xx !&#x3D; null) 2、遍历数组和集合 数组或集合变量.fori：for循环 数组或集合变量.for：增强for循环 数组或集合变量.forr：反向for循环 数组或集合变量.iter：增强for循环遍历数组或集合 3、输出语句 sout：相当于System.out.println soutm：打印当前方法的名称 soutp：打印当前方法的形参及形参对应的实参值 soutv：打印方法中声明的最近的变量的值 变量.sout：打印当前变量值 变量.soutv：打印当前变量名及变量值 4、对象操作 创建对象 Xxx.new .var ：创建Xxx类的对象，并赋给相应的变量 Xxx.new .field：会将方法内刚创建的Xxx对象抽取为一个属性 强转 对象.cast：将对象进行强转 对象.castvar：将对象强转后，并赋给一个变量 5、静态常量声明 psf：public static final psfi：public static final int psfs：public static final String prsf：private static final 7.4 自定义代码模板7.4.1 自定义后缀补全模板 7.4.2 自定义Live Templates例如：定义sop代表System.out.print();语句 ①在Live Templates中增加模板 ②先定义一个模板的组，这样方便管理所有自定义的代码模板 ③在模板组里新建模板 ④定义模板（以输出语句为例） Abbreviation：模板的缩略名称 Description：模板的描述 Template text：模板的代码片段 模板应用范围。比如点击Define。选择如下：应用在java代码中。 其它模板1：单元测试模板： 1234@Testpublic void test$var1$()&#123; $var2$&#125; 其它模板2：创建多线程 12345new Thread()&#123; public void run()&#123; $var$ &#125;&#125;; 其它模板3：冒泡排序 123456789for(int $INDEX$ = 1; $INDEX$ &lt; $ARRAY$.length; $INDEX$++) &#123; for(int $INDEX2$ = 0; $INDEX2$ &lt; $ARRAY$.length-$INDEX$; $INDEX2$++) &#123; if($ARRAY$[$INDEX2$] &gt; $ARRAY$[$INDEX2$+1])&#123; $ELEMENT_TYPE$ temp = $ARRAY$[$INDEX2$]; $ARRAY$[$INDEX2$] = $ARRAY$[$INDEX2$+1]; $ARRAY$[$INDEX2$+1] = temp; &#125; &#125;&#125;","categories":[{"name":"java基础","slug":"java基础","permalink":"http://example.com/categories/java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"java","slug":"java","permalink":"http://example.com/tags/java/"}]},{"title":"第04章_IDEA的安装与使用（下）","slug":"Java/尚硅谷_第04章_IDEA的安装与使用/尚硅谷_宋红康_第04章_IDEA的安装与使用（下）","date":"2022-09-27T00:55:54.000Z","updated":"2023-10-07T11:32:40.645Z","comments":true,"path":"2022/09/27/Java/尚硅谷_第04章_IDEA的安装与使用/尚硅谷_宋红康_第04章_IDEA的安装与使用（下）/","link":"","permalink":"http://example.com/2022/09/27/Java/%E5%B0%9A%E7%A1%85%E8%B0%B7_%E7%AC%AC04%E7%AB%A0_IDEA%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/%E5%B0%9A%E7%A1%85%E8%B0%B7_%E5%AE%8B%E7%BA%A2%E5%BA%B7_%E7%AC%AC04%E7%AB%A0_IDEA%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%8B%EF%BC%89/","excerpt":"","text":"第04章_IDEA的安装与使用（下）讲师：尚硅谷-宋红康（江湖人称：康师傅） 官网：http://www.atguigu.com 8. 快捷键的使用8.1 常用快捷键见《尚硅谷_宋红康_IntelliJ IDEA 常用快捷键一览表.md》 8.2 查看快捷键1、已知快捷键操作名，未知快捷键 2、已知快捷键，不知道对应的操作名 8.3 自定义快捷键 8.4 使用其它平台快捷键苹果电脑或者是用惯Eclipse快捷的，可以选择其他快捷键插件。 9. IDEA断点调试(Debug)9.1 为什么需要Debug编好的程序在执行过程中如果出现错误，该如何查找或定位错误呢？简单的代码直接就可以看出来，但如果代码比较复杂，就需要借助程序调试工具（Debug）来查找错误了。 123456789运行编写好的程序时，可能出现的几种情况：&gt; 情况1：没有任何bug,程序执行正确！====================如果出现如下的三种情况，都又必要使用debug=============================&gt; 情况2：运行以后，出现了错误或异常信息。但是通过日志文件或控制台，显示了异常信息的位置。&gt; 情况3：运行以后，得到了结果，但是结果不是我们想要的。&gt; 情况4：运行以后，得到了结果，结果大概率是我们想要的。但是多次运行的话，可能会出现不是我们想要的情况。 比如：多线程情况下，处理线程安全问题。 9.2 Debug的步骤Debug(调试)程序步骤如下： 1、添加断点 2、启动调试 3、单步执行 4、观察变量和执行流程，找到并解决问题 1、添加断点在源代码文件中，在想要设置断点的代码行的前面的标记行处，单击鼠标左键就可以设置断点，在相同位置再次单击即可取消断点。 2、启动调试IDEA提供多种方式来启动程序(Launch)的调试，分别是通过菜单(Run –&gt; Debug)、图标(“绿色臭虫”等等 3、单步调试工具介绍 或 ：Step Over（F8）：进入下一步，如果当前行断点是调用一个方法，则不进入当前方法体内 ：Step Into（F7）：进入下一步，如果当前行断点是调用一个自定义方法，则进入该方法体内 ：Force Step Into（Alt +Shift + F7）：进入下一步，如果当前行断点是调用一个核心类库方法，则进入该方法体内 ：Step Out（Shift + F8）：跳出当前方法体 ：Run to Cursor（Alt + F9）：直接跳到光标处继续调试 ：Resume Program（F9）：恢复程序运行，但如果该断点下面代码还有断点则停在下一个断点上 ：Stop（Ctrl + F2）：结束调试 ：View Breakpoints（Ctrl + Shift + F8）：查看所有断点 ：Mute Breakpoints：使得当前代码后面所有的断点失效， 一下执行到底 说明：在Debug过程中，可以动态的下断点。 9.3 多种Debug情况介绍9.3.1 行断点 断点打在代码所在的行上。执行到此行时，会停下来。 123456789101112131415161718192021222324252627282930313233343536package com.atguigu.debug;/** * ClassName: Debug01 * Package: com.atguigu.debug * Description: 演示1：行断点 &amp; 测试debug各个常见操作按钮 * * @Author: 尚硅谷-宋红康 * @Create: 2022/10/20 18:44 * @Version 1.0 */public class Debug01 &#123; public static void main(String[] args) &#123; //1. int m = 10; int n = 20; System.out.println(&quot;m = &quot; + m + &quot;,n = &quot; + n); swap(m, n); System.out.println(&quot;m = &quot; + m + &quot;,n = &quot; + n); //2. int[] arr = new int[] &#123;1,2,3,4,5&#125;; System.out.println(arr);//地址值 char[] arr1 = new char[] &#123;&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;&#125;; System.out.println(arr1);//abc &#125; public static void swap(int m,int n)&#123; int temp = m; m = n; n = temp; &#125;&#125; 9.3.2 方法断点 断点设置在方法的签名上，默认当进入时，断点可以被唤醒。 也可以设置在方法退出时，断点也被唤醒 在多态的场景下，在父类或接口的方法上打断点，会自动调入到子类或实现类的方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960package com.atguigu.debug;import java.util.HashMap;/** * ClassName: Debug02 * Package: com.atguigu.debug * Description: 演示2： 方法断点 * * @Author: 尚硅谷-宋红康 * @Create: 2022/10/20 21:15 * @Version 1.0 */public class Debug02 &#123; public static void main(String[] args) &#123; //1. Son instance = new Son(); instance.test(); //2. Father instance1 = new Son(); instance1.test(); //3. Consumer con = new ConsumerImpl(); con.accept(&quot;atguigu&quot;); //4. HashMap map = new HashMap(); map.put(&quot;Tom&quot;,12); map.put(&quot;Jerry&quot;,11); map.put(&quot;Tony&quot;,20); &#125;&#125;class Father&#123; public void test()&#123; System.out.println(&quot;Father : test&quot;); &#125;&#125;class Son extends Father&#123; public void test()&#123; System.out.println(&quot;Son : test&quot;); &#125;&#125;interface Consumer&#123; void accept(String str);&#125;class ConsumerImpl implements Consumer&#123; @Override public void accept(String str) &#123; System.out.println(&quot;ConsumerImple:&quot; + str); &#125;&#125; 9.3.3 字段断点 在类的属性声明上打断点，默认对属性的修改操作进行监控 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475package com.atguigu.debug;/** * ClassName: Debug03 * Package: com.atguigu.debug * Description: 演示3：字段断点 * * @Author: 尚硅谷-宋红康 * @Create: 2022/10/20 21:34 * @Version 1.0 */public class Debug03 &#123; public static void main(String[] args) &#123; Person p1 = new Person(3); System.out.println(p1); &#125;&#125;class Person&#123; private int id = 1; private String name; private int age; public Person() &#123; &#125; &#123; id = 2; &#125; public Person(int id) &#123; this.id = id; &#125; public Person(int id, String name, int age) &#123; this.id = id; this.name = name; this.age = age; &#125; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; @Override public String toString() &#123; return &quot;Person&#123;&quot; + &quot;id=&quot; + id + &quot;, name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, age=&quot; + age + &#x27;&#125;&#x27;; &#125;&#125; 9.3.4 条件断点123456789101112131415161718192021package com.atguigu.debug;/** * ClassName: Debug04 * Package: com.atguigu.debug * Description: 演示4：条件断点 * * @Author: 尚硅谷-宋红康 * @Create: 2022/10/20 21:49 * @Version 1.0 */public class Debug04 &#123; public static void main(String[] args) &#123; int[] arr = new int[]&#123;1,2,3,4,5,6,7,8,9,10,11,12&#125;; for (int i = 0; i &lt; arr.length; i++) &#123; int target = arr[i]; System.out.println(target); &#125; &#125;&#125; 针对上述代码，在满足arr[i] % 3 &#x3D;&#x3D; 0的条件下，执行断点。 9.3.5 异常断点（暂略） 对异常进行跟踪。如果程序出现指定异常，程序就会执行断点，自动停住。 1234567891011121314151617181920212223242526272829package com.atguigu.debug;import java.util.Date;/** * ClassName: Debug05 * Package: com.atguigu.debug * Description: 演示5：异常断点 * * @Author: 尚硅谷-宋红康 * @Create: 2022/10/20 22:01 * @Version 1.0 */public class Debug05 &#123; public static void main(String[] args) &#123; int m = 10; int n = 0; int result = m / n; System.out.println(result);// Person p1 = new Person(1001);// System.out.println(p1.getName().toUpperCase()); &#125;&#125; 通过下图的方式，对指定的异常进行监控： 9.3.6 线程调试（暂略）123456789101112131415161718192021222324252627282930package com.atguigu.debug;/** * ClassName: Debug06 * Package: com.atguigu.debug * Description: 演示6：线程调试 * * @Author: 尚硅谷-宋红康 * @Create: 2022/10/20 22:46 * @Version 1.0 */public class Debug06 &#123; public static void main(String[] args) &#123; test(&quot;Thread1&quot;); test(&quot;Thread2&quot;); &#125; public static void test(String threadName) &#123; new Thread( () -&gt; System.out.println(Thread.currentThread().getName()), threadName ).start(); &#125;&#125; 9.3.7 强制结束12345678910111213141516171819202122232425262728package com.atguigu.debug;/** * ClassName: Debug07 * Package: com.atguigu.debug * Description: 演示7：强制结束 * * @Author: 尚硅谷-宋红康 * @Create: 2022/10/20 23:15 * @Version 1.0 */public class Debug07 &#123; public static void main(String[] args) &#123; System.out.println(&quot;获取请求的数据&quot;); System.out.println(&quot;调用写入数据库的方法&quot;); insert(); System.out.println(&quot;程序结束&quot;); &#125; private static void insert() &#123; System.out.println(&quot;进入insert()方法&quot;); System.out.println(&quot;获取数据库连接&quot;); System.out.println(&quot;将数据写入数据表中&quot;); System.out.println(&quot;写出操作完成&quot;); System.out.println(&quot;断开连接&quot;); &#125;&#125; 9.4 自定义调试数据视图（暂略）12345678910111213141516171819202122232425package com.atguigu.debug;import java.util.HashMap;/** * ClassName: Debug08 * Package: com.atguigu.debug * Description: 演示8：用户自定义数据视图 * * @Author: 尚硅谷-宋红康 * @Create: 2022/10/20 23:21 * @Version 1.0 */public class Debug08 &#123; public static void main(String[] args) &#123; HashMap&lt;Integer,String&gt; map = new HashMap&lt;&gt;(); map.put(1,&quot;高铁&quot;); map.put(2,&quot;网购&quot;); map.put(3,&quot;支付宝&quot;); map.put(4,&quot;共享单车&quot;); System.out.println(map); &#125;&#125; 设置如下： 9.5 常见问题问题：使用Step Into时，会出现无法进入源码的情况。如何解决？ 方案1：使用 force step into 即可 方案2：点击Setting -&gt; Build,Execution,Deployment -&gt; Debugger -&gt; Stepping 把Do not step into the classess中的java.*、javax.* 取消勾选即可。 小结： 经验：初学者对于在哪里加断点，缺乏经验，这也是调试程序最麻烦的地方，需要一定的经验。 简单来说，在可能发生错误的代码的前面加断点。如果不会判断，就在程序执行的起点处加断点。 10. IDEA常用插件推荐1：Alibaba Java Coding Guidelines 阿里巴巴Java编码规范检查插件，检测代码是否存在问题，以及是否符合规范。 使用：在类中，右键，选择编码规约扫描，在下方显示扫描规约和提示。根据提示规范代码，提高代码质量。 推荐2：jclasslib bytecode viewer 可视化的字节码查看器。 使用： 在 IDEA 打开想研究的类。 编译该类或者直接编译整个项目（ 如果想研究的类在 jar 包中，此步可略过）。 打开“view” 菜单，选择“Show Bytecode With jclasslib” 选项。 选择上述菜单项后 IDEA 中会弹出 jclasslib 工具窗口。 英文设置： 在 Help -&gt; Edit Custom VM Options …，加上 1-Duser.language=en 推荐3：Translation 注册翻译服务（有道智云、百度翻译开放平台、阿里云机器翻译）帐号，开通翻译服务并获取其应用ID和密钥绑定应用ID和密钥：偏好设置（设置） &gt; 工具 &gt; 翻译 &gt; 常规 &gt; 翻译引擎 &gt; 配置… 使用：鼠标选中文本，点击右键即可自动翻译成多国语言。 注：请注意保管好你的应用密钥，防止其泄露。 推荐4：GenerateAllSetter 实际开发中还有一个非常常见的场景： 我们创建一个对象后，想依次调用 Setter 函数对属性赋值，如果属性较多很容易遗漏或者重复。 可以使用这 GenerateAllSetter 提供的功能，快速生成对象的所有 Setter 函数（可填充默认值），然后自己再跟进实际需求设置属性值。 插件5：Rainbow Brackets 给括号添加彩虹色，使开发者通过颜色区分括号嵌套层级，便于阅读 推荐6：CodeGlance Pro 在编辑器右侧生成代码小地图，可以拖拽小地图光标快速定位代码，阅读行数很多的代码文件时非常实用。 推荐7：Statistic 代码统计工具。 推荐8：Presentation Assistant 显示快捷键操作的按键 推荐9：Key Promoter X 快捷键提示插件。当你执行鼠标操作时，如果该操作可被快捷键代替，会给出提示，帮助你自然形成使用快捷键的习惯，告别死记硬背。 推荐10：JavaDoc 按alt+insert，执行操作： 推荐11： LeetCode Editor 在 IDEA 里刷力扣算法题 推荐12：GsonFormatPlus 根据 json 生成对象。 使用：使用alt + s 或 alt + insert调取。 举例： 12345678910&#123; &quot;name&quot;: &quot;tom&quot;, &quot;age&quot;: &quot;18&quot;, &quot;gender&quot;: &quot;man&quot;, &quot;hometown&quot;: &#123; &quot;province&quot;: &quot;河北省&quot;, &quot;city&quot;: &quot;石家庄市&quot;, &quot;county&quot;: &quot;正定县&quot; &#125;&#125; 插件13：Material Theme UI 对于很多人而言，写代码时略显枯燥的，如果能够安装自己喜欢的主题将为开发工作带来些许乐趣。 IDEA 支持各种主题插件，其中最出名的当属 Material Theme UI。 安装后，可以从该插件内置的各种风格个选择自己最喜欢的一种。","categories":[{"name":"java基础","slug":"java基础","permalink":"http://example.com/categories/java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"java","slug":"java","permalink":"http://example.com/tags/java/"}]},{"title":"第05章_数组","slug":"Java/尚硅谷_第05章_数组/尚硅谷_宋红康_第05章_数组","date":"2022-09-27T00:55:54.000Z","updated":"2023-10-07T11:36:20.542Z","comments":true,"path":"2022/09/27/Java/尚硅谷_第05章_数组/尚硅谷_宋红康_第05章_数组/","link":"","permalink":"http://example.com/2022/09/27/Java/%E5%B0%9A%E7%A1%85%E8%B0%B7_%E7%AC%AC05%E7%AB%A0_%E6%95%B0%E7%BB%84/%E5%B0%9A%E7%A1%85%E8%B0%B7_%E5%AE%8B%E7%BA%A2%E5%BA%B7_%E7%AC%AC05%E7%AB%A0_%E6%95%B0%E7%BB%84/","excerpt":"","text":"第05章_数组本章专题与脉络 1. 数组的概述1.1 为什么需要数组需求分析1： 需要统计某公司50个员工的工资情况，例如计算平均工资、找到最高工资等。用之前知识，首先需要声明50个变量来分别记录每位员工的工资，这样会很麻烦。因此我们可以将所有的数据全部存储到一个容器中统一管理，并使用容器进行计算。 需求分析2： 容器的概念： 生活中的容器：水杯（装水等液体），衣柜（装衣服等物品），集装箱（装货物等）。 程序中的容器：将多个数据存储到一起，每个数据称为该容器的元素。 1.2 数组的概念 数组(Array)，是多个相同类型数据按一定顺序排列的集合，并使用一个名字命名，并通过编号的方式对这些数据进行统一管理。 数组中的概念 数组名 下标（或索引） 元素 数组的长度 数组的特点： 数组本身是引用数据类型，而数组中的元素可以是任何数据类型，包括基本数据类型和引用数据类型。 创建数组对象会在内存中开辟一整块连续的空间。占据的空间的大小，取决于数组的长度和数组中元素的类型。 数组中的元素在内存中是依次紧密排列的，有序的。 数组，一旦初始化完成，其长度就是确定的。数组的长度一旦确定，就不能修改。 我们可以直接通过下标(或索引)的方式调用指定位置的元素，速度很快。 数组名中引用的是这块连续空间的首地址。 1.3 数组的分类1、按照元素类型分： 基本数据类型元素的数组：每个元素位置存储基本数据类型的值 引用数据类型元素的数组：每个元素位置存储对象（本质是存储对象的首地址）（在面向对象部分讲解） 2、按照维度分： 一维数组：存储一组数据 二维数组：存储多组数据，相当于二维表，一行代表一组数据，只是这里的二维表每一行长度不要求一样。 2. 一维数组的使用2.1 一维数组的声明格式： 12345//推荐元素的数据类型[] 一维数组的名称;//不推荐元素的数据类型 一维数组名[]; 举例： 1234int[] arr;int arr1[];double[] arr2;String[] arr3; //引用类型变量数组 数组的声明，需要明确： （1）数组的维度：在Java中数组的符号是[]，[]表示一维，[][]表示二维。 （2）数组的元素类型：即创建的数组容器可以存储什么数据类型的数据。元素的类型可以是任意的Java的数据类型。例如：int、String、Student等。 （3）数组名：就是代表某个数组的标识符，数组名其实也是变量名，按照变量的命名规范来命名。数组名是个引用数据类型的变量，因为它代表一组数据。 举例： 123456789101112131415161718public class ArrayTest1 &#123; public static void main(String[] args) &#123; //比如，要存储一个小组的成绩 int[] scores; int grades[];// System.out.println(scores);//未初始化不能使用 //比如，要存储一组字母 char[] letters; //比如，要存储一组姓名 String[] names; //比如，要存储一组价格 double[] prices; &#125;&#125; 注意：Java语言中声明数组时不能指定其长度(数组中元素的个数)。 例如： int a[5]; &#x2F;&#x2F;非法 2.2 一维数组的初始化2.2.1 静态初始化 如果数组变量的初始化和数组元素的赋值操作同时进行，那就称为静态初始化。 静态初始化，本质是用静态数据（编译时已知）为数组初始化。此时数组的长度由静态数据的个数决定。 一维数组声明和静态初始化格式1： 123456数据类型[] 数组名 = new 数据类型[]&#123;元素1,元素2,元素3,...&#125;;或 数据类型[] 数组名;数组名 = new 数据类型[]&#123;元素1,元素2,元素3,...&#125;; new：关键字，创建数组使用的关键字。因为数组本身是引用数据类型，所以要用new创建数组实体。 例如，定义存储1，2，3，4，5整数的数组容器。 1234int[] arr = new int[]&#123;1,2,3,4,5&#125;;//正确//或int[] arr;arr = new int[]&#123;1,2,3,4,5&#125;;//正确 一维数组声明和静态初始化格式2： 1数据类型[] 数组名 = &#123;元素1,元素2,元素3...&#125;;//必须在一个语句中完成，不能分成两个语句写 例如，定义存储1，2，3，4，5整数的数组容器 1234int[] arr = &#123;1,2,3,4,5&#125;;//正确int[] arr;arr = &#123;1,2,3,4,5&#125;;//错误 举例： 1234567891011121314151617public class ArrayTest2 &#123; public static void main(String[] args) &#123; int[] arr = &#123;1,2,3,4,5&#125;;//右边不需要写new int[] int[] nums; nums = new int[]&#123;10,20,30,40&#125;; //声明和初始化在两个语句完成，就不能使用new int[] char[] word = &#123;&#x27;h&#x27;,&#x27;e&#x27;,&#x27;l&#x27;,&#x27;l&#x27;,&#x27;o&#x27;&#125;; String[] heros = &#123;&quot;袁隆平&quot;,&quot;邓稼先&quot;,&quot;钱学森&quot;&#125;; System.out.println(&quot;arr数组：&quot; + arr);//arr数组：[I@1b6d3586 System.out.println(&quot;nums数组：&quot; + nums);//nums数组：[I@4554617c System.out.println(&quot;word数组：&quot; + word);//word数组：[C@74a14482 System.out.println(&quot;heros数组：&quot; + heros);//heros数组：[Ljava.lang.String;@1540e19d &#125;&#125; 2.2.2 动态初始化数组变量的初始化和数组元素的赋值操作分开进行，即为动态初始化。 动态初始化中，只确定了元素的个数（即数组的长度），而元素值此时只是默认值，还并未真正赋自己期望的值。真正期望的数据需要后续单独一个一个赋值。 格式： 123456数组存储的元素的数据类型[] 数组名字 = new 数组存储的元素的数据类型[长度];或数组存储的数据类型[] 数组名字;数组名字 = new 数组存储的数据类型[长度]; [长度]：数组的长度，表示数组容器中可以最多存储多少个元素。 注意：数组有定长特性，长度一旦指定，不可更改。和水杯道理相同，买了一个2升的水杯，总容量就是2升是固定的。 举例1：正确写法 12345int[] arr = new int[5];int[] arr;arr = new int[5]; 举例2：错误写法 1int[] arr = new int[5]&#123;1,2,3,4,5&#125;;//错误的，后面有&#123;&#125;指定元素列表，就不需要在[]中指定元素个数了。 2.3 一维数组的使用2.3.1 数组的长度 数组的元素总个数，即数组的长度 每个数组都有一个属性length指明它的长度，例如：arr.length 指明数组arr的长度(即元素个数) 每个数组都具有长度，而且一旦初始化，其长度就是确定，且是不可变的。 2.3.2 数组元素的引用如何表示数组中的一个元素？ 每一个存储到数组的元素，都会自动的拥有一个编号，从0开始，这个自动编号称为数组索引(index)或下标，可以通过数组的索引&#x2F;下标访问到数组中的元素。 1数组名[索引/下标] 数组的下标范围？ Java中数组的下标从[0]开始，下标范围是[0, 数组的长度-1]，即[0, 数组名.length-1] 数组元素下标可以是整型常量或整型表达式。如a[3] , b[i] , c[6*i]; 举例 1234567891011121314151617public class ArrayTest3 &#123; public static void main(String[] args) &#123; int[] arr = &#123;1,2,3,4,5&#125;; System.out.println(&quot;arr数组的长度：&quot; + arr.length); System.out.println(&quot;arr数组的第1个元素：&quot; + arr[0]);//下标从0开始 System.out.println(&quot;arr数组的第2个元素：&quot; + arr[1]); System.out.println(&quot;arr数组的第3个元素：&quot; + arr[2]); System.out.println(&quot;arr数组的第4个元素：&quot; + arr[3]); System.out.println(&quot;arr数组的第5个元素：&quot; + arr[4]); //修改第1个元素的值 //此处arr[0]相当于一个int类型的变量 arr[0] = 100; System.out.println(&quot;arr数组的第1个元素：&quot; + arr[0]); &#125;&#125; 2.4 一维数组的遍历将数组中的每个元素分别获取出来，就是遍历。for循环与数组的遍历是绝配。 举例1 12345678910111213public class ArrayTest4 &#123; public static void main(String[] args) &#123; int[] arr = new int[]&#123;1,2,3,4,5&#125;; //打印数组的属性，输出结果是5 System.out.println(&quot;数组的长度：&quot; + arr.length); //遍历输出数组中的元素 System.out.println(&quot;数组的元素有：&quot;); for(int i=0; i&lt;arr.length; i++)&#123; System.out.println(arr[i]); &#125; &#125;&#125; 举例2 123456789101112131415161718192021222324252627282930313233343536373839public class ArrayTest5 &#123; public static void main(String[] args) &#123; int[] arr = new int[5]; System.out.println(&quot;arr数组的长度：&quot; + arr.length); System.out.print(&quot;存储数据到arr数组之前：[&quot;); for (int i = 0; i &lt; arr.length; i++) &#123; if(i==0)&#123; System.out.print(arr[i]); &#125;else&#123; System.out.print(&quot;,&quot; + arr[i]); &#125; &#125; System.out.println(&quot;]&quot;); //初始化 /* arr[0] = 2; arr[1] = 4; arr[2] = 6; arr[3] = 8; arr[4] = 10; */ for (int i = 0; i &lt; arr.length; i++) &#123; arr[i] = (i+1) * 2; &#125; System.out.print(&quot;存储数据到arr数组之后：[&quot;); for (int i = 0; i &lt; arr.length; i++) &#123; if(i==0)&#123; System.out.print(arr[i]); &#125;else&#123; System.out.print(&quot;,&quot; + arr[i]); &#125; &#125; System.out.println(&quot;]&quot;); &#125;&#125; 2.5 数组元素的默认值数组是引用类型，当我们使用动态初始化方式创建数组时，元素值只是默认值。例如： 123456public class ArrayTest6 &#123; public static void main(String argv[])&#123; int a[]= new int[5]; System.out.println(a[3]); //a[3]的默认值为0 &#125;&#125; 对于基本数据类型而言，默认初始化值各有不同。 对于引用数据类型而言，默认初始化值为null（注意与0不同！) 1234567891011121314151617181920212223242526272829public class ArrayTest7 &#123; public static void main(String[] args) &#123; //存储26个字母 char[] letters = new char[26]; System.out.println(&quot;letters数组的长度：&quot; + letters.length); System.out.print(&quot;存储字母到letters数组之前：[&quot;); for (int i = 0; i &lt; letters.length; i++) &#123; if(i==0)&#123; System.out.print(letters[i]); &#125;else&#123; System.out.print(&quot;,&quot; + letters[i]); &#125; &#125; System.out.println(&quot;]&quot;); //存储5个姓名 String[] names = new String[5]; System.out.println(&quot;names数组的长度：&quot; + names.length); System.out.print(&quot;存储姓名到names数组之前：[&quot;); for (int i = 0; i &lt; names.length; i++) &#123; if(i==0)&#123; System.out.print(names[i]); &#125;else&#123; System.out.print(&quot;,&quot; + names[i]); &#125; &#125; System.out.println(&quot;]&quot;); &#125;&#125; 3. 一维数组内存分析3.1 Java虚拟机的内存划分为了提高运算效率，就对空间进行了不同区域的划分，因为每一片区域都有特定的处理数据方式和内存管理方式。 区域名称 作用 虚拟机栈 用于存储正在执行的每个Java方法的局部变量表等。局部变量表存放了编译期可知长度的各种基本数据类型、对象引用，方法执行完，自动释放。 堆内存 存储对象（包括数组对象），new来创建的，都存储在堆内存。 方法区 存储已被虚拟机加载的类信息、常量、（静态变量）、即时编译器编译后的代码等数据。 本地方法栈 当程序中调用了native的本地方法时，本地方法执行期间的内存区域 程序计数器 程序计数器是CPU中的寄存器，它包含每一个线程下一条要执行的指令的地址 3.2 一维数组在内存中的存储1、一个一维数组内存图12345public static void main(String[] args) &#123; int[] arr = new int[3]; System.out.println(arr);//[I@5f150435&#125; 2、数组下标为什么是0开始因为第一个元素距离数组首地址间隔0个单元格。 3、两个一维数组内存图两个数组独立 1234567public static void main(String[] args) &#123; int[] arr = new int[3]; int[] arr2 = new int[2]; System.out.println(arr); System.out.println(arr2);&#125; 4、两个变量指向一个一维数组两个数组变量本质上代表同一个数组。 12345678910111213141516public static void main(String[] args) &#123; // 定义数组，存储3个元素 int[] arr = new int[3]; //数组索引进行赋值 arr[0] = 5; arr[1] = 6; arr[2] = 7; //输出3个索引上的元素值 System.out.println(arr[0]); System.out.println(arr[1]); System.out.println(arr[2]); //定义数组变量arr2，将arr的地址赋值给arr2 int[] arr2 = arr; arr2[1] = 9; System.out.println(arr[1]);&#125; 4. 一维数组的应用案例1：升景坊单间短期出租4个月，550元&#x2F;月（水电煤公摊，网费35元&#x2F;月），空调、卫生间、厨房齐全。屋内均是IT行业人士，喜欢安静。所以要求来租者最好是同行或者刚毕业的年轻人，爱干净、安静。 123456789101112public class ArrayTest &#123; public static void main(String[] args) &#123; int[] arr = new int[]&#123;8,2,1,0,3&#125;; int[] index = new int[]&#123;2,0,3,2,4,0,1,3,2,3,3&#125;; String tel = &quot;&quot;; for(int i = 0;i &lt; index.length;i++)&#123; tel += arr[index[i]]; &#125; System.out.println(&quot;联系方式：&quot; + tel); &#125;&#125; 案例2：输出英文星期几 用一个数组，保存星期一到星期天的7个英语单词，从键盘输入1-7，显示对应的单词{“Monday”,”Tuesday”,”Wednesday”,”Thursday”,”Friday”,”Saturday”,”Sunday”} 123456789101112131415161718192021222324252627282930import java.util.Scanner;/** * @author 尚硅谷-宋红康 * @create 14:37 */public class WeekArrayTest &#123; public static void main(String[] args) &#123; //1. 声明并初始化星期的数组 String[] weeks = &#123;&quot;Monday&quot;,&quot;Tuesday&quot;,&quot;Wednesday&quot;,&quot;Thursday&quot;,&quot;Friday&quot;,&quot;Saturday&quot;,&quot;Sunday&quot;&#125;; //2. 使用Scanner从键盘获取1-7范围的整数 Scanner scanner = new Scanner(System.in); System.out.println(&quot;请输入[1-7]范围的整数：&quot;); int number = scanner.nextInt(); if(number &lt; 1 || number &gt; 7)&#123; System.out.println(&quot;你输入的输入非法&quot;); &#125;else&#123; //3. 根据输入的整数，到数组中相应的索引位置获取指定的元素（即：星期几） System.out.println(&quot;对应的星期为：&quot; + weeks[number - 1]); &#125; scanner.close(); &#125;&#125; 案例3：从键盘读入学生成绩，找出最高分，并输出学生成绩等级。 成绩&gt;&#x3D;最高分-10 等级为’A’ 成绩&gt;&#x3D;最高分-20 等级为’B’ 成绩&gt;&#x3D;最高分-30 等级为’C’ 其余 等级为’D’ 提示：先读入学生人数，根据人数创建int数组，存放学生成绩。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/** * @author 尚硅谷-宋红康 * @create 14:55 */public class ScoreTest1 &#123; public static void main(String[] args) &#123; //1. 根据提示，获取学生人数 System.out.print(&quot;请输入学生人数：&quot;); Scanner scanner = new Scanner(System.in); int count = scanner.nextInt(); //2. 根据学生人数，创建指定长度的数组 (使用动态初始化) int[] scores = new int[count]; //3. 使用循环，依次给数组的元素赋值 int maxScore = 0; //记录最高分 System.out.println(&quot;请输入&quot; + count + &quot;个成绩&quot;); for (int i = 0; i &lt; scores.length; i++) &#123; scores[i] = scanner.nextInt(); //4. 获取数组中元素的最大值，即为最高分 if(maxScore &lt; scores[i])&#123; maxScore = scores[i]; &#125; &#125; System.out.println(&quot;最高分是：&quot; + maxScore); //5. 遍历数组元素，输出各自的分数，并根据其分数与最高分的差值，获取各自的等级 char grade; for (int i = 0; i &lt; scores.length; i++) &#123; if(scores[i] &gt;= maxScore - 10)&#123; grade = &#x27;A&#x27;; &#125;else if(scores[i] &gt;= maxScore - 20)&#123; grade = &#x27;B&#x27;; &#125;else if(scores[i] &gt;= maxScore - 30)&#123; grade = &#x27;C&#x27;; &#125;else&#123; grade = &#x27;D&#x27;; &#125; System.out.println(&quot;student &quot; + i + &quot; socre is &quot; + scores[i] + &quot;, grade is &quot; + grade); &#125; //关闭资源 scanner.close(); &#125;&#125; 5. 多维数组的使用5.1 概述 Java 语言里提供了支持多维数组的语法。 如果说可以把一维数组当成几何中的线性图形，那么二维数组就相当于是一个表格，像Excel中的表格、围棋棋盘一样。 应用举例1： 某公司2022年全年各个月份的销售额进行登记。按月份存储，可以使用一维数组。如下： 1int[] monthData = new int[]&#123;23,43,22,34,55,65,44,67,45,78,67,66&#125;; 如果改写为按季度为单位存储怎么办呢？ 1int[][] quarterData = new int[][]&#123;&#123;23,43,22&#125;,&#123;34,55,65&#125;,&#123;44,67,45&#125;,&#123;78,67,66&#125;&#125;; 应用举例2： 高一年级三个班级均由多个学生姓名构成一个个数组。如下： 123456String[] class1 = new String[]&#123;&quot;段誉&quot;,&quot;令狐冲&quot;,&quot;任我行&quot;&#125;;String[] class2 = new String[]&#123;&quot;张三丰&quot;,&quot;周芷若&quot;&#125;;String[] class3 = new String[]&#123;&quot;赵敏&quot;,&quot;张无忌&quot;,&quot;韦小宝&quot;,&quot;杨过&quot;&#125;; 那从整个年级看，我们可以声明一个二维数组。如下： 1String[][] grade = new String[][]&#123;&#123;&quot;段誉&quot;,&quot;令狐冲&quot;,&quot;任我行&quot;&#125;,&#123;&quot;张三丰&quot;,&quot;周芷若&quot;&#125;,&#123;&quot;赵敏&quot;,&quot;张无忌&quot;,&quot;韦小宝&quot;,&quot;杨过&quot;&#125;&#125;; 应用举例3： 蓝框的几个元素，可以使用一维数组来存储。但现在发现每个元素下还有下拉框，其内部还有元素，那就需要使用二维数组来存储： 使用说明 对于二维数组的理解，可以看成是一维数组array1又作为另一个一维数组array2的元素而存在。 其实，从数组底层的运行机制来看，其实没有多维数组。 5.2 声明与初始化5.2.1 声明二维数组声明的语法格式： 1234567//推荐元素的数据类型[][] 二维数组的名称;//不推荐元素的数据类型 二维数组名[][];//不推荐元素的数据类型[] 二维数组名[]; 例如： 123456789public class Test20TwoDimensionalArrayDefine &#123; public static void main(String[] args) &#123; //存储多组成绩 int[][] grades; //存储多组姓名 String[][] names; &#125;&#125; 面试： 12int[] x, y[];//x是一维数组，y是二维数组 5.2.2 静态初始化格式： 1int[][] arr = new int[][]&#123;&#123;3,8,2&#125;,&#123;2,7&#125;,&#123;9,0,1,6&#125;&#125;; 定义一个名称为arr的二维数组，二维数组中有三个一维数组 每一个一维数组中具体元素也都已初始化 第一个一维数组 arr[0] &#x3D; {3,8,2}; 第二个一维数组 arr[1] &#x3D; {2,7}; 第三个一维数组 arr[2] &#x3D; {9,0,1,6}; 第三个一维数组的长度表示方式：arr[2].length; 注意特殊写法情况：int[] x,y[]; x是一维数组，y是二维数组。 举例1： 12345678int[][] arr = &#123;&#123;1,2,3&#125;,&#123;4,5,6&#125;,&#123;7,8,9,10&#125;&#125;;//声明与初始化必须在一句完成int[][] arr = new int[][]&#123;&#123;1,2,3&#125;,&#123;4,5,6&#125;,&#123;7,8,9,10&#125;&#125;;int[][] arr;arr = new int[][]&#123;&#123;1,2,3&#125;,&#123;4,5,6&#125;,&#123;7,8,9,10&#125;&#125;;arr = new int[3][3]&#123;&#123;1,2,3&#125;,&#123;4,5,6&#125;,&#123;7,8,9,10&#125;&#125;;//错误，静态初始化右边new 数据类型[][]中不能写数字 举例2： 12345678910111213141516171819public class TwoDimensionalArrayInitialize &#123; public static void main(String[] args) &#123; //存储多组成绩 int[][] grades = &#123; &#123;89,75,99,100&#125;, &#123;88,96,78,63,100,86&#125;, &#123;56,63,58&#125;, &#123;99,66,77,88&#125; &#125;; //存储多组姓名 String[][] names = &#123; &#123;&quot;张三&quot;,&quot;李四&quot;, &quot;王五&quot;, &quot;赵六&quot;&#125;, &#123;&quot;刘备&quot;,&quot;关羽&quot;,&quot;张飞&quot;,&quot;诸葛亮&quot;,&quot;赵云&quot;,&quot;马超&quot;&#125;, &#123;&quot;曹丕&quot;,&quot;曹植&quot;,&quot;曹冲&quot;&#125;, &#123;&quot;孙权&quot;,&quot;周瑜&quot;,&quot;鲁肃&quot;,&quot;黄盖&quot;&#125; &#125;; &#125;&#125; 5.2.3 动态初始化如果二维数组的每一个数据，甚至是每一行的列数，需要后期单独确定，那么就只能使用动态初始化方式了。动态初始化方式分为两种格式： 格式1：规则二维表：每一行的列数是相同的 123456789//（1）确定行数和列数元素的数据类型[][] 二维数组名 = new 元素的数据类型[m][n]; //其中，m:表示这个二维数组有多少个一维数组。或者说一共二维表有几行 //其中，n:表示每一个一维数组的元素有多少个。或者说每一行共有一个单元格//此时创建完数组，行数、列数确定，而且元素也都有默认值//（2）再为元素赋新值二维数组名[行下标][列下标] = 值; 举例： 1int[][] arr = new int[3][2]; 定义了名称为arr的二维数组 二维数组中有3个一维数组 每一个一维数组中有2个元素 一维数组的名称分别为arr[0], arr[1], arr[2] 给第一个一维数组1脚标位赋值为78写法是：arr[0][1] = 78; 格式2：不规则：每一行的列数不一样 123456789101112//（1）先确定总行数元素的数据类型[][] 二维数组名 = new 元素的数据类型[总行数][];//此时只是确定了总行数，每一行里面现在是null//（2）再确定每一行的列数，创建每一行的一维数组二维数组名[行下标] = new 元素的数据类型[该行的总列数];//此时已经new完的行的元素就有默认值了，没有new的行还是null//(3)再为元素赋值二维数组名[行下标][列下标] = 值; 举例： 1int[][] arr = new int[3][]; 二维数组中有3个一维数组。 每个一维数组都是默认初始化值null (注意：区别于格式1） 可以对这个三个一维数组分别进行初始化：arr[0] &#x3D; new int[3]; arr[1] &#x3D; new int[1]; arr[2] &#x3D; new int[2]; 注：int[][]arr = new int[][3]; &#x2F;&#x2F;非法 练习： 123456789101112131415161718192021222324252627282930313233343536373839404142/* 1 2 2 3 3 3 4 4 4 4 5 5 5 5 5 */public class Test25DifferentElementCount &#123; public static void main(String[] args)&#123; //1、声明一个二维数组，并且确定行数 //因为每一行的列数不同，这里无法直接确定列数 int[][] arr = new int[5][]; //2、确定每一行的列数 for(int i=0; i&lt;arr.length; i++)&#123; /* arr[0] 的列数是1 arr[1] 的列数是2 arr[2] 的列数是3 arr[3] 的列数是4 arr[4] 的列数是5 */ arr[i] = new int[i+1]; &#125; //3、确定元素的值 for(int i=0; i&lt;arr.length; i++)&#123; for(int j=0; j&lt;arr[i].length; j++)&#123; arr[i][j] = i+1; &#125; &#125; //4、遍历显示 for(int i=0; i&lt;arr.length; i++)&#123; for(int j=0; j&lt;arr[i].length; j++)&#123; System.out.print(arr[i][j] + &quot; &quot;); &#125; System.out.println(); &#125; &#125;&#125; 5.3 数组的长度和角标 二维数组的长度&#x2F;行数：二维数组名.length 二维数组的某一行：二维数组名[行下标]，此时相当于获取其中一组数据。它本质上是一个一维数组。行下标的范围：[0, 二维数组名.length-1]。此时把二维数组看成一维数组的话，元素是行对象。 某一行的列数：二维数组名[行下标].length，因为二维数组的每一行是一个一维数组。 某一个元素：二维数组名[行下标][列下标]，即先确定行&#x2F;组，再确定列。 12345678910111213141516171819202122232425262728293031323334353637public class Test22TwoDimensionalArrayUse &#123; public static void main(String[] args)&#123; //存储3个小组的学员的成绩，分开存储，使用二维数组。 /* int[][] scores1; int scores2[][]; int[] scores3[];*/ int[][] scores = &#123; &#123;85,96,85,75&#125;, &#123;99,96,74,72,75&#125;, &#123;52,42,56,75&#125; &#125;; System.out.println(scores);//[[I@15db9742 System.out.println(&quot;一共有&quot; + scores.length +&quot;组成绩.&quot;); //[[：代表二维数组，I代表元素类型是int System.out.println(scores[0]);//[I@6d06d69c //[：代表一维数组，I代表元素类型是int System.out.println(scores[1]);//[I@7852e922 System.out.println(scores[2]);//[I@4e25154f //System.out.println(scores[3]);//ArrayIndexOutOfBoundsException: 3 System.out.println(&quot;第1组有&quot; + scores[0].length +&quot;个学员.&quot;); System.out.println(&quot;第2组有&quot; + scores[1].length +&quot;个学员.&quot;); System.out.println(&quot;第3组有&quot; + scores[2].length +&quot;个学员.&quot;); System.out.println(&quot;第1组的每一个学员成绩如下：&quot;); //第一行的元素 System.out.println(scores[0][0]);//85 System.out.println(scores[0][1]);//96 System.out.println(scores[0][2]);//85 System.out.println(scores[0][3]);//75 //System.out.println(scores[0][4]);//java.lang.ArrayIndexOutOfBoundsException: 4 &#125;&#125; 5.4 二维数组的遍历 格式： 123456for(int i=0; i&lt;二维数组名.length; i++)&#123; //二维数组对象.length for(int j=0; j&lt;二维数组名[i].length; j++)&#123;//二维数组行对象.length System.out.print(二维数组名[i][j]); &#125; System.out.println();&#125; 举例： 12345678910111213141516171819public class Test23TwoDimensionalArrayIterate &#123; public static void main(String[] args) &#123; //存储3个小组的学员的成绩，分开存储，使用二维数组。 int[][] scores = &#123; &#123;85,96,85,75&#125;, &#123;99,96,74,72,75&#125;, &#123;52,42,56,75&#125; &#125;; System.out.println(&quot;一共有&quot; + scores.length +&quot;组成绩.&quot;); for (int i = 0; i &lt; scores.length; i++) &#123; System.out.print(&quot;第&quot; + (i+1) +&quot;组有&quot; + scores[i].length + &quot;个学员，成绩如下：&quot;); for (int j = 0; j &lt; scores[i].length; j++) &#123; System.out.print(scores[i][j]+&quot;\\t&quot;); &#125; System.out.println(); &#125; &#125;&#125; 5.5 内存解析二维数组本质上是元素类型是一维数组的一维数组。 1234567int[][] arr = &#123; &#123;1&#125;, &#123;2,2&#125;, &#123;3,3,3&#125;, &#123;4,4,4,4&#125;, &#123;5,5,5,5,5&#125;&#125;; 123456789//1、声明二维数组，并确定行数和列数int[][] arr = new int[4][5];//2、确定元素的值for (int i = 0; i &lt; arr.length; i++) &#123; for (int j = 0; j &lt; arr.length; j++) &#123; arr[i][j] = i + 1; &#125;&#125; 12345678910111213141516171819202122//1、声明一个二维数组，并且确定行数//因为每一行的列数不同，这里无法直接确定列数int[][] arr = new int[5][];//2、确定每一行的列数for(int i=0; i&lt;arr.length; i++)&#123; /* arr[0] 的列数是1 arr[1] 的列数是2 arr[2] 的列数是3 arr[3] 的列数是4 arr[4] 的列数是5 */ arr[i] = new int[i+1];&#125;//3、确定元素的值for(int i=0; i&lt;arr.length; i++)&#123; for(int j=0; j&lt;arr[i].length; j++)&#123; arr[i][j] = i+1; &#125;&#125; 5.6 应用举例案例1：获取arr数组中所有元素的和。 提示：使用for的嵌套循环即可。 案例2：声明：int[] x,y[]; 在给x,y变量赋值以后，以下选项允许通过编译的是： 123456789101112声明：int[] x,y[]; 在给x,y变量赋值以后，以下选项允许通过编译的是：a) x[0] = y; //nob) y[0] = x; //yesc) y[0][0] = x; //nod) x[0][0] = y; //noe) y[0][0] = x[0]; //yesf) x = y; //no提示：一维数组：int[] x 或者int x[] 二维数组：int[][] y 或者 int[] y[] 或者 int y[][] 案例3：使用二维数组打印一个 10 行杨辉三角。 提示： 第一行有 1 个元素, 第 n 行有 n 个元素 每一行的第一个元素和最后一个元素都是 1 从第三行开始, 对于非第一个元素和最后一个元素的元素。即： 1yanghui[i][j] = yanghui[i-1][j-1] + yanghui[i-1][j]; 123456789101112131415161718192021222324252627282930313233343536373839/** * @author 尚硅谷-宋红康 * @create 10:11 */public class YangHuiTest &#123; public static void main(String[] args) &#123; //1. 动态初始化的方式创建二维数组 int[][] yangHui = new int[10][]; for (int i = 0; i &lt; yangHui.length; i++) &#123; yangHui[i] = new int[i + 1]; //2. 给数组元素赋值 // 2.1 给外层数组元素中的首元素和末元素赋值 yangHui[i][0] = yangHui[i][i] = 1; //2.2 给外层数组元素中的非首元素和非末元素赋值（难） //if(i &gt; 1)&#123; //从 i == 2 开始执行 for(int j = 1;j &lt; yangHui[i].length - 1;j++)&#123; //非首元素和非末元素的角标范围 yangHui[i][j] = yangHui[i-1][j-1] + yangHui[i-1][j]; &#125; //&#125; &#125; //3. 遍历二维数组 for (int i = 0; i &lt; yangHui.length; i++) &#123; for (int j = 0; j &lt; yangHui[i].length; j++) &#123; System.out.print(yangHui[i][j] + &quot;\\t&quot;); &#125; System.out.println(); &#125; &#125;&#125; 6. 数组的常见算法6.1 数值型数组特征值统计 这里的特征值涉及到：平均值、最大值、最小值、总和等 举例1：数组统计：求总和、均值 1234567891011121314public class TestArrayElementSum &#123; public static void main(String[] args) &#123; int[] arr = &#123;4,5,6,1,9&#125;; //求总和、均值 int sum = 0;//因为0加上任何数都不影响结果 for(int i=0; i&lt;arr.length; i++)&#123; sum += arr[i]; &#125; double avg = (double)sum/arr.length; System.out.println(&quot;sum = &quot; + sum); System.out.println(&quot;avg = &quot; + avg); &#125;&#125; 举例2：求数组元素的总乘积 12345678910111213public class TestArrayElementMul &#123; public static void main(String[] args) &#123; int[] arr = &#123;4,5,6,1,9&#125;; //求总乘积 long result = 1;//因为1乘以任何数都不影响结果 for(int i=0; i&lt;arr.length; i++)&#123; result *= arr[i]; &#125; System.out.println(&quot;result = &quot; + result); &#125;&#125; 举例3：求数组元素中偶数的个数 1234567891011121314public class TestArrayElementEvenCount &#123; public static void main(String[] args) &#123; int[] arr = &#123;4,5,6,1,9&#125;; //统计偶数个数 int evenCount = 0; for(int i=0; i&lt;arr.length; i++)&#123; if(arr[i]%2==0)&#123; evenCount++; &#125; &#125; System.out.println(&quot;evenCount = &quot; + evenCount); &#125;&#125; 举例4：求数组元素的最大值 1234567891011121314public class TestArrayMax &#123; public static void main(String[] args) &#123; int[] arr = &#123;4,5,6,1,9&#125;; //找最大值 int max = arr[0]; for(int i=1; i&lt;arr.length; i++)&#123;//此处i从1开始，是max不需要与arr[0]再比较一次了 if(arr[i] &gt; max)&#123; max = arr[i]; &#125; &#125; System.out.println(&quot;max = &quot; + max); &#125;&#125; 举例5：找最值及其第一次出现的下标 1234567891011121314151617public class TestMaxIndex &#123; public static void main(String[] args) &#123; int[] arr = &#123;4,5,6,1,9&#125;; //找最大值以及第一个最大值下标 int max = arr[0]; int index = 0; for(int i=1; i&lt;arr.length; i++)&#123; if(arr[i] &gt; max)&#123; max = arr[i]; index = i; &#125; &#125; System.out.println(&quot;max = &quot; + max); System.out.println(&quot;index = &quot; + index); &#125;&#125; 举例6：找最值及其所有最值的下标 12345678910111213141516171819202122public class Test13AllMaxIndex &#123; public static void main(String[] args) &#123; int[] arr = &#123;4,5,6,1,9,9,3&#125;; //找最大值 int max = arr[0]; for(int i=1; i&lt;arr.length; i++)&#123; if(arr[i] &gt; max)&#123; max = arr[i]; &#125; &#125; System.out.println(&quot;最大值是：&quot; + max); System.out.print(&quot;最大值的下标有：&quot;); //遍历数组，看哪些元素和最大值是一样的 for(int i=0; i&lt;arr.length; i++)&#123; if(max == arr[i])&#123; System.out.print(i+&quot;\\t&quot;); &#125; &#125; System.out.println(); &#125;&#125; 优化 12345678910111213141516171819public class Test13AllMaxIndex2 &#123; public static void main(String[] args) &#123; int[] arr = &#123;4,5,6,1,9,9,3&#125;; //找最大值 int max = arr[0]; String index = &quot;0&quot;; for(int i=1; i&lt;arr.length; i++)&#123; if(arr[i] &gt; max)&#123; max = arr[i]; index = i + &quot;&quot;; &#125;else if(arr[i] == max)&#123; index += &quot;,&quot; + i; &#125; &#125; System.out.println(&quot;最大值是&quot; + max); System.out.println(&quot;最大值的下标是[&quot; + index+&quot;]&quot;); &#125;&#125; 举例7(难)：输入一个整形数组，数组里有正数也有负数。数组中连续的一个或多个整数组成一个子数组，每个子数组都有一个和。求所有子数组的和的最大值。要求时间复杂度为O(n)。例如：输入的数组为1, -2, 3, -10, -4, 7, 2, -5，和最大的子数组为3, 10, -4, 7, 2，因此输出为该子数组的和18。 1234567891011121314151617181920212223242526272829303132333435public class Test5 &#123; public static void main(String[] args) &#123; int[] arr = new int[]&#123;1, -2, 3, 10, -4, 7, 2, -5&#125;; int i = getGreatestSum(arr); System.out.println(i); &#125; public static int getGreatestSum(int[] arr)&#123; int greatestSum = 0; if(arr == null || arr.length == 0)&#123; return 0; &#125; int temp = greatestSum; for(int i = 0;i &lt; arr.length;i++)&#123; temp += arr[i]; if(temp &lt; 0)&#123; temp = 0; &#125; if(temp &gt; greatestSum)&#123; greatestSum = temp; &#125; &#125; if(greatestSum == 0)&#123; greatestSum = arr[0]; for(int i = 1;i &lt; arr.length;i++)&#123; if(greatestSum &lt; arr[i])&#123; greatestSum = arr[i]; &#125; &#125; &#125; return greatestSum; &#125;&#125; 举例8：评委打分 分析以下需求，并用代码实现： （1）在编程竞赛中，有10位评委为参赛的选手打分，分数分别为：5，4，6，8，9，0，1，2，7，3 （2）求选手的最后得分（去掉一个最高分和一个最低分后其余8位评委打分的平均值） 12345678910111213141516171819202122232425262728/** * @author 尚硅谷-宋红康 * @create 10:03 */public class ArrayExer &#123; public static void main(String[] args) &#123; int[] scores = &#123;5,4,6,8,9,0,1,2,7,3&#125;; int max = scores[0]; int min = scores[0]; int sum = 0; for(int i = 0;i &lt; scores.length;i++)&#123; if(max &lt; scores[i])&#123; max = scores[i]; &#125; if(min &gt; scores[i])&#123; min = scores[i]; &#125; sum += scores[i]; &#125; double avg = (double)(sum - max - min) / (scores.length - 2); System.out.println(&quot;选手去掉最高分和最低分之后的平均分为：&quot; + avg); &#125;&#125; 6.2 数组元素的赋值与数组复制举例1：杨辉三角（见二维数组课后案例） 举例2：使用简单数组 (1)创建一个名为ArrayTest的类，在main()方法中声明array1和array2两个变量，他们是int[]类型的数组。 (2)使用大括号{}，把array1初始化为8个素数：2,3,5,7,11,13,17,19。 (3)显示array1的内容。 (4)赋值array2变量等于array1，修改array2中的偶索引元素，使其等于索引值(如array[0]&#x3D;0,array[2]&#x3D;2)。打印出array1。 array2 &#x3D; array1; 思考：array1和array2是什么关系？ 拓展：修改题目，实现array2对array1数组的复制 举例3：一个数组，让数组的每个元素去除第一个元素，得到的商作为被除数所在位置的新值。 12345678910111213141516public class Test3 &#123; public static void main(String[] args) &#123; int[] arr = new int[]&#123;12,43,65,3,-8,64,2&#125;; // for(int i = 0;i &lt; arr.length;i++)&#123;// arr[i] = arr[i] / arr[0];// &#125; for(int i = arr.length -1;i &gt;= 0;i--)&#123; arr[i] = arr[i] / arr[0]; &#125; //遍历arr for(int i = 0;i &lt; arr.length;i++)&#123; System.out.print(arr[i] + &quot; &quot;); &#125; &#125;&#125; 举例4：创建一个长度为6的int型数组，要求数组元素的值都在1-30之间，且是随机赋值。同时，要求元素的值各不相同。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class Test4 &#123; // 5-67 Math.random() * 63 + 5; @Test public void test1() &#123; int[] arr = new int[6]; for (int i = 0; i &lt; arr.length; i++) &#123;// [0,1) [0,30) [1,31) arr[i] = (int) (Math.random() * 30) + 1; boolean flag = false; while (true) &#123; for (int j = 0; j &lt; i; j++) &#123; if (arr[i] == arr[j]) &#123; flag = true; break; &#125; &#125; if (flag) &#123; arr[i] = (int) (Math.random() * 30) + 1; flag = false; continue; &#125; break; &#125; &#125; for (int i = 0; i &lt; arr.length; i++) &#123; System.out.println(arr[i]); &#125; &#125; //更优的方法 @Test public void test2()&#123; int[] arr = new int[6]; for (int i = 0; i &lt; arr.length; i++) &#123;// [0,1) [0,30) [1,31) arr[i] = (int) (Math.random() * 30) + 1; for (int j = 0; j &lt; i; j++) &#123; if (arr[i] == arr[j]) &#123; i--; break; &#125; &#125; &#125; for (int i = 0; i &lt; arr.length; i++) &#123; System.out.println(arr[i]); &#125; &#125;&#125; 举例5：扑克牌 案例：遍历扑克牌 遍历扑克牌，效果如图所示： 提示：使用两个字符串数组，分别保存花色和点数，再用一个字符串数组保存最后的扑克牌。String[] hua &#x3D; {“黑桃”,”红桃”,”梅花”,”方片”};String[] dian &#x3D; {“A”,”2”,”3”,”4”,”5”,”6”,”7”,”8”,”9”,”10”,”J”,”Q”,”K”}; 123456789101112131415161718192021222324252627282930package com.atguigu3.common_algorithm.exer5;/** * @author 尚硅谷-宋红康 * @create 17:16 */public class ArrayExer05 &#123; public static void main(String[] args) &#123; String[] hua = &#123;&quot;黑桃&quot;,&quot;红桃&quot;,&quot;梅花&quot;,&quot;方片&quot;&#125;; String[] dian = &#123;&quot;A&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;,&quot;5&quot;,&quot;6&quot;,&quot;7&quot;,&quot;8&quot;,&quot;9&quot;,&quot;10&quot;,&quot;J&quot;,&quot;Q&quot;,&quot;K&quot;&#125;; String[] pai = new String[hua.length * dian.length]; int k = 0; for(int i = 0;i &lt; hua.length;i++)&#123; for(int j = 0;j &lt; dian.length;j++)&#123; pai[k++] = hua[i] + dian[j]; &#125; &#125; for (int i = 0; i &lt; pai.length; i++) &#123; System.out.print(pai[i] + &quot; &quot;); if(i % 13 == 12)&#123; System.out.println(); &#125; &#125; &#125;&#125; 拓展：在上述基础上，增加大王、小王。 举例6：回形数 从键盘输入一个整数（1~20） ，则以该数字为矩阵的大小，把1,2,3…n*n 的数字按照顺时针螺旋的形式填入其中。 例如： 输入数字2，则程序输出：1 24 3 输入数字3，则程序输出：1 2 38 9 47 6 5输入数字4， 则程序输出：1 2 3 412 13 14 511 16 15 610 9 8 7 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566//方式1public class RectangleTest &#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); System.out.println(&quot;输入一个数字&quot;); int len = scanner.nextInt(); int[][] arr = new int[len][len]; int s = len * len; /* * k = 1:向右 * k = 2:向下 * k = 3:向左 * k = 4:向上 */ int k = 1; int i = 0,j = 0; for(int m = 1;m &lt;= s;m++)&#123; if(k == 1)&#123; if(j &lt; len &amp;&amp; arr[i][j] == 0)&#123; arr[i][j++] = m; &#125;else&#123; k = 2; i++; j--; m--; &#125; &#125;else if(k == 2)&#123; if(i &lt; len &amp;&amp; arr[i][j] == 0)&#123; arr[i++][j] = m; &#125;else&#123; k = 3; i--; j--; m--; &#125; &#125;else if(k == 3)&#123; if(j &gt;= 0 &amp;&amp; arr[i][j] == 0)&#123; arr[i][j--] = m; &#125;else&#123; k = 4; i--; j++; m--; &#125; &#125;else if(k == 4)&#123; if(i &gt;= 0 &amp;&amp; arr[i][j] == 0)&#123; arr[i--][j] = m; &#125;else&#123; k = 1; i++; j++; m--; &#125; &#125; &#125; //遍历 for(int m = 0;m &lt; arr.length;m++)&#123; for(int n = 0;n &lt; arr[m].length;n++)&#123; System.out.print(arr[m][n] + &quot;\\t&quot;); &#125; System.out.println(); &#125; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950//方式2/* 01 02 03 04 05 06 07 24 25 26 27 28 29 08 23 40 41 42 43 30 09 22 39 48 49 44 31 10 21 38 47 46 45 32 11 20 37 36 35 34 33 12 19 18 17 16 15 14 13 */public class RectangleTest1 &#123; public static void main(String[] args) &#123; int n = 7; int[][] arr = new int[n][n]; int count = 0; //要显示的数据 int maxX = n-1; //x轴的最大下标 int maxY = n-1; //Y轴的最大下标 int minX = 0; //x轴的最小下标 int minY = 0; //Y轴的最小下标 while(minX&lt;=maxX) &#123; for(int x=minX;x&lt;=maxX;x++) &#123; arr[minY][x] = ++count; &#125; minY++; for(int y=minY;y&lt;=maxY;y++) &#123; arr[y][maxX] = ++count; &#125; maxX--; for(int x=maxX;x&gt;=minX;x--) &#123; arr[maxY][x] = ++count; &#125; maxY--; for(int y=maxY;y&gt;=minY;y--) &#123; arr[y][minX] = ++count; &#125; minX++; &#125; for(int i=0;i&lt;arr.length;i++) &#123; for(int j=0;j&lt;arr.length;j++) &#123; String space = (arr[i][j]+&quot;&quot;).length()==1 ? &quot;0&quot;:&quot;&quot;; System.out.print(space+arr[i][j]+&quot; &quot;); &#125; System.out.println(); &#125; &#125;&#125; 6.3 数组元素的反转实现思想：数组对称位置的元素互换。 123456789101112131415161718192021222324252627282930313233public class TestArrayReverse1 &#123; public static void main(String[] args) &#123; int[] arr = &#123;1,2,3,4,5&#125;; System.out.println(&quot;反转之前：&quot;); for (int i = 0; i &lt; arr.length; i++) &#123; System.out.println(arr[i]); &#125; //反转 /* 思路：首尾对应位置的元素交换 （1）确定交换几次 次数 = 数组.length / 2 （2）谁和谁交换 for(int i=0; i&lt;次数; i++)&#123; int temp = arr[i]; arr[i] = arr[arr.length-1-i]; arr[arr.length-1-i] = temp; &#125; */ for(int i=0; i&lt;arr.length/2; i++)&#123; int temp = arr[i]; arr[i] = arr[arr.length-1-i]; arr[arr.length-1-i] = temp; &#125; System.out.println(&quot;反转之后：&quot;); for (int i = 0; i &lt; arr.length; i++) &#123; System.out.println(arr[i]); &#125; &#125;&#125; 或 1234567891011121314151617181920212223public class TestArrayReverse2 &#123; public static void main(String[] args) &#123; int[] arr = &#123;1,2,3,4,5&#125;; System.out.println(&quot;反转之前：&quot;); for (int i = 0; i &lt; arr.length; i++) &#123; System.out.println(arr[i]); &#125; //反转 //左右对称位置交换 for(int left=0,right=arr.length-1; left&lt;right; left++,right--)&#123; //首 与 尾交换 int temp = arr[left]; arr[left] = arr[right]; arr[right] = temp; &#125; System.out.println(&quot;反转之后：&quot;); for (int i = 0; i &lt; arr.length; i++) &#123; System.out.println(arr[i]); &#125; &#125;&#125; 6.4 数组的扩容与缩容数组的扩容 题目：现有数组 int[] arr &#x3D; new int[]{1,2,3,4,5}; ，现将数组长度扩容1倍，并将10,20,30三个数据添加到arr数组中，如何操作？ 12345678910111213141516171819202122public class ArrTest1 &#123; public static void main(String[] args) &#123; int[] arr = new int[]&#123;1,2,3,4,5&#125;; int[] newArr = new int[arr.length &lt;&lt; 1]; for(int i = 0;i &lt; arr.length;i++)&#123; newArr[i] = arr[i]; &#125; newArr[arr.length] = 10; newArr[arr.length + 1] = 20; newArr[arr.length + 2] = 30; arr = newArr; //遍历arr for (int i = 0; i &lt; arr.length; i++) &#123; System.out.println(arr[i]); &#125; &#125;&#125; 数组的缩容 题目：现有数组 int[] arr&#x3D;{1,2,3,4,5,6,7}。现需删除数组中索引为4的元素。 123456789101112131415161718192021222324252627282930313233public class ArrTest2 &#123; public static void main(String[] args) &#123; int[] arr = &#123;1, 2, 3, 4, 5, 6, 7&#125;; //删除数组中索引为4的元素 int delIndex = 4; //方案1： /*//创建新数组 int[] newArr = new int[arr.length - 1]; for (int i = 0; i &lt; delIndex; i++) &#123; newArr[i] = arr[i]; &#125; for (int i = delIndex + 1; i &lt; arr.length; i++) &#123; newArr[i - 1] = arr[i]; &#125; arr = newArr; for (int i = 0; i &lt; arr.length; i++) &#123; System.out.println(arr[i]); &#125;*/ //方案2： for (int i = delIndex; i &lt; arr.length - 1; i++) &#123; arr[i] = arr[i + 1]; &#125; arr[arr.length - 1] = 0; for (int i = 0; i &lt; arr.length; i++) &#123; System.out.println(arr[i]); &#125; &#125;&#125; 6.5 数组的元素查找1、顺序查找 顺序查找：挨个查看 要求：对数组元素的顺序没要求 123456789101112131415161718192021public class TestArrayOrderSearch &#123; //查找value第一次在数组中出现的index public static void main(String[] args)&#123; int[] arr = &#123;4,5,6,1,9&#125;; int value = 1; int index = -1; for(int i=0; i&lt;arr.length; i++)&#123; if(arr[i] == value)&#123; index = i; break; &#125; &#125; if(index==-1)&#123; System.out.println(value + &quot;不存在&quot;); &#125;else&#123; System.out.println(value + &quot;的下标是&quot; + index); &#125; &#125;&#125; 2、二分查找 举例： 实现步骤： 123456789101112131415161718192021222324//二分法查找：要求此数组必须是有序的。int[] arr3 = new int[]&#123;-99,-54,-2,0,2,33,43,256,999&#125;;boolean isFlag = true;int value = 256;//int value = 25;int head = 0;//首索引位置int end = arr3.length - 1;//尾索引位置while(head &lt;= end)&#123; int middle = (head + end) / 2; if(arr3[middle] == value)&#123; System.out.println(&quot;找到指定的元素，索引为：&quot; + middle); isFlag = false; break; &#125;else if(arr3[middle] &gt; value)&#123; end = middle - 1; &#125;else&#123;//arr3[middle] &lt; value head = middle + 1; &#125;&#125;if(isFlag)&#123; System.out.println(&quot;未找打指定的元素&quot;);&#125; 6.6 数组元素排序6.6.1 算法概述 定义 排序：假设含有n个记录的序列为{R1，R2，…,Rn},其相应的关键字序列为{K1，K2，…,Kn}。将这些记录重新排序为{Ri1,Ri2,…,Rin},使得相应的关键字值满足条Ki1&lt;&#x3D;Ki2&lt;&#x3D;…&lt;&#x3D;Kin,这样的一种操作称为排序。 通常来说，排序的目的是快速查找。 衡量排序算法的优劣： 时间复杂度：分析关键字的比较次数和记录的移动次数 常见的算法时间复杂度由小到大依次为：Ο(1)＜Ο(log2n)＜Ο(n)＜Ο(nlog2n)＜Ο(n2)＜Ο(n3)＜…＜Ο(2n)＜Ο(n!)&lt;O(nn) 空间复杂度：分析排序算法中需要多少辅助内存 1一个算法的空间复杂度S(n)定义为该算法所耗费的存储空间，它也是问题规模n的函数。 稳定性：若两个记录A和B的关键字值相等，但排序后A、B的先后次序保持不变，则称这种排序算法是稳定的。 6.6.2 排序算法概述 排序算法分类：内部排序和外部排序 内部排序：整个排序过程不需要借助于外部存储器（如磁盘等），所有排序操作都在内存中完成。 外部排序：参与排序的数据非常多，数据量非常大，计算机无法把整个排序过程放在内存中完成，必须借助于外部存储器（如磁盘）。外部排序最常见的是多路归并排序。可以认为外部排序是由多次内部排序组成。 十大内部排序算法 ​ 数组的排序算法很多，实现方式各不相同，时间复杂度、空间复杂度、稳定性也各不相同： 常见时间复杂度所消耗的时间从小到大排序： O(1) &lt; O(logn) &lt; O(n) &lt; O(nlogn) &lt; O(n^2) &lt; O(n^3) &lt; O(2^n) &lt; O(n!) &lt; O(n^n) 注意，经常将以2为底n的对数简写成logn。 6.6.3 冒泡排序（Bubble Sort） 排序思想： 比较相邻的元素。如果第一个比第二个大（升序），就交换他们两个。 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。 针对所有的元素重复以上的步骤，除了最后一个。 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较为止。 动态演示：https://visualgo.net/zh/sorting 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788/*1、冒泡排序（最经典）思想：每一次比较“相邻（位置相邻）”元素，如果它们不符合目标顺序（例如：从小到大）， 就交换它们，经过多轮比较，最终实现排序。 （例如：从小到大） 每一轮可以把最大的沉底，或最小的冒顶。 过程：arr&#123;6,9,2,9,1&#125; 目标：从小到大第一轮： 第1次，arr[0]与arr[1]，6&gt;9不成立，满足目标要求，不交换 第2次，arr[1]与arr[2]，9&gt;2成立，不满足目标要求，交换arr[1]与arr[2] &#123;6,2,9,9,1&#125; 第3次，arr[2]与arr[3]，9&gt;9不成立，满足目标要求，不交换 第4次，arr[3]与arr[4]，9&gt;1成立，不满足目标要求，交换arr[3]与arr[4] &#123;6,2,9,1,9&#125; 第一轮所有元素&#123;6,9,2,9,1&#125;已经都参与了比较，结束。 第一轮的结果：第“一”最大值9沉底（本次是后面的9沉底），即到&#123;6,2,9,1,9&#125;元素的最右边第二轮： 第1次，arr[0]与arr[1]，6&gt;2成立，不满足目标要求，交换arr[0]与arr[1] &#123;2,6,9,1,9&#125; 第2次，arr[1]与arr[2]，6&gt;9不成立，满足目标要求，不交换 第3次：arr[2]与arr[3]，9&gt;1成立，不满足目标要求，交换arr[2]与arr[3] &#123;2,6,1,9,9&#125; 第二轮未排序的所有元素 &#123;6,2,9,1&#125;已经都参与了比较，结束。 第二轮的结果：第“二”最大值9沉底（本次是前面的9沉底），即到&#123;2,6,1,9&#125;元素的最右边第三轮： 第1次，arr[0]与arr[1]，2&gt;6不成立，满足目标要求，不交换 第2次，arr[1]与arr[2]，6&gt;1成立，不满足目标要求，交换arr[1]与arr[2] &#123;2,1,6,9,9&#125; 第三轮未排序的所有元素&#123;2,6,1&#125;已经都参与了比较，结束。 第三轮的结果：第三最大值6沉底，即到 &#123;2,1,6&#125;元素的最右边第四轮： 第1次，arr[0]与arr[1]，2&gt;1成立，不满足目标要求，交换arr[0]与arr[1] &#123;1,2,6,9,9&#125; 第四轮未排序的所有元素&#123;2,1&#125;已经都参与了比较，结束。 第四轮的结果：第四最大值2沉底，即到&#123;1,2&#125;元素的最右边*/public class Test19BubbleSort&#123; public static void main(String[] args)&#123; int[] arr = &#123;6,9,2,9,1&#125;; //目标：从小到大 //冒泡排序的轮数 = 元素的总个数 - 1 //轮数是多轮，每一轮比较的次数是多次，需要用到双重循环，即循环嵌套 //外循环控制 轮数，内循环控制每一轮的比较次数和过程 for(int i=1; i&lt;arr.length; i++)&#123; //循环次数是arr.length-1次/轮 /* 假设arr.length=5 i=1,第1轮，比较4次 arr[0]与arr[1] arr[1]与arr[2] arr[2]与arr[3] arr[3]与arr[4] arr[j]与arr[j+1]，int j=0;j&lt;4; j++ i=2,第2轮，比较3次 arr[0]与arr[1] arr[1]与arr[2] arr[2]与arr[3] arr[j]与arr[j+1]，int j=0;j&lt;3; j++ i=3,第3轮，比较2次 arr[0]与arr[1] arr[1]与arr[2] arr[j]与arr[j+1]，int j=0;j&lt;2; j++ i=4,第4轮，比较1次 arr[0]与arr[1] arr[j]与arr[j+1]，int j=0;j&lt;1; j++ int j=0; j&lt;arr.length-i; j++ */ for(int j=0; j&lt;arr.length-i; j++)&#123; //希望的是arr[j] &lt; arr[j+1] if(arr[j] &gt; arr[j+1])&#123; //交换arr[j]与arr[j+1] int temp = arr[j]; arr[j] = arr[j+1]; arr[j+1] = temp; &#125; &#125; &#125; //完成排序，遍历结果 for(int i=0; i&lt;arr.length; i++)&#123; System.out.print(arr[i]+&quot; &quot;); &#125; &#125;&#125; 冒泡排序优化（选讲） 1234567891011121314151617181920212223242526272829303132/*思考：冒泡排序是否可以优化*/class Test19BubbleSort2&#123; public static void main(String[] args) &#123; int[] arr = &#123;1, 3, 5, 7, 9&#125;; //从小到大排序 for (int i = 0; i &lt; arr.length - 1; i++) &#123; boolean flag = true;//假设数组已经是有序的 for (int j = 0; j &lt; arr.length - 1 - i; j++) &#123; //希望的是arr[j] &lt; arr[j+1] if (arr[j] &gt; arr[j + 1]) &#123; //交换arr[j]与arr[j+1] int temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; flag = false;//如果元素发生了交换，那么说明数组还没有排好序 &#125; &#125; if (flag) &#123; break; &#125; &#125; //完成排序，遍历结果 for (int i = 0; i &lt; arr.length; i++) &#123; System.out.print(arr[i] + &quot; &quot;); &#125; &#125;&#125; 6.6.4 快速排序快速排序（Quick Sort）由图灵奖获得者Tony Hoare发明，被列为20世纪十大算法之一，是迄今为止所有内排序算法中速度最快的一种，快速排序的时间复杂度为O(nlog(n))。 快速排序通常明显比同为O(nlogn)的其他算法更快，因此常被采用，而且快排采用了分治法的思想，所以在很多笔试面试中能经常看到快排的影子。 排序思想： 从数列中挑出一个元素，称为”基准”（pivot）， 重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区结束之后，该基准就处于数列的中间位置。这个称为分区（partition）操作。 递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。 递归的最底部情形，是数列的大小是零或一，也就是永远都已经被排序好了。虽然一直递归下去，但是这个算法总会结束，因为在每次的迭代（iteration）中，它至少会把一个元素摆到它最后的位置去。 动态演示：https://visualgo.net/zh/sorting 图示1： 图示2： 第一轮操作： 第二轮操作： 6.6.5 内部排序性能比较与选择 性能比较 从平均时间而言：快速排序最佳。但在最坏情况下时间性能不如堆排序和归并排序。 从算法简单性看：由于直接选择排序、直接插入排序和冒泡排序的算法比较简单，将其认为是简单算法。对于Shell排序、堆排序、快速排序和归并排序算法，其算法比较复杂，认为是复杂排序。 从稳定性看：直接插入排序、冒泡排序和归并排序时稳定的；而直接选择排序、快速排序、 Shell排序和堆排序是不稳定排序 从待排序的记录数n的大小看，n较小时，宜采用简单排序；而n较大时宜采用改进排序。 选择 若n较小(如n≤50)，可采用直接插入或直接选择排序。当记录规模较小时，直接插入排序较好；否则因为直接选择移动的记录数少于直接插入，应选直接选择排序为宜。 若文件初始状态基本有序(指正序)，则应选用直接插入、冒泡或随机的快速排序为宜； 若n较大，则应采用时间复杂度为O(nlgn)的排序方法：快速排序、堆排序或归并排序。 7. Arrays工具类的使用java.util.Arrays类即为操作数组的工具类，包含了用来操作数组（比如排序和搜索）的各种方法。 比如： 数组元素拼接 static String toString(int[] a) ：字符串表示形式由数组的元素列表组成，括在方括号（”[]”）中。相邻元素用字符 “, “（逗号加空格）分隔。形式为：[元素1，元素2，元素3。。。] static String toString(Object[] a) ：字符串表示形式由数组的元素列表组成，括在方括号（”[]”）中。相邻元素用字符 “, “（逗号加空格）分隔。元素将自动调用自己从Object继承的toString方法将对象转为字符串进行拼接，如果没有重写，则返回类型@hash值，如果重写则按重写返回的字符串进行拼接。 数组排序 static void sort(int[] a) ：将a数组按照从小到大进行排序 static void sort(int[] a, int fromIndex, int toIndex) ：将a数组的[fromIndex, toIndex)部分按照升序排列 static void sort(Object[] a) ：根据元素的自然顺序对指定对象数组按升序进行排序。 static void sort(T[] a, Comparator&lt;? super T&gt; c) ：根据指定比较器产生的顺序对指定对象数组进行排序。 数组元素的二分查找 static int binarySearch(int[] a, int key) 、static int binarySearch(Object[] a, Object key) ：要求数组有序，在数组中查找key是否存在，如果存在返回第一次找到的下标，不存在返回负数。 数组的复制 static int[] copyOf(int[] original, int newLength) ：根据original原数组复制一个长度为newLength的新数组，并返回新数组 static T[] copyOf(T[] original,int newLength)：根据original原数组复制一个长度为newLength的新数组，并返回新数组 static int[] copyOfRange(int[] original, int from, int to) ：复制original原数组的[from,to)构成新数组，并返回新数组 static T[] copyOfRange(T[] original,int from,int to)：复制original原数组的[from,to)构成新数组，并返回新数组 比较两个数组是否相等 static boolean equals(int[] a, int[] a2) ：比较两个数组的长度、元素是否完全相同 static boolean equals(Object[] a,Object[] a2)：比较两个数组的长度、元素是否完全相同 填充数组 static void fill(int[] a, int val) ：用val值填充整个a数组 static void fill(Object[] a,Object val)：用val对象填充整个a数组 static void fill(int[] a, int fromIndex, int toIndex, int val)：将a数组[fromIndex,toIndex)部分填充为val值 static void fill(Object[] a, int fromIndex, int toIndex, Object val) ：将a数组[fromIndex,toIndex)部分填充为val对象 举例：java.util.Arrays类的sort()方法提供了数组元素排序功能： 12345678910import java.util.Arrays;public class SortTest &#123; public static void main(String[] args) &#123; int[] arr = &#123;3, 2, 5, 1, 6&#125;; System.out.println(&quot;排序前&quot; + Arrays.toString(arr)); Arrays.sort(arr); System.out.println(&quot;排序后&quot; + Arrays.toString(arr)); &#125;&#125; 8. 数组中的常见异常8.1 数组角标越界异常当访问数组元素时，下标指定超出[0, 数组名.length-1]的范围时，就会报数组下标越界异常：ArrayIndexOutOfBoundsException。 123456789public class TestArrayIndexOutOfBoundsException &#123; public static void main(String[] args) &#123; int[] arr = &#123;1,2,3&#125;; // System.out.println(&quot;最后一个元素：&quot; + arr[3]);//错误，下标越界 // System.out.println(&quot;最后一个元素：&quot; + arr[arr.length]);//错误，下标越界 System.out.println(&quot;最后一个元素：&quot; + arr[arr.length-1]);//对 &#125;&#125; 创建数组，赋值3个元素，数组的索引就是0，1，2，没有3索引，因此我们不能访问数组中不存在的索引，程序运行后，将会抛出 ArrayIndexOutOfBoundsException 数组越界异常。在开发中，数组的越界异常是不能出现的，一旦出现了，就必须要修改我们编写的代码。 8.2 空指针异常观察一下代码，运行后会出现什么结果。 12345678public class TestNullPointerException &#123; public static void main(String[] args) &#123; //定义数组 int[][] arr = new int[3][]; System.out.println(arr[0][0]);//NullPointerException &#125;&#125; 因为此时数组的每一行还未分配具体存储元素的空间，此时arr[0]是null，此时访问arr[0][0]会抛出NullPointerException 空指针异常。 空指针异常在内存图中的表现 小结：空指针异常情况 12345678910111213 //举例一：// int[] arr1 = new int[10];// arr1 = null;// System.out.println(arr1[9]); //举例二：// int[][] arr2 = new int[5][];// //arr2[3] = new int[10];// System.out.println(arr2[3][3]); //举例三： String[] arr3 = new String[10]; System.out.println(arr3[2].toString());","categories":[{"name":"java基础","slug":"java基础","permalink":"http://example.com/categories/java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"java","slug":"java","permalink":"http://example.com/tags/java/"}]},{"title":"第02章_变量与运算符","slug":"Java/尚硅谷_第02章_变量与运算符/尚硅谷_宋红康_第02章_变量与运算符","date":"2022-09-27T00:55:54.000Z","updated":"2023-10-07T11:28:12.396Z","comments":true,"path":"2022/09/27/Java/尚硅谷_第02章_变量与运算符/尚硅谷_宋红康_第02章_变量与运算符/","link":"","permalink":"http://example.com/2022/09/27/Java/%E5%B0%9A%E7%A1%85%E8%B0%B7_%E7%AC%AC02%E7%AB%A0_%E5%8F%98%E9%87%8F%E4%B8%8E%E8%BF%90%E7%AE%97%E7%AC%A6/%E5%B0%9A%E7%A1%85%E8%B0%B7_%E5%AE%8B%E7%BA%A2%E5%BA%B7_%E7%AC%AC02%E7%AB%A0_%E5%8F%98%E9%87%8F%E4%B8%8E%E8%BF%90%E7%AE%97%E7%AC%A6/","excerpt":"","text":"第02章_变量与运算符 本章专题与脉络 1. 关键字（keyword） 定义：被Java语言赋予了特殊含义，用做专门用途的字符串（或单词） HelloWorld案例中，出现的关键字有 class、public 、 static 、 void 等，这些单词已经被Java定义好了。 特点：全部关键字都是小写字母。 关键字比较多，不需要死记硬背，学到哪里记到哪里即可。 官方地址： https://docs.oracle.com/javase/tutorial/java/nutsandbolts/_keywords.html 说明： 关键字一共50个，其中const和goto是保留字(reserved word)。 true，false，null不在其中，它们看起来像关键字，其实是字面量，表示特殊的布尔值和空值。 2. 标识符( identifier)Java中变量、方法、类等要素命名时使用的字符序列，称为标识符。 技巧：凡是自己可以起名字的地方都叫标识符。 标识符的命名规则（必须遵守的硬性规定）： 12345&gt; 由26个英文字母大小写，0-9 ，_或 $ 组成 &gt; 数字不可以开头。&gt; 不可以使用关键字和保留字，但能包含关键字和保留字。&gt; Java中严格区分大小写，长度无限制。&gt; 标识符不能包含空格。 练习：miles、Test、a++、 –a、4#R、$4、 #44、apps、class、public、int、x、y、radius 标识符的命名规范（建议遵守的软性要求，否则工作时容易被鄙视）: 1234567891011&gt; 包名：多单词组成时所有字母都小写：xxxyyyzzz。 例如：java.lang、com.atguigu.bean &gt; 类名、接口名：多单词组成时，所有单词的首字母大写：XxxYyyZzz 例如：HelloWorld，String，System等 &gt; 变量名、方法名：多单词组成时，第一个单词首字母小写，第二个单词开始每个单词首字母大写：xxxYyyZzz 例如：age,name,bookName,main,binarySearch,getName &gt; 常量名：所有字母都大写。多单词时每个单词用下划线连接：XXX_YYY_ZZZ 例如：MAX_VALUE,PI,DEFAULT_CAPACITY 注意：在起名字时，为了提高阅读性，要尽量有意义，“见名知意”。 更多细节详见《代码整洁之道_关于标识符.txt》《阿里巴巴Java开发手册-1.7.1-黄山版》 3. 变量3.1 为什么需要变量 一花一世界，如果把一个程序看做一个世界或一个社会的话，那么变量就是程序世界的花花草草、万事万物。即，变量是程序中不可或缺的组成单位，最基本的存储单元。 3.2 初识变量 变量的概念： 内存中的一个存储区域，该区域的数据可以在同一类型范围内不断变化 变量的构成包含三个要素：数据类型、变量名、存储的值 Java中变量声明的格式：数据类型 变量名 = 变量值 变量的作用：用于在内存中保存数据。 使用变量注意： Java中每个变量必须先声明，后使用。 使用变量名来访问这块区域的数据。 变量的作用域：其定义所在的一对{ }内。 变量只有在其作用域内才有效。出了作用域，变量不可以再被调用。 同一个作用域内，不能定义重名的变量。 3.3 Java中变量的数据类型Java中变量的数据类型分为两大类： 基本数据类型：包括 整数类型、浮点数类型、字符类型、布尔类型。 引用数据类型：包括数组、 类、接口、枚举、注解、记录。 3.4 变量的使用3.4.1 步骤1：变量的声明1格式：数据类型 变量名; 123456789101112131415161718//例如：//存储一个整数类型的年龄int age; //存储一个小数类型的体重double weight;//存储一个单字符类型的性别 char gender;//存储一个布尔类型的婚姻状态boolean marry;//存储一个字符串类型的姓名String name;//声明多个同类型的变量int a,b,c; //表示a,b,c三个变量都是int类型。 注意：变量的数据类型可以是基本数据类型，也可以是引用数据类型。 3.4.2 步骤2：变量的赋值给变量赋值，就是把“值”存到该变量代表的内存空间中。同时，给变量赋的值类型必须与变量声明的类型一致或兼容。 变量赋值的语法格式： 1变量名 = 值; 举例1：可以使用合适类型的常量值给已经声明的变量赋值 123age = 18;weight = 109;gender = &#x27;女&#x27;; 举例2：可以使用其他变量或者表达式给变量赋值 123456int m = 1;int n = m; int x = 1;int y = 2;int z = 2 * x + y; 3：变量可以反复赋值 1234567//先声明，后初始化char gender;gender = &#x27;女&#x27;;//给变量重新赋值，修改gender变量的值gender = &#x27;男&#x27;;System.out.println(&quot;gender = &quot; + gender);//gender = 男 举例4：也可以将变量的声明和赋值一并执行 12boolean isBeauty = true;String name = &quot;迪丽热巴&quot;; 内存结构如图： 4. 基本数据类型介绍4.1 整数类型：byte、short、int、long Java各整数类型有固定的表数范围和字段长度，不受具体操作系统的影响，以保证Java程序的可移植性。 定义long类型的变量，赋值时需要以”l“或”L“作为后缀。 Java程序中变量通常声明为int型，除非不足以表示较大的数，才使用long。 Java的整型常量默认为 int 型。 4.1.1 补充：计算机存储单位 字节（Byte）：是计算机用于计量存储容量的基本单位，一个字节等于8 bit。 位（bit）：是数据存储的最小单位。二进制数系统中，每个0或1就是一个位，叫做bit（比特），其中8 bit 就称为一个字节(Byte)。 转换关系： 8 bit &#x3D; 1 Byte 1024 Byte &#x3D; 1 KB 1024 KB &#x3D; 1 MB 1024 MB &#x3D; 1 GB 1024 GB &#x3D; 1 TB 4.2 浮点类型：float、double 与整数类型类似，Java 浮点类型也有固定的表数范围和字段长度，不受具体操作系统的影响。 浮点型常量有两种表示形式： 十进制数形式。如：5.12 512.0f .512 (必须有小数点） 科学计数法形式。如：5.12e2 512E2 100E-2 float：单精度，尾数可以精确到7位有效数字。很多情况下，精度很难满足需求。 double：双精度，精度是float的两倍。通常采用此类型。 定义float类型的变量，赋值时需要以”f“或”F“作为后缀。 Java 的浮点型常量默认为double型。 4.2.1 关于浮点型精度的说明 并不是所有的小数都能可以精确的用二进制浮点数表示。二进制浮点数不能精确的表示0.1、0.01、0.001这样10的负次幂。 浮点类型float、double的数据不适合在不容许舍入误差的金融计算领域。如果需要精确数字计算或保留指定位数的精度，需要使用BigDecimal类。 测试用例： 12345678910//测试1：（解释见章末企业真题：为什么0.1 + 0.2不等于0.3）System.out.println(0.1 + 0.2);//0.30000000000000004//测试2：float ff1 = 123123123f;float ff2 = ff1 + 1;System.out.println(ff1);System.out.println(ff2);System.out.println(ff1 == ff2); 4.2.2 应用举例案例1：定义圆周率并赋值为3.14，现有3个圆的半径分别为1.2、2.5、6，求它们的面积。 1234567891011121314151617/** * @author 尚硅谷-宋红康 * @create 12:36 */public class Exercise1 &#123; public static void main(String[] args) &#123; double PI = 3.14; //圆周率 double radius1 = 1.2; double radius2 = 2.5; int radius3 = 6; System.out.println(&quot;第1个圆的面积：&quot; + PI * radius1 * radius1); System.out.println(&quot;第2个圆的面积：&quot; + PI * radius2 * radius2); System.out.println(&quot;第3个圆的面积：&quot; + PI * radius3 * radius3); &#125;&#125; 案例2：小明要到美国旅游，可是那里的温度是以华氏度为单位记录的。它需要一个程序将华氏温度（80度）转换为摄氏度，并以华氏度和摄氏度为单位分别显示该温度。 1℃ = (℉ - 32) / 1.8 1234567891011/** * @author 尚硅谷-宋红康 * @create 12:51 */public class Exercise2 &#123; public static void main(String[] args) &#123; double hua = 80; double she = (hua-32)/1.8; System.out.println(&quot;华氏度&quot; + hua+&quot;℉转为摄氏度是&quot; +she+&quot;℃&quot;); &#125;&#125; 4.3 字符类型：char char 型数据用来表示通常意义上“字符”（占2字节） Java中的所有字符都使用Unicode编码，故一个字符可以存储一个字母，一个汉字，或其他书面语的一个字符。 字符型变量的三种表现形式： 形式1：使用单引号(‘ ‘)括起来的单个字符。 例如：char c1 &#x3D; ‘a’; char c2 &#x3D; ‘中’; char c3 &#x3D; ‘9’; 形式2：直接使用 Unicode值来表示字符型常量：‘\\uXXXX’。其中，XXXX代表一个十六进制整数。 例如：\\u0023 表示 ‘#’。 形式3：Java中还允许使用转义字符‘\\’来将其后的字符转变为特殊字符型常量。 例如：char c3 &#x3D; ‘\\n’; &#x2F;&#x2F; ‘\\n’表示换行符 | 转义字符 | 说明 | Unicode表示方式 | | :——: | :—-: | :————-: | | \\n | 换行符 | \\u000a | | \\t | 制表符 | \\u0009 | | \\&quot; | 双引号 | \\u0022 | | \\&#39; | 单引号 | \\u0027 | | \\\\ | 反斜线 | \\u005c | | \\b | 退格符 | \\u0008 | | \\r | 回车符 | \\u000d | char类型是可以进行运算的。因为它都对应有Unicode码，可以看做是一个数值。 4.4 布尔类型：boolean boolean 类型用来判断逻辑条件，一般用于流程控制语句中： if条件控制语句； while循环控制语句； for循环控制语句； do-while循环控制语句； boolean类型数据只有两个值：true、false，无其它。 不可以使用0或非 0 的整数替代false和true，这点和C语言不同。 拓展：Java虚拟机中没有任何供boolean值专用的字节码指令，Java语言表达所操作的boolean值，在编译之后都使用java虚拟机中的int数据类型来代替：true用1表示，false用0表示。——《java虚拟机规范 8版》 举例： 1234567boolean isFlag = true;if(isFlag)&#123; //true分支&#125;else&#123; //false分支&#125; 经验之谈： Less is More！建议不要这样写：if ( isFlag &#x3D; &#x3D; true )，只有新手才如此。关键也很容易写错成if(isFlag &#x3D; true)，这样就变成赋值isFlag为true而不是判断！老鸟的写法是if (isFlag)或者if ( !isFlag)。 5. 基本数据类型变量间运算规则在Java程序中，不同的基本数据类型（只有7种，不包含boolean类型）变量的值经常需要进行相互转换。 转换的方式有两种：自动类型提升和强制类型转换。 5.1 自动类型提升规则：将取值范围小（或容量小）的类型自动提升为取值范围大（或容量大）的类型 。 基本数据类型的转换规则如图所示： （1）当把存储范围小的值（常量值、变量的值、表达式计算的结果值）赋值给了存储范围大的变量时 123456int i = &#x27;A&#x27;;//char自动升级为int，其实就是把字符的编码值赋值给i变量了double d = 10;//int自动升级为doublelong num = 1234567; //右边的整数常量值如果在int范围呢，编译和运行都可以通过，这里涉及到数据类型转换//byte bigB = 130;//错误，右边的整数常量值超过byte范围long bigNum = 12345678912L;//右边的整数常量值如果超过int范围，必须加L，显式表示long类型。否则编译不通过 （2）当存储范围小的数据类型与存储范围大的数据类型变量一起混合运算时，会按照其中最大的类型运算。 12345int i = 1;byte b = 1;double d = 1.0;double sum = i + b + d;//混合运算，升级为double （3）当byte,short,char数据类型的变量进行算术运算时，按照int类型处理。 12345678byte b1 = 1;byte b2 = 2;byte b3 = b1 + b2;//编译报错，b1 + b2自动升级为intchar c1 = &#x27;0&#x27;;char c2 = &#x27;A&#x27;;int i = c1 + c2;//至少需要使用int类型来接收System.out.println(c1 + c2);//113 练习： 1234设 x 为float型变量，y为double型变量，a为int型变量，b为long型变量，c为char型变量，则表达式x + y * a / x + b / y + c的值类型为：A. int B. long C. double D. char 5.2 强制类型转换将3.14 赋值到int 类型变量会发生什么？产生编译失败，肯定无法赋值。 1int i = 3.14; // 编译报错 想要赋值成功，只有通过强制类型转换，将double 类型强制转换成int 类型才能赋值。 规则：将取值范围大（或容量大）的类型强制转换成取值范围小（或容量小）的类型。 自动类型提升是Java自动执行的，而强制类型转换是自动类型提升的逆运算，需要我们自己手动执行。 转换格式： 1数据类型1 变量名 = (数据类型1)被强转数据值; //()中的数据类型必须&lt;=变量值的数据类型 （1）当把存储范围大的值（常量值、变量的值、表达式计算的结果值）强制转换为存储范围小的变量时，可能会损失精度或溢出。 1234567int i = (int)3.14;//损失精度double d = 1.2;int num = (int)d;//损失精度int i = 200;byte b = (byte)i;//溢出 （2）当某个值想要提升数据类型时，也可以使用强制类型转换。这种情况的强制类型转换是没有风险的，通常省略。 123int i = 1;int j = 2;double bigger = (double)(i/j); （3）声明long类型变量时，可以出现省略后缀的情况。float则不同。 12345678910long l1 = 123L;long l2 = 123;//如何理解呢？ 此时可以看做是int类型的123自动类型提升为long类型//long l3 = 123123123123; //报错，因为123123123123超出了int的范围。long l4 = 123123123123L;//float f1 = 12.3; //报错，因为12.3看做是double，不能自动转换为float类型float f2 = 12.3F;float f3 = (float)12.3; 练习：判断是否能通过编译 123456789101112131）short s = 5; s = s-2; //判断：no2） byte b = 3; b = b + 4; //判断：no b = (byte)(b+4); //判断：yes3）char c = ‘a’; int i = 5; float d = .314F; double result = c+i+d; //判断：yes4） byte b = 5; short s = 3; short t = s + b; //判断：no 问答：为什么标识符的声明规则里要求不能数字开头？ 1234//如果允许数字开头，则如下的声明编译就可以通过：int 123L = 12;//进而，如下的声明中l的值到底是123？还是变量123L对应的取值12呢？ 出现歧义了。long l = 123L; 5.3 基本数据类型与String的运算5.3.1 字符串类型：String String不是基本数据类型，属于引用数据类型 使用一对&quot;&quot;来表示一个字符串，内部可以包含0个、1个或多个字符。 声明方式与基本数据类型类似。例如：String str &#x3D; “尚硅谷”; 5.3.2 运算规则1、任意八种基本数据类型的数据与String类型只能进行连接“+”运算，且结果一定也是String类型 1234567891011System.out.println(&quot;&quot; + 1 + 2);//12int num = 10;boolean b1 = true;String s1 = &quot;abc&quot;;String s2 = s1 + num + b1;System.out.println(s2);//abc10true//String s3 = num + b1 + s1;//编译不通过，因为int类型不能与boolean运算String s4 = num + (b1 + s1);//编译通过 2、String类型不能通过强制类型()转换，转为其他的类型 1234String str = &quot;123&quot;;int num = (int)str;//错误的int num = Integer.parseInt(str);//正确的，后面才能讲到，借助包装类的方法才能转 5.3.3 案例与练习案例：公安局身份登记 要求填写自己的姓名、年龄、性别、体重、婚姻状况（已婚用true表示，单身用false表示）、联系方式等等。 12345678910111213141516171819202122232425/** * @author 尚硅谷-宋红康 * @create 12:34 */public class Info &#123; public static void main(String[] args) &#123; String name = &quot;康师傅&quot;; int age = 37; char gender = &#x27;男&#x27;; double weight = 145.6; boolean isMarried = true; String phoneNumber = &quot;13112341234&quot;; System.out.println(&quot;姓名：&quot; + name); System.out.println(&quot;年龄：&quot; + age); System.out.println(&quot;性别：&quot; + gender); System.out.println(&quot;体重：&quot; + weight); System.out.println(&quot;婚否：&quot; + isMarried); System.out.println(&quot;电话：&quot; + phoneNumber); //或者 System.out.println(&quot;name = &quot; + name + &quot;,age = &quot; + age + &quot;，gender = &quot; + gender + &quot;,weight = &quot; + weight + &quot;,isMarried = &quot; + isMarried + &quot;,phoneNumber = &quot; + phoneNumber); &#125;&#125; 练习： 练习1： 1234567String str1 = 4; //判断对错：String str2 = 3.5f + &quot;&quot;; //判断str2对错：System.out.println(str2); //输出：System.out .println(3+4+&quot;Hello!&quot;); //输出：System.out.println(&quot;Hello!&quot;+3+4); //输出：System.out.println(&#x27;a&#x27;+1+&quot;Hello!&quot;); //输出：System.out.println(&quot;Hello&quot;+&#x27;a&#x27;+1); //输出： 练习2： 12345678System.out.println(&quot;* *&quot;); //输出：System.out.println(&quot;*\\t*&quot;); //输出：System.out.println(&quot;*&quot; + &quot;\\t&quot; + &quot;*&quot;); //输出：System.out.println(&#x27;*&#x27; + &quot;\\t&quot; + &quot;*&quot;); //输出：System.out.println(&#x27;*&#x27; + &#x27;\\t&#x27; + &quot;*&quot;); //输出：System.out.println(&#x27;*&#x27; + &quot;\\t&quot; + &#x27;*&#x27;); //输出：System.out.println(&quot;*&quot; + &#x27;\\t&#x27; + &#x27;*&#x27;); //输出：System.out.println(&#x27;*&#x27; + &#x27;\\t&#x27; + &#x27;*&#x27;); //输出： 6. 计算机底层如何存储数据计算机世界中只有二进制，所以计算机中存储和运算的所有数据都要转为二进制。包括数字、字符、图片、声音、视频等。 世界上有10种人 ，认识和不认识二进制的。 6.1 进制的分类 十进制（decimal） 数字组成：0-9 进位规则：满十进一 二进制（binary） 数字组成：0-1 进位规则：满二进一，以0b或0B开头 八进制（octal）：很少使用 数字组成：0-7 进位规则：满八进一，以数字0开头表示 十六进制 数字组成：0-9，a-f 进位规则：满十六进一，以0x或0X开头表示。此处的 a-f 不区分大小写 代码演示： 123456789101112131415class BinaryTest &#123; public static void main(String[] args) &#123; int num1 = 123; //十进制 int num2 = 0b101; //二进制 int num3 = 0127; //八进制 int num4 = 0x12aF; //十六进制 System.out.println(num1); System.out.println(num2); System.out.println(num3); System.out.println(num4); &#125;&#125; 6.2 进制的换算举例 十进制 二进制 八进制 十六进制 0 0 0 0 1 1 1 1 2 10 2 2 3 11 3 3 4 100 4 4 5 101 5 5 6 110 6 6 7 111 7 7 8 1000 10 8 9 1001 11 9 10 1010 12 a或A 11 1011 13 b或B 12 1100 14 c或C 13 1101 15 d或D 14 1110 16 e或E 15 1111 17 f或F 16 10000 20 10 6.3 二进制的由来二进制，是计算技术中广泛采用的一种数制，由德国数理哲学大师莱布尼茨于1679年发明。 二进制数据是用0和1两个数码来表示的数。它的基数为2，进位规则是“逢二进一”。 二进制广泛应用于我们生活的方方面面。比如，广泛使用的摩尔斯电码（Morse Code），它由两种基本信号组成：短促的点信号“·”，读“滴”；保持一定时间的长信号“—”，读“嗒”。然后，组成了26个字母，从而拼写出相应的单词。 记忆技巧： 我们偶尔会看到的：SOS，即为： 6.4 二进制转十进制二进制如何表示整数？ 计算机数据的存储使用二进制补码形式存储，并且最高位是符号位。 正数：最高位是0 负数：最高位是1 规 定 正数的补码与反码、原码一样，称为三码合一 负数的补码与反码、原码不一样： 负数的原码：把十进制转为二进制，然后最高位设置为1 负数的反码：在原码的基础上，最高位不变，其余位取反（0变1,1变0） 负数的补码：反码+1 二进制转十进制：权相加法 针对于byte数据举例来说： 例如：byte类型（1个字节，8位） 25 &#x3D;&#x3D;&gt; 原码 0001 1001 &#x3D;&#x3D;&gt; 反码 0001 1001 –&gt;补码 0001 1001 -25 &#x3D;&#x3D;&gt;原码 1001 1001 &#x3D;&#x3D;&gt; 反码1110 0110 &#x3D;&#x3D;&gt;补码 1110 0111 12345678整数：正数：25 00000000 00000000 000000000 00011001（原码）正数：25 00000000 00000000 000000000 00011001（反码）正数：25 00000000 00000000 000000000 00011001（补码）负数：-25 10000000 00000000 000000000 00011001（原码）负数：-25 11111111 11111111 111111111 11100110（反码）负数：-25 11111111 11111111 111111111 11100111（补码） 一个字节可以存储的整数范围是多少？ 123456789//1个字节：8位0000 0001 ~ 0111 111 ==&gt; 1~1271000 0001 ~ 1111 1111 ==&gt; -127 ~ -10000 0000 ==&gt;01000 0000 ==&gt; -128（特殊规定）=-127-1 6.5 十进制转二进制十进制转二进制：除2取余的逆 6.6 二进制与八进制、十六进制间的转换二进制转八进制 二进制转十六进制 八进制、十六进制转二进制 6.7 各进制间的转换 练习： 1234561.将以下十进制数转换为十六进制和二进制123 256 87 622.将以下十六进制数转换为十进制和二进制0x123 0x25F 0x38 0x62 7. 运算符（Operator）（掌握）运算符是一种特殊的符号，用以表示数据的运算、赋值和比较等。 运算符的分类： 按照功能分为：算术运算符、赋值运算符、比较(或关系)运算符、逻辑运算符、位运算符、条件运算符、Lambda运算符 分类 运算符 算术运算符（7个） +、-、*、&#x2F;、%、++、– 赋值运算符（12个） &#x3D;、+&#x3D;、-&#x3D;、*&#x3D;、&#x2F;&#x3D;、%&#x3D;、&gt;&gt;&#x3D;、&lt;&lt;&#x3D;、&gt;&gt;&gt;&#x3D;、&amp;&#x3D;、|&#x3D;、^&#x3D;等 比较(或关系)运算符（6个） &gt;、&gt;&#x3D;、&lt;、&lt;&#x3D;、&#x3D;&#x3D;、!&#x3D; 逻辑运算符（6个） &amp;、|、^、!、&amp;&amp;、|| 位运算符（7个） &amp;、|、^、~、&lt;&lt;、&gt;&gt;、&gt;&gt;&gt; 条件运算符（1个） (条件表达式)?结果1:结果2 Lambda运算符（1个） -&gt;（第18章时讲解） 按照操作数个数分为：一元运算符（单目运算符）、二元运算符（双目运算符）、三元运算符 （三目运算符） 分类 运算符 一元运算符（单目运算符） 正号（+）、负号（-）、++、–、!、~ 二元运算符（双目运算符） 除了一元和三元运算符剩下的都是二元运算符 三元运算符 （三目运算符） (条件表达式)?结果1:结果2 7.1 算术运算符7.1.1 基本语法 举例1：加减乘除模 123456789101112131415161718192021public class ArithmeticTest1 &#123; public static void main(String[] args) &#123; int a = 3; int b = 4; System.out.println(a + b);// 7 System.out.println(a - b);// -1 System.out.println(a * b);// 12 System.out.println(a / b);// 计算机结果是0，为什么不是0.75呢？ System.out.println(a % b);// 3 //结果与被模数符号相同 System.out.println(5%2);//1 System.out.println(5%-2);//1 System.out.println(-5%2);//-1 System.out.println(-5%-2);//-1 //商*除数 + 余数 = 被除数 //5%-2 ==&gt;商是-2，余数时1 (-2)*(-2)+1 = 5 //-5%2 ==&gt;商是-2，余数是-1 (-2)*2+(-1) = -4-1=-5 &#125;&#125; 举例2：“+”号的两种用法 第一种：对于+两边都是数值的话，+就是加法的意思 第二种：对于+两边至少有一边是字符串的话，+就是拼接的意思 123456789101112131415161718public class ArithmeticTest2 &#123; public static void main(String[] args) &#123; // 字符串类型的变量基本使用 // 数据类型 变量名称 = 数据值; String str1 = &quot;Hello&quot;; System.out.println(str1); // Hello System.out.println(&quot;Hello&quot; + &quot;World&quot;); // HelloWorld String str2 = &quot;Java&quot;; // String + int --&gt; String System.out.println(str2 + 520); // Java520 // String + int + int // String + int // String System.out.println(str2 + 5 + 20); // Java520 &#125;&#125; 举例3：自加自减运算 理解：++ 运算，表示自增1。同理，-- 运算，表示自减1，用法与++ 一致。 1、单独使用 变量在单独运算的时候，变量前++和变量后++，是没有区别的。 变量前++ ：例如 ++a 。 变量后++ ：例如 a++ 。 12345678910public class ArithmeticTest3 &#123; public static void main(String[] args) &#123; // 定义一个int类型的变量a int a = 3; //++a; a++; // 无论是变量前++还是变量后++，结果都是4 System.out.println(a); &#125;&#125; 2、复合使用 和其他变量放在一起使用或者和输出语句放在一起使用，前++和后++就产生了不同。 变量前++ ：变量先自增1，然后再运算。 变量后++ ：变量先运算，然后再自增1。 12345678910111213141516171819public class ArithmeticTest4 &#123; public static void main(String[] args) &#123; // 其他变量放在一起使用 int x = 3; //int y = ++x; // y的值是4，x的值是4， int y = x++; // y的值是3，x的值是4 System.out.println(x); System.out.println(y); System.out.println(&quot;==========&quot;); // 和输出语句一起 int z = 5; //System.out.println(++z);// 输出结果是6，z的值也是6 System.out.println(z++);// 输出结果是5，z的值是6 System.out.println(z); &#125; &#125; 7.1.2 案例与练习案例1： 12345678910111213随意给出一个整数，打印显示它的个位数，十位数，百位数的值。格式如下：数字xxx的情况如下：个位数：十位数：百位数：例如：数字153的情况如下：个位数：3十位数：5百位数：1 12345678910111213141516171819/** * @author 尚硅谷-宋红康 * @create 12:20 */class ArithmeticExer1 &#123; public static void main(String[] args) &#123; int num = 187; int bai = num / 100; int shi = num % 100 / 10;//int shi = num / 10 % 10; int ge = num % 10; System.out.println(&quot;百位为：&quot; + bai); System.out.println(&quot;十位为：&quot; + shi); System.out.println(&quot;个位为：&quot; + ge); &#125;&#125; 拓展：获取一个四位数的个位，十位，百位，千位 123456789101112131415161718192021/** * @author 尚硅谷-宋红康 * @create 12:39 */public class ArithmeticExer01 &#123; public static void main (String [] args) &#123; //1.定义一个变量，赋值为一个四位数整数，例如1234 int num = 1234; //2.通过运算操作求出个位，十位，百位，千位 int ge = num % 10; int shi = num /10 % 10; int bai = num /100 % 10; int qian = num / 1000 % 10; System.out.println(&quot;个位上的数字是：&quot; + ge); System.out.println(&quot;十位上的数字是：&quot; + shi); System.out.println(&quot;百位上的数字是：&quot; + bai); System.out.println(&quot;千位上的数字是：&quot; + qian); &#125;&#125; 案例2：为抵抗洪水，战士连续作战89小时，编程计算共多少天零多少小时？ 12345678910111213/** * @author 尚硅谷-宋红康 * @create 17:47 */public class ArithmeticExer2 &#123; public static void main(String[] args)&#123; int hours = 89; int day = hours / 24; int hour = hours % 24; System.out.println(&quot;为抵抗洪水，战士连续作战89小时：&quot;); System.out.println(hours + &quot;是&quot; + day + &quot;天&quot; + hour +&quot;小时&quot;); &#125;&#125; 练习1：算术运算符：自加、自减 123456789101112131415161718public class ArithmeticExer3&#123; public static void main(String[] args)&#123; int i1 = 10; int i2 = 20; int i = i1++; System.out.print(&quot;i=&quot;+i); // System.out.println(&quot;i1=&quot;+i1);// i = ++i1; System.out.print(&quot;i=&quot;+i);// System.out.println(&quot;i1=&quot;+i1);// i = i2--; System.out.print(&quot;i=&quot;+i);// System.out.println(&quot;i2=&quot;+i2);// i = --i2; System.out.print(&quot;i=&quot;+i);// System.out.println(&quot;i2=&quot;+i2);// &#125;&#125; 练习2： 1System.out.println(&quot;5+5=&quot; + 5 + 5); //打印结果是？ 5+5=55 ? 练习3： 123byte bb1 = 127;bb1++;System.out.println(&quot;bb1 = &quot; + bb1);//-128 练习4： 123int i = 1;int j = i++ + ++i * i++;System.out.println(&quot;j = &quot; + j); 练习5：（企业真题）写出下列程序的输出结果 1234567int i = 2;int j = i++;System.out.println(j);int m = 2;m = m++; //(1)先取b的值“2”放操作数栈 (2)m再自增,m=3 (3)再把操作数栈中的&quot;2&quot;赋值给m,m=2System.out.println(m); 7.2 赋值运算符7.2.1 基本语法 符号：&#x3D; 当“&#x3D;”两侧数据类型不一致时，可以使用自动类型转换或使用强制类型转换原则进行处理。 支持连续赋值。 扩展赋值运算符： +&#x3D;、 -&#x3D;、*&#x3D;、 &#x2F;&#x3D;、%&#x3D; 赋值运算符 符号解释 += 将符号左边的值和右边的值进行相加操作，最后将结果赋值给左边的变量 -= 将符号左边的值和右边的值进行相减操作，最后将结果赋值给左边的变量 *= 将符号左边的值和右边的值进行相乘操作，最后将结果赋值给左边的变量 /= 将符号左边的值和右边的值进行相除操作，最后将结果赋值给左边的变量 %= 将符号左边的值和右边的值进行取余操作，最后将结果赋值给左边的变量 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public class SetValueTest1 &#123; public static void main(String[] args) &#123; int i1 = 10; long l1 = i1; //自动类型转换 byte bb1 = (byte)i1; //强制类型转换 int i2 = i1; //连续赋值的测试 //以前的写法 int a1 = 10; int b1 = 10; //连续赋值的写法 int a2,b2; a2 = b2 = 10; int a3 = 10,b3 = 20; //举例说明+= -= *= /= %= int m1 = 10; m1 += 5; //类似于 m1 = m1 + 5的操作，但不等同于。 System.out.println(m1);//15 //练习1：开发中，如何实现一个变量+2的操作呢？ // += 的操作不会改变变量本身的数据类型。其他拓展的运算符也如此。 //写法1：推荐 short s1 = 10; s1 += 2; //编译通过，因为在得到int类型的结果后，JVM自动完成一步强制类型转换，将int类型强转成short System.out.println(s1);//12 //写法2： short s2 = 10; //s2 = s2 + 2;//编译报错，因为将int类型的结果赋值给short类型的变量s时，可能损失精度 s2 = (short)(s2 + 2); System.out.println(s2); //练习2：开发中，如何实现一个变量+1的操作呢？ //写法1：推荐 int num1 = 10; num1++; System.out.println(num1); //写法2： int num2 = 10; num2 += 1; System.out.println(num2); //写法3： int num3 = 10; num3 = num3 + 1; System.out.println(num3); &#125;&#125; 7.2.2 练习练习1： 123456short s = 3; s = s+2; //① 编译报错s += 2; //② 正常执行//①和②有什么区别？ 练习2： 123456int i = 1;i *= 0.1;System.out.println(i);//0i++;System.out.println(i);//1 练习3： 123456int m = 2;int n = 3;n *= m++; //n = n * m++;System.out.println(&quot;m=&quot; + m);//3System.out.println(&quot;n=&quot; + n);//6 练习4： 1234int n = 10;n += (n++) + (++n); //n = n + (n++) + (++n)System.out.println(n);//32 练习5：你有几种办法实现变量值减1？变量值减2呢？ 1234567891011121314151617181920212223/** * @author 尚硅谷-宋红康 * @create 16:55 */public class MinusTest &#123; public static void main(String[] args) &#123; //练习①：变量值减1 short s = 10; //方式1： //s = (short)(s - 1); //方式2：推荐 s--; //或者 --s //方式3： s -= 1; //练习②：变量值减2 short s1 = 10; //方式1： //s1 = (short)(s1 - 2); //方式2：推荐 s1 -= 2; &#125;&#125; 7.3 比较(关系)运算符 比较运算符的结果都是boolean型，也就是要么是true，要么是false。 &gt; &lt; &gt;&#x3D; &lt;&#x3D; ：只适用于基本数据类型（除boolean类型之外） &#x3D;&#x3D; !&#x3D; ：适用于基本数据类型和引用数据类型 比较运算符“==”不能误写成“=” 举例： 123456789101112131415161718192021class CompareTest &#123; public static void main(String[] args) &#123; int i1 = 10; int i2 = 20; System.out.println(i1 == i2);//false System.out.println(i1 != i2);//true System.out.println(i1 &gt;= i2);//false int m = 10; int n = 20; System.out.println(m == n);//false System.out.println(m = n);//20 boolean b1 = false; boolean b2 = true; System.out.println(b1 == b2);//false System.out.println(b1 = b2);//true &#125;&#125; 思考： 1234567boolean b1 = false;//区分好==和=的区别。if(b1 == true) //if(b1 = true) System.out.println(&quot;结果为真&quot;);else System.out.println(&quot;结果为假&quot;); 7.4 逻辑运算符7.4.1 基本语法 逻辑运算符，操作的都是boolean类型的变量或常量，而且运算得结果也是boolean类型的值。 运算符说明： &amp; 和 &amp;&amp;：表示”且”关系，当符号左右两边布尔值都是true时，结果才能为true。否则，为false。 | 和 || ：表示”或”关系，当符号两边布尔值有一边为true时，结果为true。当两边都为false时，结果为false ! ：表示”非”关系，当变量布尔值为true时，结果为false。当变量布尔值为false时，结果为true。 ^ ：当符号左右两边布尔值不同时，结果为true。当两边布尔值相同时，结果为false。 理解：异或，追求的是“异”！ 逻辑运算符用于连接布尔型表达式，在Java中不可以写成 3 &lt; x &lt; 6，应该写成x &gt; 3 &amp; x &lt; 6 。 区分“&amp;”和“&amp;&amp;”： 相同点：如果符号左边是true，则二者都执行符号右边的操作 不同点：&amp; ： 如果符号左边是false,则继续执行符号右边的操作 ​ &amp;&amp; ：如果符号左边是false,则不再继续执行符号右边的操作 建议：开发中，推荐使用 &amp;&amp; 区分“|”和“||”： 相同点：如果符号左边是false，则二者都执行符号右边的操作 不同点：| ： 如果符号左边是true，则继续执行符号右边的操作 ​ || ：如果符号左边是true，则不再继续执行符号右边的操作 建议：开发中，推荐使用 || 代码举例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class LoginTest &#123; public static void main(String[] args) &#123; int a = 3; int b = 4; int c = 5; // &amp; 与，且；有false则false System.out.println((a &gt; b) &amp; (a &gt; c)); System.out.println((a &gt; b) &amp; (a &lt; c)); System.out.println((a &lt; b) &amp; (a &gt; c)); System.out.println((a &lt; b) &amp; (a &lt; c)); System.out.println(&quot;===============&quot;); // | 或；有true则true System.out.println((a &gt; b) | (a &gt; c)); System.out.println((a &gt; b) | (a &lt; c)); System.out.println((a &lt; b) | (a &gt; c)); System.out.println((a &lt; b) | (a &lt; c)); System.out.println(&quot;===============&quot;); // ^ 异或；相同为false，不同为true System.out.println((a &gt; b) ^ (a &gt; c)); System.out.println((a &gt; b) ^ (a &lt; c)); System.out.println((a &lt; b) ^ (a &gt; c)); System.out.println((a &lt; b) ^ (a &lt; c)); System.out.println(&quot;===============&quot;); // ! 非；非false则true，非true则false System.out.println(!false); System.out.println(!true); //&amp;和&amp;&amp;的区别 System.out.println((a &gt; b) &amp; (a++ &gt; c)); System.out.println(&quot;a = &quot; + a); System.out.println((a &gt; b) &amp;&amp; (a++ &gt; c)); System.out.println(&quot;a = &quot; + a); System.out.println((a == b) &amp;&amp; (a++ &gt; c)); System.out.println(&quot;a = &quot; + a); //|和||的区别 System.out.println((a &gt; b) | (a++ &gt; c)); System.out.println(&quot;a = &quot; + a); System.out.println((a &gt; b) || (a++ &gt; c)); System.out.println(&quot;a = &quot; + a); System.out.println((a == b) || (a++ &gt; c)); System.out.println(&quot;a = &quot; + a); &#125;&#125; 7.4.2 案例与练习案例： 12345671. 定义类 CompareLogicExer2. 定义 main方法3. 定义一个int类型变量a,变量b,都赋值为204. 定义boolean类型变量bo1 , 判断++a 是否被3整除,并且a++ 是否被7整除,将结果赋值给bo15. 输出a的值,bo1的值6. 定义boolean类型变量bo2 , 判断b++ 是否被3整除,并且++b 是否被7整除,将结果赋值给bo27. 输出b的值,bo2的值 123456789101112131415161718/** * @author 尚硅谷-宋红康 * @create 12:42 */public class CompareLogicExer &#123; public static void main(String[] args)&#123; int a = 20; int b = 20; boolean bo1 = ((++a % 3) == 0) &amp;&amp; ((a++ % 7) == 0); System.out.println(&quot;bo1的值：&quot; + bo1); System.out.println(&quot;a的值：&quot; + a); System.out.println(&quot;----------------------------&quot;); boolean bo2 = ((b++ % 3) == 0) &amp;&amp; ((++b % 7) == 0); System.out.println(&quot;bo2的值：&quot; + bo2); System.out.println(&quot;b的值：&quot; + b); &#125;&#125; 练习1：区分 &amp; 和 &amp;&amp; 12345678int x = 1;int y = 1;if(x++ == 2 &amp; ++y == 2)&#123; x = 7;&#125;System.out.println(&quot;x=&quot; + x + &quot;,y=&quot; + y); 1234567int x = 1,y = 1;if(x++ == 2 &amp;&amp; ++y == 2)&#123; x =7;&#125;System.out.println(&quot;x=&quot;+x+&quot;,y=&quot;+y); 练习2：区分 | 和 || 1234567int x = 1,y = 1;if(x++==1 | ++y==1)&#123; x =7;&#125;System.out.println(&quot;x=&quot;+x+&quot;,y=&quot;+y); 1234567int x = 1,y = 1;if(x++==1 || ++y==1)&#123; x =7;&#125;System.out.println(&quot;x=&quot;+x+&quot;,y=&quot;+y); 练习3：程序输出 12345678910111213141516class Test &#123; public static void main (String [] args) &#123; boolean x = true; boolean y = false; short z = 42; if ((z++ == 42) &amp;&amp; (y = true)) &#123; z++; &#125; if ((x = false) || (++z == 45)) &#123; z++; &#125; System.out.println(&quot;z=&quot; + z); &#125;&#125; 12//结果为：//z= 46 7.5 位运算符（难点、非重点）7.5.1 基本语法 位运算符的运算过程都是基于二进制的补码运算 （1）左移：&lt;&lt; 运算规则：在一定范围内，数据每向左移动一位，相当于原数据*2。（正数、负数都适用） 【注意】当左移的位数n超过该数据类型的总位数时，相当于左移（n-总位数）位 13&lt;&lt;4 类似于 3*2的4次幂 =&gt; 3*16 =&gt; 48 1-3&lt;&lt;4 类似于 -3*2的4次幂 =&gt; -3*16 =&gt; -48 （2）右移：&gt;&gt; 运算规则：在一定范围内，数据每向右移动一位，相当于原数据&#x2F;2。（正数、负数都适用） 【注意】如果不能整除，向下取整。 169&gt;&gt;4 类似于 69/2的4次 = 69/16 =4 1-69&gt;&gt;4 类似于 -69/2的4次 = -69/16 = -5 （3）无符号右移：&gt;&gt;&gt; 运算规则：往右移动后，左边空出来的位直接补0。（正数、负数都适用） 169&gt;&gt;&gt;4 类似于 69/2的4次 = 69/16 =4 1-69&gt;&gt;&gt;4 结果：268435451 （4）按位与：&amp; 运算规则：对应位都是1才为1，否则为0。 1 &amp; 1 结果为1 1 &amp; 0 结果为0 0 &amp; 1 结果为0 0 &amp; 0 结果为0 19 &amp; 7 = 1 1-9 &amp; 7 = 7 （5）按位或：| 运算规则：对应位只要有1即为1，否则为0。 1 | 1 结果为1 1 | 0 结果为1 0 | 1 结果为1 0 &amp; 0 结果为0 19 | 7 //结果： 15 1-9 | 7 //结果： -9 （6）按位异或：^ 运算规则：对应位一个为1一个为0，才为1，否则为0。 1 ^ 1 结果为0 1 ^ 0 结果为1 0 ^ 1 结果为1 0 ^ 0 结果为0 19 ^ 7 //结果为14 1-9 ^ 7 //结果为-16 （7）按位取反：~ 运算规则：对应位为1，则结果为0；对应位为0，则结果为1。 ~0就是1 ~1就是0 1~9 //结果：-10 1~-9 //结果：8 7.5.2 举例举例1： 举例2：体会 m &#x3D; k ^ n &#x3D; (m ^ n) ^ n 7.5.3 案例案例1：高效的方式计算2 * 8的值（经典面试题） 1答案：2 &lt;&lt; 3 、 8 &lt;&lt; 1 案例2：如何交换两个int型变量的值？String呢？ 1234567891011121314151617181920212223242526272829/** * @author 尚硅谷-宋红康 * @create 16:58 */public class BitExer &#123; public static void main(String[] args) &#123; int m = 10; int n = 5; System.out.println(&quot;m = &quot; + m + &quot;, n = &quot; + n); //（推荐）实现方式1：优点：容易理解，适用于不同数据类型 缺点：需要额外定义变量 //int temp = m; //m = n; //n = temp; //实现方式2：优点：没有额外定义变量 缺点：可能超出int的范围；只能适用于数值类型 //m = m + n; //15 = 10 + 5 //n = m - n;//10 = 15 - 5 //m = m - n;//5 = 15 - 10 //实现方式3：优点：没有额外定义变量 缺点：不易理解；只能适用于数值类型 m = m ^ n; n = m ^ n; //(m ^ n) ^ n m = m ^ n; System.out.println(&quot;m = &quot; + m + &quot;, n = &quot; + n); &#125;&#125; 7.6 条件运算符7.6.1 基本语法 条件运算符格式： 1(条件表达式)? 表达式1:表达式2 说明：条件表达式是boolean类型的结果，根据boolean的值选择表达式1或表达式2 如果运算后的结果赋给新的变量，要求表达式1和表达式2为同种或兼容的类型 12345678910111213public static void main(String[] args) &#123; int i = (1==2 ? 100 : 200); System.out.println(i);//200 boolean marry = false; System.out.println(marry ? &quot;已婚&quot; : &quot;未婚&quot; ); double d1 = (m1 &gt; m2)? 1 : 2.0; System.out.println(d1); int num = 12; System.out.println(num &gt; 0? true : &quot;num非正数&quot;);&#125; 7.6.2 案例案例1：获取两个数中的较大值 1234567891011121314/** * @author 尚硅谷-宋红康 * @create 12:40 */public class ConditionExer1 &#123; public static void main(String[] args) &#123; //获取两个数的较大值 int m1 = 10; int m2 = 20; int max1 = (m1 &gt; m2)? m1 : m2; System.out.println(&quot;m1和m2中的较大值为&quot; + max1); &#125;&#125; 案例2：获取三个数中的最大值 12345678910111213141516171819/** * @author 尚硅谷-宋红康 * @create 12:43 */public class ConditionExer2 &#123; public static void main(String[] args) &#123; int n1 = 23; int n2 = 13; int n3 = 33; //写法1： int tempMax = (n1 &gt; n2)? n1:n2; int finalMax = (tempMax &gt; n3)? tempMax : n3; System.out.println(&quot;三个数中最大值为：&quot; + finalMax); //写法2：不推荐，可读性差 int finalMax1 = (((n1 &gt; n2)? n1:n2) &gt; n3)? ((n1 &gt; n2)? n1:n2) : n3; System.out.println(&quot;三个数中最大值为：&quot; + finalMax1); &#125;&#125; 案例3：今天是周2，10天以后是周几？ 要求：控制台输出”今天是周2，10天以后是周x”。 1234567891011121314/** * @author 尚硅谷-宋红康 * @create 12:46 */public class ConditionExer3 &#123; public static void main(String[] args) &#123; int week = 2; week += 10; week %= 7; System.out.println(&quot;今天是周2,10天以后是周&quot; + (week == 0 ? &quot;日&quot; : week)); &#125;&#125; 7.6.3 与if-else的转换关系 凡是可以使用条件运算符的地方，都可以改写为if-else结构。反之，不成立。 开发中，如果既可以使用条件运算符，又可以使用if-else，推荐使用条件运算符。因为执行效率稍高。 1234567891011121314//if-else实现获取两个数的较大值int i1 = 10;int i2 = 20;int max;//声明变量max，用于记录i1和i2的较大值if(i1 &gt; i2)&#123; max = i1;&#125;else&#123; max = i2;&#125;System.out.println(max); 7.7 运算符优先级运算符有不同的优先级，所谓优先级就是在表达式运算中的运算符顺序。 上一行中的运算符总是优先于下一行的。 优先级 运算符说明 Java运算符 1 括号 ()、[]、&#123;&#125; 2 正负号 +、- 3 单元运算符 ++、--、~、！ 4 乘法、除法、求余 *、/、% 5 加法、减法 +、- 6 移位运算符 &lt;&lt;、&gt;&gt;、&gt;&gt;&gt; 7 关系运算符 &lt;、&lt;=、&gt;=、&gt;、instanceof 8 等价运算符 ==、!= 9 按位与 &amp; 10 按位异或 ^ 11 按位或 &#96; 12 条件与 &amp;&amp; 13 条件或 &#96; 14 三元运算符 ? : 15 赋值运算符 =、+=、-=、*=、/=、%= 16 位赋值运算符 &amp;=、&#96; 开发建议： 不要过多的依赖运算的优先级来控制表达式的执行顺序，这样可读性太差，尽量使用()来控制表达式的执行顺序。 不要把一个表达式写得过于复杂，如果一个表达式过于复杂，则把它分成几步来完成。例如： ​ (num1 + num2) * 2 &gt; num3 &amp;&amp; num2 &gt; num3 ? num3 : num1 + num2; 8. 【拓展】关于字符集8.1 字符集 编码与解码 计算机中储存的信息都是用二进制数表示的，而我们在屏幕上看到的数字、英文、标点符号、汉字等字符是二进制数转换之后的结果。按照某种规则，将字符存储到计算机中，称为编码 。反之，将存储在计算机中的二进制数按照某种规则解析显示出来，称为解码 。 字符编码（Character Encoding） : 就是一套自然语言的字符与二进制数之间的对应规则。 字符集：也叫编码表。是一个系统支持的所有字符的集合，包括各国家文字、标点符号、图形符号、数字等。 8.2 ASCII码 ASCII码（American Standard Code for Information Interchange，美国信息交换标准代码）：上个世纪60年代，美国制定了一套字符编码，对英语字符与二进制位之间的关系，做了统一规定。这被称为ASCII码。 ASCII码用于显示现代英语，主要包括控制字符（回车键、退格、换行键等）和可显示字符（英文大小写字符、阿拉伯数字和西文符号）。 基本的ASCII字符集，使用7位（bits）表示一个字符（最前面的1位统一规定为0），共128个字符。比如：空格“SPACE”是32（二进制00100000），大写的字母A是65（二进制01000001）。 缺点：不能表示所有字符。 8.3 ISO-8859-1字符集 拉丁码表，别名Latin-1，用于显示欧洲使用的语言，包括荷兰语、德语、意大利语、葡萄牙语等 ISO-8859-1使用单字节编码，兼容ASCII编码。 8.4 GBxxx字符集 GB就是国标的意思，是为了显示中文而设计的一套字符集。 GB2312：简体中文码表。一个小于127的字符的意义与原来相同，即向下兼容ASCII码。但两个大于127的字符连在一起时，就表示一个汉字，这样大约可以组合了包含7000多个简体汉字，此外数学符号、罗马希腊的字母、日文的假名们都编进去了，这就是常说的”全角”字符，而原来在127号以下的那些符号就叫”半角”字符了。 GBK：最常用的中文码表。是在GB2312标准基础上的扩展规范，使用了双字节编码方案，共收录了21003个汉字，完全兼容GB2312标准，同时支持繁体汉字以及日韩汉字等。 GB18030：最新的中文码表。收录汉字70244个，采用多字节编码，每个字可以由1个、2个或4个字节组成。支持中国国内少数民族的文字，同时支持繁体汉字以及日韩汉字等。 8.5 Unicode码 Unicode编码为表达任意语言的任意字符而设计，也称为统一码、标准万国码。Unicode 将世界上所有的文字用2个字节统一进行编码，为每个字符设定唯一的二进制编码，以满足跨语言、跨平台进行文本处理的要求。 Unicode 的缺点：这里有三个问题： 第一，英文字母只用一个字节表示就够了，如果用更多的字节存储是极大的浪费。 第二，如何才能区别Unicode和ASCII？计算机怎么知道两个字节表示一个符号，而不是分别表示两个符号呢？ 第三，如果和GBK等双字节编码方式一样，用最高位是1或0表示两个字节和一个字节，就少了很多值无法用于表示字符，不够表示所有字符。 Unicode在很长一段时间内无法推广，直到互联网的出现，为解决Unicode如何在网络上传输的问题，于是面向传输的众多 UTF（UCS Transfer Format）标准出现。具体来说，有三种编码方案，UTF-8、UTF-16和UTF-32。 8.6 UTF-8 Unicode是字符集，UTF-8、UTF-16、UTF-32是三种将数字转换到程序数据的编码方案。顾名思义，UTF-8就是每次8个位传输数据，而UTF-16就是每次16个位。其中，UTF-8 是在互联网上使用最广的一种 Unicode 的实现方式。 互联网工程工作小组（IETF）要求所有互联网协议都必须支持UTF-8编码。所以，我们开发Web应用，也要使用UTF-8编码。UTF-8 是一种变长的编码方式。它可以使用 1-4 个字节表示一个符号它使用一至四个字节为每个字符编码，编码规则： 128个US-ASCII字符，只需一个字节编码。 拉丁文等字符，需要二个字节编码。 大部分常用字（含中文），使用三个字节编码。 其他极少使用的Unicode辅助字符，使用四字节编码。 举例 Unicode符号范围 | UTF-8编码方式 1234567891011(十六进制) | （二进制）————————————————————|—–—–—–—–—–—–—–—–—–—–—–—–—–—–0000 0000-0000 007F | 0xxxxxxx（兼容原来的ASCII）0000 0080-0000 07FF | 110xxxxx 10xxxxxx0000 0800-0000 FFFF | 1110xxxx 10xxxxxx 10xxxxxx0001 0000-0010 FFFF | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx 8.7 小结 注意：在中文操作系统上，ANSI（美国国家标准学会、AMERICAN NATIONAL STANDARDS INSTITUTE: ANSI）编码即为GBK；在英文操作系统上，ANSI编码即为ISO-8859-1。","categories":[{"name":"java基础","slug":"java基础","permalink":"http://example.com/categories/java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"java","slug":"java","permalink":"http://example.com/tags/java/"}]},{"title":"一、高效构建Java应用：Maven入门和进阶","slug":"SSM/一、高效构建Java应用：Maven入门和进阶/一、高效构建Java应用：Maven入门和进阶","date":"2022-09-27T00:55:54.000Z","updated":"2023-09-28T00:29:57.856Z","comments":true,"path":"2022/09/27/SSM/一、高效构建Java应用：Maven入门和进阶/一、高效构建Java应用：Maven入门和进阶/","link":"","permalink":"http://example.com/2022/09/27/SSM/%E4%B8%80%E3%80%81%E9%AB%98%E6%95%88%E6%9E%84%E5%BB%BAJava%E5%BA%94%E7%94%A8%EF%BC%9AMaven%E5%85%A5%E9%97%A8%E5%92%8C%E8%BF%9B%E9%98%B6/%E4%B8%80%E3%80%81%E9%AB%98%E6%95%88%E6%9E%84%E5%BB%BAJava%E5%BA%94%E7%94%A8%EF%BC%9AMaven%E5%85%A5%E9%97%A8%E5%92%8C%E8%BF%9B%E9%98%B6/","excerpt":"","text":"一、高效构建Java应用：Maven入门和进阶1.1 Maven介绍https://maven.apache.org/what-is-maven.html Maven 是一款为 Java 项目构建管理、依赖管理的工具（软件），使用 Maven 可以自动化构建、测试、打包和发布项目，大大提高了开发效率和质量。 总结：Maven就是一个软件，掌握软件安装、配置、以及基本功能 （项目构建、依赖管理） 使用就是本课程的主要目标！ 1.2 Maven主要作用理解 场景概念 场景1： 例如我们项目需要第三方库（依赖），如Druid连接池、MySQL数据库驱动和Jackson等。那么我们可以将需要的依赖项的信息编写到Maven工程的配置文件，Maven软件就会自动下载并复制这些依赖项到项目中，也会自动下载依赖需要的依赖！确保依赖版本正确无冲突和依赖完整！ 场景2： 项目开发完成后，想要将项目打成.war文件，并部署到服务器中运行，使用Maven软件，我们可以通过一行构建命令（mvn package）快速项目构建和打包！节省大量时间！ 依赖管理： Maven 可以管理项目的依赖，包括自动下载所需依赖库、自动下载依赖需要的依赖并且保证版本没有冲突、依赖版本管理等。通过 Maven，我们可以方便地维护项目所依赖的外部库，而我们仅仅需要编写配置即可。 构建管理： 项目构建是指将源代码、配置文件、资源文件等转化为能够运行或部署的应用程序或库的过程！ Maven 可以管理项目的编译、测试、打包、部署等构建过程。通过实现标准的构建生命周期，Maven 可以确保每一个构建过程都遵循同样的规则和最佳实践。同时，Maven 的插件机制也使得开发者可以对构建过程进行扩展和定制。主动触发构建，只需要简单的命令操作即可。 1.3 Maven安装和配置https://maven.apache.org/docs/history.html 选用版本： apache-maven-3.6.3-bin.zip 发布时间 maven版本 jdk最低版本 **2019 - 11 - **25 3.6. 3 Java 7 安装 安装条件： maven需要本机安装java环境、必需包含java_home环境变量！ 软件安装： 右键解压即可（绿色免安装） 软件结构： 环境变量 环境变量： 配置maven_home 和 path 命令测试 123mvn -v # 输出版本信息即可，如果错误，请仔细检查环境变量即可！# 友好提示，如果此处错误，绝大部分原因都是java_home变量的事，请仔细检查！！ 配置文件 我们需要需改maven&#x2F;conf&#x2F;settings.xml配置文件，来修改maven的一些默认配置。我们主要休要修改的有三个配置：1.依赖本地缓存位置（本地仓库位置）2.maven下载镜像3.maven选用编译项目的jdk版本！ 配置本地仓库地址12345678&lt;!-- localRepository | The path to the local repository maven will use to store artifacts. | | Default: $&#123;user.home&#125;/.m2/repository&lt;localRepository&gt;/path/to/local/repo&lt;/localRepository&gt;--&gt;&lt;!-- conf/settings.xml 55行 --&gt;&lt;localRepository&gt;D:\\repository&lt;/localRepository&gt; 配置国内阿里镜像1234567&lt;!--在mirrors节点(标签)下添加中央仓库镜像 160行附近--&gt;&lt;mirror&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt;&lt;/mirror&gt; 配置jdk17版本项目构建12345678910111213&lt;!--在profiles节点(标签)下添加jdk编译版本 268行附近--&gt;&lt;profile&gt; &lt;id&gt;jdk-17&lt;/id&gt; &lt;activation&gt; &lt;activeByDefault&gt;true&lt;/activeByDefault&gt; &lt;jdk&gt;17&lt;/jdk&gt; &lt;/activation&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;17&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;17&lt;/maven.compiler.target&gt; &lt;maven.compiler.compilerVersion&gt;17&lt;/maven.compiler.compilerVersion&gt; &lt;/properties&gt;&lt;/profile&gt; idea配置本地maven 我们需要将配置好的maven软件，配置到idea开发工具中即可！ 注意：idea工具默认自带maven配置软件，但是因为没有修改配置，建议替换成本地配置好的maven！ 打开idea配置文件，构建工具配置 依次点击 file / settings / build / build tool / maven 选中本地maven软件 测试是否配置成功 注意：如果本地仓库地址不变化，只有一个原因，就是maven&#x2F;conf&#x2F;settings.xml配置文件编写错误！仔细检查即可！ 二、基于IDEA的Maven工程创建2.1梳理Maven工程GAVP属性 Maven工程相对之前的工程，多出一组gavp属性，gav需要我们在创建项目的时指定，p有默认值，后期通过配置文件修改。既然要填写的属性，我们先行了解下这组属性的含义! Maven 中的 GAVP 是指 GroupId、ArtifactId、Version、Packaging 等四个属性的缩写，其中前三个是必要的，而 Packaging 属性为可选项。这四个属性主要为每个项目在maven仓库总做一个标识，类似人的《姓-名》。有了具体标识，方便maven软件对项目进行管理和互相引用！ GAV遵循一下规则： 1） GroupID 格式：com.{公司&#x2F;BU }.业务线.[子业务线]，最多 4 级。 说明：{公司&#x2F;BU} 例如：alibaba&#x2F;taobao&#x2F;tmall&#x2F;aliexpress 等 BU 一级；子业务线可选。 正例：com.taobao.tddl 或 com.alibaba.sourcing.multilang com.atguigu.java 2） ArtifactID 格式：产品线名-模块名。语义不重复不遗漏，先到仓库中心去查证一下。 正例：tc-client &#x2F; uic-api &#x2F; tair-tool &#x2F; bookstore 3） Version版本号格式推荐：主版本号.次版本号.修订号 1.0.0 1） 主版本号：当做了不兼容的 API 修改，或者增加了能改变产品方向的新功能。 2） 次版本号：当做了向下兼容的功能性新增（新增类、接口等）。 3） 修订号：修复 bug，没有修改方法签名的功能加强，保持 API 兼容性。 例如： 初始→1.0.0 修改bug → 1.0.1 功能调整 → 1.1.1等 Packaging定义规则： 指示将项目打包为什么类型的文件，idea根据packaging值，识别maven项目类型！ packaging 属性为 jar（默认值），代表普通的Java工程，打包以后是.jar结尾的文件。 packaging 属性为 war，代表Java的web工程，打包以后.war结尾的文件。 packaging 属性为 pom，代表不会打包，用来做继承的父工程。 2.2 Idea构建Maven JavaSE工程注意：此处省略了version，直接给了一个默认值&lt;version&gt;1.0-SNAPSHOT&lt;&#x2F;version&gt; 自己后期可以在项目中随意修改！ 2.3 Idea构建Maven JavaEE工程 手动创建 创建一个javasemaven工程 手动添加web项目结构文件 注意：结构和命名固定 修改pom.xml文件打包方式 修改位置：项目下&#x2F;pom.xml 12345&lt;groupId&gt;com.atguigu&lt;/groupId&gt;&lt;artifactId&gt;maven_parent&lt;/artifactId&gt;&lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;&lt;!-- 新增一列打包方式packaging --&gt;&lt;packaging&gt;war&lt;/packaging&gt; 刷新和校验 项目的webapp文件夹出现小蓝点，代表成功！！ 插件方式创建 安装插件JBLJavaToWeb file &#x2F; settings &#x2F; plugins &#x2F; marketplace 创建一个javasemaven工程 右键、使用插件快速补全web项目 2.4 Maven工程项目结构说明Maven 是一个强大的构建工具，它提供一种标准化的项目结构，可以帮助开发者更容易地管理项目的依赖、构建、测试和发布等任务。以下是 Maven Web 程序的文件结构及每个文件的作用： 123456789101112131415161718192021222324|-- pom.xml # Maven 项目管理文件 |-- src |-- main # 项目主要代码 | |-- java # Java 源代码目录 | | `-- com/example/myapp # 开发者代码主目录 | | |-- controller # 存放 Controller 层代码的目录 | | |-- service # 存放 Service 层代码的目录 | | |-- dao # 存放 DAO 层代码的目录 | | `-- model # 存放数据模型的目录 | |-- resources # 资源目录，存放配置文件、静态资源等 | | |-- log4j.properties # 日志配置文件 | | |-- spring-mybatis.xml # Spring Mybatis 配置文件 | | `-- static # 存放静态资源的目录 | | |-- css # 存放 CSS 文件的目录 | | |-- js # 存放 JavaScript 文件的目录 | | `-- images # 存放图片资源的目录 | `-- webapp # 存放 WEB 相关配置和资源 | |-- WEB-INF # 存放 WEB 应用配置文件 | | |-- web.xml # Web 应用的部署描述文件 | | `-- classes # 存放编译后的 class 文件 | `-- index.html # Web 应用入口页面 `-- test # 项目测试代码 |-- java # 单元测试目录 `-- resources # 测试资源目录 pom.xml：Maven 项目管理文件，用于描述项目的依赖和构建配置等信息。 src&#x2F;main&#x2F;java：存放项目的 Java 源代码。 src&#x2F;main&#x2F;resources：存放项目的资源文件，如配置文件、静态资源等。 src&#x2F;main&#x2F;webapp&#x2F;WEB-INF：存放 Web 应用的配置文件。 src&#x2F;main&#x2F;webapp&#x2F;index.html：Web 应用的入口页面。 src&#x2F;test&#x2F;java：存放项目的测试代码。 src&#x2F;test&#x2F;resources：存放测试相关的资源文件，如测试配置文件等。 三、Maven核心功能依赖和构建管理3.1 依赖管理和配置Maven 依赖管理是 Maven 软件中最重要的功能之一。Maven 的依赖管理能够帮助开发人员自动解决软件包依赖问题，使得开发人员能够轻松地将其他开发人员开发的模块或第三方框架集成到自己的应用程序或模块中，避免出现版本冲突和依赖缺失等问题。 我们通过定义 POM 文件，Maven 能够自动解析项目的依赖关系，并通过 Maven 仓库自动下载和管理依赖，从而避免了手动下载和管理依赖的繁琐工作和可能引发的版本冲突问题。 重点: 编写pom.xml文件! maven项目信息属性配置和读取： 12345678910111213141516&lt;!-- 模型版本 --&gt;&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;&lt;!-- 公司或者组织的唯一标志，并且配置时生成的路径也是由此生成， 如com.companyname.project-group，maven会将该项目打成的jar包放本地路径：/com/companyname/project-group --&gt;&lt;groupId&gt;com.companyname.project-group&lt;/groupId&gt;&lt;!-- 项目的唯一ID，一个groupId下面可能多个项目，就是靠artifactId来区分的 --&gt;&lt;artifactId&gt;project&lt;/artifactId&gt;&lt;!-- 版本号 --&gt;&lt;version&gt;1.0.0&lt;/version&gt;&lt;!--打包方式 默认：jar jar指的是普通的java项目打包方式！ 项目打成jar包！ war指的是web项目打包方式！项目打成war包！ pom不会讲项目打包！这个项目作为父工程，被其他工程聚合或者继承！后面会讲解两个概念--&gt;&lt;packaging&gt;jar/pom/war&lt;/packaging&gt; 依赖管理和添加： 123456789101112131415161718192021222324&lt;!-- 通过编写依赖jar包的gav必要属性，引入第三方依赖！ scope属性是可选的，可以指定依赖生效范围！ 依赖信息查询方式： 1. maven仓库信息官网 https://mvnrepository.com/ 2. mavensearch插件搜索 --&gt;&lt;dependencies&gt; &lt;!-- 引入具体的依赖包 --&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt; &lt;!-- 生效范围 - compile ：main目录 test目录 打包打包 [默认] - provided：main目录 test目录 Servlet - runtime： 打包运行 MySQL - test: test目录 junit --&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 依赖版本提取和维护: 1234567891011121314151617&lt;!--声明版本--&gt;&lt;properties&gt; &lt;!--命名随便,内部制定版本号即可！--&gt; &lt;junit.version&gt;4.11&lt;/junit.version&gt; &lt;!-- 也可以通过 maven规定的固定的key，配置maven的参数！如下配置编码格式！--&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt;&lt;/properties&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;!--引用properties声明版本 --&gt; &lt;version&gt;$&#123;junit.version&#125;&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 3.2依赖传递和冲突依赖传递指的是当一个模块或库 A 依赖于另一个模块或库 B，而 B 又依赖于模块或库 C，那么 A 会间接依赖于 C。这种依赖传递结构可以形成一个依赖树。当我们引入一个库或框架时，构建工具（如 Maven、Gradle）会自动解析和加载其所有的直接和间接依赖，确保这些依赖都可用。 依赖传递的作用是： 减少重复依赖：当多个项目依赖同一个库时，Maven 可以自动下载并且只下载一次该库。这样可以减少项目的构建时间和磁盘空间。 自动管理依赖: Maven 可以自动管理依赖项，使用依赖传递，简化了依赖项的管理，使项目构建更加可靠和一致。 确保依赖版本正确性：通过依赖传递的依赖，之间都不会存在版本兼容性问题，确实依赖的版本正确性！ 依赖传递演示： 项目中，需要导入jackson相关的依赖，通过之前导入经验，jackson需要导入三个依赖，分别为： 通过查看网站介绍的依赖传递特性：data-bind中，依赖其他两个依赖 最佳导入：直接可以导入data-bind，自动依赖传递需要的依赖 123456&lt;!-- https://mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-databind --&gt;&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.15.0&lt;/version&gt;&lt;/dependency&gt; 依赖冲突演示： 当直接引用或者间接引用出现了相同的jar包! 这时呢，一个项目就会出现相同的重复jar包，这就算作冲突！依赖冲突避免出现重复依赖，并且终止依赖传递！ maven自动解决依赖冲突问题能力，会按照自己的原则，进行重复依赖选择。同时也提供了手动解决的冲突的方式，不过不推荐！ 解决依赖冲突（如何选择重复依赖）方式： 自动选择原则 短路优先原则（第一原则） A—&gt;B—&gt;C—&gt;D—&gt;E—&gt;X(version 0.0.1) A—&gt;F—&gt;X(version 0.0.2) 则A依赖于X(version 0.0.2)。 依赖路径长度相同情况下，则“先声明优先”（第二原则） A—&gt;E—&gt;X(version 0.0.1) A—&gt;F—&gt;X(version 0.0.2) 在&lt;depencies&gt;&lt;&#x2F;depencies&gt;中，先声明的，路径相同，会优先选择！ 小思考: 123456789前提： A 1.1 -&gt; B 1.1 -&gt; C 1.1 F 2.2 -&gt; B 2.2 pom声明： F 2.2 A 1.1 B 2.2 3.3 依赖导入失败场景和解决方案在使用 Maven 构建项目时，可能会发生依赖项下载错误的情况，主要原因有以下几种： 下载依赖时出现网络故障或仓库服务器宕机等原因，导致无法连接至 Maven 仓库，从而无法下载依赖。 依赖项的版本号或配置文件中的版本号错误，或者依赖项没有正确定义，导致 Maven 下载的依赖项与实际需要的不一致，从而引发错误。 本地 Maven 仓库或缓存被污染或损坏，导致 Maven 无法正确地使用现有的依赖项，并且也无法重新下载！ 解决方案： 检查网络连接和 Maven 仓库服务器状态。 确保依赖项的版本号与项目对应的版本号匹配，并检查 POM 文件中的依赖项是否正确。 清除本地 Maven 仓库缓存（lastUpdated 文件），因为只要存在lastupdated缓存文件，刷新也不会重新下载。本地仓库中，根据依赖的gav属性依次向下查找文件夹，最终删除内部的文件，刷新重新下载即可！ 例如： pom.xml依赖 12345&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.2.8&lt;/version&gt;&lt;/dependency&gt; 文件： 脚本使用： 清理maven错误缓存.bat 123使用记事本打开set REPOSITORY_PATH=D:\\repository 改成你本地仓库地址即可！点击运行脚本，即可自动清理本地错误缓存文件！！ 3.4 扩展构建管理和插件配置构建概念: 项目构建是指将源代码、依赖库和资源文件等转换成可执行或可部署的应用程序的过程，在这个过程中包括编译源代码、链接依赖库、打包和部署等多个步骤。 主动触发场景： 重新编译 : 编译不充分, 部分文件没有被编译! 打包 : 独立部署到外部服务器软件,打包部署 部署本地或者私服仓库 : maven工程加入到本地或者私服仓库,供其他工程使用 命令方式构建: 语法: mvn 构建命令 构建命令…. 命令 描述 mvn clean 清理编译或打包后的项目结构,删除target文件夹 mvn compile 编译项目，生成target文件 mvn test 执行测试源码 (测试) mvn site 生成一个项目依赖信息的展示页面 mvn package 打包项目，生成war &#x2F; jar 文件 mvn install 打包后上传到maven本地仓库(本地部署) mvn deploy 只打包，上传到maven私服仓库(私服部署) 可视化方式构建: 构建命令周期: 构建生命周期可以理解成是一组固定构建命令的有序集合，触发周期后的命令，会自动触发周期前的命令！也是一种简化构建的思路! 清理周期：主要是对项目编译生成文件进行清理 包含命令：clean 默认周期：定义了真正构件时所需要执行的所有步骤，它是生命周期中最核心的部分 包含命令：compile - test - package - install &#x2F; deploy 报告周期 包含命令：site 打包: mvn clean package 本地仓库: mvn clean install 最佳使用方案: 123打包: mvn clean package重新编译: mvn clean compile本地部署: mvn clean install 周期，命令和插件: 周期→包含若干命令→包含若干插件! 使用周期命令构建，简化构建过程！ 最终进行构建的是插件！ 插件配置: 12345678910&lt;build&gt; &lt;!-- jdk17 和 war包版本插件不匹配 --&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt; &lt;version&gt;3.2.2&lt;/version&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 四、Maven继承和聚合特性4.1 Maven工程继承关系 继承概念 Maven 继承是指在 Maven 的项目中，让一个项目从另一个项目中继承配置信息的机制。继承可以让我们在多个项目中共享同一配置信息，简化项目的管理和维护工作。 继承作用 作用：在父工程中统一管理项目中的依赖信息,进行统一版本管理! 它的背景是： 对一个比较大型的项目进行了模块拆分。 一个 project 下面，创建了很多个 module。 每一个 module 都需要配置自己的依赖信息。它背后的需求是： 多个模块要使用同一个框架，它们应该是同一个版本，所以整个项目中使用的框架版本需要统一管理。 使用框架时所需要的 jar 包组合（或者说依赖信息组合）需要经过长期摸索和反复调试，最终确定一个可用组合。这个耗费很大精力总结出来的方案不应该在新的项目中重新摸索。通过在父工程中为整个项目维护依赖信息的组合既保证了整个项目使用规范、准确的 jar 包；又能够将以往的经验沉淀下来，节约时间和精力。 继承语法 父工程123456&lt;groupId&gt;com.atguigu.maven&lt;/groupId&gt;&lt;artifactId&gt;pro03-maven-parent&lt;/artifactId&gt;&lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;&lt;!-- 当前工程作为父工程，它要去管理子工程，所以打包方式必须是 pom --&gt;&lt;packaging&gt;pom&lt;/packaging&gt; 子工程12345678910111213&lt;!-- 使用parent标签指定当前工程的父工程 --&gt;&lt;parent&gt; &lt;!-- 父工程的坐标 --&gt; &lt;groupId&gt;com.atguigu.maven&lt;/groupId&gt; &lt;artifactId&gt;pro03-maven-parent&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;&lt;/parent&gt;&lt;!-- 子工程的坐标 --&gt;&lt;!-- 如果子工程坐标中的groupId和version与父工程一致，那么可以省略 --&gt;&lt;!-- &lt;groupId&gt;com.atguigu.maven&lt;/groupId&gt; --&gt;&lt;artifactId&gt;pro04-maven-module&lt;/artifactId&gt;&lt;!-- &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; --&gt; 父工程依赖统一管理 父工程声明版本12345678910111213141516171819202122232425262728293031&lt;!-- 使用dependencyManagement标签配置对依赖的管理 --&gt;&lt;!-- 被管理的依赖并没有真正被引入到工程 --&gt;&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;4.0.0.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;version&gt;4.0.0.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;4.0.0.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-expression&lt;/artifactId&gt; &lt;version&gt;4.0.0.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;version&gt;4.0.0.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt; 子工程引用版本12345678910111213141516171819202122232425&lt;!-- 子工程引用父工程中的依赖信息时，可以把版本号去掉。 --&gt;&lt;!-- 把版本号去掉就表示子工程中这个依赖的版本由父工程决定。 --&gt;&lt;!-- 具体来说是由父工程的dependencyManagement来决定。 --&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-expression&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 4.2 Maven工程聚合关系 聚合概念 Maven 聚合是指将多个项目组织到一个父级项目中，通过触发父工程的构建,统一按顺序触发子工程构建的过程!! 聚合作用 统一管理子项目构建：通过聚合，可以将多个子项目组织在一起，方便管理和维护。 优化构建顺序：通过聚合，可以对多个项目进行顺序控制，避免出现构建依赖混乱导致构建失败的情况。 聚合语法 父项目中包含的子项目列表。 12345678910&lt;project&gt; &lt;groupId&gt;com.example&lt;/groupId&gt; &lt;artifactId&gt;parent-project&lt;/artifactId&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;version&gt;1.0.0&lt;/version&gt; &lt;modules&gt; &lt;module&gt;child-project1&lt;/module&gt; &lt;module&gt;child-project2&lt;/module&gt; &lt;/modules&gt;&lt;/project&gt; 聚合演示 通过触发父工程构建命令、引发所有子模块构建！产生反应堆！ 五、Maven实战案例：搭建微服务Maven工程架构5.1 项目需求和结构分析 需求案例：搭建一个电商平台项目，该平台包括用户服务、订单服务、通用工具模块等。 项目架构： 用户服务：负责处理用户相关的逻辑，例如用户信息的管理、用户注册、登录等。 订单服务：负责处理订单相关的逻辑，例如订单的创建、订单支付、退货、订单查看等。 通用模块：负责存储其他服务需要通用工具类，其他服务依赖此模块。 服务依赖： 用户服务 (1.0.1) spring-context 6.0.6&#x20; spring-core 6.0.6 spring-beans 6.0.6 jackson-databind &#x2F; jackson-core &#x2F; jackson-annotations 2.15.0&#x20; 订单服务 (1.0.1) shiro-core 1.10.1&#x20; spring-context 6.0.6&#x20; spring-core 6.0.6 spring-beans 6.0.6 通用模块 (1.0.1) commons-io 2.11.0 5.2项目搭建和统一构建 父模块搭建 (micro-shop) 创建父工程 pom.xml配置 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.atguigu&lt;/groupId&gt; &lt;artifactId&gt;micro-shop&lt;/artifactId&gt; &lt;version&gt;1.0.1&lt;/version&gt; &lt;!-- 父工程不打包，所以选择pom值--&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;properties&gt; &lt;spring.version&gt;6.0.6&lt;/spring.version&gt; &lt;jackson.version&gt;2.15.0&lt;/jackson.version&gt; &lt;shiro.version&gt;1.10.1&lt;/shiro.version&gt; &lt;commons.version&gt;2.11.0&lt;/commons.version&gt; &lt;maven.compiler.source&gt;17&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;17&lt;/maven.compiler.target&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;/properties&gt; &lt;!-- 依赖管理 --&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;!-- spring-context会依赖传递core/beans --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- jackson-databind会依赖传递core/annotations --&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;$&#123;jackson.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- shiro-core --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-core&lt;/artifactId&gt; &lt;version&gt;$&#123;shiro.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- commons-io --&gt; &lt;dependency&gt; &lt;groupId&gt;commons-io&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;version&gt;$&#123;commons.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;dependencies&gt; &lt;!-- 父工程添加依赖，会自动传递给所有子工程，不推荐！ --&gt; &lt;/dependencies&gt; &lt;!-- 统一更新子工程打包插件--&gt; &lt;build&gt; &lt;!-- jdk17 和 war包版本插件不匹配 --&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt; &lt;version&gt;3.2.2&lt;/version&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 通用模块 (common-service) 创建模块 pom.xml配置 1234567891011121314151617181920212223242526272829&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;com.atguigu&lt;/groupId&gt; &lt;artifactId&gt;micro-shop&lt;/artifactId&gt; &lt;version&gt;1.0.1&lt;/version&gt; &lt;/parent&gt; &lt;artifactId&gt;common-service&lt;/artifactId&gt; &lt;!-- 打包方式默认就是jar！ --&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;17&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;17&lt;/maven.compiler.target&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!-- 声明commons-io，继承父工程版本 --&gt; &lt;dependency&gt; &lt;groupId&gt;commons-io&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 用户模块 (user-service) 创建模块 pom.xml配置 123456789101112131415161718192021222324252627282930313233&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;com.atguigu&lt;/groupId&gt; &lt;artifactId&gt;micro-shop&lt;/artifactId&gt; &lt;version&gt;1.0.1&lt;/version&gt; &lt;/parent&gt; &lt;artifactId&gt;user-service&lt;/artifactId&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;17&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;17&lt;/maven.compiler.target&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!-- 添加spring-context 自动传递 core / beans --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- 添加jackson-databind 自动传递 core / annotations --&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 订单模块 (order-service) 创建模块 pom.xml 1234567891011121314151617181920212223242526272829303132333435&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;com.atguigu&lt;/groupId&gt; &lt;artifactId&gt;micro-shop&lt;/artifactId&gt; &lt;version&gt;1.0.1&lt;/version&gt; &lt;/parent&gt; &lt;artifactId&gt;order-service&lt;/artifactId&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;17&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;17&lt;/maven.compiler.target&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!-- 继承父工程依赖版本 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- 继承父工程依赖版本 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-core&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 六、Maven核心掌握总结 核心点 掌握目标 安装 maven安装、环境变量、maven配置文件修改 工程创建 gavp属性理解、JavaSE&#x2F;EE工程创建、项目结构 依赖管理 依赖添加、依赖传递、版本提取、导入依赖错误解决 构建管理 构建过程、构建场景、构建周期等 继承和聚合 理解继承和聚合作用、继承语法和实践、聚合语法和实践","categories":[{"name":"SSM框架","slug":"SSM框架","permalink":"http://example.com/categories/SSM%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"ssm","slug":"ssm","permalink":"http://example.com/tags/ssm/"}]},{"title":"Spring6","slug":"Spring6/spring6","date":"2022-05-29T23:55:54.000Z","updated":"2023-09-28T00:38:48.115Z","comments":true,"path":"2022/05/30/Spring6/spring6/","link":"","permalink":"http://example.com/2022/05/30/Spring6/spring6/","excerpt":"","text":"Spring6 1、概述1.1、Spring是什么？Spring 是一款主流的 Java EE 轻量级开源框架 ，Spring 由“Spring 之父”Rod Johnson 提出并创立，其目的是用于简化 Java 企业级应用的开发难度和开发周期。Spring的用途不仅限于服务器端的开发。从简单性、可测试性和松耦合的角度而言，任何Java应用都可以从Spring中受益。Spring 框架除了自己提供功能外，还提供整合其他技术和框架的能力。 Spring 自诞生以来备受青睐，一直被广大开发人员作为 Java 企业级应用程序开发的首选。时至今日，Spring 俨然成为了 Java EE 代名词，成为了构建 Java EE 应用的事实标准。 自 2004 年 4 月，Spring 1.0 版本正式发布以来，Spring 已经步入到了第 6 个大版本，也就是 Spring 6。本课程采用Spring当前最新发布的正式版本6.0.2。 1.2、Spring 的狭义和广义在不同的语境中，Spring 所代表的含义是不同的。下面我们就分别从“广义”和“狭义”两个角度，对 Spring 进行介绍。 广义的 Spring：Spring 技术栈 广义上的 Spring 泛指以 Spring Framework 为核心的 Spring 技术栈。 经过十多年的发展，Spring 已经不再是一个单纯的应用框架，而是逐渐发展成为一个由多个不同子项目（模块）组成的成熟技术，例如 Spring Framework、Spring MVC、SpringBoot、Spring Cloud、Spring Data、Spring Security 等，其中 Spring Framework 是其他子项目的基础。 这些子项目涵盖了从企业级应用开发到云计算等各方面的内容，能够帮助开发人员解决软件发展过程中不断产生的各种实际问题，给开发人员带来了更好的开发体验。 狭义的 Spring：Spring Framework 狭义的 Spring 特指 Spring Framework，通常我们将它称为 Spring 框架。 Spring 框架是一个分层的、面向切面的 Java 应用程序的一站式轻量级解决方案，它是 Spring 技术栈的核心和基础，是为了解决企业级应用开发的复杂性而创建的。 Spring 有两个最核心模块： IoC 和 AOP。 IoC：Inverse of Control 的简写，译为“控制反转”，指把创建对象过程交给 Spring 进行管理。 AOP：Aspect Oriented Programming 的简写，译为“面向切面编程”。AOP 用来封装多个类的公共行为，将那些与业务无关，却为业务模块所共同调用的逻辑封装起来，减少系统的重复代码，降低模块间的耦合度。另外，AOP 还解决一些系统层面上的问题，比如日志、事务、权限等。 1.3、Spring Framework特点 非侵入式：使用 Spring Framework 开发应用程序时，Spring 对应用程序本身的结构影响非常小。对领域模型可以做到零污染；对功能性组件也只需要使用几个简单的注解进行标记，完全不会破坏原有结构，反而能将组件结构进一步简化。这就使得基于 Spring Framework 开发应用程序时结构清晰、简洁优雅。 控制反转：IoC——Inversion of Control，翻转资源获取方向。把自己创建资源、向环境索取资源变成环境将资源准备好，我们享受资源注入。 面向切面编程：AOP——Aspect Oriented Programming，在不修改源代码的基础上增强代码功能。 容器：Spring IoC 是一个容器，因为它包含并且管理组件对象的生命周期。组件享受到了容器化的管理，替程序员屏蔽了组件创建过程中的大量细节，极大的降低了使用门槛，大幅度提高了开发效率。 组件化：Spring 实现了使用简单的组件配置组合成一个复杂的应用。在 Spring 中可以使用 XML 和 Java 注解组合这些对象。这使得我们可以基于一个个功能明确、边界清晰的组件有条不紊的搭建超大型复杂应用系统。 一站式：在 IoC 和 AOP 的基础上可以整合各种企业应用的开源框架和优秀的第三方类库。而且 Spring 旗下的项目已经覆盖了广泛领域，很多方面的功能性需求可以在 Spring Framework 的基础上全部使用 Spring 来实现。 1.4、Spring模块组成官网地址：https://spring.io/ 上图中包含了 Spring 框架的所有模块，这些模块可以满足一切企业级应用开发的需求，在开发过程中可以根据需求有选择性地使用所需要的模块。下面分别对这些模块的作用进行简单介绍。 ①Spring Core（核心容器） spring core提供了IOC,DI,Bean配置装载创建的核心实现。核心概念： Beans、BeanFactory、BeanDefinitions、ApplicationContext。 spring-core ：IOC和DI的基本实现 spring-beans：BeanFactory和Bean的装配管理(BeanFactory) spring-context：Spring context上下文，即IOC容器(AppliactionContext) spring-expression：spring表达式语言 ②Spring AOP spring-aop：面向切面编程的应用模块，整合ASM，CGLib，JDK Proxy spring-aspects：集成AspectJ，AOP应用框架 spring-instrument：动态Class Loading模块 ③Spring Data Access spring-jdbc：spring对JDBC的封装，用于简化jdbc操作 spring-orm：java对象与数据库数据的映射框架 spring-oxm：对象与xml文件的映射框架 spring-jms： Spring对Java Message Service(java消息服务)的封装，用于服务之间相互通信 spring-tx：spring jdbc事务管理 ④Spring Web spring-web：最基础的web支持，建立于spring-context之上，通过servlet或listener来初始化IOC容器 spring-webmvc：实现web mvc spring-websocket：与前端的全双工通信协议 spring-webflux：Spring 5.0提供的，用于取代传统java servlet，非阻塞式Reactive Web框架，异步，非阻塞，事件驱动的服务 ⑤Spring Message Spring-messaging：spring 4.0提供的，为Spring集成一些基础的报文传送服务 ⑥Spring test spring-test：集成测试支持，主要是对junit的封装 1.5、Spring6特点1.5.1、版本要求（1）Spring6要求JDK最低版本是JDK17 1.5.2、本课程软件版本（1）IDEA开发工具：2022.1.2 （2）JDK：Java17（Spring6要求JDK最低版本是Java17） （3）Spring：6.0.2 2、入门2.1、环境要求 JDK：Java17+（Spring6要求JDK最低版本是Java17） Maven：3.6+ Spring：6.0.2 2.2、构建模块（1）构建父模块spring6 在idea中，依次单击 File -&gt; New -&gt; Project -&gt; New Project 点击“Create” 删除src目录 （2）构建子模块spring6-first 点击 Create 完成 2.3、程序开发2.3.1、引入依赖https://spring.io/projects/spring-framework#learn 添加依赖： 12345678910111213141516&lt;dependencies&gt; &lt;!--spring context依赖--&gt; &lt;!--当你引入Spring Context依赖之后，表示将Spring的基础依赖引入了--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;6.0.2&lt;/version&gt; &lt;/dependency&gt; &lt;!--junit5测试--&gt; &lt;dependency&gt; &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt; &lt;artifactId&gt;junit-jupiter-api&lt;/artifactId&gt; &lt;version&gt;5.3.1&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 查看依赖： 2.3.2、创建java类12345678package com.atguigu.spring6.bean;public class HelloWorld &#123; public void sayHello()&#123; System.out.println(&quot;helloworld&quot;); &#125;&#125; 2.3.3、创建配置文件在resources目录创建一个 Spring 配置文件 beans.xml（配置文件名称可随意命名，如：springs.xm） 123456789101112131415&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;!-- 配置HelloWorld所对应的bean，即将HelloWorld的对象交给Spring的IOC容器管理 通过bean标签配置IOC容器所管理的bean 属性： id：设置bean的唯一标识 class：设置bean所对应类型的全类名 --&gt; &lt;bean id=&quot;helloWorld&quot; class=&quot;com.atguigu.spring6.bean.HelloWorld&quot;&gt;&lt;/bean&gt; &lt;/beans&gt; 2.3.4、创建测试类测试123456789101112131415package com.atguigu.spring6.bean;import org.junit.jupiter.api.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class HelloWorldTest &#123; @Test public void testHelloWorld()&#123; ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;); HelloWorld helloworld = (HelloWorld) ac.getBean(&quot;helloWorld&quot;); helloworld.sayHello(); &#125;&#125; 2.3.5、运行测试程序 2.4、程序分析1. 底层是怎么创建对象的，是通过反射机制调用无参数构造方法吗？ 修改HelloWorld类： 123456789101112package com.atguigu.spring6.bean;public class HelloWorld &#123; public HelloWorld() &#123; System.out.println(&quot;无参数构造方法执行&quot;); &#125; public void sayHello()&#123; System.out.println(&quot;helloworld&quot;); &#125;&#125; 执行结果： 测试得知：创建对象时确实调用了无参数构造方法。 2. Spring是如何创建对象的呢？原理是什么？ 12345// dom4j解析beans.xml文件，从中获取class属性值，类的全类名 // 通过反射机制调用无参数构造方法创建对象 Class clazz = Class.forName(&quot;com.atguigu.spring6.bean.HelloWorld&quot;); //Object obj = clazz.newInstance(); Object object = clazz.getDeclaredConstructor().newInstance(); 3. 把创建好的对象存储到一个什么样的数据结构当中了呢？ bean对象最终存储在spring容器中，在spring源码底层就是一个map集合，存储bean的map在DefaultListableBeanFactory类中： 1private final Map&lt;String, BeanDefinition&gt; beanDefinitionMap = new ConcurrentHashMap&lt;&gt;(256); Spring容器加载到Bean类时 , 会把这个类的描述信息, 以包名加类名的方式存到beanDefinitionMap 中,Map&lt;String,BeanDefinition&gt; , 其中 String是Key , 默认是类名首字母小写 , BeanDefinition , 存的是类的定义(描述信息) , 我们通常叫BeanDefinition接口为 : bean的定义对象。 2.5、启用Log4j2日志框架2.5.1、Log4j2日志概述在项目开发中，日志十分的重要，不管是记录运行情况还是定位线上问题，都离不开对日志的分析。日志记录了系统行为的时间、地点、状态等相关信息，能够帮助我们了解并监控系统状态，在发生错误或者接近某种危险状态时能够及时提醒我们处理，同时在系统产生问题时，能够帮助我们快速的定位、诊断并解决问题。 Apache Log4j2是一个开源的日志记录组件，使用非常的广泛。在工程中以易用方便代替了 System.out 等打印语句，它是JAVA下最流行的日志输入工具。 Log4j2主要由几个重要的组件构成： （1）日志信息的优先级，日志信息的优先级从高到低有TRACE &lt; DEBUG &lt; INFO &lt; WARN &lt; ERROR &lt; FATAL TRACE：追踪，是最低的日志级别，相当于追踪程序的执行 DEBUG：调试，一般在开发中，都将其设置为最低的日志级别 INFO：信息，输出重要的信息，使用较多 WARN：警告，输出警告的信息 ERROR：错误，输出错误信息 FATAL：严重错误 这些级别分别用来指定这条日志信息的重要程度；级别高的会自动屏蔽级别低的日志，也就是说，设置了WARN的日志，则INFO、DEBUG的日志级别的日志不会显示 （2）日志信息的输出目的地，日志信息的输出目的地指定了日志将打印到控制台还是文件中； （3）日志信息的输出格式，而输出格式则控制了日志信息的显示内容。 2.5.2、引入Log4j2依赖1234567891011&lt;!--log4j2的依赖--&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j-core&lt;/artifactId&gt; &lt;version&gt;2.19.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j-slf4j2-impl&lt;/artifactId&gt; &lt;version&gt;2.19.0&lt;/version&gt;&lt;/dependency&gt; 2.5.3、加入日志配置文件在类的根路径下提供log4j2.xml配置文件（文件名固定为：log4j2.xml，文件必须放到类根路径下。） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;configuration&gt; &lt;loggers&gt; &lt;!-- level指定日志级别，从低到高的优先级： TRACE &lt; DEBUG &lt; INFO &lt; WARN &lt; ERROR &lt; FATAL trace：追踪，是最低的日志级别，相当于追踪程序的执行 debug：调试，一般在开发中，都将其设置为最低的日志级别 info：信息，输出重要的信息，使用较多 warn：警告，输出警告的信息 error：错误，输出错误信息 fatal：严重错误 --&gt; &lt;root level=&quot;DEBUG&quot;&gt; &lt;appender-ref ref=&quot;spring6log&quot;/&gt; &lt;appender-ref ref=&quot;RollingFile&quot;/&gt; &lt;appender-ref ref=&quot;log&quot;/&gt; &lt;/root&gt; &lt;/loggers&gt; &lt;appenders&gt; &lt;!--输出日志信息到控制台--&gt; &lt;console name=&quot;spring6log&quot; target=&quot;SYSTEM_OUT&quot;&gt; &lt;!--控制日志输出的格式--&gt; &lt;PatternLayout pattern=&quot;%d&#123;yyyy-MM-dd HH:mm:ss SSS&#125; [%t] %-3level %logger&#123;1024&#125; - %msg%n&quot;/&gt; &lt;/console&gt; &lt;!--文件会打印出所有信息，这个log每次运行程序会自动清空，由append属性决定，适合临时测试用--&gt; &lt;File name=&quot;log&quot; fileName=&quot;d:/spring6_log/test.log&quot; append=&quot;false&quot;&gt; &lt;PatternLayout pattern=&quot;%d&#123;HH:mm:ss.SSS&#125; %-5level %class&#123;36&#125; %L %M - %msg%xEx%n&quot;/&gt; &lt;/File&gt; &lt;!-- 这个会打印出所有的信息， 每次大小超过size， 则这size大小的日志会自动存入按年份-月份建立的文件夹下面并进行压缩， 作为存档--&gt; &lt;RollingFile name=&quot;RollingFile&quot; fileName=&quot;d:/spring6_log/app.log&quot; filePattern=&quot;log/$$&#123;date:yyyy-MM&#125;/app-%d&#123;MM-dd-yyyy&#125;-%i.log.gz&quot;&gt; &lt;PatternLayout pattern=&quot;%d&#123;yyyy-MM-dd &#x27;at&#x27; HH:mm:ss z&#125; %-5level %class&#123;36&#125; %L %M - %msg%xEx%n&quot;/&gt; &lt;SizeBasedTriggeringPolicy size=&quot;50MB&quot;/&gt; &lt;!-- DefaultRolloverStrategy属性如不设置， 则默认为最多同一文件夹下7个文件，这里设置了20 --&gt; &lt;DefaultRolloverStrategy max=&quot;20&quot;/&gt; &lt;/RollingFile&gt; &lt;/appenders&gt;&lt;/configuration&gt; 2.5.4、测试运行原测试程序 运行原测试程序，多了spring打印日志 2.5.5、使用日志123456789101112public class HelloWorldTest &#123; private Logger logger = LoggerFactory.getLogger(HelloWorldTest.class); @Test public void testHelloWorld()&#123; ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;); HelloWorld helloworld = (HelloWorld) ac.getBean(&quot;helloWorld&quot;); helloworld.sayHello(); logger.info(&quot;执行成功&quot;); &#125;&#125; 控制台： 3、容器：IoCIoC 是 Inversion of Control 的简写，译为“控制反转”，它不是一门技术，而是一种设计思想，是一个重要的面向对象编程法则，能够指导我们如何设计出松耦合、更优良的程序。 Spring 通过 IoC 容器来管理所有 Java 对象的实例化和初始化，控制对象与对象之间的依赖关系。我们将由 IoC 容器管理的 Java 对象称为 Spring Bean，它与使用关键字 new 创建的 Java 对象没有任何区别。 IoC 容器是 Spring 框架中最重要的核心组件之一，它贯穿了 Spring 从诞生到成长的整个过程。 3.1、IoC容器3.1.1、控制反转（IoC） 控制反转是一种思想。 控制反转是为了降低程序耦合度，提高程序扩展力。 控制反转，反转的是什么？ 将对象的创建权利交出去，交给第三方容器负责。 将对象和对象之间关系的维护权交出去，交给第三方容器负责。 控制反转这种思想如何实现呢？ DI（Dependency Injection）：依赖注入 3.1.2、依赖注入DI（Dependency Injection）：依赖注入，依赖注入实现了控制反转的思想。 依赖注入： 指Spring创建对象的过程中，将对象依赖属性通过配置进行注入 依赖注入常见的实现方式包括两种： 第一种：set注入 第二种：构造注入 所以结论是：IOC 就是一种控制反转的思想， 而 DI 是对IoC的一种具体实现。 Bean管理说的是：Bean对象的创建，以及Bean对象中属性的赋值（或者叫做Bean对象之间关系的维护）。 3.1.3、IoC容器在Spring的实现Spring 的 IoC 容器就是 IoC思想的一个落地的产品实现。IoC容器中管理的组件也叫做 bean。在创建 bean 之前，首先需要创建IoC 容器。Spring 提供了IoC 容器的两种实现方式： ①BeanFactory 这是 IoC 容器的基本实现，是 Spring 内部使用的接口。面向 Spring 本身，不提供给开发人员使用。 ②ApplicationContext BeanFactory 的子接口，提供了更多高级特性。面向 Spring 的使用者，几乎所有场合都使用 ApplicationContext 而不是底层的 BeanFactory。 ③ApplicationContext的主要实现类 类型名 简介 ClassPathXmlApplicationContext 通过读取类路径下的 XML 格式的配置文件创建 IOC 容器对象 FileSystemXmlApplicationContext 通过文件系统路径读取 XML 格式的配置文件创建 IOC 容器对象 ConfigurableApplicationContext ApplicationContext 的子接口，包含一些扩展方法 refresh() 和 close() ，让 ApplicationContext 具有启动、关闭和刷新上下文的能力。 WebApplicationContext 专门为 Web 应用准备，基于 Web 环境创建 IOC 容器对象，并将对象引入存入 ServletContext 域中。 3.2、基于XML管理Bean3.2.1、搭建子模块spring6-ioc-xml①搭建模块 搭建方式如：spring-first ②引入配置文件 引入spring-first模块配置文件：beans.xml、log4j2.xml ③添加依赖 12345678910111213141516171819202122232425262728&lt;dependencies&gt; &lt;!--spring context依赖--&gt; &lt;!--当你引入Spring Context依赖之后，表示将Spring的基础依赖引入了--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;6.0.3&lt;/version&gt; &lt;/dependency&gt; &lt;!--junit5测试--&gt; &lt;dependency&gt; &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt; &lt;artifactId&gt;junit-jupiter-api&lt;/artifactId&gt; &lt;version&gt;5.3.1&lt;/version&gt; &lt;/dependency&gt; &lt;!--log4j2的依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j-core&lt;/artifactId&gt; &lt;version&gt;2.19.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j-slf4j2-impl&lt;/artifactId&gt; &lt;version&gt;2.19.0&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; ④引入java类 引入spring-first模块java及test目录下实体类 12345678910111213package com.atguigu.spring6.bean;public class HelloWorld &#123; public HelloWorld() &#123; System.out.println(&quot;无参数构造方法执行&quot;); &#125; public void sayHello()&#123; System.out.println(&quot;helloworld&quot;); &#125;&#125; 1234567891011121314151617package com.atguigu.spring6.bean;import org.junit.jupiter.api.Test;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class HelloWorldTest &#123; private Logger logger = LoggerFactory.getLogger(HelloWorldTest.class); @Test public void testHelloWorld()&#123; &#125;&#125; 3.2.2、实验一：获取bean①方式一：根据id获取由于 id 属性指定了 bean 的唯一标识，所以根据 bean 标签的 id 属性可以精确获取到一个组件对象。上个实验中我们使用的就是这种方式。 ②方式二：根据类型获取123456@Testpublic void testHelloWorld1()&#123; ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;); HelloWorld bean = ac.getBean(HelloWorld.class); bean.sayHello();&#125; ③方式三：根据id和类型123456@Testpublic void testHelloWorld2()&#123; ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;); HelloWorld bean = ac.getBean(&quot;helloworld&quot;, HelloWorld.class); bean.sayHello();&#125; ④注意的地方当根据类型获取bean时，要求IOC容器中指定类型的bean有且只能有一个 当IOC容器中一共配置了两个： 12&lt;bean id=&quot;helloworldOne&quot; class=&quot;com.atguigu.spring6.bean.HelloWorld&quot;&gt;&lt;/bean&gt;&lt;bean id=&quot;helloworldTwo&quot; class=&quot;com.atguigu.spring6.bean.HelloWorld&quot;&gt;&lt;/bean&gt; 根据类型获取时会抛出异常： org.springframework.beans.factory.NoUniqueBeanDefinitionException: No qualifying bean of type ‘com.atguigu.spring6.bean.HelloWorld’ available: expected single matching bean but found 2: helloworldOne,helloworldTwo ⑤扩展知识如果组件类实现了接口，根据接口类型可以获取 bean 吗？ 可以，前提是bean唯一 如果一个接口有多个实现类，这些实现类都配置了 bean，根据接口类型可以获取 bean 吗？ 不行，因为bean不唯一 结论 根据类型来获取bean时，在满足bean唯一性的前提下，其实只是看：『对象 instanceof 指定的类型』的返回结果，只要返回的是true就可以认定为和类型匹配，能够获取到。 java中，instanceof运算符用于判断前面的对象是否是后面的类，或其子类、实现类的实例。如果是返回true，否则返回false。也就是说：用instanceof关键字做判断时， instanceof 操作符的左右操作必须有继承或实现关系 3.2.3、实验二：依赖注入之setter注入①创建学生类Student 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758package com.atguigu.spring6.bean;public class Student &#123; private Integer id; private String name; private Integer age; private String sex; public Student() &#123; &#125; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Integer getAge() &#123; return age; &#125; public void setAge(Integer age) &#123; this.age = age; &#125; public String getSex() &#123; return sex; &#125; public void setSex(String sex) &#123; this.sex = sex; &#125; @Override public String toString() &#123; return &quot;Student&#123;&quot; + &quot;id=&quot; + id + &quot;, name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, age=&quot; + age + &quot;, sex=&#x27;&quot; + sex + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125;&#125; ②配置bean时为属性赋值 spring-di.xml 123456789&lt;bean id=&quot;studentOne&quot; class=&quot;com.atguigu.spring6.bean.Student&quot;&gt; &lt;!-- property标签：通过组件类的setXxx()方法给组件对象设置属性 --&gt; &lt;!-- name属性：指定属性名（这个属性名是getXxx()、setXxx()方法定义的，和成员变量无关） --&gt; &lt;!-- value属性：指定属性值 --&gt; &lt;property name=&quot;id&quot; value=&quot;1001&quot;&gt;&lt;/property&gt; &lt;property name=&quot;name&quot; value=&quot;张三&quot;&gt;&lt;/property&gt; &lt;property name=&quot;age&quot; value=&quot;23&quot;&gt;&lt;/property&gt; &lt;property name=&quot;sex&quot; value=&quot;男&quot;&gt;&lt;/property&gt;&lt;/bean&gt; ③测试 123456@Testpublic void testDIBySet()&#123; ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;spring-di.xml&quot;); Student studentOne = ac.getBean(&quot;studentOne&quot;, Student.class); System.out.println(studentOne);&#125; 3.2.4、实验三：依赖注入之构造器注入①在Student类中添加有参构造 123456public Student(Integer id, String name, Integer age, String sex) &#123; this.id = id; this.name = name; this.age = age; this.sex = sex;&#125; ②配置bean spring-di.xml 123456&lt;bean id=&quot;studentTwo&quot; class=&quot;com.atguigu.spring6.bean.Student&quot;&gt; &lt;constructor-arg value=&quot;1002&quot;&gt;&lt;/constructor-arg&gt; &lt;constructor-arg value=&quot;李四&quot;&gt;&lt;/constructor-arg&gt; &lt;constructor-arg value=&quot;33&quot;&gt;&lt;/constructor-arg&gt; &lt;constructor-arg value=&quot;女&quot;&gt;&lt;/constructor-arg&gt;&lt;/bean&gt; 注意： constructor-arg标签还有两个属性可以进一步描述构造器参数： index属性：指定参数所在位置的索引（从0开始） name属性：指定参数名 ③测试 123456@Testpublic void testDIByConstructor()&#123; ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;spring-di.xml&quot;); Student studentOne = ac.getBean(&quot;studentTwo&quot;, Student.class); System.out.println(studentOne);&#125; 3.2.5、实验四：特殊值处理①字面量赋值 什么是字面量？ int a &#x3D; 10; 声明一个变量a，初始化为10，此时a就不代表字母a了，而是作为一个变量的名字。当我们引用a的时候，我们实际上拿到的值是10。 而如果a是带引号的：’a’，那么它现在不是一个变量，它就是代表a这个字母本身，这就是字面量。所以字面量没有引申含义，就是我们看到的这个数据本身。 12&lt;!-- 使用value属性给bean的属性赋值时，Spring会把value属性的值看做字面量 --&gt;&lt;property name=&quot;name&quot; value=&quot;张三&quot;/&gt; ②null值123&lt;property name=&quot;name&quot;&gt; &lt;null /&gt;&lt;/property&gt; 注意： 1&lt;property name=&quot;name&quot; value=&quot;null&quot;&gt;&lt;/property&gt; 以上写法，为name所赋的值是字符串null ③xml实体123&lt;!-- 小于号在XML文档中用来定义标签的开始，不能随便使用 --&gt;&lt;!-- 解决方案一：使用XML实体来代替 --&gt;&lt;property name=&quot;expression&quot; value=&quot;a &amp;lt; b&quot;/&gt; ④CDATA节1234567&lt;property name=&quot;expression&quot;&gt; &lt;!-- 解决方案二：使用CDATA节 --&gt; &lt;!-- CDATA中的C代表Character，是文本、字符的含义，CDATA就表示纯文本数据 --&gt; &lt;!-- XML解析器看到CDATA节就知道这里是纯文本，就不会当作XML标签或属性来解析 --&gt; &lt;!-- 所以CDATA节中写什么符号都随意 --&gt; &lt;value&gt;&lt;![CDATA[a &lt; b]]&gt;&lt;/value&gt;&lt;/property&gt; 3.2.6、实验五：为对象类型属性赋值①创建班级类Clazz 12345678910111213141516171819202122232425262728293031323334353637383940package com.atguigu.spring6.bean public class Clazz &#123; private Integer clazzId; private String clazzName; public Integer getClazzId() &#123; return clazzId; &#125; public void setClazzId(Integer clazzId) &#123; this.clazzId = clazzId; &#125; public String getClazzName() &#123; return clazzName; &#125; public void setClazzName(String clazzName) &#123; this.clazzName = clazzName; &#125; @Override public String toString() &#123; return &quot;Clazz&#123;&quot; + &quot;clazzId=&quot; + clazzId + &quot;, clazzName=&#x27;&quot; + clazzName + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125; public Clazz() &#123; &#125; public Clazz(Integer clazzId, String clazzName) &#123; this.clazzId = clazzId; this.clazzName = clazzName; &#125;&#125; ②修改Student类 在Student类中添加以下代码： 123456789private Clazz clazz;public Clazz getClazz() &#123; return clazz;&#125;public void setClazz(Clazz clazz) &#123; this.clazz = clazz;&#125; 方式一：引用外部bean配置Clazz类型的bean： 1234&lt;bean id=&quot;clazzOne&quot; class=&quot;com.atguigu.spring6.bean.Clazz&quot;&gt; &lt;property name=&quot;clazzId&quot; value=&quot;1111&quot;&gt;&lt;/property&gt; &lt;property name=&quot;clazzName&quot; value=&quot;财源滚滚班&quot;&gt;&lt;/property&gt;&lt;/bean&gt; 为Student中的clazz属性赋值： 12345678&lt;bean id=&quot;studentFour&quot; class=&quot;com.atguigu.spring6.bean.Student&quot;&gt; &lt;property name=&quot;id&quot; value=&quot;1004&quot;&gt;&lt;/property&gt; &lt;property name=&quot;name&quot; value=&quot;赵六&quot;&gt;&lt;/property&gt; &lt;property name=&quot;age&quot; value=&quot;26&quot;&gt;&lt;/property&gt; &lt;property name=&quot;sex&quot; value=&quot;女&quot;&gt;&lt;/property&gt; &lt;!-- ref属性：引用IOC容器中某个bean的id，将所对应的bean为属性赋值 --&gt; &lt;property name=&quot;clazz&quot; ref=&quot;clazzOne&quot;&gt;&lt;/property&gt;&lt;/bean&gt; 错误演示： 1234567&lt;bean id=&quot;studentFour&quot; class=&quot;com.atguigu.spring6.bean.Student&quot;&gt; &lt;property name=&quot;id&quot; value=&quot;1004&quot;&gt;&lt;/property&gt; &lt;property name=&quot;name&quot; value=&quot;赵六&quot;&gt;&lt;/property&gt; &lt;property name=&quot;age&quot; value=&quot;26&quot;&gt;&lt;/property&gt; &lt;property name=&quot;sex&quot; value=&quot;女&quot;&gt;&lt;/property&gt; &lt;property name=&quot;clazz&quot; value=&quot;clazzOne&quot;&gt;&lt;/property&gt;&lt;/bean&gt; 如果错把ref属性写成了value属性，会抛出异常： Caused by: java.lang.IllegalStateException: Cannot convert value of type ‘java.lang.String’ to required type ‘com.atguigu.spring6.bean.Clazz’ for property ‘clazz’: no matching editors or conversion strategy found 意思是不能把String类型转换成我们要的Clazz类型，说明我们使用value属性时，Spring只把这个属性看做一个普通的字符串，不会认为这是一个bean的id，更不会根据它去找到bean来赋值 方式二：内部bean1234567891011121314&lt;bean id=&quot;studentFour&quot; class=&quot;com.atguigu.spring6.bean.Student&quot;&gt; &lt;property name=&quot;id&quot; value=&quot;1004&quot;&gt;&lt;/property&gt; &lt;property name=&quot;name&quot; value=&quot;赵六&quot;&gt;&lt;/property&gt; &lt;property name=&quot;age&quot; value=&quot;26&quot;&gt;&lt;/property&gt; &lt;property name=&quot;sex&quot; value=&quot;女&quot;&gt;&lt;/property&gt; &lt;property name=&quot;clazz&quot;&gt; &lt;!-- 在一个bean中再声明一个bean就是内部bean --&gt; &lt;!-- 内部bean只能用于给属性赋值，不能在外部通过IOC容器获取，因此可以省略id属性 --&gt; &lt;bean id=&quot;clazzInner&quot; class=&quot;com.atguigu.spring6.bean.Clazz&quot;&gt; &lt;property name=&quot;clazzId&quot; value=&quot;2222&quot;&gt;&lt;/property&gt; &lt;property name=&quot;clazzName&quot; value=&quot;远大前程班&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;/property&gt;&lt;/bean&gt; 方式三：级联属性赋值123456789&lt;bean id=&quot;studentFour&quot; class=&quot;com.atguigu.spring6.bean.Student&quot;&gt; &lt;property name=&quot;id&quot; value=&quot;1004&quot;&gt;&lt;/property&gt; &lt;property name=&quot;name&quot; value=&quot;赵六&quot;&gt;&lt;/property&gt; &lt;property name=&quot;age&quot; value=&quot;26&quot;&gt;&lt;/property&gt; &lt;property name=&quot;sex&quot; value=&quot;女&quot;&gt;&lt;/property&gt; &lt;property name=&quot;clazz&quot; ref=&quot;clazzOne&quot;&gt;&lt;/property&gt; &lt;property name=&quot;clazz.clazzId&quot; value=&quot;3333&quot;&gt;&lt;/property&gt; &lt;property name=&quot;clazz.clazzName&quot; value=&quot;最强王者班&quot;&gt;&lt;/property&gt;&lt;/bean&gt; 3.2.7、实验六：为数组类型属性赋值①修改Student类 在Student类中添加以下代码： 123456789private String[] hobbies;public String[] getHobbies() &#123; return hobbies;&#125;public void setHobbies(String[] hobbies) &#123; this.hobbies = hobbies;&#125; ②配置bean 123456789101112131415&lt;bean id=&quot;studentFour&quot; class=&quot;com.atguigu.spring.bean6.Student&quot;&gt; &lt;property name=&quot;id&quot; value=&quot;1004&quot;&gt;&lt;/property&gt; &lt;property name=&quot;name&quot; value=&quot;赵六&quot;&gt;&lt;/property&gt; &lt;property name=&quot;age&quot; value=&quot;26&quot;&gt;&lt;/property&gt; &lt;property name=&quot;sex&quot; value=&quot;女&quot;&gt;&lt;/property&gt; &lt;!-- ref属性：引用IOC容器中某个bean的id，将所对应的bean为属性赋值 --&gt; &lt;property name=&quot;clazz&quot; ref=&quot;clazzOne&quot;&gt;&lt;/property&gt; &lt;property name=&quot;hobbies&quot;&gt; &lt;array&gt; &lt;value&gt;抽烟&lt;/value&gt; &lt;value&gt;喝酒&lt;/value&gt; &lt;value&gt;烫头&lt;/value&gt; &lt;/array&gt; &lt;/property&gt;&lt;/bean&gt; 3.2.8、实验七：为集合类型属性赋值①为List集合类型属性赋值在Clazz类中添加以下代码： 123456789private List&lt;Student&gt; students;public List&lt;Student&gt; getStudents() &#123; return students;&#125;public void setStudents(List&lt;Student&gt; students) &#123; this.students = students;&#125; 配置bean： 1234567891011&lt;bean id=&quot;clazzTwo&quot; class=&quot;com.atguigu.spring6.bean.Clazz&quot;&gt; &lt;property name=&quot;clazzId&quot; value=&quot;4444&quot;&gt;&lt;/property&gt; &lt;property name=&quot;clazzName&quot; value=&quot;Javaee0222&quot;&gt;&lt;/property&gt; &lt;property name=&quot;students&quot;&gt; &lt;list&gt; &lt;ref bean=&quot;studentOne&quot;&gt;&lt;/ref&gt; &lt;ref bean=&quot;studentTwo&quot;&gt;&lt;/ref&gt; &lt;ref bean=&quot;studentThree&quot;&gt;&lt;/ref&gt; &lt;/list&gt; &lt;/property&gt;&lt;/bean&gt; 若为Set集合类型属性赋值，只需要将其中的list标签改为set标签即可 ②为Map集合类型属性赋值创建教师类Teacher： 12345678910111213141516171819202122232425262728293031323334353637383940package com.atguigu.spring6.bean;public class Teacher &#123; private Integer teacherId; private String teacherName; public Integer getTeacherId() &#123; return teacherId; &#125; public void setTeacherId(Integer teacherId) &#123; this.teacherId = teacherId; &#125; public String getTeacherName() &#123; return teacherName; &#125; public void setTeacherName(String teacherName) &#123; this.teacherName = teacherName; &#125; public Teacher(Integer teacherId, String teacherName) &#123; this.teacherId = teacherId; this.teacherName = teacherName; &#125; public Teacher() &#123; &#125; @Override public String toString() &#123; return &quot;Teacher&#123;&quot; + &quot;teacherId=&quot; + teacherId + &quot;, teacherName=&#x27;&quot; + teacherName + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125;&#125; 在Student类中添加以下代码： 123456789private Map&lt;String, Teacher&gt; teacherMap;public Map&lt;String, Teacher&gt; getTeacherMap() &#123; return teacherMap;&#125;public void setTeacherMap(Map&lt;String, Teacher&gt; teacherMap) &#123; this.teacherMap = teacherMap;&#125; 配置bean： 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;bean id=&quot;teacherOne&quot; class=&quot;com.atguigu.spring6.bean.Teacher&quot;&gt; &lt;property name=&quot;teacherId&quot; value=&quot;10010&quot;&gt;&lt;/property&gt; &lt;property name=&quot;teacherName&quot; value=&quot;大宝&quot;&gt;&lt;/property&gt;&lt;/bean&gt;&lt;bean id=&quot;teacherTwo&quot; class=&quot;com.atguigu.spring6.bean.Teacher&quot;&gt; &lt;property name=&quot;teacherId&quot; value=&quot;10086&quot;&gt;&lt;/property&gt; &lt;property name=&quot;teacherName&quot; value=&quot;二宝&quot;&gt;&lt;/property&gt;&lt;/bean&gt;&lt;bean id=&quot;studentFour&quot; class=&quot;com.atguigu.spring6.bean.Student&quot;&gt; &lt;property name=&quot;id&quot; value=&quot;1004&quot;&gt;&lt;/property&gt; &lt;property name=&quot;name&quot; value=&quot;赵六&quot;&gt;&lt;/property&gt; &lt;property name=&quot;age&quot; value=&quot;26&quot;&gt;&lt;/property&gt; &lt;property name=&quot;sex&quot; value=&quot;女&quot;&gt;&lt;/property&gt; &lt;!-- ref属性：引用IOC容器中某个bean的id，将所对应的bean为属性赋值 --&gt; &lt;property name=&quot;clazz&quot; ref=&quot;clazzOne&quot;&gt;&lt;/property&gt; &lt;property name=&quot;hobbies&quot;&gt; &lt;array&gt; &lt;value&gt;抽烟&lt;/value&gt; &lt;value&gt;喝酒&lt;/value&gt; &lt;value&gt;烫头&lt;/value&gt; &lt;/array&gt; &lt;/property&gt; &lt;property name=&quot;teacherMap&quot;&gt; &lt;map&gt; &lt;entry&gt; &lt;key&gt; &lt;value&gt;10010&lt;/value&gt; &lt;/key&gt; &lt;ref bean=&quot;teacherOne&quot;&gt;&lt;/ref&gt; &lt;/entry&gt; &lt;entry&gt; &lt;key&gt; &lt;value&gt;10086&lt;/value&gt; &lt;/key&gt; &lt;ref bean=&quot;teacherTwo&quot;&gt;&lt;/ref&gt; &lt;/entry&gt; &lt;/map&gt; &lt;/property&gt;&lt;/bean&gt; ③引用集合类型的bean123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!--list集合类型的bean--&gt;&lt;util:list id=&quot;students&quot;&gt; &lt;ref bean=&quot;studentOne&quot;&gt;&lt;/ref&gt; &lt;ref bean=&quot;studentTwo&quot;&gt;&lt;/ref&gt; &lt;ref bean=&quot;studentThree&quot;&gt;&lt;/ref&gt;&lt;/util:list&gt;&lt;!--map集合类型的bean--&gt;&lt;util:map id=&quot;teacherMap&quot;&gt; &lt;entry&gt; &lt;key&gt; &lt;value&gt;10010&lt;/value&gt; &lt;/key&gt; &lt;ref bean=&quot;teacherOne&quot;&gt;&lt;/ref&gt; &lt;/entry&gt; &lt;entry&gt; &lt;key&gt; &lt;value&gt;10086&lt;/value&gt; &lt;/key&gt; &lt;ref bean=&quot;teacherTwo&quot;&gt;&lt;/ref&gt; &lt;/entry&gt;&lt;/util:map&gt;&lt;bean id=&quot;clazzTwo&quot; class=&quot;com.atguigu.spring6.bean.Clazz&quot;&gt; &lt;property name=&quot;clazzId&quot; value=&quot;4444&quot;&gt;&lt;/property&gt; &lt;property name=&quot;clazzName&quot; value=&quot;Javaee0222&quot;&gt;&lt;/property&gt; &lt;property name=&quot;students&quot; ref=&quot;students&quot;&gt;&lt;/property&gt;&lt;/bean&gt;&lt;bean id=&quot;studentFour&quot; class=&quot;com.atguigu.spring6.bean.Student&quot;&gt; &lt;property name=&quot;id&quot; value=&quot;1004&quot;&gt;&lt;/property&gt; &lt;property name=&quot;name&quot; value=&quot;赵六&quot;&gt;&lt;/property&gt; &lt;property name=&quot;age&quot; value=&quot;26&quot;&gt;&lt;/property&gt; &lt;property name=&quot;sex&quot; value=&quot;女&quot;&gt;&lt;/property&gt; &lt;!-- ref属性：引用IOC容器中某个bean的id，将所对应的bean为属性赋值 --&gt; &lt;property name=&quot;clazz&quot; ref=&quot;clazzOne&quot;&gt;&lt;/property&gt; &lt;property name=&quot;hobbies&quot;&gt; &lt;array&gt; &lt;value&gt;抽烟&lt;/value&gt; &lt;value&gt;喝酒&lt;/value&gt; &lt;value&gt;烫头&lt;/value&gt; &lt;/array&gt; &lt;/property&gt; &lt;property name=&quot;teacherMap&quot; ref=&quot;teacherMap&quot;&gt;&lt;/property&gt;&lt;/bean&gt; 使用util:list、util:map标签必须引入相应的命名空间 12345678&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:util=&quot;http://www.springframework.org/schema/util&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util.xsd http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; 3.2.9、实验八：p命名空间引入p命名空间 123456789&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:util=&quot;http://www.springframework.org/schema/util&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util.xsd http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; 引入p命名空间后，可以通过以下方式为bean的各个属性赋值 12&lt;bean id=&quot;studentSix&quot; class=&quot;com.atguigu.spring6.bean.Student&quot; p:id=&quot;1006&quot; p:name=&quot;小明&quot; p:clazz-ref=&quot;clazzOne&quot; p:teacherMap-ref=&quot;teacherMap&quot;&gt;&lt;/bean&gt; 3.2.10、实验九：引入外部属性文件①加入依赖 12345678910111213 &lt;!-- MySQL驱动 --&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.30&lt;/version&gt;&lt;/dependency&gt;&lt;!-- 数据源 --&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.2.15&lt;/version&gt;&lt;/dependency&gt; ②创建外部属性文件 1234jdbc.user=rootjdbc.password=atguigujdbc.url=jdbc:mysql://localhost:3306/ssm?serverTimezone=UTCjdbc.driver=com.mysql.cj.jdbc.Driver ③引入属性文件 引入context 名称空间 12345678910&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;&lt;/beans&gt; 12&lt;!-- 引入外部属性文件 --&gt;&lt;context:property-placeholder location=&quot;classpath:jdbc.properties&quot;/&gt; 注意：在使用 context:property-placeholder 元素加载外包配置文件功能前，首先需要在 XML 配置的一级标签 中添加 context 相关的约束。 ④配置bean 123456&lt;bean id=&quot;druidDataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot;/&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;$&#123;jdbc.driver&#125;&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.user&#125;&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;/&gt;&lt;/bean&gt; ⑤测试 1234567@Testpublic void testDataSource() throws SQLException &#123; ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;spring-datasource.xml&quot;); DataSource dataSource = ac.getBean(DataSource.class); Connection connection = dataSource.getConnection(); System.out.println(connection);&#125; 3.2.11、实验十：bean的作用域①概念 在Spring中可以通过配置bean标签的scope属性来指定bean的作用域范围，各取值含义参加下表： 取值 含义 创建对象的时机 singleton（默认） 在IOC容器中，这个bean的对象始终为单实例 IOC容器初始化时 prototype 这个bean在IOC容器中有多个实例 获取bean时 如果是在WebApplicationContext环境下还会有另外几个作用域（但不常用）： 取值 含义 request 在一个请求范围内有效 session 在一个会话范围内有效 ②创建类User 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263package com.atguigu.spring6.bean;public class User &#123; private Integer id; private String username; private String password; private Integer age; public User() &#123; &#125; public User(Integer id, String username, String password, Integer age) &#123; this.id = id; this.username = username; this.password = password; this.age = age; &#125; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; public Integer getAge() &#123; return age; &#125; public void setAge(Integer age) &#123; this.age = age; &#125; @Override public String toString() &#123; return &quot;User&#123;&quot; + &quot;id=&quot; + id + &quot;, username=&#x27;&quot; + username + &#x27;\\&#x27;&#x27; + &quot;, password=&#x27;&quot; + password + &#x27;\\&#x27;&#x27; + &quot;, age=&quot; + age + &#x27;&#125;&#x27;; &#125;&#125; ③配置bean 123&lt;!-- scope属性：取值singleton（默认值），bean在IOC容器中只有一个实例，IOC容器初始化时创建对象 --&gt;&lt;!-- scope属性：取值prototype，bean在IOC容器中可以有多个实例，getBean()时创建对象 --&gt;&lt;bean class=&quot;com.atguigu.spring6.bean.User&quot; scope=&quot;prototype&quot;&gt;&lt;/bean&gt; ④测试 1234567@Testpublic void testBeanScope()&#123; ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;spring-scope.xml&quot;); User user1 = ac.getBean(User.class); User user2 = ac.getBean(User.class); System.out.println(user1==user2);&#125; 3.2.12、实验十一：bean生命周期①具体的生命周期过程 bean对象创建（调用无参构造器） 给bean对象设置属性 bean的后置处理器（初始化之前） bean对象初始化（需在配置bean时指定初始化方法） bean的后置处理器（初始化之后） bean对象就绪可以使用 bean对象销毁（需在配置bean时指定销毁方法） IOC容器关闭 ②修改类User 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172public class User &#123; private Integer id; private String username; private String password; private Integer age; public User() &#123; System.out.println(&quot;生命周期：1、创建对象&quot;); &#125; public User(Integer id, String username, String password, Integer age) &#123; this.id = id; this.username = username; this.password = password; this.age = age; &#125; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; System.out.println(&quot;生命周期：2、依赖注入&quot;); this.id = id; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; public Integer getAge() &#123; return age; &#125; public void setAge(Integer age) &#123; this.age = age; &#125; public void initMethod()&#123; System.out.println(&quot;生命周期：3、初始化&quot;); &#125; public void destroyMethod()&#123; System.out.println(&quot;生命周期：5、销毁&quot;); &#125; @Override public String toString() &#123; return &quot;User&#123;&quot; + &quot;id=&quot; + id + &quot;, username=&#x27;&quot; + username + &#x27;\\&#x27;&#x27; + &quot;, password=&#x27;&quot; + password + &#x27;\\&#x27;&#x27; + &quot;, age=&quot; + age + &#x27;&#125;&#x27;; &#125;&#125; 注意其中的initMethod()和destroyMethod()，可以通过配置bean指定为初始化和销毁的方法 ③配置bean 12345678&lt;!-- 使用init-method属性指定初始化方法 --&gt;&lt;!-- 使用destroy-method属性指定销毁方法 --&gt;&lt;bean class=&quot;com.atguigu.spring6.bean.User&quot; scope=&quot;prototype&quot; init-method=&quot;initMethod&quot; destroy-method=&quot;destroyMethod&quot;&gt; &lt;property name=&quot;id&quot; value=&quot;1001&quot;&gt;&lt;/property&gt; &lt;property name=&quot;username&quot; value=&quot;admin&quot;&gt;&lt;/property&gt; &lt;property name=&quot;password&quot; value=&quot;123456&quot;&gt;&lt;/property&gt; &lt;property name=&quot;age&quot; value=&quot;23&quot;&gt;&lt;/property&gt;&lt;/bean&gt; ④测试 1234567@Testpublic void testLife()&#123; ClassPathXmlApplicationContext ac = new ClassPathXmlApplicationContext(&quot;spring-lifecycle.xml&quot;); User bean = ac.getBean(User.class); System.out.println(&quot;生命周期：4、通过IOC容器获取bean并使用&quot;); ac.close();&#125; ⑤bean的后置处理器 bean的后置处理器会在生命周期的初始化前后添加额外的操作，需要实现BeanPostProcessor接口，且配置到IOC容器中，需要注意的是，bean后置处理器不是单独针对某一个bean生效，而是针对IOC容器中所有bean都会执行 创建bean的后置处理器： 12345678910111213141516171819package com.atguigu.spring6.process; import org.springframework.beans.BeansException;import org.springframework.beans.factory.config.BeanPostProcessor;public class MyBeanProcessor implements BeanPostProcessor &#123; @Override public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException &#123; System.out.println(&quot;☆☆☆&quot; + beanName + &quot; = &quot; + bean); return bean; &#125; @Override public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException &#123; System.out.println(&quot;★★★&quot; + beanName + &quot; = &quot; + bean); return bean; &#125;&#125; 在IOC容器中配置后置处理器： 12&lt;!-- bean的后置处理器要放入IOC容器才能生效 --&gt;&lt;bean id=&quot;myBeanProcessor&quot; class=&quot;com.atguigu.spring6.process.MyBeanProcessor&quot;/&gt; 3.2.13、实验十二：FactoryBean①简介 FactoryBean是Spring提供的一种整合第三方框架的常用机制。和普通的bean不同，配置一个FactoryBean类型的bean，在获取bean的时候得到的并不是class属性中配置的这个类的对象，而是getObject()方法的返回值。通过这种机制，Spring可以帮我们把复杂组件创建的详细过程和繁琐细节都屏蔽起来，只把最简洁的使用界面展示给我们。 将来我们整合Mybatis时，Spring就是通过FactoryBean机制来帮我们创建SqlSessionFactory对象的。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146/* * Copyright 2002-2020 the original author or authors. * * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * https://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.springframework.beans.factory;import org.springframework.lang.Nullable;/** * Interface to be implemented by objects used within a &#123;@link BeanFactory&#125; which * are themselves factories for individual objects. If a bean implements this * interface, it is used as a factory for an object to expose, not directly as a * bean instance that will be exposed itself. * * &lt;p&gt;&lt;b&gt;NB: A bean that implements this interface cannot be used as a normal bean.&lt;/b&gt; * A FactoryBean is defined in a bean style, but the object exposed for bean * references (&#123;@link #getObject()&#125;) is always the object that it creates. * * &lt;p&gt;FactoryBeans can support singletons and prototypes, and can either create * objects lazily on demand or eagerly on startup. The &#123;@link SmartFactoryBean&#125; * interface allows for exposing more fine-grained behavioral metadata. * * &lt;p&gt;This interface is heavily used within the framework itself, for example for * the AOP &#123;@link org.springframework.aop.framework.ProxyFactoryBean&#125; or the * &#123;@link org.springframework.jndi.JndiObjectFactoryBean&#125;. It can be used for * custom components as well; however, this is only common for infrastructure code. * * &lt;p&gt;&lt;b&gt;&#123;@code FactoryBean&#125; is a programmatic contract. Implementations are not * supposed to rely on annotation-driven injection or other reflective facilities.&lt;/b&gt; * &#123;@link #getObjectType()&#125; &#123;@link #getObject()&#125; invocations may arrive early in the * bootstrap process, even ahead of any post-processor setup. If you need access to * other beans, implement &#123;@link BeanFactoryAware&#125; and obtain them programmatically. * * &lt;p&gt;&lt;b&gt;The container is only responsible for managing the lifecycle of the FactoryBean * instance, not the lifecycle of the objects created by the FactoryBean.&lt;/b&gt; Therefore, * a destroy method on an exposed bean object (such as &#123;@link java.io.Closeable#close()&#125; * will &lt;i&gt;not&lt;/i&gt; be called automatically. Instead, a FactoryBean should implement * &#123;@link DisposableBean&#125; and delegate any such close call to the underlying object. * * &lt;p&gt;Finally, FactoryBean objects participate in the containing BeanFactory&#x27;s * synchronization of bean creation. There is usually no need for internal * synchronization other than for purposes of lazy initialization within the * FactoryBean itself (or the like). * * @author Rod Johnson * @author Juergen Hoeller * @since 08.03.2003 * @param &lt;T&gt; the bean type * @see org.springframework.beans.factory.BeanFactory * @see org.springframework.aop.framework.ProxyFactoryBean * @see org.springframework.jndi.JndiObjectFactoryBean */public interface FactoryBean&lt;T&gt; &#123; /** * The name of an attribute that can be * &#123;@link org.springframework.core.AttributeAccessor#setAttribute set&#125; on a * &#123;@link org.springframework.beans.factory.config.BeanDefinition&#125; so that * factory beans can signal their object type when it can&#x27;t be deduced from * the factory bean class. * @since 5.2 */ String OBJECT_TYPE_ATTRIBUTE = &quot;factoryBeanObjectType&quot;; /** * Return an instance (possibly shared or independent) of the object * managed by this factory. * &lt;p&gt;As with a &#123;@link BeanFactory&#125;, this allows support for both the * Singleton and Prototype design pattern. * &lt;p&gt;If this FactoryBean is not fully initialized yet at the time of * the call (for example because it is involved in a circular reference), * throw a corresponding &#123;@link FactoryBeanNotInitializedException&#125;. * &lt;p&gt;As of Spring 2.0, FactoryBeans are allowed to return &#123;@code null&#125; * objects. The factory will consider this as normal value to be used; it * will not throw a FactoryBeanNotInitializedException in this case anymore. * FactoryBean implementations are encouraged to throw * FactoryBeanNotInitializedException themselves now, as appropriate. * @return an instance of the bean (can be &#123;@code null&#125;) * @throws Exception in case of creation errors * @see FactoryBeanNotInitializedException */ @Nullable T getObject() throws Exception; /** * Return the type of object that this FactoryBean creates, * or &#123;@code null&#125; if not known in advance. * &lt;p&gt;This allows one to check for specific types of beans without * instantiating objects, for example on autowiring. * &lt;p&gt;In the case of implementations that are creating a singleton object, * this method should try to avoid singleton creation as far as possible; * it should rather estimate the type in advance. * For prototypes, returning a meaningful type here is advisable too. * &lt;p&gt;This method can be called &lt;i&gt;before&lt;/i&gt; this FactoryBean has * been fully initialized. It must not rely on state created during * initialization; of course, it can still use such state if available. * &lt;p&gt;&lt;b&gt;NOTE:&lt;/b&gt; Autowiring will simply ignore FactoryBeans that return * &#123;@code null&#125; here. Therefore it is highly recommended to implement * this method properly, using the current state of the FactoryBean. * @return the type of object that this FactoryBean creates, * or &#123;@code null&#125; if not known at the time of the call * @see ListableBeanFactory#getBeansOfType */ @Nullable Class&lt;?&gt; getObjectType(); /** * Is the object managed by this factory a singleton? That is, * will &#123;@link #getObject()&#125; always return the same object * (a reference that can be cached)? * &lt;p&gt;&lt;b&gt;NOTE:&lt;/b&gt; If a FactoryBean indicates to hold a singleton object, * the object returned from &#123;@code getObject()&#125; might get cached * by the owning BeanFactory. Hence, do not return &#123;@code true&#125; * unless the FactoryBean always exposes the same reference. * &lt;p&gt;The singleton status of the FactoryBean itself will generally * be provided by the owning BeanFactory; usually, it has to be * defined as singleton there. * &lt;p&gt;&lt;b&gt;NOTE:&lt;/b&gt; This method returning &#123;@code false&#125; does not * necessarily indicate that returned objects are independent instances. * An implementation of the extended &#123;@link SmartFactoryBean&#125; interface * may explicitly indicate independent instances through its * &#123;@link SmartFactoryBean#isPrototype()&#125; method. Plain &#123;@link FactoryBean&#125; * implementations which do not implement this extended interface are * simply assumed to always return independent instances if the * &#123;@code isSingleton()&#125; implementation returns &#123;@code false&#125;. * &lt;p&gt;The default implementation returns &#123;@code true&#125;, since a * &#123;@code FactoryBean&#125; typically manages a singleton instance. * @return whether the exposed object is a singleton * @see #getObject() * @see SmartFactoryBean#isPrototype() */ default boolean isSingleton() &#123; return true; &#125;&#125; ②创建类UserFactoryBean 123456789101112package com.atguigu.spring6.bean;public class UserFactoryBean implements FactoryBean&lt;User&gt; &#123; @Override public User getObject() throws Exception &#123; return new User(); &#125; @Override public Class&lt;?&gt; getObjectType() &#123; return User.class; &#125;&#125; ③配置bean 1&lt;bean id=&quot;user&quot; class=&quot;com.atguigu.spring6.bean.UserFactoryBean&quot;&gt;&lt;/bean&gt; ④测试 1234567@Testpublic void testUserFactoryBean()&#123; //获取IOC容器 ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;spring-factorybean.xml&quot;); User user = (User) ac.getBean(&quot;user&quot;); System.out.println(user);&#125; 3.2.14、实验十三：基于xml自动装配 自动装配： 根据指定的策略，在IOC容器中匹配某一个bean，自动为指定的bean中所依赖的类类型或接口类型属性赋值 ①场景模拟 创建类UserController 1234567891011121314package com.atguigu.spring6.autowire.controllerpublic class UserController &#123; private UserService userService; public void setUserService(UserService userService) &#123; this.userService = userService; &#125; public void saveUser()&#123; userService.saveUser(); &#125;&#125; 创建接口UserService 123456package com.atguigu.spring6.autowire.servicepublic interface UserService &#123; void saveUser();&#125; 创建类UserServiceImpl实现接口UserService 123456789101112131415package com.atguigu.spring6.autowire.service.implpublic class UserServiceImpl implements UserService &#123; private UserDao userDao; public void setUserDao(UserDao userDao) &#123; this.userDao = userDao; &#125; @Override public void saveUser() &#123; userDao.saveUser(); &#125;&#125; 创建接口UserDao 123456package com.atguigu.spring6.autowire.daopublic interface UserDao &#123; void saveUser();&#125; 创建类UserDaoImpl实现接口UserDao 123456789package com.atguigu.spring6.autowire.dao.implpublic class UserDaoImpl implements UserDao &#123; @Override public void saveUser() &#123; System.out.println(&quot;保存成功&quot;); &#125;&#125; ②配置bean 使用bean标签的autowire属性设置自动装配效果 自动装配方式：byType byType：根据类型匹配IOC容器中的某个兼容类型的bean，为属性自动赋值 若在IOC中，没有任何一个兼容类型的bean能够为属性赋值，则该属性不装配，即值为默认值null 若在IOC中，有多个兼容类型的bean能够为属性赋值，则抛出异常NoUniqueBeanDefinitionException 12345&lt;bean id=&quot;userController&quot; class=&quot;com.atguigu.spring6.autowire.controller.UserController&quot; autowire=&quot;byType&quot;&gt;&lt;/bean&gt;&lt;bean id=&quot;userService&quot; class=&quot;com.atguigu.spring6.autowire.service.impl.UserServiceImpl&quot; autowire=&quot;byType&quot;&gt;&lt;/bean&gt;&lt;bean id=&quot;userDao&quot; class=&quot;com.atguigu.spring6.autowire.dao.impl.UserDaoImpl&quot;&gt;&lt;/bean&gt; 自动装配方式：byName byName：将自动装配的属性的属性名，作为bean的id在IOC容器中匹配相对应的bean进行赋值 1234567&lt;bean id=&quot;userController&quot; class=&quot;com.atguigu.spring6.autowire.controller.UserController&quot; autowire=&quot;byName&quot;&gt;&lt;/bean&gt;&lt;bean id=&quot;userService&quot; class=&quot;com.atguigu.spring6.autowire.service.impl.UserServiceImpl&quot; autowire=&quot;byName&quot;&gt;&lt;/bean&gt;&lt;bean id=&quot;userServiceImpl&quot; class=&quot;com.atguigu.spring6.autowire.service.impl.UserServiceImpl&quot; autowire=&quot;byName&quot;&gt;&lt;/bean&gt;&lt;bean id=&quot;userDao&quot; class=&quot;com.atguigu.spring6.autowire.dao.impl.UserDaoImpl&quot;&gt;&lt;/bean&gt;&lt;bean id=&quot;userDaoImpl&quot; class=&quot;com.atguigu.spring6.autowire.dao.impl.UserDaoImpl&quot;&gt;&lt;/bean&gt; ③测试 123456@Testpublic void testAutoWireByXML()&#123; ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;autowire-xml.xml&quot;); UserController userController = ac.getBean(UserController.class); userController.saveUser();&#125; 3.3、基于注解管理Bean（☆）从 Java 5 开始，Java 增加了对注解（Annotation）的支持，它是代码中的一种特殊标记，可以在编译、类加载和运行时被读取，执行相应的处理。开发人员可以通过注解在不改变原有代码和逻辑的情况下，在源代码中嵌入补充信息。 Spring 从 2.5 版本开始提供了对注解技术的全面支持，我们可以使用注解来实现自动装配，简化 Spring 的 XML 配置。 Spring 通过注解实现自动装配的步骤如下： 引入依赖 开启组件扫描 使用注解定义 Bean 依赖注入 3.3.1、搭建子模块spring6-ioc-annotation①搭建模块 搭建方式如：spring6-ioc-xml ②引入配置文件 引入spring-ioc-xml模块日志log4j2.xml ③添加依赖 123456789101112131415161718192021222324252627&lt;dependencies&gt; &lt;!--spring context依赖--&gt; &lt;!--当你引入Spring Context依赖之后，表示将Spring的基础依赖引入了--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;6.0.3&lt;/version&gt; &lt;/dependency&gt; &lt;!--junit5测试--&gt; &lt;dependency&gt; &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt; &lt;artifactId&gt;junit-jupiter-api&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--log4j2的依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j-core&lt;/artifactId&gt; &lt;version&gt;2.19.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j-slf4j2-impl&lt;/artifactId&gt; &lt;version&gt;2.19.0&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 3.3.2、开启组件扫描Spring 默认不使用注解装配 Bean，因此我们需要在 Spring 的 XML 配置中，通过 context:component-scan 元素开启 Spring Beans的自动扫描功能。开启此功能后，Spring 会自动从扫描指定的包（base-package 属性设置）及其子包下的所有类，如果类上使用了 @Component 注解，就将该类装配到容器中。 1234567891011&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;!--开启组件扫描功能--&gt; &lt;context:component-scan base-package=&quot;com.atguigu.spring6&quot;&gt;&lt;/context:component-scan&gt;&lt;/beans&gt; 注意：在使用 context:component-scan 元素开启自动扫描功能前，首先需要在 XML 配置的一级标签 中添加 context 相关的约束。 情况一：最基本的扫描方式 12&lt;context:component-scan base-package=&quot;com.atguigu.spring6&quot;&gt;&lt;/context:component-scan&gt; 情况二：指定要排除的组件 12345678910&lt;context:component-scan base-package=&quot;com.atguigu.spring6&quot;&gt; &lt;!-- context:exclude-filter标签：指定排除规则 --&gt; &lt;!-- type：设置排除或包含的依据 type=&quot;annotation&quot;，根据注解排除，expression中设置要排除的注解的全类名 type=&quot;assignable&quot;，根据类型排除，expression中设置要排除的类型的全类名 --&gt; &lt;context:exclude-filter type=&quot;annotation&quot; expression=&quot;org.springframework.stereotype.Controller&quot;/&gt; &lt;!--&lt;context:exclude-filter type=&quot;assignable&quot; expression=&quot;com.atguigu.spring6.controller.UserController&quot;/&gt;--&gt;&lt;/context:component-scan&gt; 情况三：仅扫描指定组件 123456789101112&lt;context:component-scan base-package=&quot;com.atguigu&quot; use-default-filters=&quot;false&quot;&gt; &lt;!-- context:include-filter标签：指定在原有扫描规则的基础上追加的规则 --&gt; &lt;!-- use-default-filters属性：取值false表示关闭默认扫描规则 --&gt; &lt;!-- 此时必须设置use-default-filters=&quot;false&quot;，因为默认规则即扫描指定包下所有类 --&gt; &lt;!-- type：设置排除或包含的依据 type=&quot;annotation&quot;，根据注解排除，expression中设置要排除的注解的全类名 type=&quot;assignable&quot;，根据类型排除，expression中设置要排除的类型的全类名 --&gt; &lt;context:include-filter type=&quot;annotation&quot; expression=&quot;org.springframework.stereotype.Controller&quot;/&gt; &lt;!--&lt;context:include-filter type=&quot;assignable&quot; expression=&quot;com.atguigu.spring6.controller.UserController&quot;/&gt;--&gt;&lt;/context:component-scan&gt; 3.3.3、使用注解定义 BeanSpring 提供了以下多个注解，这些注解可以直接标注在 Java 类上，将它们定义成 Spring Bean。 注解 说明 @Component 该注解用于描述 Spring 中的 Bean，它是一个泛化的概念，仅仅表示容器中的一个组件（Bean），并且可以作用在应用的任何层次，例如 Service 层、Dao 层等。 使用时只需将该注解标注在相应类上即可。 @Repository 该注解用于将数据访问层（Dao 层）的类标识为 Spring 中的 Bean，其功能与 @Component 相同。 @Service 该注解通常作用在业务层（Service 层），用于将业务层的类标识为 Spring 中的 Bean，其功能与 @Component 相同。 @Controller 该注解通常作用在控制层（如SpringMVC 的 Controller），用于将控制层的类标识为 Spring 中的 Bean，其功能与 @Component 相同。 3.3.4、实验一：@Autowired注入单独使用@Autowired注解，默认根据类型装配。【默认是byType】 查看源码： 1234567891011121314package org.springframework.beans.factory.annotation;import java.lang.annotation.Documented;import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;@Target(&#123;ElementType.CONSTRUCTOR, ElementType.METHOD, ElementType.PARAMETER, ElementType.FIELD, ElementType.ANNOTATION_TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Documentedpublic @interface Autowired &#123; boolean required() default true;&#125; 源码中有两处需要注意： 第一处：该注解可以标注在哪里？ 构造方法上 方法上 形参上 属性上 注解上 第二处：该注解有一个required属性，默认值是true，表示在注入的时候要求被注入的Bean必须是存在的，如果不存在则报错。如果required属性设置为false，表示注入的Bean存在或者不存在都没关系，存在的话就注入，不存在的话，也不报错。 ①场景一：属性注入创建UserDao接口 123456package com.atguigu.spring6.dao;public interface UserDao &#123; public void print();&#125; 创建UserDaoImpl实现 12345678910111213package com.atguigu.spring6.dao.impl;import com.atguigu.spring6.dao.UserDao;import org.springframework.stereotype.Repository;@Repositorypublic class UserDaoImpl implements UserDao &#123; @Override public void print() &#123; System.out.println(&quot;Dao层执行结束&quot;); &#125;&#125; 创建UserService接口 123456package com.atguigu.spring6.service;public interface UserService &#123; public void out();&#125; 创建UserServiceImpl实现类 12345678910111213141516171819package com.atguigu.spring6.service.impl;import com.atguigu.spring6.dao.UserDao;import com.atguigu.spring6.service.UserService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;@Servicepublic class UserServiceImpl implements UserService &#123; @Autowired private UserDao userDao; @Override public void out() &#123; userDao.print(); System.out.println(&quot;Service层执行结束&quot;); &#125;&#125; 创建UserController类 123456789101112131415161718package com.atguigu.spring6.controller;import com.atguigu.spring6.service.UserService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;@Controllerpublic class UserController &#123; @Autowired private UserService userService; public void out() &#123; userService.out(); System.out.println(&quot;Controller层执行结束。&quot;); &#125;&#125; 测试一 1234567891011121314151617181920212223package com.atguigu.spring6.bean;import com.atguigu.spring6.controller.UserController;import org.junit.jupiter.api.Test;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class UserTest &#123; private Logger logger = LoggerFactory.getLogger(UserTest.class); @Test public void testAnnotation()&#123; ApplicationContext context = new ClassPathXmlApplicationContext(&quot;Beans.xml&quot;); UserController userController = context.getBean(&quot;userController&quot;, UserController.class); userController.out(); logger.info(&quot;执行成功&quot;); &#125;&#125; 测试结果： 以上构造方法和setter方法都没有提供，经过测试，仍然可以注入成功。 ②场景二：set注入修改UserServiceImpl类 1234567891011121314151617181920212223package com.atguigu.spring6.service.impl;import com.atguigu.spring6.dao.UserDao;import com.atguigu.spring6.service.UserService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;@Servicepublic class UserServiceImpl implements UserService &#123; private UserDao userDao; @Autowired public void setUserDao(UserDao userDao) &#123; this.userDao = userDao; &#125; @Override public void out() &#123; userDao.print(); System.out.println(&quot;Service层执行结束&quot;); &#125;&#125; 修改UserController类 12345678910111213141516171819202122package com.atguigu.spring6.controller;import com.atguigu.spring6.service.UserService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;@Controllerpublic class UserController &#123; private UserService userService; @Autowired public void setUserService(UserService userService) &#123; this.userService = userService; &#125; public void out() &#123; userService.out(); System.out.println(&quot;Controller层执行结束。&quot;); &#125;&#125; 测试：成功调用 ③场景三：构造方法注入修改UserServiceImpl类 1234567891011121314151617181920212223package com.atguigu.spring6.service.impl;import com.atguigu.spring6.dao.UserDao;import com.atguigu.spring6.service.UserService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;@Servicepublic class UserServiceImpl implements UserService &#123; private UserDao userDao; @Autowired public UserServiceImpl(UserDao userDao) &#123; this.userDao = userDao; &#125; @Override public void out() &#123; userDao.print(); System.out.println(&quot;Service层执行结束&quot;); &#125;&#125; 修改UserController类 12345678910111213141516171819202122package com.atguigu.spring6.controller;import com.atguigu.spring6.service.UserService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;@Controllerpublic class UserController &#123; private UserService userService; @Autowired public UserController(UserService userService) &#123; this.userService = userService; &#125; public void out() &#123; userService.out(); System.out.println(&quot;Controller层执行结束。&quot;); &#125;&#125; 测试：成功调用 ④场景四：形参上注入修改UserServiceImpl类 12345678910111213141516171819202122package com.atguigu.spring6.service.impl;import com.atguigu.spring6.dao.UserDao;import com.atguigu.spring6.service.UserService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;@Servicepublic class UserServiceImpl implements UserService &#123; private UserDao userDao; public UserServiceImpl(@Autowired UserDao userDao) &#123; this.userDao = userDao; &#125; @Override public void out() &#123; userDao.print(); System.out.println(&quot;Service层执行结束&quot;); &#125;&#125; 修改UserController类 123456789101112131415161718192021package com.atguigu.spring6.controller;import com.atguigu.spring6.service.UserService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;@Controllerpublic class UserController &#123; private UserService userService; public UserController(@Autowired UserService userService) &#123; this.userService = userService; &#125; public void out() &#123; userService.out(); System.out.println(&quot;Controller层执行结束。&quot;); &#125;&#125; 测试：成功调用 ⑤场景五：只有一个构造函数，无注解修改UserServiceImpl类 123456789101112131415161718192021222324package com.atguigu.spring6.service.impl;import com.atguigu.spring6.dao.UserDao;import com.atguigu.spring6.service.UserService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.beans.factory.annotation.Qualifier;import org.springframework.stereotype.Service;@Servicepublic class UserServiceImpl implements UserService &#123; @Autowired private UserDao userDao; public UserServiceImpl(UserDao userDao) &#123; this.userDao = userDao; &#125; @Override public void out() &#123; userDao.print(); System.out.println(&quot;Service层执行结束&quot;); &#125;&#125; 测试通过 当有参数的构造方法只有一个时，@Autowired注解可以省略。 说明：有多个构造方法时呢？大家可以测试（再添加一个无参构造函数），测试报错 ⑥场景六：@Autowired注解和@Qualifier注解联合添加dao层实现 12345678910111213package com.atguigu.spring6.dao.impl;import com.atguigu.spring6.dao.UserDao;import org.springframework.stereotype.Repository;@Repositorypublic class UserDaoRedisImpl implements UserDao &#123; @Override public void print() &#123; System.out.println(&quot;Redis Dao层执行结束&quot;); &#125;&#125; 测试：测试异常 错误信息中说：不能装配，UserDao这个Bean的数量等于2 怎么解决这个问题呢？当然要byName，根据名称进行装配了。 修改UserServiceImpl类 1234567891011121314151617181920package com.atguigu.spring6.service.impl;import com.atguigu.spring6.dao.UserDao;import com.atguigu.spring6.service.UserService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;@Servicepublic class UserServiceImpl implements UserService &#123; @Autowired @Qualifier(&quot;userDaoImpl&quot;) // 指定bean的名字 private UserDao userDao; @Override public void out() &#123; userDao.print(); System.out.println(&quot;Service层执行结束&quot;); &#125;&#125; 总结 @Autowired注解可以出现在：属性上、构造方法上、构造方法的参数上、setter方法上。 当带参数的构造方法只有一个，@Autowired注解可以省略。（） @Autowired注解默认根据类型注入。如果要根据名称注入的话，需要配合@Qualifier注解一起使用。 3.3.5、实验二：@Resource注入@Resource注解也可以完成属性注入。那它和@Autowired注解有什么区别？ @Resource注解是JDK扩展包中的，也就是说属于JDK的一部分。所以该注解是标准注解，更加具有通用性。(JSR-250标准中制定的注解类型。JSR是Java规范提案。) @Autowired注解是Spring框架自己的。 @Resource注解默认根据名称装配byName，未指定name时，使用属性名作为name。通过name找不到的话会自动启动通过类型byType装配。 @Autowired注解默认根据类型装配byType，如果想根据名称装配，需要配合@Qualifier注解一起用。 @Resource注解用在属性上、setter方法上。 @Autowired注解用在属性上、setter方法上、构造方法上、构造方法参数上。 @Resource注解属于JDK扩展包，所以不在JDK当中，需要额外引入以下依赖：【如果是JDK8的话不需要额外引入依赖。高于JDK11或低于JDK8需要引入以下依赖。】 12345&lt;dependency&gt; &lt;groupId&gt;jakarta.annotation&lt;/groupId&gt; &lt;artifactId&gt;jakarta.annotation-api&lt;/artifactId&gt; &lt;version&gt;2.1.1&lt;/version&gt;&lt;/dependency&gt; 源码： 12345678910111213141516171819202122232425262728293031323334package jakarta.annotation;import java.lang.annotation.ElementType;import java.lang.annotation.Repeatable;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;@Target(&#123;ElementType.TYPE, ElementType.FIELD, ElementType.METHOD&#125;)@Retention(RetentionPolicy.RUNTIME)@Repeatable(Resources.class)public @interface Resource &#123; String name() default &quot;&quot;; String lookup() default &quot;&quot;; Class&lt;?&gt; type() default Object.class; Resource.AuthenticationType authenticationType() default Resource.AuthenticationType.CONTAINER; boolean shareable() default true; String mappedName() default &quot;&quot;; String description() default &quot;&quot;; public static enum AuthenticationType &#123; CONTAINER, APPLICATION; private AuthenticationType() &#123; &#125; &#125;&#125; ①场景一：根据name注入修改UserDaoImpl类 12345678910111213package com.atguigu.spring6.dao.impl;import com.atguigu.spring6.dao.UserDao;import org.springframework.stereotype.Repository;@Repository(&quot;myUserDao&quot;)public class UserDaoImpl implements UserDao &#123; @Override public void print() &#123; System.out.println(&quot;Dao层执行结束&quot;); &#125;&#125; 修改UserServiceImpl类 123456789101112131415161718192021package com.atguigu.spring6.service.impl;import com.atguigu.spring6.dao.UserDao;import com.atguigu.spring6.service.UserService;import jakarta.annotation.Resource;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.beans.factory.annotation.Qualifier;import org.springframework.stereotype.Service;@Servicepublic class UserServiceImpl implements UserService &#123; @Resource(name = &quot;myUserDao&quot;) private UserDao myUserDao; @Override public void out() &#123; myUserDao.print(); System.out.println(&quot;Service层执行结束&quot;); &#125;&#125; 测试通过 ②场景二：name未知注入修改UserDaoImpl类 12345678910111213package com.atguigu.spring6.dao.impl;import com.atguigu.spring6.dao.UserDao;import org.springframework.stereotype.Repository;@Repository(&quot;myUserDao&quot;)public class UserDaoImpl implements UserDao &#123; @Override public void print() &#123; System.out.println(&quot;Dao层执行结束&quot;); &#125;&#125; 修改UserServiceImpl类 123456789101112131415161718192021package com.atguigu.spring6.service.impl;import com.atguigu.spring6.dao.UserDao;import com.atguigu.spring6.service.UserService;import jakarta.annotation.Resource;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.beans.factory.annotation.Qualifier;import org.springframework.stereotype.Service;@Servicepublic class UserServiceImpl implements UserService &#123; @Resource private UserDao myUserDao; @Override public void out() &#123; myUserDao.print(); System.out.println(&quot;Service层执行结束&quot;); &#125;&#125; 测试通过 当@Resource注解使用时没有指定name的时候，还是根据name进行查找，这个name是属性名。 ③场景三 其他情况修改UserServiceImpl类，userDao1属性名不存在 123456789101112131415161718192021package com.atguigu.spring6.service.impl;import com.atguigu.spring6.dao.UserDao;import com.atguigu.spring6.service.UserService;import jakarta.annotation.Resource;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.beans.factory.annotation.Qualifier;import org.springframework.stereotype.Service;@Servicepublic class UserServiceImpl implements UserService &#123; @Resource private UserDao userDao1; @Override public void out() &#123; userDao1.print(); System.out.println(&quot;Service层执行结束&quot;); &#125;&#125; 测试异常 根据异常信息得知：显然当通过name找不到的时候，自然会启动byType进行注入，以上的错误是因为UserDao接口下有两个实现类导致的。所以根据类型注入就会报错。 @Resource的set注入可以自行测试 总结： @Resource注解：默认byName注入，没有指定name时把属性名当做name，根据name找不到时，才会byType注入。byType注入时，某种类型的Bean只能有一个 3.3.6、Spring全注解开发全注解开发就是不再使用spring配置文件了，写一个配置类来代替配置文件。 12345678910package com.atguigu.spring6.config;import org.springframework.context.annotation.ComponentScan;import org.springframework.context.annotation.Configuration;@Configuration//@ComponentScan(&#123;&quot;com.atguigu.spring6.controller&quot;, &quot;com.atguigu.spring6.service&quot;,&quot;com.atguigu.spring6.dao&quot;&#125;)@ComponentScan(&quot;com.atguigu.spring6&quot;)public class Spring6Config &#123;&#125; 测试类 1234567@Testpublic void testAllAnnotation()&#123; ApplicationContext context = new AnnotationConfigApplicationContext(Spring6Config.class); UserController userController = context.getBean(&quot;userController&quot;, UserController.class); userController.out(); logger.info(&quot;执行成功&quot;);&#125; 4、原理-手写IoC我们都知道，Spring框架的IOC是基于Java反射机制实现的，下面我们先回顾一下java反射。 4.1、回顾Java反射Java反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性；这种动态获取信息以及动态调用对象方法的功能称为Java语言的反射机制。简单来说，反射机制指的是程序在运行时能够获取自身的信息。 要想解剖一个类，必须先要获取到该类的Class对象。而剖析一个类或用反射解决具体的问题就是使用相关API（1）java.lang.Class（2）java.lang.reflect，所以，Class对象是反射的根源。 自定义类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package com.atguigu.reflect;public class Car &#123; //属性 private String name; private int age; private String color; //无参数构造 public Car() &#123; &#125; //有参数构造 public Car(String name, int age, String color) &#123; this.name = name; this.age = age; this.color = color; &#125; //普通方法 private void run() &#123; System.out.println(&quot;私有方法-run.....&quot;); &#125; //get和set方法 public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public String getColor() &#123; return color; &#125; public void setColor(String color) &#123; this.color = color; &#125; @Override public String toString() &#123; return &quot;Car&#123;&quot; + &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, age=&quot; + age + &quot;, color=&#x27;&quot; + color + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125;&#125; 编写测试类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899package com.atguigu.reflect;import org.junit.jupiter.api.Test;import java.lang.reflect.Constructor;import java.lang.reflect.Field;import java.lang.reflect.Method;public class TestCar &#123; //1、获取Class对象多种方式 @Test public void test01() throws Exception &#123; //1 类名.class Class clazz1 = Car.class; //2 对象.getClass() Class clazz2 = new Car().getClass(); //3 Class.forName(&quot;全路径&quot;) Class clazz3 = Class.forName(&quot;com.atguigu.reflect.Car&quot;); //实例化 Car car = (Car)clazz3.getConstructor().newInstance(); System.out.println(car); &#125; //2、获取构造方法 @Test public void test02() throws Exception &#123; Class clazz = Car.class; //获取所有构造 // getConstructors()获取所有public的构造方法// Constructor[] constructors = clazz.getConstructors(); // getDeclaredConstructors()获取所有的构造方法public private Constructor[] constructors = clazz.getDeclaredConstructors(); for (Constructor c:constructors) &#123; System.out.println(&quot;方法名称：&quot;+c.getName()+&quot; 参数个数：&quot;+c.getParameterCount()); &#125; //指定有参数构造创建对象 //1 构造public// Constructor c1 = clazz.getConstructor(String.class, int.class, String.class);// Car car1 = (Car)c1.newInstance(&quot;夏利&quot;, 10, &quot;红色&quot;);// System.out.println(car1); //2 构造private Constructor c2 = clazz.getDeclaredConstructor(String.class, int.class, String.class); c2.setAccessible(true); Car car2 = (Car)c2.newInstance(&quot;捷达&quot;, 15, &quot;白色&quot;); System.out.println(car2); &#125; //3、获取属性 @Test public void test03() throws Exception &#123; Class clazz = Car.class; Car car = (Car)clazz.getDeclaredConstructor().newInstance(); //获取所有public属性 //Field[] fields = clazz.getFields(); //获取所有属性（包含私有属性） Field[] fields = clazz.getDeclaredFields(); for (Field field:fields) &#123; if(field.getName().equals(&quot;name&quot;)) &#123; //设置允许访问 field.setAccessible(true); field.set(car,&quot;五菱宏光&quot;); System.out.println(car); &#125; System.out.println(field.getName()); &#125; &#125; //4、获取方法 @Test public void test04() throws Exception &#123; Car car = new Car(&quot;奔驰&quot;,10,&quot;黑色&quot;); Class clazz = car.getClass(); //1 public方法 Method[] methods = clazz.getMethods(); for (Method m1:methods) &#123; //System.out.println(m1.getName()); //执行方法 toString if(m1.getName().equals(&quot;toString&quot;)) &#123; String invoke = (String)m1.invoke(car); //System.out.println(&quot;toString执行了：&quot;+invoke); &#125; &#125; //2 private方法 Method[] methodsAll = clazz.getDeclaredMethods(); for (Method m:methodsAll) &#123; //执行方法 run if(m.getName().equals(&quot;run&quot;)) &#123; m.setAccessible(true); m.invoke(car); &#125; &#125; &#125;&#125; 4.2、实现Spring的IoC我们知道，IoC（控制反转）和DI（依赖注入）是Spring里面核心的东西，那么，我们如何自己手写出这样的代码呢？下面我们就一步一步写出Spring框架最核心的部分。 ①搭建子模块 搭建模块：guigu-spring，搭建方式如其他spring子模块 ②准备测试需要的bean 添加依赖 12345678&lt;dependencies&gt; &lt;!--junit5测试--&gt; &lt;dependency&gt; &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt; &lt;artifactId&gt;junit-jupiter-api&lt;/artifactId&gt; &lt;version&gt;5.3.1&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 创建UserDao接口 123456package com.atguigu.spring6.test.dao;public interface UserDao &#123; public void print();&#125; 创建UserDaoImpl实现 123456789101112package com.atguigu.spring6.test.dao.impl;import com.atguigu.spring.dao.UserDao;public class UserDaoImpl implements UserDao &#123; @Override public void print() &#123; System.out.println(&quot;Dao层执行结束&quot;); &#125;&#125; 创建UserService接口 123456package com.atguigu.spring6.test.service;public interface UserService &#123; public void out();&#125; 创建UserServiceImpl实现类 1234567891011121314151617package com.atguigu.spring.test.service.impl;import com.atguigu.spring.core.annotation.Bean;import com.atguigu.spring.service.UserService;@Beanpublic class UserServiceImpl implements UserService &#123;// private UserDao userDao; @Override public void out() &#123; //userDao.print(); System.out.println(&quot;Service层执行结束&quot;); &#125;&#125; ③定义注解 我们通过注解的形式加载bean与实现依赖注入 bean注解 1234567891011package com.atguigu.spring.core.annotation;import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)public @interface Bean &#123;&#125; 依赖注入注解 1234567891011package com.atguigu.spring.core.annotation;import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;@Target(&#123;ElementType.FIELD&#125;)@Retention(RetentionPolicy.RUNTIME)public @interface Di &#123;&#125; 说明：上面两个注解可以随意取名 ④定义bean容器接口 123456package com.atguigu.spring.core;public interface ApplicationContext &#123; Object getBean(Class clazz);&#125; ⑤编写注解bean容器接口实现 AnnotationApplicationContext基于注解扫描bean 12345678910111213141516171819202122package com.atguigu.spring.core;import java.util.HashMap;public class AnnotationApplicationContext implements ApplicationContext &#123; //存储bean的容器 private HashMap&lt;Class, Object&gt; beanFactory = new HashMap&lt;&gt;(); @Override public Object getBean(Class clazz) &#123; return beanFactory.get(clazz); &#125; /** * 根据包扫描加载bean * @param basePackage */ public AnnotationApplicationContext(String basePackage) &#123; &#125;&#125; ⑥编写扫描bean逻辑 我们通过构造方法传入包的base路径，扫描被@Bean注解的java对象，完整代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485package com.atguigu.spring.core;import com.atguigu.spring.core.annotation.Bean;import java.io.File;import java.util.HashMap;public class AnnotationApplicationContext implements ApplicationContext &#123; //存储bean的容器 private HashMap&lt;Class, Object&gt; beanFactory = new HashMap&lt;&gt;(); private static String rootPath; @Override public Object getBean(Class clazz) &#123; return beanFactory.get(clazz); &#125; /** * 根据包扫描加载bean * @param basePackage */ public AnnotationApplicationContext(String basePackage) &#123; try &#123; String packageDirName = basePackage.replaceAll(&quot;\\\\.&quot;, &quot;\\\\\\\\&quot;); Enumeration&lt;URL&gt; dirs =Thread.currentThread().getContextClassLoader().getResources(packageDirName); while (dirs.hasMoreElements()) &#123; URL url = dirs.nextElement(); String filePath = URLDecoder.decode(url.getFile(),&quot;utf-8&quot;); rootPath = filePath.substring(0, filePath.length()-packageDirName.length()); loadBean(new File(filePath)); &#125; &#125; catch (Exception e) &#123; throw new RuntimeException(e); &#125; &#125; private void loadBean(File fileParent) &#123; if (fileParent.isDirectory()) &#123; File[] childrenFiles = fileParent.listFiles(); if(childrenFiles == null || childrenFiles.length == 0)&#123; return; &#125; for (File child : childrenFiles) &#123; if (child.isDirectory()) &#123; //如果是个文件夹就继续调用该方法,使用了递归 loadBean(child); &#125; else &#123; //通过文件路径转变成全类名,第一步把绝对路径部分去掉 String pathWithClass = child.getAbsolutePath().substring(rootPath.length() - 1); //选中class文件 if (pathWithClass.contains(&quot;.class&quot;)) &#123; // com.xinzhi.dao.UserDao //去掉.class后缀，并且把 \\ 替换成 . String fullName = pathWithClass.replaceAll(&quot;\\\\\\\\&quot;, &quot;.&quot;).replace(&quot;.class&quot;, &quot;&quot;); try &#123; Class&lt;?&gt; aClass = Class.forName(fullName); //把非接口的类实例化放在map中 if(!aClass.isInterface())&#123; Bean annotation = aClass.getAnnotation(Bean.class); if(annotation != null)&#123; Object instance = aClass.newInstance(); //判断一下有没有接口 if(aClass.getInterfaces().length &gt; 0) &#123; //如果有接口把接口的class当成key，实例对象当成value System.out.println(&quot;正在加载【&quot;+ aClass.getInterfaces()[0] +&quot;】,实例对象是：&quot; + instance.getClass().getName()); beanFactory.put(aClass.getInterfaces()[0], instance); &#125;else&#123; //如果有接口把自己的class当成key，实例对象当成value System.out.println(&quot;正在加载【&quot;+ aClass.getName() +&quot;】,实例对象是：&quot; + instance.getClass().getName()); beanFactory.put(aClass, instance); &#125; &#125; &#125; &#125; catch (ClassNotFoundException | IllegalAccessException | InstantiationException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; &#125; &#125;&#125; ⑦java类标识Bean注解 12@Beanpublic class UserServiceImpl implements UserService 12@Beanpublic class UserDaoImpl implements UserDao ⑧测试Bean加载 1234567891011121314151617package com.atguigu.spring;import com.atguigu.spring.core.AnnotationApplicationContext;import com.atguigu.spring.core.ApplicationContext;import com.atguigu.spring.test.service.UserService;import org.junit.jupiter.api.Test;public class SpringIocTest &#123; @Test public void testIoc() &#123; ApplicationContext applicationContext = new AnnotationApplicationContext(&quot;com.atguigu.spring.test&quot;); UserService userService = (UserService)applicationContext.getBean(UserService.class); userService.out(); System.out.println(&quot;run success&quot;); &#125;&#125; 控制台打印测试 ⑨依赖注入 只要userDao.print();调用成功，说明就注入成功 12345678910111213141516171819package com.atguigu.spring.test.service.impl;import com.atguigu.spring.core.annotation.Bean;import com.atguigu.spring.core.annotation.Di;import com.atguigu.spring.dao.UserDao;import com.atguigu.spring.service.UserService;@Beanpublic class UserServiceImpl implements UserService &#123; @Di private UserDao userDao; @Override public void out() &#123; userDao.print(); System.out.println(&quot;Service层执行结束&quot;); &#125;&#125; 执行第八步：报错了，说明当前userDao是个空对象 ⑩依赖注入实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112package com.atguigu.spring.core;import com.atguigu.spring.core.annotation.Bean;import com.atguigu.spring.core.annotation.Di;import java.io.File;import java.lang.reflect.Field;import java.util.HashMap;import java.util.Map;public class AnnotationApplicationContext implements ApplicationContext &#123; //存储bean的容器 private HashMap&lt;Class, Object&gt; beanFactory = new HashMap&lt;&gt;(); private static String rootPath; @Override public Object getBean(Class clazz) &#123; return beanFactory.get(clazz); &#125; /** * 根据包扫描加载bean * @param basePackage */ public AnnotationApplicationContext(String basePackage) &#123; try &#123; String packageDirName = basePackage.replaceAll(&quot;\\\\.&quot;, &quot;\\\\\\\\&quot;); Enumeration&lt;URL&gt; dirs =Thread.currentThread().getContextClassLoader().getResources(packageDirName); while (dirs.hasMoreElements()) &#123; URL url = dirs.nextElement(); String filePath = URLDecoder.decode(url.getFile(),&quot;utf-8&quot;); rootPath = filePath.substring(0, filePath.length()-packageDirName.length()); loadBean(new File(filePath)); &#125; &#125; catch (Exception e) &#123; throw new RuntimeException(e); &#125; //依赖注入 loadDi(); &#125; private void loadBean(File fileParent) &#123; if (fileParent.isDirectory()) &#123; File[] childrenFiles = fileParent.listFiles(); if(childrenFiles == null || childrenFiles.length == 0)&#123; return; &#125; for (File child : childrenFiles) &#123; if (child.isDirectory()) &#123; //如果是个文件夹就继续调用该方法,使用了递归 loadBean(child); &#125; else &#123; //通过文件路径转变成全类名,第一步把绝对路径部分去掉 String pathWithClass = child.getAbsolutePath().substring(rootPath.length() - 1); //选中class文件 if (pathWithClass.contains(&quot;.class&quot;)) &#123; // com.xinzhi.dao.UserDao //去掉.class后缀，并且把 \\ 替换成 . String fullName = pathWithClass.replaceAll(&quot;\\\\\\\\&quot;, &quot;.&quot;).replace(&quot;.class&quot;, &quot;&quot;); try &#123; Class&lt;?&gt; aClass = Class.forName(fullName); //把非接口的类实例化放在map中 if(!aClass.isInterface())&#123; Bean annotation = aClass.getAnnotation(Bean.class); if(annotation != null)&#123; Object instance = aClass.newInstance(); //判断一下有没有接口 if(aClass.getInterfaces().length &gt; 0) &#123; //如果有接口把接口的class当成key，实例对象当成value System.out.println(&quot;正在加载【&quot;+ aClass.getInterfaces()[0] +&quot;】,实例对象是：&quot; + instance.getClass().getName()); beanFactory.put(aClass.getInterfaces()[0], instance); &#125;else&#123; //如果有接口把自己的class当成key，实例对象当成value System.out.println(&quot;正在加载【&quot;+ aClass.getName() +&quot;】,实例对象是：&quot; + instance.getClass().getName()); beanFactory.put(aClass, instance); &#125; &#125; &#125; &#125; catch (ClassNotFoundException | IllegalAccessException | InstantiationException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; &#125; &#125; private void loadDi() &#123; for(Map.Entry&lt;Class,Object&gt; entry : beanFactory.entrySet())&#123; //就是咱们放在容器的对象 Object obj = entry.getValue(); Class&lt;?&gt; aClass = obj.getClass(); Field[] declaredFields = aClass.getDeclaredFields(); for (Field field : declaredFields)&#123; Di annotation = field.getAnnotation(Di.class); if( annotation != null )&#123; field.setAccessible(true); try &#123; System.out.println(&quot;正在给【&quot;+obj.getClass().getName()+&quot;】属性【&quot; + field.getName() + &quot;】注入值【&quot;+ beanFactory.get(field.getType()).getClass().getName() +&quot;】&quot;); field.set(obj,beanFactory.get(field.getType())); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; &#125;&#125; 执行第八步：执行成功，依赖注入成功 5、面向切面：AOP5.1、场景模拟搭建子模块：spring6-aop 5.1.1、声明接口声明计算器接口Calculator，包含加减乘除的抽象方法 1234567891011public interface Calculator &#123; int add(int i, int j); int sub(int i, int j); int mul(int i, int j); int div(int i, int j); &#125; 5.1.2、创建实现类 123456789101112131415161718192021222324252627282930313233343536373839404142public class CalculatorImpl implements Calculator &#123; @Override public int add(int i, int j) &#123; int result = i + j; System.out.println(&quot;方法内部 result = &quot; + result); return result; &#125; @Override public int sub(int i, int j) &#123; int result = i - j; System.out.println(&quot;方法内部 result = &quot; + result); return result; &#125; @Override public int mul(int i, int j) &#123; int result = i * j; System.out.println(&quot;方法内部 result = &quot; + result); return result; &#125; @Override public int div(int i, int j) &#123; int result = i / j; System.out.println(&quot;方法内部 result = &quot; + result); return result; &#125;&#125; 5.1.3、创建带日志功能的实现类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public class CalculatorLogImpl implements Calculator &#123; @Override public int add(int i, int j) &#123; System.out.println(&quot;[日志] add 方法开始了，参数是：&quot; + i + &quot;,&quot; + j); int result = i + j; System.out.println(&quot;方法内部 result = &quot; + result); System.out.println(&quot;[日志] add 方法结束了，结果是：&quot; + result); return result; &#125; @Override public int sub(int i, int j) &#123; System.out.println(&quot;[日志] sub 方法开始了，参数是：&quot; + i + &quot;,&quot; + j); int result = i - j; System.out.println(&quot;方法内部 result = &quot; + result); System.out.println(&quot;[日志] sub 方法结束了，结果是：&quot; + result); return result; &#125; @Override public int mul(int i, int j) &#123; System.out.println(&quot;[日志] mul 方法开始了，参数是：&quot; + i + &quot;,&quot; + j); int result = i * j; System.out.println(&quot;方法内部 result = &quot; + result); System.out.println(&quot;[日志] mul 方法结束了，结果是：&quot; + result); return result; &#125; @Override public int div(int i, int j) &#123; System.out.println(&quot;[日志] div 方法开始了，参数是：&quot; + i + &quot;,&quot; + j); int result = i / j; System.out.println(&quot;方法内部 result = &quot; + result); System.out.println(&quot;[日志] div 方法结束了，结果是：&quot; + result); return result; &#125;&#125; 5.1.4、提出问题①现有代码缺陷 针对带日志功能的实现类，我们发现有如下缺陷： 对核心业务功能有干扰，导致程序员在开发核心业务功能时分散了精力 附加功能分散在各个业务功能方法中，不利于统一维护 ②解决思路 解决这两个问题，核心就是：解耦。我们需要把附加功能从业务功能代码中抽取出来。 ③困难 解决问题的困难：要抽取的代码在方法内部，靠以前把子类中的重复代码抽取到父类的方式没法解决。所以需要引入新的技术。 5.2、代理模式5.2.1、概念①介绍 二十三种设计模式中的一种，属于结构型模式。它的作用就是通过提供一个代理类，让我们在调用目标方法的时候，不再是直接对目标方法进行调用，而是通过代理类间接调用。让不属于目标方法核心逻辑的代码从目标方法中剥离出来——解耦。调用目标方法时先调用代理对象的方法，减少对目标方法的调用和打扰，同时让附加功能能够集中在一起也有利于统一维护。 使用代理后： ②生活中的代理 广告商找大明星拍广告需要经过经纪人 合作伙伴找大老板谈合作要约见面时间需要经过秘书 房产中介是买卖双方的代理 ③相关术语 代理：将非核心逻辑剥离出来以后，封装这些非核心逻辑的类、对象、方法。 目标：被代理“套用”了非核心逻辑代码的类、对象、方法。 5.2.2、静态代理创建静态代理类： 1234567891011121314151617181920212223public class CalculatorStaticProxy implements Calculator &#123; // 将被代理的目标对象声明为成员变量 private Calculator target; public CalculatorStaticProxy(Calculator target) &#123; this.target = target; &#125; @Override public int add(int i, int j) &#123; // 附加功能由代理类中的代理方法来实现 System.out.println(&quot;[日志] add 方法开始了，参数是：&quot; + i + &quot;,&quot; + j); // 通过目标对象来实现核心业务逻辑 int addResult = target.add(i, j); System.out.println(&quot;[日志] add 方法结束了，结果是：&quot; + addResult); return addResult; &#125;&#125; 静态代理确实实现了解耦，但是由于代码都写死了，完全不具备任何的灵活性。就拿日志功能来说，将来其他地方也需要附加日志，那还得再声明更多个静态代理类，那就产生了大量重复的代码，日志功能还是分散的，没有统一管理。 提出进一步的需求：将日志功能集中到一个代理类中，将来有任何日志需求，都通过这一个代理类来实现。这就需要使用动态代理技术了。 5.2.3、动态代理 生产代理对象的工厂类： 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class ProxyFactory &#123; private Object target; public ProxyFactory(Object target) &#123; this.target = target; &#125; public Object getProxy()&#123; /** * newProxyInstance()：创建一个代理实例 * 其中有三个参数： * 1、classLoader：加载动态生成的代理类的类加载器 * 2、interfaces：目标对象实现的所有接口的class对象所组成的数组 * 3、invocationHandler：设置代理对象实现目标对象方法的过程，即代理类中如何重写接口中的抽象方法 */ ClassLoader classLoader = target.getClass().getClassLoader(); Class&lt;?&gt;[] interfaces = target.getClass().getInterfaces(); InvocationHandler invocationHandler = new InvocationHandler() &#123; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; /** * proxy：代理对象 * method：代理对象需要实现的方法，即其中需要重写的方法 * args：method所对应方法的参数 */ Object result = null; try &#123; System.out.println(&quot;[动态代理][日志] &quot;+method.getName()+&quot;，参数：&quot;+ Arrays.toString(args)); result = method.invoke(target, args); System.out.println(&quot;[动态代理][日志] &quot;+method.getName()+&quot;，结果：&quot;+ result); &#125; catch (Exception e) &#123; e.printStackTrace(); System.out.println(&quot;[动态代理][日志] &quot;+method.getName()+&quot;，异常：&quot;+e.getMessage()); &#125; finally &#123; System.out.println(&quot;[动态代理][日志] &quot;+method.getName()+&quot;，方法执行完毕&quot;); &#125; return result; &#125; &#125;; return Proxy.newProxyInstance(classLoader, interfaces, invocationHandler); &#125;&#125; 5.2.4、测试1234567@Testpublic void testDynamicProxy()&#123; ProxyFactory factory = new ProxyFactory(new CalculatorLogImpl()); Calculator proxy = (Calculator) factory.getProxy(); proxy.div(1,0); //proxy.div(1,1);&#125; 5.3、AOP概念及相关术语5.3.1、概述AOP（Aspect Oriented Programming）是一种设计思想，是软件设计领域中的面向切面编程，它是面向对象编程的一种补充和完善，它以通过预编译方式和运行期动态代理方式实现，在不修改源代码的情况下，给程序动态统一添加额外功能的一种技术。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。 5.3.2、相关术语①横切关注点分散在每个各个模块中解决同一样的问题，如用户验证、日志管理、事务处理、数据缓存都属于横切关注点。 从每个方法中抽取出来的同一类非核心业务。在同一个项目中，我们可以使用多个横切关注点对相关方法进行多个不同方面的增强。 这个概念不是语法层面的，而是根据附加功能的逻辑上的需要：有十个附加功能，就有十个横切关注点。 ②通知（增强）增强，通俗说，就是你想要增强的功能，比如 安全，事务，日志等。 每一个横切关注点上要做的事情都需要写一个方法来实现，这样的方法就叫通知方法。 前置通知：在被代理的目标方法前执行 返回通知：在被代理的目标方法成功结束后执行（寿终正寝） 异常通知：在被代理的目标方法异常结束后执行（死于非命） 后置通知：在被代理的目标方法最终结束后执行（盖棺定论） 环绕通知：使用try…catch…finally结构围绕整个被代理的目标方法，包括上面四种通知对应的所有位置 ③切面封装通知方法的类。 ④目标被代理的目标对象。 ⑤代理向目标对象应用通知之后创建的代理对象。 ⑥连接点这也是一个纯逻辑概念，不是语法定义的。 把方法排成一排，每一个横切位置看成x轴方向，把方法从上到下执行的顺序看成y轴，x轴和y轴的交叉点就是连接点。通俗说，就是spring允许你使用通知的地方 ⑦切入点定位连接点的方式。 每个类的方法中都包含多个连接点，所以连接点是类中客观存在的事物（从逻辑上来说）。 如果把连接点看作数据库中的记录，那么切入点就是查询记录的 SQL 语句。 Spring 的 AOP 技术可以通过切入点定位到特定的连接点。通俗说，要实际去增强的方法 切点通过 org.springframework.aop.Pointcut 接口进行描述，它使用类和方法作为连接点的查询条件。 5.3.3、作用 简化代码：把方法中固定位置的重复的代码抽取出来，让被抽取的方法更专注于自己的核心功能，提高内聚性。 代码增强：把特定的功能封装到切面类中，看哪里有需要，就往上套，被套用了切面逻辑的方法就被切面给增强了。 5.4、基于注解的AOP5.4.1、技术说明 动态代理分为JDK动态代理和cglib动态代理 当目标类有接口的情况使用JDK动态代理和cglib动态代理，没有接口时只能使用cglib动态代理 JDK动态代理动态生成的代理类会在com.sun.proxy包下，类名为$proxy1，和目标类实现相同的接口 cglib动态代理动态生成的代理类会和目标在在相同的包下，会继承目标类 动态代理（InvocationHandler）：JDK原生的实现方式，需要被代理的目标类必须实现接口。因为这个技术要求代理对象和目标对象实现同样的接口（兄弟两个拜把子模式）。 cglib：通过继承被代理的目标类（认干爹模式）实现代理，所以不需要目标类实现接口。 AspectJ：是AOP思想的一种实现。本质上是静态代理，将代理逻辑“织入”被代理的目标类编译得到的字节码文件，所以最终效果是动态的。weaver就是织入器。Spring只是借用了AspectJ中的注解。 5.4.2、准备工作①添加依赖 在IOC所需依赖基础上再加入下面依赖即可： 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;dependencies&gt; &lt;!--spring context依赖--&gt; &lt;!--当你引入Spring Context依赖之后，表示将Spring的基础依赖引入了--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;6.0.2&lt;/version&gt; &lt;/dependency&gt; &lt;!--spring aop依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;version&gt;6.0.2&lt;/version&gt; &lt;/dependency&gt; &lt;!--spring aspects依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt; &lt;version&gt;6.0.2&lt;/version&gt; &lt;/dependency&gt; &lt;!--junit5测试--&gt; &lt;dependency&gt; &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt; &lt;artifactId&gt;junit-jupiter-api&lt;/artifactId&gt; &lt;version&gt;5.3.1&lt;/version&gt; &lt;/dependency&gt; &lt;!--log4j2的依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j-core&lt;/artifactId&gt; &lt;version&gt;2.19.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j-slf4j2-impl&lt;/artifactId&gt; &lt;version&gt;2.19.0&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; ②准备被代理的目标资源 接口： 1234567891011public interface Calculator &#123; int add(int i, int j); int sub(int i, int j); int mul(int i, int j); int div(int i, int j); &#125; 实现类： 12345678910111213141516171819202122232425262728293031323334353637383940414243@Componentpublic class CalculatorImpl implements Calculator &#123; @Override public int add(int i, int j) &#123; int result = i + j; System.out.println(&quot;方法内部 result = &quot; + result); return result; &#125; @Override public int sub(int i, int j) &#123; int result = i - j; System.out.println(&quot;方法内部 result = &quot; + result); return result; &#125; @Override public int mul(int i, int j) &#123; int result = i * j; System.out.println(&quot;方法内部 result = &quot; + result); return result; &#125; @Override public int div(int i, int j) &#123; int result = i / j; System.out.println(&quot;方法内部 result = &quot; + result); return result; &#125;&#125; 5.4.3、创建切面类并配置123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// @Aspect表示这个类是一个切面类@Aspect// @Component注解保证这个切面类能够放入IOC容器@Componentpublic class LogAspect &#123; @Before(&quot;execution(public int com.atguigu.aop.annotation.CalculatorImpl.*(..))&quot;) public void beforeMethod(JoinPoint joinPoint)&#123; String methodName = joinPoint.getSignature().getName(); String args = Arrays.toString(joinPoint.getArgs()); System.out.println(&quot;Logger--&gt;前置通知，方法名：&quot;+methodName+&quot;，参数：&quot;+args); &#125; @After(&quot;execution(* com.atguigu.aop.annotation.CalculatorImpl.*(..))&quot;) public void afterMethod(JoinPoint joinPoint)&#123; String methodName = joinPoint.getSignature().getName(); System.out.println(&quot;Logger--&gt;后置通知，方法名：&quot;+methodName); &#125; @AfterReturning(value = &quot;execution(* com.atguigu.aop.annotation.CalculatorImpl.*(..))&quot;, returning = &quot;result&quot;) public void afterReturningMethod(JoinPoint joinPoint, Object result)&#123; String methodName = joinPoint.getSignature().getName(); System.out.println(&quot;Logger--&gt;返回通知，方法名：&quot;+methodName+&quot;，结果：&quot;+result); &#125; @AfterThrowing(value = &quot;execution(* com.atguigu.aop.annotation.CalculatorImpl.*(..))&quot;, throwing = &quot;ex&quot;) public void afterThrowingMethod(JoinPoint joinPoint, Throwable ex)&#123; String methodName = joinPoint.getSignature().getName(); System.out.println(&quot;Logger--&gt;异常通知，方法名：&quot;+methodName+&quot;，异常：&quot;+ex); &#125; @Around(&quot;execution(* com.atguigu.aop.annotation.CalculatorImpl.*(..))&quot;) public Object aroundMethod(ProceedingJoinPoint joinPoint)&#123; String methodName = joinPoint.getSignature().getName(); String args = Arrays.toString(joinPoint.getArgs()); Object result = null; try &#123; System.out.println(&quot;环绕通知--&gt;目标对象方法执行之前&quot;); //目标对象（连接点）方法的执行 result = joinPoint.proceed(); System.out.println(&quot;环绕通知--&gt;目标对象方法返回值之后&quot;); &#125; catch (Throwable throwable) &#123; throwable.printStackTrace(); System.out.println(&quot;环绕通知--&gt;目标对象方法出现异常时&quot;); &#125; finally &#123; System.out.println(&quot;环绕通知--&gt;目标对象方法执行完毕&quot;); &#125; return result; &#125; &#125; 在Spring的配置文件中配置： 123456789101112131415161718192021&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt; &lt;!-- 基于注解的AOP的实现： 1、将目标对象和切面交给IOC容器管理（注解+扫描） 2、开启AspectJ的自动代理，为目标对象自动生成代理 3、将切面类通过注解@Aspect标识 --&gt; &lt;context:component-scan base-package=&quot;com.atguigu.aop.annotation&quot;&gt;&lt;/context:component-scan&gt; &lt;aop:aspectj-autoproxy /&gt;&lt;/beans&gt; 执行测试： 12345678910111213public class CalculatorTest &#123; private Logger logger = LoggerFactory.getLogger(CalculatorTest.class); @Test public void testAdd()&#123; ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;); Calculator calculator = ac.getBean( Calculator.class); int add = calculator.add(1, 1); logger.info(&quot;执行成功:&quot;+add); &#125;&#125; 执行结果： 5.4.4、各种通知 前置通知：使用@Before注解标识，在被代理的目标方法前执行 返回通知：使用@AfterReturning注解标识，在被代理的目标方法成功结束后执行（寿终正寝） 异常通知：使用@AfterThrowing注解标识，在被代理的目标方法异常结束后执行（死于非命） 后置通知：使用@After注解标识，在被代理的目标方法最终结束后执行（盖棺定论） 环绕通知：使用@Around注解标识，使用try…catch…finally结构围绕整个被代理的目标方法，包括上面四种通知对应的所有位置 各种通知的执行顺序： Spring版本5.3.x以前： 前置通知 目标操作 后置通知 返回通知或异常通知 Spring版本5.3.x以后： 前置通知 目标操作 返回通知或异常通知 后置通知 5.4.5、切入点表达式语法①作用 ②语法细节 用*号代替“权限修饰符”和“返回值”部分表示“权限修饰符”和“返回值”不限 在包名的部分，一个“*”号只能代表包的层次结构中的一层，表示这一层是任意的。 例如：*.Hello匹配com.Hello，不匹配com.atguigu.Hello 在包名的部分，使用“*..”表示包名任意、包的层次深度任意 在类名的部分，类名部分整体用*号代替，表示类名任意 在类名的部分，可以使用*号代替类名的一部分 例如：*Service匹配所有名称以Service结尾的类或接口 在方法名部分，可以使用*号表示方法名任意 在方法名部分，可以使用*号代替方法名的一部分 例如：*Operation匹配所有方法名以Operation结尾的方法 在方法参数列表部分，使用(..)表示参数列表任意 在方法参数列表部分，使用(int,..)表示参数列表以一个int类型的参数开头 在方法参数列表部分，基本数据类型和对应的包装类型是不一样的 切入点表达式中使用 int 和实际方法中 Integer 是不匹配的 在方法返回值部分，如果想要明确指定一个返回值类型，那么必须同时写明权限修饰符 例如：execution(public int ..Service.(.., int)) 正确 例如：execution( int *..Service.(.., int)) 错误 5.4.6、重用切入点表达式①声明 12@Pointcut(&quot;execution(* com.atguigu.aop.annotation.*.*(..))&quot;)public void pointCut()&#123;&#125; ②在同一个切面中使用 123456@Before(&quot;pointCut()&quot;)public void beforeMethod(JoinPoint joinPoint)&#123; String methodName = joinPoint.getSignature().getName(); String args = Arrays.toString(joinPoint.getArgs()); System.out.println(&quot;Logger--&gt;前置通知，方法名：&quot;+methodName+&quot;，参数：&quot;+args);&#125; ③在不同切面中使用 123456@Before(&quot;com.atguigu.aop.CommonPointCut.pointCut()&quot;)public void beforeMethod(JoinPoint joinPoint)&#123; String methodName = joinPoint.getSignature().getName(); String args = Arrays.toString(joinPoint.getArgs()); System.out.println(&quot;Logger--&gt;前置通知，方法名：&quot;+methodName+&quot;，参数：&quot;+args);&#125; 5.4.7、获取通知的相关信息①获取连接点信息 获取连接点信息可以在通知方法的参数位置设置JoinPoint类型的形参 12345678@Before(&quot;execution(public int com.atguigu.aop.annotation.CalculatorImpl.*(..))&quot;)public void beforeMethod(JoinPoint joinPoint)&#123; //获取连接点的签名信息 String methodName = joinPoint.getSignature().getName(); //获取目标方法到的实参信息 String args = Arrays.toString(joinPoint.getArgs()); System.out.println(&quot;Logger--&gt;前置通知，方法名：&quot;+methodName+&quot;，参数：&quot;+args);&#125; ②获取目标方法的返回值 @AfterReturning中的属性returning，用来将通知方法的某个形参，接收目标方法的返回值 12345@AfterReturning(value = &quot;execution(* com.atguigu.aop.annotation.CalculatorImpl.*(..))&quot;, returning = &quot;result&quot;)public void afterReturningMethod(JoinPoint joinPoint, Object result)&#123; String methodName = joinPoint.getSignature().getName(); System.out.println(&quot;Logger--&gt;返回通知，方法名：&quot;+methodName+&quot;，结果：&quot;+result);&#125; ③获取目标方法的异常 @AfterThrowing中的属性throwing，用来将通知方法的某个形参，接收目标方法的异常 12345@AfterThrowing(value = &quot;execution(* com.atguigu.aop.annotation.CalculatorImpl.*(..))&quot;, throwing = &quot;ex&quot;)public void afterThrowingMethod(JoinPoint joinPoint, Throwable ex)&#123; String methodName = joinPoint.getSignature().getName(); System.out.println(&quot;Logger--&gt;异常通知，方法名：&quot;+methodName+&quot;，异常：&quot;+ex);&#125; 5.4.8、环绕通知123456789101112131415161718@Around(&quot;execution(* com.atguigu.aop.annotation.CalculatorImpl.*(..))&quot;)public Object aroundMethod(ProceedingJoinPoint joinPoint)&#123; String methodName = joinPoint.getSignature().getName(); String args = Arrays.toString(joinPoint.getArgs()); Object result = null; try &#123; System.out.println(&quot;环绕通知--&gt;目标对象方法执行之前&quot;); //目标方法的执行，目标方法的返回值一定要返回给外界调用者 result = joinPoint.proceed(); System.out.println(&quot;环绕通知--&gt;目标对象方法返回值之后&quot;); &#125; catch (Throwable throwable) &#123; throwable.printStackTrace(); System.out.println(&quot;环绕通知--&gt;目标对象方法出现异常时&quot;); &#125; finally &#123; System.out.println(&quot;环绕通知--&gt;目标对象方法执行完毕&quot;); &#125; return result;&#125; 5.4.9、切面的优先级相同目标方法上同时存在多个切面时，切面的优先级控制切面的内外嵌套顺序。 优先级高的切面：外面 优先级低的切面：里面 使用@Order注解可以控制切面的优先级： @Order(较小的数)：优先级高 @Order(较大的数)：优先级低 5.5、基于XML的AOP5.5.1、准备工作参考基于注解的AOP环境 5.5.2、实现1234567891011121314&lt;context:component-scan base-package=&quot;com.atguigu.aop.xml&quot;&gt;&lt;/context:component-scan&gt;&lt;aop:config&gt; &lt;!--配置切面类--&gt; &lt;aop:aspect ref=&quot;loggerAspect&quot;&gt; &lt;aop:pointcut id=&quot;pointCut&quot; expression=&quot;execution(* com.atguigu.aop.xml.CalculatorImpl.*(..))&quot;/&gt; &lt;aop:before method=&quot;beforeMethod&quot; pointcut-ref=&quot;pointCut&quot;&gt;&lt;/aop:before&gt; &lt;aop:after method=&quot;afterMethod&quot; pointcut-ref=&quot;pointCut&quot;&gt;&lt;/aop:after&gt; &lt;aop:after-returning method=&quot;afterReturningMethod&quot; returning=&quot;result&quot; pointcut-ref=&quot;pointCut&quot;&gt;&lt;/aop:after-returning&gt; &lt;aop:after-throwing method=&quot;afterThrowingMethod&quot; throwing=&quot;ex&quot; pointcut-ref=&quot;pointCut&quot;&gt;&lt;/aop:after-throwing&gt; &lt;aop:around method=&quot;aroundMethod&quot; pointcut-ref=&quot;pointCut&quot;&gt;&lt;/aop:around&gt; &lt;/aop:aspect&gt;&lt;/aop:config&gt; 6、单元测试：JUnit在之前的测试方法中，几乎都能看到以下的两行代码： 12ApplicationContext context = new ClassPathXmlApplicationContext(&quot;xxx.xml&quot;);Xxxx xxx = context.getBean(Xxxx.class); 这两行代码的作用是创建Spring容器，最终获取到对象，但是每次测试都需要重复编写。针对上述问题，我们需要的是程序能自动帮我们创建容器。我们都知道JUnit无法知晓我们是否使用了 Spring 框架，更不用说帮我们创建 Spring 容器了。Spring提供了一个运行器，可以读取配置文件（或注解）来创建容器。我们只需要告诉它配置文件位置就可以了。这样一来，我们通过Spring整合JUnit可以使程序创建spring容器了 6.1、整合JUnit56.1.1、搭建子模块搭建spring-junit模块 6.1.2、引入依赖1234567891011121314151617181920212223242526272829303132333435&lt;dependencies&gt; &lt;!--spring context依赖--&gt; &lt;!--当你引入Spring Context依赖之后，表示将Spring的基础依赖引入了--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;6.0.2&lt;/version&gt; &lt;/dependency&gt; &lt;!--spring对junit的支持相关依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;6.0.2&lt;/version&gt; &lt;/dependency&gt; &lt;!--junit5测试--&gt; &lt;dependency&gt; &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt; &lt;artifactId&gt;junit-jupiter-api&lt;/artifactId&gt; &lt;version&gt;5.9.0&lt;/version&gt; &lt;/dependency&gt; &lt;!--log4j2的依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j-core&lt;/artifactId&gt; &lt;version&gt;2.19.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j-slf4j2-impl&lt;/artifactId&gt; &lt;version&gt;2.19.0&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 6.1.3、添加配置文件beans.xml 12345678&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;context:component-scan base-package=&quot;com.atguigu.spring6.bean&quot;/&gt;&lt;/beans&gt; copy日志文件：log4j2.xml 6.1.4、添加java类1234567891011package com.atguigu.spring6.bean;import org.springframework.stereotype.Component;@Componentpublic class User &#123; public User() &#123; System.out.println(&quot;run user&quot;); &#125;&#125; 6.1.5、测试123456789101112131415161718192021222324import com.atguigu.spring6.bean.User;import org.junit.jupiter.api.Test;import org.junit.jupiter.api.extension.ExtendWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit.jupiter.SpringExtension;import org.springframework.test.context.junit.jupiter.SpringJUnitConfig;//两种方式均可//方式一//@ExtendWith(SpringExtension.class)//@ContextConfiguration(&quot;classpath:beans.xml&quot;)//方式二@SpringJUnitConfig(locations = &quot;classpath:beans.xml&quot;)public class SpringJUnit5Test &#123; @Autowired private User user; @Test public void testUser()&#123; System.out.println(user); &#125;&#125; 6.2、整合JUnit4JUnit4在公司也会经常用到，在此也学习一下 6.2.1、添加依赖123456&lt;!-- junit测试 --&gt;&lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt;&lt;/dependency&gt; 6.2.2、测试12345678910111213141516171819import com.atguigu.spring6.bean.User;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(&quot;classpath:beans.xml&quot;)public class SpringJUnit4Test &#123; @Autowired private User user; @Test public void testUser()&#123; System.out.println(user); &#125;&#125; 7、事务7.1、JdbcTemplate7.1.1、简介 Spring 框架对 JDBC 进行封装，使用 JdbcTemplate 方便实现对数据库操作 7.1.2、准备工作①搭建子模块 搭建子模块：spring-jdbc-tx ②加入依赖 1234567891011121314151617181920&lt;dependencies&gt; &lt;!--spring jdbc Spring 持久化层支持jar包--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;6.0.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- MySQL驱动 --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.30&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 数据源 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.2.15&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; ③创建jdbc.properties 1234jdbc.user=rootjdbc.password=rootjdbc.url=jdbc:mysql://localhost:3306/spring?characterEncoding=utf8&amp;useSSL=falsejdbc.driver=com.mysql.cj.jdbc.Driver ④配置Spring的配置文件 beans.xml 123456789101112131415161718192021222324252627&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;!-- 导入外部属性文件 --&gt; &lt;context:property-placeholder location=&quot;classpath:jdbc.properties&quot; /&gt; &lt;!-- 配置数据源 --&gt; &lt;bean id=&quot;druidDataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot;/&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;$&#123;jdbc.driver&#125;&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.user&#125;&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;/&gt; &lt;/bean&gt; &lt;!-- 配置 JdbcTemplate --&gt; &lt;bean id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt; &lt;!-- 装配数据源 --&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;druidDataSource&quot;/&gt; &lt;/bean&gt;&lt;/beans&gt; ⑤准备数据库与测试表 1234567891011CREATE DATABASE `spring`;use `spring`;CREATE TABLE `t_emp` ( `id` int(11) NOT NULL AUTO_INCREMENT, `name` varchar(20) DEFAULT NULL COMMENT &#x27;姓名&#x27;, `age` int(11) DEFAULT NULL COMMENT &#x27;年龄&#x27;, `sex` varchar(2) DEFAULT NULL COMMENT &#x27;性别&#x27;, PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4; 7.1.3、实现CURD①装配 JdbcTemplate创建测试类，整合JUnit，注入JdbcTemplate 12345678910111213package com.atguigu.spring6;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.jdbc.core.JdbcTemplate;import org.springframework.test.context.junit.jupiter.SpringJUnitConfig;@SpringJUnitConfig(locations = &quot;classpath:beans.xml&quot;)public class JDBCTemplateTest &#123; @Autowired private JdbcTemplate jdbcTemplate; &#125; ②测试增删改功能123456789101112131415@Test//测试增删改功能public void testUpdate()&#123; //添加功能 String sql = &quot;insert into t_emp values(null,?,?,?)&quot;; int result = jdbcTemplate.update(sql, &quot;张三&quot;, 23, &quot;男&quot;); //修改功能 //String sql = &quot;update t_emp set name=? where id=?&quot;; //int result = jdbcTemplate.update(sql, &quot;张三atguigu&quot;, 1); //删除功能 //String sql = &quot;delete from t_emp where id=?&quot;; //int result = jdbcTemplate.update(sql, 1);&#125; ③查询数据返回对象1234567891011121314151617181920public class Emp &#123; private Integer id; private String name; private Integer age; private String sex; //生成get和set方法 //...... @Override public String toString() &#123; return &quot;Emp&#123;&quot; + &quot;id=&quot; + id + &quot;, name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, age=&quot; + age + &quot;, sex=&#x27;&quot; + sex + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125;&#125; 12345678910111213141516171819202122//查询：返回对象@Testpublic void testSelectObject() &#123; //写法一// String sql = &quot;select * from t_emp where id=?&quot;;// Emp empResult = jdbcTemplate.queryForObject(sql,// (rs, rowNum) -&gt; &#123;// Emp emp = new Emp();// emp.setId(rs.getInt(&quot;id&quot;));// emp.setName(rs.getString(&quot;name&quot;));// emp.setAge(rs.getInt(&quot;age&quot;));// emp.setSex(rs.getString(&quot;sex&quot;));// return emp;// &#125;, 1);// System.out.println(empResult); //写法二 String sql = &quot;select * from t_emp where id=?&quot;; Emp emp = jdbcTemplate.queryForObject(sql, new BeanPropertyRowMapper&lt;&gt;(Emp.class),1); System.out.println(emp);&#125; ④查询数据返回list集合1234567@Test//查询多条数据为一个list集合public void testSelectList()&#123; String sql = &quot;select * from t_emp&quot;; List&lt;Emp&gt; list = jdbcTemplate.query(sql, new BeanPropertyRowMapper&lt;&gt;(Emp.class)); System.out.println(list);&#125; ⑤查询返回单个的值1234567@Test//查询单行单列的值public void selectCount()&#123; String sql = &quot;select count(id) from t_emp&quot;; Integer count = jdbcTemplate.queryForObject(sql, Integer.class); System.out.println(count);&#125; 7.2、声明式事务概念7.2.1、事务基本概念①什么是事务数据库事务( transaction)是访问并可能操作各种数据项的一个数据库操作序列，这些操作要么全部执行,要么全部不执行，是一个不可分割的工作单位。事务由事务开始与事务结束之间执行的全部数据库操作组成。 ②事务的特性A：原子性(Atomicity) 一个事务(transaction)中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。 C：一致性(Consistency) 事务的一致性指的是在一个事务执行之前和执行之后数据库都必须处于一致性状态。 如果事务成功地完成，那么系统中所有变化将正确地应用，系统处于有效状态。 如果在事务中出现错误，那么系统中的所有变化将自动地回滚，系统返回到原始状态。 I：隔离性(Isolation) 指的是在并发环境中，当不同的事务同时操纵相同的数据时，每个事务都有各自的完整数据空间。由并发事务所做的修改必须与任何其他并发事务所做的修改隔离。事务查看数据更新时，数据所处的状态要么是另一事务修改它之前的状态，要么是另一事务修改它之后的状态，事务不会查看到中间状态的数据。 D：持久性(Durability) 指的是只要事务成功结束，它对数据库所做的更新就必须保存下来。即使发生系统崩溃，重新启动数据库系统后，数据库还能恢复到事务成功结束时的状态。 7.2.2、编程式事务事务功能的相关操作全部通过自己编写代码来实现： 1234567891011121314151617181920212223Connection conn = ...; try &#123; // 开启事务：关闭事务的自动提交 conn.setAutoCommit(false); // 核心操作 // 提交事务 conn.commit(); &#125;catch(Exception e)&#123; // 回滚事务 conn.rollBack(); &#125;finally&#123; // 释放数据库连接 conn.close(); &#125; 编程式的实现方式存在缺陷： 细节没有被屏蔽：具体操作过程中，所有细节都需要程序员自己来完成，比较繁琐。 代码复用性不高：如果没有有效抽取出来，每次实现功能都需要自己编写代码，代码就没有得到复用。 7.2.3、声明式事务既然事务控制的代码有规律可循，代码的结构基本是确定的，所以框架就可以将固定模式的代码抽取出来，进行相关的封装。 封装起来后，我们只需要在配置文件中进行简单的配置即可完成操作。 好处1：提高开发效率 好处2：消除了冗余的代码 好处3：框架会综合考虑相关领域中在实际开发环境下有可能遇到的各种问题，进行了健壮性、性能等各个方面的优化 所以，我们可以总结下面两个概念： 编程式：自己写代码实现功能 声明式：通过配置让框架实现功能 7.3、基于注解的声明式事务7.3.1、准备工作①添加配置 在beans.xml添加配置 12&lt;!--扫描组件--&gt;&lt;context:component-scan base-package=&quot;com.atguigu.spring6&quot;&gt;&lt;/context:component-scan&gt; ②创建表 123456789101112131415CREATE TABLE `t_book` ( `book_id` int(11) NOT NULL AUTO_INCREMENT COMMENT &#x27;主键&#x27;, `book_name` varchar(20) DEFAULT NULL COMMENT &#x27;图书名称&#x27;, `price` int(11) DEFAULT NULL COMMENT &#x27;价格&#x27;, `stock` int(10) unsigned DEFAULT NULL COMMENT &#x27;库存（无符号）&#x27;, PRIMARY KEY (`book_id`)) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8;insert into `t_book`(`book_id`,`book_name`,`price`,`stock`) values (1,&#x27;斗破苍穹&#x27;,80,100),(2,&#x27;斗罗大陆&#x27;,50,100);CREATE TABLE `t_user` ( `user_id` int(11) NOT NULL AUTO_INCREMENT COMMENT &#x27;主键&#x27;, `username` varchar(20) DEFAULT NULL COMMENT &#x27;用户名&#x27;, `balance` int(10) unsigned DEFAULT NULL COMMENT &#x27;余额（无符号）&#x27;, PRIMARY KEY (`user_id`)) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8;insert into `t_user`(`user_id`,`username`,`balance`) values (1,&#x27;admin&#x27;,50); ③创建组件 创建BookController： 123456789101112package com.atguigu.spring6.controller;@Controllerpublic class BookController &#123; @Autowired private BookService bookService; public void buyBook(Integer bookId, Integer userId)&#123; bookService.buyBook(bookId, userId); &#125;&#125; 创建接口BookService： 1234package com.atguigu.spring6.service;public interface BookService &#123; void buyBook(Integer bookId, Integer userId);&#125; 创建实现类BookServiceImpl： 1234567891011121314151617package com.atguigu.spring6.service.impl;@Servicepublic class BookServiceImpl implements BookService &#123; @Autowired private BookDao bookDao; @Override public void buyBook(Integer bookId, Integer userId) &#123; //查询图书的价格 Integer price = bookDao.getPriceByBookId(bookId); //更新图书的库存 bookDao.updateStock(bookId); //更新用户的余额 bookDao.updateBalance(userId, price); &#125;&#125; 创建接口BookDao： 12345678package com.atguigu.spring6.dao;public interface BookDao &#123; Integer getPriceByBookId(Integer bookId); void updateStock(Integer bookId); void updateBalance(Integer userId, Integer price);&#125; 创建实现类BookDaoImpl： 12345678910111213141516171819202122232425package com.atguigu.spring6.dao.impl;@Repositorypublic class BookDaoImpl implements BookDao &#123; @Autowired private JdbcTemplate jdbcTemplate; @Override public Integer getPriceByBookId(Integer bookId) &#123; String sql = &quot;select price from t_book where book_id = ?&quot;; return jdbcTemplate.queryForObject(sql, Integer.class, bookId); &#125; @Override public void updateStock(Integer bookId) &#123; String sql = &quot;update t_book set stock = stock - 1 where book_id = ?&quot;; jdbcTemplate.update(sql, bookId); &#125; @Override public void updateBalance(Integer userId, Integer price) &#123; String sql = &quot;update t_user set balance = balance - ? where user_id = ?&quot;; jdbcTemplate.update(sql, price, userId); &#125;&#125; 7.3.2、测试无事务情况①创建测试类 1234567891011121314151617import org.junit.jupiter.api.Test;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.jdbc.core.JdbcTemplate;import org.springframework.test.context.junit.jupiter.SpringJUnitConfig;@SpringJUnitConfig(locations = &quot;classpath:beans.xml&quot;)public class TxByAnnotationTest &#123; @Autowired private BookController bookController; @Test public void testBuyBook()&#123; bookController.buyBook(1, 1); &#125;&#125; ②模拟场景 用户购买图书，先查询图书的价格，再更新图书的库存和用户的余额 假设用户id为1的用户，购买id为1的图书 用户余额为50，而图书价格为80 购买图书之后，用户的余额为-30，数据库中余额字段设置了无符号，因此无法将-30插入到余额字段 此时执行sql语句会抛出SQLException ③观察结果 因为没有添加事务，图书的库存更新了，但是用户的余额没有更新 显然这样的结果是错误的，购买图书是一个完整的功能，更新库存和更新余额要么都成功要么都失败 7.3.3、加入事务①添加事务配置在spring配置文件中引入tx命名空间 1234567891011&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd&quot;&gt; 在Spring的配置文件中添加配置： 12345678910&lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;druidDataSource&quot;&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!-- 开启事务的注解驱动 通过注解@Transactional所标识的方法或标识的类中所有的方法，都会被事务管理器管理事务--&gt;&lt;!-- transaction-manager属性的默认值是transactionManager，如果事务管理器bean的id正好就是这个默认值，则可以省略这个属性 --&gt;&lt;tx:annotation-driven transaction-manager=&quot;transactionManager&quot; /&gt; ②添加事务注解因为service层表示业务逻辑层，一个方法表示一个完成的功能，因此处理事务一般在service层处理 在BookServiceImpl的buybook()添加注解@Transactional ③观察结果由于使用了Spring的声明式事务，更新库存和更新余额都没有执行 7.3.4、@Transactional注解标识的位置@Transactional标识在方法上，则只会影响该方法 @Transactional标识的类上，则会影响类中所有的方法 7.3.5、事务属性：只读①介绍 对一个查询操作来说，如果我们把它设置成只读，就能够明确告诉数据库，这个操作不涉及写操作。这样数据库就能够针对查询操作来进行优化。 ②使用方式 12345678910@Transactional(readOnly = true)public void buyBook(Integer bookId, Integer userId) &#123; //查询图书的价格 Integer price = bookDao.getPriceByBookId(bookId); //更新图书的库存 bookDao.updateStock(bookId); //更新用户的余额 bookDao.updateBalance(userId, price); //System.out.println(1/0);&#125; ③注意 对增删改操作设置只读会抛出下面异常： Caused by: java.sql.SQLException: Connection is read-only. Queries leading to data modification are not allowed 7.3.6、事务属性：超时①介绍 事务在执行过程中，有可能因为遇到某些问题，导致程序卡住，从而长时间占用数据库资源。而长时间占用资源，大概率是因为程序运行出现了问题（可能是Java程序或MySQL数据库或网络连接等等）。此时这个很可能出问题的程序应该被回滚，撤销它已做的操作，事务结束，把资源让出来，让其他正常程序可以执行。 概括来说就是一句话：超时回滚，释放资源。 ②使用方式 12345678910111213141516//超时时间单位秒@Transactional(timeout = 3)public void buyBook(Integer bookId, Integer userId) &#123; try &#123; TimeUnit.SECONDS.sleep(5); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; //查询图书的价格 Integer price = bookDao.getPriceByBookId(bookId); //更新图书的库存 bookDao.updateStock(bookId); //更新用户的余额 bookDao.updateBalance(userId, price); //System.out.println(1/0);&#125; ③观察结果 执行过程中抛出异常： org.springframework.transaction.TransactionTimedOutException: Transaction timed out: deadline was Fri Jun 04 16:25:39 CST 2022 7.3.7、事务属性：回滚策略①介绍 声明式事务默认只针对运行时异常回滚，编译时异常不回滚。 可以通过@Transactional中相关属性设置回滚策略 rollbackFor属性：需要设置一个Class类型的对象 rollbackForClassName属性：需要设置一个字符串类型的全类名 noRollbackFor属性：需要设置一个Class类型的对象 rollbackFor属性：需要设置一个字符串类型的全类名 ②使用方式 1234567891011@Transactional(noRollbackFor = ArithmeticException.class)//@Transactional(noRollbackForClassName = &quot;java.lang.ArithmeticException&quot;)public void buyBook(Integer bookId, Integer userId) &#123; //查询图书的价格 Integer price = bookDao.getPriceByBookId(bookId); //更新图书的库存 bookDao.updateStock(bookId); //更新用户的余额 bookDao.updateBalance(userId, price); System.out.println(1/0);&#125; ③观察结果 虽然购买图书功能中出现了数学运算异常（ArithmeticException），但是我们设置的回滚策略是，当出现ArithmeticException不发生回滚，因此购买图书的操作正常执行 7.3.8、事务属性：隔离级别①介绍 数据库系统必须具有隔离并发运行各个事务的能力，使它们不会相互影响，避免各种并发问题。一个事务与其他事务隔离的程度称为隔离级别。SQL标准中规定了多种事务隔离级别，不同隔离级别对应不同的干扰程度，隔离级别越高，数据一致性就越好，但并发性越弱。 隔离级别一共有四种： 读未提交：READ UNCOMMITTED 允许Transaction01读取Transaction02未提交的修改。 读已提交：READ COMMITTED、 要求Transaction01只能读取Transaction02已提交的修改。 可重复读：REPEATABLE READ 确保Transaction01可以多次从一个字段中读取到相同的值，即Transaction01执行期间禁止其它事务对这个字段进行更新。 串行化：SERIALIZABLE 确保Transaction01可以多次从一个表中读取到相同的行，在Transaction01执行期间，禁止其它事务对这个表进行添加、更新、删除操作。可以避免任何并发问题，但性能十分低下。 各个隔离级别解决并发问题的能力见下表： 隔离级别 脏读 不可重复读 幻读 READ UNCOMMITTED 有 有 有 READ COMMITTED 无 有 有 REPEATABLE READ 无 无 有 SERIALIZABLE 无 无 无 各种数据库产品对事务隔离级别的支持程度： 隔离级别 Oracle MySQL READ UNCOMMITTED × √ READ COMMITTED √(默认) √ REPEATABLE READ × √(默认) SERIALIZABLE √ √ ②使用方式 12345@Transactional(isolation = Isolation.DEFAULT)//使用数据库默认的隔离级别@Transactional(isolation = Isolation.READ_UNCOMMITTED)//读未提交@Transactional(isolation = Isolation.READ_COMMITTED)//读已提交@Transactional(isolation = Isolation.REPEATABLE_READ)//可重复读@Transactional(isolation = Isolation.SERIALIZABLE)//串行化 7.3.9、事务属性：传播行为①介绍 什么是事务的传播行为？ 在service类中有a()方法和b()方法，a()方法上有事务，b()方法上也有事务，当a()方法执行过程中调用了b()方法，事务是如何传递的？合并到一个事务里？还是开启一个新的事务？这就是事务传播行为。 一共有七种传播行为： REQUIRED：支持当前事务，如果不存在就新建一个(默认)【没有就新建，有就加入】 SUPPORTS：支持当前事务，如果当前没有事务，就以非事务方式执行【有就加入，没有就不管了】 MANDATORY：必须运行在一个事务中，如果当前没有事务正在发生，将抛出一个异常【有就加入，没有就抛异常】 REQUIRES_NEW：开启一个新的事务，如果一个事务已经存在，则将这个存在的事务挂起【不管有没有，直接开启一个新事务，开启的新事务和之前的事务不存在嵌套关系，之前事务被挂起】 NOT_SUPPORTED：以非事务方式运行，如果有事务存在，挂起当前事务【不支持事务，存在就挂起】 NEVER：以非事务方式运行，如果有事务存在，抛出异常【不支持事务，存在就抛异常】 NESTED：如果当前正有一个事务在进行中，则该方法应当运行在一个嵌套式事务中。被嵌套的事务可以独立于外层事务进行提交或回滚。如果外层事务不存在，行为就像REQUIRED一样。【有事务的话，就在这个事务里再嵌套一个完全独立的事务，嵌套的事务可以独立的提交和回滚。没有事务就和REQUIRED一样。】 ②测试 创建接口CheckoutService： 12345package com.atguigu.spring6.service;public interface CheckoutService &#123; void checkout(Integer[] bookIds, Integer userId);&#125; 创建实现类CheckoutServiceImpl： 1234567891011121314151617package com.atguigu.spring6.service.impl;@Servicepublic class CheckoutServiceImpl implements CheckoutService &#123; @Autowired private BookService bookService; @Override @Transactional //一次购买多本图书 public void checkout(Integer[] bookIds, Integer userId) &#123; for (Integer bookId : bookIds) &#123; bookService.buyBook(bookId, userId); &#125; &#125;&#125; 在BookController中添加方法： 123456@Autowiredprivate CheckoutService checkoutService;public void checkout(Integer[] bookIds, Integer userId)&#123; checkoutService.checkout(bookIds, userId);&#125; 在数据库中将用户的余额修改为100元 ③观察结果 可以通过@Transactional中的propagation属性设置事务传播行为 修改BookServiceImpl中buyBook()上，注解@Transactional的propagation属性 @Transactional(propagation &#x3D; Propagation.REQUIRED)，默认情况，表示如果当前线程上有已经开启的事务可用，那么就在这个事务中运行。经过观察，购买图书的方法buyBook()在checkout()中被调用，checkout()上有事务注解，因此在此事务中执行。所购买的两本图书的价格为80和50，而用户的余额为100，因此在购买第二本图书时余额不足失败，导致整个checkout()回滚，即只要有一本书买不了，就都买不了 @Transactional(propagation &#x3D; Propagation.REQUIRES_NEW)，表示不管当前线程上是否有已经开启的事务，都要开启新事务。同样的场景，每次购买图书都是在buyBook()的事务中执行，因此第一本图书购买成功，事务结束，第二本图书购买失败，只在第二次的buyBook()中回滚，购买第一本图书不受影响，即能买几本就买几本。 7.3.10、全注解配置事务①添加配置类 12345678910111213141516171819202122232425262728293031323334353637383940package com.atguigu.spring6.config;import com.alibaba.druid.pool.DruidDataSource;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.ComponentScan;import org.springframework.context.annotation.Configuration;import org.springframework.jdbc.core.JdbcTemplate;import org.springframework.jdbc.datasource.DataSourceTransactionManager;import org.springframework.transaction.annotation.EnableTransactionManagement;import javax.sql.DataSource;@Configuration@ComponentScan(&quot;com.atguigu.spring6&quot;)@EnableTransactionManagementpublic class SpringConfig &#123; @Bean public DataSource getDataSource()&#123; DruidDataSource dataSource = new DruidDataSource(); dataSource.setDriverClassName(&quot;com.mysql.cj.jdbc.Driver&quot;); dataSource.setUrl(&quot;jdbc:mysql://localhost:3306/spring?characterEncoding=utf8&amp;useSSL=false&quot;); dataSource.setUsername(&quot;root&quot;); dataSource.setPassword(&quot;root&quot;); return dataSource; &#125; @Bean(name = &quot;jdbcTemplate&quot;) public JdbcTemplate getJdbcTemplate(DataSource dataSource)&#123; JdbcTemplate jdbcTemplate = new JdbcTemplate(); jdbcTemplate.setDataSource(dataSource); return jdbcTemplate; &#125; @Bean public DataSourceTransactionManager getDataSourceTransactionManager(DataSource dataSource)&#123; DataSourceTransactionManager dataSourceTransactionManager = new DataSourceTransactionManager(); dataSourceTransactionManager.setDataSource(dataSource); return dataSourceTransactionManager; &#125;&#125; ②测试 1234567891011121314151617import com.atguigu.spring6.config.SpringConfig;import com.atguigu.spring6.controller.BookController;import org.junit.jupiter.api.Test;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.context.ApplicationContext;import org.springframework.context.annotation.AnnotationConfigApplicationContext;import org.springframework.test.context.junit.jupiter.SpringJUnitConfig;public class TxByAllAnnotationTest &#123; @Test public void testTxAllAnnotation()&#123; ApplicationContext applicationContext = new AnnotationConfigApplicationContext(SpringConfig.class); BookController accountService = applicationContext.getBean(&quot;bookController&quot;, BookController.class); accountService.buyBook(1, 1); &#125;&#125; 7.4、基于XML的声明式事务7.3.1、场景模拟参考基于注解的声明式事务 7.3.2、修改Spring配置文件将Spring配置文件中去掉tx:annotation-driven 标签，并添加配置： 1234567891011121314151617181920212223242526&lt;aop:config&gt; &lt;!-- 配置事务通知和切入点表达式 --&gt; &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut=&quot;execution(* com.atguigu.spring.tx.xml.service.impl.*.*(..))&quot;&gt;&lt;/aop:advisor&gt;&lt;/aop:config&gt;&lt;!-- tx:advice标签：配置事务通知 --&gt;&lt;!-- id属性：给事务通知标签设置唯一标识，便于引用 --&gt;&lt;!-- transaction-manager属性：关联事务管理器 --&gt;&lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;transactionManager&quot;&gt; &lt;tx:attributes&gt; &lt;!-- tx:method标签：配置具体的事务方法 --&gt; &lt;!-- name属性：指定方法名，可以使用星号代表多个字符 --&gt; &lt;tx:method name=&quot;get*&quot; read-only=&quot;true&quot;/&gt; &lt;tx:method name=&quot;query*&quot; read-only=&quot;true&quot;/&gt; &lt;tx:method name=&quot;find*&quot; read-only=&quot;true&quot;/&gt; &lt;!-- read-only属性：设置只读属性 --&gt; &lt;!-- rollback-for属性：设置回滚的异常 --&gt; &lt;!-- no-rollback-for属性：设置不回滚的异常 --&gt; &lt;!-- isolation属性：设置事务的隔离级别 --&gt; &lt;!-- timeout属性：设置事务的超时属性 --&gt; &lt;!-- propagation属性：设置事务的传播行为 --&gt; &lt;tx:method name=&quot;save*&quot; read-only=&quot;false&quot; rollback-for=&quot;java.lang.Exception&quot; propagation=&quot;REQUIRES_NEW&quot;/&gt; &lt;tx:method name=&quot;update*&quot; read-only=&quot;false&quot; rollback-for=&quot;java.lang.Exception&quot; propagation=&quot;REQUIRES_NEW&quot;/&gt; &lt;tx:method name=&quot;delete*&quot; read-only=&quot;false&quot; rollback-for=&quot;java.lang.Exception&quot; propagation=&quot;REQUIRES_NEW&quot;/&gt; &lt;/tx:attributes&gt;&lt;/tx:advice&gt; 注意：基于xml实现的声明式事务，必须引入aspectJ的依赖 12345 &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt; &lt;version&gt;6.0.2&lt;/version&gt;&lt;/dependency&gt; 8、资源操作：Resources8.1、Spring Resources概述 Java的标准java.net.URL类和各种URL前缀的标准处理程序无法满足所有对low-level资源的访问，比如：没有标准化的 URL 实现可用于访问需要从类路径或相对于 ServletContext 获取的资源。并且缺少某些Spring所需要的功能，例如检测某资源是否存在等。而Spring的Resource声明了访问low-level资源的能力。 8.2、Resource接口Spring 的 Resource 接口位于 org.springframework.core.io 中。 旨在成为一个更强大的接口，用于抽象对低级资源的访问。以下显示了Resource接口定义的方法 12345678910111213141516171819202122232425262728public interface Resource extends InputStreamSource &#123; boolean exists(); boolean isReadable(); boolean isOpen(); boolean isFile(); URL getURL() throws IOException; URI getURI() throws IOException; File getFile() throws IOException; ReadableByteChannel readableChannel() throws IOException; long contentLength() throws IOException; long lastModified() throws IOException; Resource createRelative(String relativePath) throws IOException; String getFilename(); String getDescription();&#125; Resource接口继承了InputStreamSource接口，提供了很多InputStreamSource所没有的方法。InputStreamSource接口，只有一个方法： 12345public interface InputStreamSource &#123; InputStream getInputStream() throws IOException;&#125; 其中一些重要的方法： getInputStream(): 找到并打开资源，返回一个InputStream以从资源中读取。预计每次调用都会返回一个新的InputStream()，调用者有责任关闭每个流exists(): 返回一个布尔值，表明某个资源是否以物理形式存在isOpen: 返回一个布尔值，指示此资源是否具有开放流的句柄。如果为true，InputStream就不能够多次读取，只能够读取一次并且及时关闭以避免内存泄漏。对于所有常规资源实现，返回false，但是InputStreamResource除外。getDescription(): 返回资源的描述，用来输出错误的日志。这通常是完全限定的文件名或资源的实际URL。 其他方法： isReadable(): 表明资源的目录读取是否通过getInputStream()进行读取。isFile(): 表明这个资源是否代表了一个文件系统的文件。getURL(): 返回一个URL句柄，如果资源不能够被解析为URL，将抛出IOExceptiongetURI(): 返回一个资源的URI句柄getFile(): 返回某个文件，如果资源不能够被解析称为绝对路径，将会抛出FileNotFoundExceptionlastModified(): 资源最后一次修改的时间戳createRelative(): 创建此资源的相关资源getFilename(): 资源的文件名是什么 例如：最后一部分的文件名 myfile.txt 8.3、Resource的实现类Resource 接口是 Spring 资源访问策略的抽象，它本身并不提供任何资源访问实现，具体的资源访问由该接口的实现类完成——每个实现类代表一种资源访问策略。Resource一般包括这些实现类：UrlResource、ClassPathResource、FileSystemResource、ServletContextResource、InputStreamResource、ByteArrayResource 8.3.1、UrlResource访问网络资源Resource的一个实现类，用来访问网络资源，它支持URL的绝对路径。 http:——该前缀用于访问基于HTTP协议的网络资源。 ftp:——该前缀用于访问基于FTP协议的网络资源 file: ——该前缀用于从文件系统中读取资源 实验：访问基于HTTP协议的网络资源 创建一个maven子模块spring6-resources，配置Spring依赖（参考前面） 12345678910111213141516171819202122232425262728package com.atguigu.spring6.resources;import org.springframework.core.io.UrlResource;public class UrlResourceDemo &#123; public static void loadAndReadUrlResource(String path)&#123; // 创建一个 Resource 对象 UrlResource url = null; try &#123; url = new UrlResource(path); // 获取资源名 System.out.println(url.getFilename()); System.out.println(url.getURI()); // 获取资源描述 System.out.println(url.getDescription()); //获取资源内容 System.out.println(url.getInputStream().read()); &#125; catch (Exception e) &#123; throw new RuntimeException(e); &#125; &#125; public static void main(String[] args) &#123; //访问网络资源 loadAndReadUrlResource(&quot;http://www.baidu.com&quot;); &#125;&#125; 实验二：在项目根路径下创建文件，从文件系统中读取资源 方法不变，修改调用传递路径 1234567public static void main(String[] args) &#123; //1 访问网络资源 //loadAndReadUrlResource(&quot;http://www.atguigu.com&quot;); //2 访问文件系统资源 loadAndReadUrlResource(&quot;file:atguigu.txt&quot;);&#125; 8.3.2、ClassPathResource 访问类路径下资源ClassPathResource 用来访问类加载路径下的资源，相对于其他的 Resource 实现类，其主要优势是方便访问类加载路径里的资源，尤其对于 Web 应用，ClassPathResource 可自动搜索位于 classes 下的资源文件，无须使用绝对路径访问。 实验：在类路径下创建文件atguigu.txt，使用ClassPathResource 访问 1234567891011121314151617181920212223242526package com.atguigu.spring6.resources;import org.springframework.core.io.ClassPathResource;import java.io.InputStream;public class ClassPathResourceDemo &#123; public static void loadAndReadUrlResource(String path) throws Exception&#123; // 创建一个 Resource 对象 ClassPathResource resource = new ClassPathResource(path); // 获取文件名 System.out.println(&quot;resource.getFileName = &quot; + resource.getFilename()); // 获取文件描述 System.out.println(&quot;resource.getDescription = &quot;+ resource.getDescription()); //获取文件内容 InputStream in = resource.getInputStream(); byte[] b = new byte[1024]; while(in.read(b)!=-1) &#123; System.out.println(new String(b)); &#125; &#125; public static void main(String[] args) throws Exception &#123; loadAndReadUrlResource(&quot;atguigu.txt&quot;); &#125;&#125; ClassPathResource实例可使用ClassPathResource构造器显式地创建，但更多的时候它都是隐式地创建的。当执行Spring的某个方法时，该方法接受一个代表资源路径的字符串参数，当Spring识别该字符串参数中包含classpath:前缀后，系统会自动创建ClassPathResource对象。 8.3.3、FileSystemResource 访问文件系统资源Spring 提供的 FileSystemResource 类用于访问文件系统资源，使用 FileSystemResource 来访问文件系统资源并没有太大的优势，因为 Java 提供的 File 类也可用于访问文件系统资源。 实验：使用FileSystemResource 访问文件系统资源 1234567891011121314151617181920212223242526272829package com.atguigu.spring6.resources;import org.springframework.core.io.FileSystemResource;import java.io.InputStream;public class FileSystemResourceDemo &#123; public static void loadAndReadUrlResource(String path) throws Exception&#123; //相对路径 FileSystemResource resource = new FileSystemResource(&quot;atguigu.txt&quot;); //绝对路径 //FileSystemResource resource = new FileSystemResource(&quot;C:\\\\atguigu.txt&quot;); // 获取文件名 System.out.println(&quot;resource.getFileName = &quot; + resource.getFilename()); // 获取文件描述 System.out.println(&quot;resource.getDescription = &quot;+ resource.getDescription()); //获取文件内容 InputStream in = resource.getInputStream(); byte[] b = new byte[1024]; while(in.read(b)!=-1) &#123; System.out.println(new String(b)); &#125; &#125; public static void main(String[] args) throws Exception &#123; loadAndReadUrlResource(&quot;atguigu.txt&quot;); &#125;&#125; FileSystemResource实例可使用FileSystemResource构造器显示地创建，但更多的时候它都是隐式创建。执行Spring的某个方法时，该方法接受一个代表资源路径的字符串参数，当Spring识别该字符串参数中包含file:前缀后，系统将会自动创建FileSystemResource对象。 8.3.4、ServletContextResource这是ServletContext资源的Resource实现，它解释相关Web应用程序根目录中的相对路径。它始终支持流(stream)访问和URL访问，但只有在扩展Web应用程序存档且资源实际位于文件系统上时才允许java.io.File访问。无论它是在文件系统上扩展还是直接从JAR或其他地方（如数据库）访问，实际上都依赖于Servlet容器。 8.3.5、InputStreamResourceInputStreamResource 是给定的输入流(InputStream)的Resource实现。它的使用场景在没有特定的资源实现的时候使用(感觉和@Component 的适用场景很相似)。与其他Resource实现相比，这是已打开资源的描述符。 因此，它的isOpen()方法返回true。如果需要将资源描述符保留在某处或者需要多次读取流，请不要使用它。 8.3.6、ByteArrayResource字节数组的Resource实现类。通过给定的数组创建了一个ByteArrayInputStream。它对于从任何给定的字节数组加载内容非常有用，而无需求助于单次使用的InputStreamResource。 8.4、Resource类图上述Resource实现类与Resource顶级接口之间的关系可以用下面的UML关系模型来表示 8.5、ResourceLoader 接口8.5.1、ResourceLoader 概述Spring 提供如下两个标志性接口： （1）ResourceLoader ： 该接口实现类的实例可以获得一个Resource实例。 （2） ResourceLoaderAware ： 该接口实现类的实例将获得一个ResourceLoader的引用。 在ResourceLoader接口里有如下方法： （1）Resource getResource（String location） ： 该接口仅有这个方法，用于返回一个Resource实例。ApplicationContext实现类都实现ResourceLoader接口，因此ApplicationContext可直接获取Resource实例。 8.5.2、使用演示实验一：ClassPathXmlApplicationContext获取Resource实例 1234567891011121314151617package com.atguigu.spring6.resouceloader;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;import org.springframework.core.io.Resource;public class Demo1 &#123; public static void main(String[] args) &#123; ApplicationContext ctx = new ClassPathXmlApplicationContext();// 通过ApplicationContext访问资源// ApplicationContext实例获取Resource实例时，// 默认采用与ApplicationContext相同的资源访问策略 Resource res = ctx.getResource(&quot;atguigu.txt&quot;); System.out.println(res.getFilename()); &#125;&#125; 实验二：FileSystemApplicationContext获取Resource实例 1234567891011121314package com.atguigu.spring6.resouceloader;import org.springframework.context.ApplicationContext;import org.springframework.context.support.FileSystemXmlApplicationContext;import org.springframework.core.io.Resource;public class Demo2 &#123; public static void main(String[] args) &#123; ApplicationContext ctx = new FileSystemXmlApplicationContext(); Resource res = ctx.getResource(&quot;atguigu.txt&quot;); System.out.println(res.getFilename()); &#125;&#125; 8.5.3、ResourceLoader 总结Spring将采用和ApplicationContext相同的策略来访问资源。也就是说，如果ApplicationContext是FileSystemXmlApplicationContext，res就是FileSystemResource实例；如果ApplicationContext是ClassPathXmlApplicationContext，res就是ClassPathResource实例 当Spring应用需要进行资源访问时，实际上并不需要直接使用Resource实现类，而是调用ResourceLoader实例的getResource()方法来获得资源，ReosurceLoader将会负责选择Reosurce实现类，也就是确定具体的资源访问策略，从而将应用程序和具体的资源访问策略分离开来 另外，使用ApplicationContext访问资源时，可通过不同前缀指定强制使用指定的ClassPathResource、FileSystemResource等实现类 123Resource res = ctx.getResource(&quot;calsspath:bean.xml&quot;);Resrouce res = ctx.getResource(&quot;file:bean.xml&quot;);Resource res = ctx.getResource(&quot;http://localhost:8080/beans.xml&quot;); 8.6、ResourceLoaderAware 接口ResourceLoaderAware接口实现类的实例将获得一个ResourceLoader的引用，ResourceLoaderAware接口也提供了一个setResourceLoader()方法，该方法将由Spring容器负责调用，Spring容器会将一个ResourceLoader对象作为该方法的参数传入。 如果把实现ResourceLoaderAware接口的Bean类部署在Spring容器中，Spring容器会将自身当成ResourceLoader作为setResourceLoader()方法的参数传入。由于ApplicationContext的实现类都实现了ResourceLoader接口，Spring容器自身完全可作为ResorceLoader使用。 实验：演示ResourceLoaderAware使用 第一步 创建类，实现ResourceLoaderAware接口 12345678910111213141516171819202122package com.atguigu.spring6.resouceloader;import org.springframework.context.ResourceLoaderAware;import org.springframework.core.io.ResourceLoader;public class TestBean implements ResourceLoaderAware &#123; private ResourceLoader resourceLoader; //实现ResourceLoaderAware接口必须实现的方法 //如果把该Bean部署在Spring容器中，该方法将会有Spring容器负责调用。 //SPring容器调用该方法时，Spring会将自身作为参数传给该方法。 public void setResourceLoader(ResourceLoader resourceLoader) &#123; this.resourceLoader = resourceLoader; &#125; //返回ResourceLoader对象的应用 public ResourceLoader getResourceLoader()&#123; return this.resourceLoader; &#125;&#125; 第二步 创建bean.xml文件，配置TestBean 1234567&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id=&quot;testBean&quot; class=&quot;com.atguigu.spring6.resouceloader.TestBean&quot;&gt;&lt;/bean&gt;&lt;/beans&gt; 第三步 测试 12345678910111213141516171819202122package com.atguigu.spring6.resouceloader;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;import org.springframework.core.io.Resource;import org.springframework.core.io.ResourceLoader;public class Demo3 &#123; public static void main(String[] args) &#123; //Spring容器会将一个ResourceLoader对象作为该方法的参数传入 ApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;bean.xml&quot;); TestBean testBean = ctx.getBean(&quot;testBean&quot;,TestBean.class); //获取ResourceLoader对象 ResourceLoader resourceLoader = testBean.getResourceLoader(); System.out.println(&quot;Spring容器将自身注入到ResourceLoaderAware Bean 中 ？ ：&quot; + (resourceLoader == ctx)); //加载其他资源 Resource resource = resourceLoader.getResource(&quot;atguigu.txt&quot;); System.out.println(resource.getFilename()); System.out.println(resource.getDescription()); &#125;&#125; 8.7、使用Resource 作为属性前面介绍了 Spring 提供的资源访问策略，但这些依赖访问策略要么需要使用 Resource 实现类，要么需要使用 ApplicationContext 来获取资源。实际上，当应用程序中的 Bean 实例需要访问资源时，Spring 有更好的解决方法：直接利用依赖注入。从这个意义上来看，Spring 框架不仅充分利用了策略模式来简化资源访问，而且还将策略模式和 IoC 进行充分地结合，最大程度地简化了 Spring 资源访问。 归纳起来，如果 Bean 实例需要访问资源，有如下两种解决方案： 代码中获取 Resource 实例。 使用依赖注入。 对于第一种方式，当程序获取 Resource 实例时，总需要提供 Resource 所在的位置，不管通过 FileSystemResource 创建实例，还是通过 ClassPathResource 创建实例，或者通过 ApplicationContext 的 getResource() 方法获取实例，都需要提供资源位置。这意味着：资源所在的物理位置将被耦合到代码中，如果资源位置发生改变，则必须改写程序。因此，通常建议采用第二种方法，让 Spring 为 Bean 实例依赖注入资源。 实验：让Spring为Bean实例依赖注入资源 第一步 创建依赖注入类，定义属性和方法 1234567891011121314151617181920package com.atguigu.spring6.resouceloader;import org.springframework.core.io.Resource;public class ResourceBean &#123; private Resource res; public void setRes(Resource res) &#123; this.res = res; &#125; public Resource getRes() &#123; return res; &#125; public void parse()&#123; System.out.println(res.getFilename()); System.out.println(res.getDescription()); &#125;&#125; 第二步 创建spring配置文件，配置依赖注入 1234567891011&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id=&quot;resourceBean&quot; class=&quot;com.atguigu.spring6.resouceloader.ResourceBean&quot; &gt; &lt;!-- 可以使用file:、http:、ftp:等前缀强制Spring采用对应的资源访问策略 --&gt; &lt;!-- 如果不采用任何前缀，则Spring将采用与该ApplicationContext相同的资源访问策略来访问资源 --&gt; &lt;property name=&quot;res&quot; value=&quot;classpath:atguigu.txt&quot;/&gt; &lt;/bean&gt;&lt;/beans&gt; 第三步 测试 1234567891011121314package com.atguigu.spring6.resouceloader;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class Demo4 &#123; public static void main(String[] args) &#123; ApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;bean.xml&quot;); ResourceBean resourceBean = ctx.getBean(&quot;resourceBean&quot;,ResourceBean.class); resourceBean.parse(); &#125;&#125; 8.8、应用程序上下文和资源路径8.8.1、概述不管以怎样的方式创建ApplicationContext实例，都需要为ApplicationContext指定配置文件，Spring允许使用一份或多分XML配置文件。当程序创建ApplicationContext实例时，通常也是以Resource的方式来访问配置文件的，所以ApplicationContext完全支持ClassPathResource、FileSystemResource、ServletContextResource等资源访问方式。 ApplicationContext确定资源访问策略通常有两种方法： （1）使用ApplicationContext实现类指定访问策略。 （2）使用前缀指定访问策略。 8.8.2、ApplicationContext实现类指定访问策略创建ApplicationContext对象时，通常可以使用如下实现类： （1） ClassPathXMLApplicationContext : 对应使用ClassPathResource进行资源访问。 （2）FileSystemXmlApplicationContext ： 对应使用FileSystemResource进行资源访问。 （3）XmlWebApplicationContext ： 对应使用ServletContextResource进行资源访问。 当使用ApplicationContext的不同实现类时，就意味着Spring使用响应的资源访问策略。 效果前面已经演示 8.8.3、使用前缀指定访问策略实验一：classpath前缀使用 12345678910111213141516171819202122package com.atguigu.spring6.context;import org.springframework.context.ApplicationContext;import org.springframework.context.support.FileSystemXmlApplicationContext;import org.springframework.core.io.Resource;public class Demo1 &#123; public static void main(String[] args) &#123; /* * 通过搜索文件系统路径下的xml文件创建ApplicationContext， * 但通过指定classpath:前缀强制搜索类加载路径 * classpath:bean.xml * */ ApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;classpath:bean.xml&quot;); System.out.println(ctx); Resource resource = ctx.getResource(&quot;atguigu.txt&quot;); System.out.println(resource.getFilename()); System.out.println(resource.getDescription()); &#125;&#125; 实验二：classpath通配符使用 classpath * :前缀提供了加载多个XML配置文件的能力，当使用classpath*:前缀来指定XML配置文件时，系统将搜索类加载路径，找到所有与文件名匹配的文件，分别加载文件中的配置定义，最后合并成一个ApplicationContext。 12ApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;classpath*:bean.xml&quot;);System.out.println(ctx); 当使用classpath * :前缀时，Spring将会搜索类加载路径下所有满足该规则的配置文件。 如果不是采用classpath * :前缀，而是改为使用classpath:前缀，Spring则只加载第一个符合条件的XML文件 注意 ： classpath * : 前缀仅对ApplicationContext有效。实际情况是，创建ApplicationContext时，分别访问多个配置文件(通过ClassLoader的getResource方法实现)。因此，classpath * :前缀不可用于Resource。 使用三：通配符其他使用 一次性加载多个配置文件的方式：指定配置文件时使用通配符 1ApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;classpath:bean*.xml&quot;); Spring允许将classpath*:前缀和通配符结合使用： 1ApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;classpath*:bean*.xml&quot;); 9、国际化：i18n 9.1、i18n概述国际化也称作i18n，其来源是英文单词 internationalization的首末字符i和n，18为中间的字符数。由于软件发行可能面向多个国家，对于不同国家的用户，软件显示不同语言的过程就是国际化。通常来讲，软件中的国际化是通过配置文件来实现的，假设要支撑两种语言，那么就需要两个版本的配置文件。 9.2、Java国际化（1）Java自身是支持国际化的，java.util.Locale用于指定当前用户所属的语言环境等信息，java.util.ResourceBundle用于查找绑定对应的资源文件。Locale包含了language信息和country信息，Locale创建默认locale对象时使用的静态方法： 12345678/** * This method must be called only for creating the Locale.* * constants due to making shortcuts. */private static Locale createConstant(String lang, String country) &#123; BaseLocale base = BaseLocale.createInstance(lang, country); return getInstance(base, null);&#125; （2）配置文件命名规则： basename_language_country.properties 必须遵循以上的命名规则，java才会识别。其中，basename是必须的，语言和国家是可选的。这里存在一个优先级概念，如果同时提供了messages.properties和messages_zh_CN.propertes两个配置文件，如果提供的locale符合en_CN，那么优先查找messages_en_CN.propertes配置文件，如果没查找到，再查找messages.properties配置文件。最后，提示下，所有的配置文件必须放在classpath中，一般放在resources目录下 （3）实验：演示Java国际化 第一步 创建子模块spring6-i18n，引入spring依赖 第二步 在resource目录下创建两个配置文件：messages_zh_CN.propertes和messages_en_GB.propertes 第三步 测试 12345678910111213141516package com.atguigu.spring6.javai18n;import java.nio.charset.StandardCharsets;import java.util.Locale;import java.util.ResourceBundle;public class Demo1 &#123; public static void main(String[] args) &#123; System.out.println(ResourceBundle.getBundle(&quot;messages&quot;, new Locale(&quot;en&quot;,&quot;GB&quot;)).getString(&quot;test&quot;)); System.out.println(ResourceBundle.getBundle(&quot;messages&quot;, new Locale(&quot;zh&quot;,&quot;CN&quot;)).getString(&quot;test&quot;)); &#125;&#125; 9.3、Spring6国际化9.3.1、MessageSource接口spring中国际化是通过MessageSource这个接口来支持的 常见实现类 ResourceBundleMessageSource 这个是基于Java的ResourceBundle基础类实现，允许仅通过资源名加载国际化资源 ReloadableResourceBundleMessageSource 这个功能和第一个类的功能类似，多了定时刷新功能，允许在不重启系统的情况下，更新资源的信息 StaticMessageSource 它允许通过编程的方式提供国际化信息，一会我们可以通过这个来实现db中存储国际化信息的功能。 9.3.2、使用Spring6国际化第一步 创建资源文件 国际化文件命名格式：基本名称 _ 语言 _ 国家.properties {0},{1}这样内容，就是动态参数 （1）创建atguigu_en_US.properties 1www.atguigu.com=welcome &#123;0&#125;,时间:&#123;1&#125; （2）创建atguigu_zh_CN.properties 1www.atguigu.com=欢迎 &#123;0&#125;,时间:&#123;1&#125; 第二步 创建spring配置文件，配置MessageSource 1234567891011121314151617&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id=&quot;messageSource&quot; class=&quot;org.springframework.context.support.ResourceBundleMessageSource&quot;&gt; &lt;property name=&quot;basenames&quot;&gt; &lt;list&gt; &lt;value&gt;atguigu&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;property name=&quot;defaultEncoding&quot;&gt; &lt;value&gt;utf-8&lt;/value&gt; &lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 第三步 创建测试类 1234567891011121314151617181920212223package com.atguigu.spring6.javai18n;import org.springframework.context.ApplicationContext;import org.springframework.context.annotation.AnnotationConfigApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;import java.util.Date;import java.util.Locale;public class Demo2 &#123; public static void main(String[] args) &#123; ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;); //传递动态参数，使用数组形式对应&#123;0&#125; &#123;1&#125;顺序 Object[] objs = new Object[]&#123;&quot;atguigu&quot;,new Date().toString()&#125;; //www.atguigu.com为资源文件的key值, //objs为资源文件value值所需要的参数,Local.CHINA为国际化为语言 String str=context.getMessage(&quot;www.atguigu.com&quot;, objs, Locale.CHINA); System.out.println(str); &#125;&#125; 10、数据校验：Validation 10.1、Spring Validation概述 在开发中，我们经常遇到参数校验的需求，比如用户注册的时候，要校验用户名不能为空、用户名长度不超过20个字符、手机号是合法的手机号格式等等。如果使用普通方式，我们会把校验的代码和真正的业务处理逻辑耦合在一起，而且如果未来要新增一种校验逻辑也需要在修改多个地方。而spring validation允许通过注解的方式来定义对象校验规则，把校验和业务逻辑分离开，让代码编写更加方便。Spring Validation其实就是对Hibernate Validator进一步的封装，方便在Spring中使用。 在Spring中有多种校验的方式 第一种是通过实现org.springframework.validation.Validator接口，然后在代码中调用这个类 第二种是按照Bean Validation方式来进行校验，即通过注解的方式。 第三种是基于方法实现校验 除此之外，还可以实现自定义校验 10.2、实验一：通过Validator接口实现第一步 创建子模块 spring6-validator 第二步 引入相关依赖 12345678910111213&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.hibernate.validator&lt;/groupId&gt; &lt;artifactId&gt;hibernate-validator&lt;/artifactId&gt; &lt;version&gt;7.0.5.Final&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.glassfish&lt;/groupId&gt; &lt;artifactId&gt;jakarta.el&lt;/artifactId&gt; &lt;version&gt;4.0.1&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 第三步 创建实体类，定义属性和方法 12345678910111213141516171819package com.atguigu.spring6.validation.method1;public class Person &#123; private String name; private int age; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125;&#125; 第四步 创建类实现Validator接口，实现接口方法指定校验规则 123456789101112131415161718192021222324package com.atguigu.spring6.validation.method1;import org.springframework.validation.Errors;import org.springframework.validation.ValidationUtils;import org.springframework.validation.Validator;public class PersonValidator implements Validator &#123; @Override public boolean supports(Class&lt;?&gt; clazz) &#123; return Person.class.equals(clazz); &#125; @Override public void validate(Object object, Errors errors) &#123; ValidationUtils.rejectIfEmpty(errors, &quot;name&quot;, &quot;name.empty&quot;); Person p = (Person) object; if (p.getAge() &lt; 0) &#123; errors.rejectValue(&quot;age&quot;, &quot;error value &lt; 0&quot;); &#125; else if (p.getAge() &gt; 110) &#123; errors.rejectValue(&quot;age&quot;, &quot;error value too old&quot;); &#125; &#125;&#125; 上面定义的类，其实就是实现接口中对应的方法， supports方法用来表示此校验用在哪个类型上， validate是设置校验逻辑的地点，其中ValidationUtils，是Spring封装的校验工具类，帮助快速实现校验。 第五步 使用上述Validator进行测试 123456789101112131415161718192021222324252627package com.atguigu.spring6.validation.method1;import org.springframework.validation.BindingResult;import org.springframework.validation.DataBinder;public class TestMethod1 &#123; public static void main(String[] args) &#123; //创建person对象 Person person = new Person(); person.setName(&quot;lucy&quot;); person.setAge(-1); // 创建Person对应的DataBinder DataBinder binder = new DataBinder(person); // 设置校验 binder.setValidator(new PersonValidator()); // 由于Person对象中的属性为空，所以校验不通过 binder.validate(); //输出结果 BindingResult results = binder.getBindingResult(); System.out.println(results.getAllErrors()); &#125;&#125; 10.3、实验二：Bean Validation注解实现使用Bean Validation校验方式，就是如何将Bean Validation需要使用的javax.validation.ValidatorFactory 和javax.validation.Validator注入到容器中。spring默认有一个实现类LocalValidatorFactoryBean，它实现了上面Bean Validation中的接口，并且也实现了org.springframework.validation.Validator接口。 第一步 创建配置类，配置LocalValidatorFactoryBean 123456789@Configuration@ComponentScan(&quot;com.atguigu.spring6.validation.method2&quot;)public class ValidationConfig &#123; @Bean public LocalValidatorFactoryBean validator() &#123; return new LocalValidatorFactoryBean(); &#125;&#125; 第二步 创建实体类，使用注解定义校验规则 12345678910111213141516171819202122232425262728package com.atguigu.spring6.validation.method2;import jakarta.validation.constraints.Max;import jakarta.validation.constraints.Min;import jakarta.validation.constraints.NotNull;public class User &#123; @NotNull private String name; @Min(0) @Max(120) private int age; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125;&#125; 常用注解说明@NotNull 限制必须不为null@NotEmpty 只作用于字符串类型，字符串不为空，并且长度不为0@NotBlank 只作用于字符串类型，字符串不为空，并且trim()后不为空串@DecimalMax(value) 限制必须为一个不大于指定值的数字@DecimalMin(value) 限制必须为一个不小于指定值的数字@Max(value) 限制必须为一个不大于指定值的数字@Min(value) 限制必须为一个不小于指定值的数字@Pattern(value) 限制必须符合指定的正则表达式@Size(max,min) 限制字符长度必须在min到max之间@Email 验证注解的元素值是Email，也可以通过正则表达式和flag指定自定义的email格式 第三步 使用两种不同的校验器实现 （1）使用jakarta.validation.Validator校验 1234567891011121314151617181920package com.atguigu.spring6.validation.method2;import jakarta.validation.ConstraintViolation;import jakarta.validation.Validator;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import java.util.Set;@Servicepublic class MyService1 &#123; @Autowired private Validator validator; public boolean validator(User user)&#123; Set&lt;ConstraintViolation&lt;User&gt;&gt; sets = validator.validate(user); return sets.isEmpty(); &#125;&#125; （2）使用org.springframework.validation.Validator校验 12345678910111213141516171819package com.atguigu.spring6.validation.method2;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import org.springframework.validation.BindException;import org.springframework.validation.Validator;@Servicepublic class MyService2 &#123; @Autowired private Validator validator; public boolean validaPersonByValidator(User user) &#123; BindException bindException = new BindException(user, user.getName()); validator.validate(user, bindException); return bindException.hasErrors(); &#125;&#125; 第四步 测试 123456789101112131415161718192021222324252627282930package com.atguigu.spring6.validation.method2;import org.junit.jupiter.api.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.annotation.AnnotationConfigApplicationContext;public class TestMethod2 &#123; @Test public void testMyService1() &#123; ApplicationContext context = new AnnotationConfigApplicationContext(ValidationConfig.class); MyService1 myService = context.getBean(MyService1.class); User user = new User(); user.setAge(-1); boolean validator = myService.validator(user); System.out.println(validator); &#125; @Test public void testMyService2() &#123; ApplicationContext context = new AnnotationConfigApplicationContext(ValidationConfig.class); MyService2 myService = context.getBean(MyService2.class); User user = new User(); user.setName(&quot;lucy&quot;); user.setAge(130); user.setAge(-1); boolean validator = myService.validaPersonByValidator(user); System.out.println(validator); &#125;&#125; 10.4、实验三：基于方法实现校验第一步 创建配置类，配置MethodValidationPostProcessor 1234567891011121314151617package com.atguigu.spring6.validation.method3;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.ComponentScan;import org.springframework.context.annotation.Configuration;import org.springframework.validation.beanvalidation.LocalValidatorFactoryBean;import org.springframework.validation.beanvalidation.MethodValidationPostProcessor;@Configuration@ComponentScan(&quot;com.atguigu.spring6.validation.method3&quot;)public class ValidationConfig &#123; @Bean public MethodValidationPostProcessor validationPostProcessor() &#123; return new MethodValidationPostProcessor(); &#125;&#125; 第二步 创建实体类，使用注解设置校验规则 123456789101112131415161718192021222324252627282930313233343536package com.atguigu.spring6.validation.method3;import jakarta.validation.constraints.*;public class User &#123; @NotNull private String name; @Min(0) @Max(120) private int age; @Pattern(regexp = &quot;^1(3|4|5|7|8)\\\\d&#123;9&#125;$&quot;,message = &quot;手机号码格式错误&quot;) @NotBlank(message = &quot;手机号码不能为空&quot;) private String phone; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public String getPhone() &#123; return phone; &#125; public void setPhone(String phone) &#123; this.phone = phone; &#125;&#125; 第三步 定义Service类，通过注解操作对象 12345678910111213141516package com.atguigu.spring6.validation.method3;import jakarta.validation.Valid;import jakarta.validation.constraints.NotNull;import org.springframework.stereotype.Service;import org.springframework.validation.annotation.Validated;@Service@Validatedpublic class MyService &#123; public String testParams(@NotNull @Valid User user) &#123; return user.toString(); &#125;&#125; 第四步 测试 1234567891011121314151617package com.atguigu.spring6.validation.method3;import org.junit.jupiter.api.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.annotation.AnnotationConfigApplicationContext;public class TestMethod3 &#123; @Test public void testMyService1() &#123; ApplicationContext context = new AnnotationConfigApplicationContext(ValidationConfig.class); MyService myService = context.getBean(MyService.class); User user = new User(); user.setAge(-1); myService.testParams(user); &#125;&#125; 10.5、实验四：实现自定义校验第一步 自定义校验注解 12345678910111213141516171819202122232425262728package com.atguigu.spring6.validation.method4;import jakarta.validation.Constraint;import jakarta.validation.Payload;import java.lang.annotation.*;@Target(&#123;ElementType.METHOD, ElementType.FIELD, ElementType.ANNOTATION_TYPE, ElementType.CONSTRUCTOR, ElementType.PARAMETER&#125;)@Retention(RetentionPolicy.RUNTIME)@Documented@Constraint(validatedBy = &#123;CannotBlankValidator.class&#125;)public @interface CannotBlank &#123; //默认错误消息 String message() default &quot;不能包含空格&quot;; //分组 Class&lt;?&gt;[] groups() default &#123;&#125;; //负载 Class&lt;? extends Payload&gt;[] payload() default &#123;&#125;; //指定多个时使用 @Target(&#123;ElementType.METHOD, ElementType.FIELD, ElementType.ANNOTATION_TYPE, ElementType.CONSTRUCTOR, ElementType.PARAMETER, ElementType.TYPE_USE&#125;) @Retention(RetentionPolicy.RUNTIME) @Documented @interface List &#123; CannotBlank[] value(); &#125;&#125; 第二步 编写真正的校验类 123456789101112131415161718192021222324252627package com.atguigu.spring6.validation.method4;import jakarta.validation.ConstraintValidator;import jakarta.validation.ConstraintValidatorContext;public class CannotBlankValidator implements ConstraintValidator&lt;CannotBlank, String&gt; &#123; @Override public void initialize(CannotBlank constraintAnnotation) &#123; &#125; @Override public boolean isValid(String value, ConstraintValidatorContext context) &#123; //null时不进行校验 if (value != null &amp;&amp; value.contains(&quot; &quot;)) &#123; //获取默认提示信息 String defaultConstraintMessageTemplate = context.getDefaultConstraintMessageTemplate(); System.out.println(&quot;default message :&quot; + defaultConstraintMessageTemplate); //禁用默认提示信息 context.disableDefaultConstraintViolation(); //设置提示语 context.buildConstraintViolationWithTemplate(&quot;can not contains blank&quot;).addConstraintViolation(); return false; &#125; return true; &#125;&#125; 11、提前编译：AOT 11.1、AOT概述11.1.1、JIT与AOT的区别JIT和AOT 这个名词是指两种不同的编译方式，这两种编译方式的主要区别在于是否在“运行时”进行编译 （1）JIT， Just-in-time,动态(即时)编译，边运行边编译； 在程序运行时，根据算法计算出热点代码，然后进行 JIT 实时编译，这种方式吞吐量高，有运行时性能加成，可以跑得更快，并可以做到动态生成代码等，但是相对启动速度较慢，并需要一定时间和调用频率才能触发 JIT 的分层机制。JIT 缺点就是编译需要占用运行时资源，会导致进程卡顿。 （2）AOT，Ahead Of Time，指运行前编译，预先编译。 AOT 编译能直接将源代码转化为机器码，内存占用低，启动速度快，可以无需 runtime 运行，直接将 runtime 静态链接至最终的程序中，但是无运行时性能加成，不能根据程序运行情况做进一步的优化，AOT 缺点就是在程序运行前编译会使程序安装的时间增加。 简单来讲：JIT即时编译指的是在程序的运行过程中，将字节码转换为可在硬件上直接运行的机器码，并部署至托管环境中的过程。而 AOT 编译指的则是，在程序运行之前，便将字节码转换为机器码的过程。 1.java -&gt; .class -&gt; (使用jaotc编译工具) -&gt; .so（程序函数库,即编译好的可以供其他程序使用的代码和数据） （3）AOT的优点 简单来讲，Java 虚拟机加载已经预编译成二进制库，可以直接执行。不必等待及时编译器的预热，减少 Java 应用给人带来“第一次运行慢” 的不良体验。 在程序运行前编译，可以避免在运行时的编译性能消耗和内存消耗可以在程序运行初期就达到最高性能，程序启动速度快运行产物只有机器码，打包体积小 AOT的缺点 由于是静态提前编译，不能根据硬件情况或程序运行情况择优选择机器指令序列，理论峰值性能不如JIT没有动态能力，同一份产物不能跨平台运行 第一种即时编译 (JIT) 是默认模式，Java Hotspot 虚拟机使用它在运行时将字节码转换为机器码。后者提前编译 (AOT)由新颖的 GraalVM 编译器支持，并允许在构建时将字节码直接静态编译为机器码。 现在正处于云原生，降本增效的时代，Java 相比于 Go、Rust 等其他编程语言非常大的弊端就是启动编译和启动进程非常慢，这对于根据实时计算资源，弹性扩缩容的云原生技术相冲突，Spring6 借助 AOT 技术在运行时内存占用低，启动速度快，逐渐的来满足 Java 在云原生时代的需求，对于大规模使用 Java 应用的商业公司可以考虑尽早调研使用 JDK17，通过云原生技术为公司实现降本增效。 11.1.2、GraalvmSpring6 支持的 AOT 技术，这个 GraalVM 就是底层的支持，Spring 也对 GraalVM 本机映像提供了一流的支持。GraalVM 是一种高性能 JDK，旨在加速用 Java 和其他 JVM 语言编写的应用程序的执行，同时还为 JavaScript、Python 和许多其他流行语言提供运行时。 GraalVM 提供两种运行 Java 应用程序的方法：在 HotSpot JVM 上使用 Graal 即时 (JIT) 编译器或作为提前 (AOT) 编译的本机可执行文件。 GraalVM 的多语言能力使得在单个应用程序中混合多种编程语言成为可能，同时消除了外语调用成本。GraalVM 向 HotSpot Java 虚拟机添加了一个用 Java 编写的高级即时 (JIT) 优化编译器。 GraalVM 具有以下特性： （1）一种高级优化编译器，它生成更快、更精简的代码，需要更少的计算资源 （2）AOT 本机图像编译提前将 Java 应用程序编译为本机二进制文件，立即启动，无需预热即可实现最高性能 （3）Polyglot 编程在单个应用程序中利用流行语言的最佳功能和库，无需额外开销 （4）高级工具在 Java 和多种语言中调试、监视、分析和优化资源消耗 总的来说对云原生的要求不算高短期内可以继续使用 2.7.X 的版本和 JDK8，不过 Spring 官方已经对 Spring6 进行了正式版发布。 11.1.3、Native Image目前业界除了这种在JVM中进行AOT的方案，还有另外一种实现Java AOT的思路，那就是直接摒弃JVM，和C&#x2F;C++一样通过编译器直接将代码编译成机器代码，然后运行。这无疑是一种直接颠覆Java语言设计的思路，那就是GraalVM Native Image。它通过C语言实现了一个超微缩的运行时组件 —— Substrate VM，基本实现了JVM的各种特性，但足够轻量、可以被轻松内嵌，这就让Java语言和工程摆脱JVM的限制，能够真正意义上实现和C&#x2F;C++一样的AOT编译。这一方案在经过长时间的优化和积累后，已经拥有非常不错的效果，基本上成为Oracle官方首推的Java AOT解决方案。Native Image 是一项创新技术，可将 Java 代码编译成独立的本机可执行文件或本机共享库。在构建本机可执行文件期间处理的 Java 字节码包括所有应用程序类、依赖项、第三方依赖库和任何所需的 JDK 类。生成的自包含本机可执行文件特定于不需要 JVM 的每个单独的操作系统和机器体系结构。 11.2、演示Native Image构建过程11.2.1、GraalVM安装（1）下载GraalVM进入官网下载：https://www.graalvm.org/downloads/ （2）配置环境变量添加GRAALVM_HOME 把JAVA_HOME修改为graalvm的位置 把Path修改位graalvm的bin位置 使用命令查看是否安装成功 （3）安装native-image插件使用命令 gu install native-image下载安装 11.2.2、安装C++的编译环境（1）下载Visual Studio安装软件https://visualstudio.microsoft.com/zh-hans/downloads/ （2）安装Visual Studio （3）添加Visual Studio环境变量配置INCLUDE、LIB和Path （4）打开工具，在工具中操作 11.2.3、编写代码，构建Native Image（1）编写Java代码123456public class Hello &#123; public static void main(String[] args) &#123; System.out.println(&quot;hello world&quot;); &#125;&#125; （2）复制文件到目录，执行编译 （3）Native Image 进行构建 （4）查看构建的文件 （5）执行构建的文件 可以看到这个Hello最终打包产出的二进制文件大小为11M，这是包含了SVM和JDK各种库后的大小，虽然相比C&#x2F;C++的二进制文件来说体积偏大，但是对比完整JVM来说，可以说是已经是非常小了。 相比于使用JVM运行，Native Image的速度要快上不少，cpu占用也更低一些，从官方提供的各类实验数据也可以看出Native Image对于启动速度和内存占用带来的提升是非常显著的：","categories":[{"name":"Spring6","slug":"Spring6","permalink":"http://example.com/categories/Spring6/"}],"tags":[{"name":"框架","slug":"框架","permalink":"http://example.com/tags/%E6%A1%86%E6%9E%B6/"}]},{"title":"page","slug":"page","date":"2021-09-27T23:55:54.000Z","updated":"2023-09-28T00:28:56.682Z","comments":true,"path":"2021/09/28/page/","link":"","permalink":"http://example.com/2021/09/28/page/","excerpt":"","text":"","categories":[],"tags":[]}],"categories":[{"name":"程序猿","slug":"程序猿","permalink":"http://example.com/categories/%E7%A8%8B%E5%BA%8F%E7%8C%BF/"},{"name":"SSM框架","slug":"SSM框架","permalink":"http://example.com/categories/SSM%E6%A1%86%E6%9E%B6/"},{"name":"java基础","slug":"java基础","permalink":"http://example.com/categories/java%E5%9F%BA%E7%A1%80/"},{"name":"Spring6","slug":"Spring6","permalink":"http://example.com/categories/Spring6/"}],"tags":[{"name":"经验","slug":"经验","permalink":"http://example.com/tags/%E7%BB%8F%E9%AA%8C/"},{"name":"ssm","slug":"ssm","permalink":"http://example.com/tags/ssm/"},{"name":"java","slug":"java","permalink":"http://example.com/tags/java/"},{"name":"框架","slug":"框架","permalink":"http://example.com/tags/%E6%A1%86%E6%9E%B6/"}]}